[
    
    {
    "name": "abs ",
    "module": "builtins",
    "class_name": null,
    "return_type": "Number",
    "parameters": [
      {
        "name": "x",
        "type": "Number"
      }
    ],
    "docstring": "Return the absolute value of a number.",
    "decorators": [],
    "main_category": "Mathematical Operations",
    "sub_category": "Numeric",
    "data_type_manipulated": ["int", "float", "complex"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The abs() function returns the absolute value of a number. The argument may be an integer, a floating point number, or an object implementing __abs__(). If the argument is a complex number, its magnitude is returned.",
    "return_value": "Returns the absolute value of the argument. The return type depends on the input type: int for integers, float for floats, and float for complex numbers.",
    "parameter_details": "This function takes one parameter: x (a number). It can be an integer, float, or complex number.",
    "function_signature": "abs(x: Number) -> Number",
    "exceptions": [
      {
        "type": "TypeError",
        "condition": "If the argument is not a number and doesn't implement __abs__()"
      }
    ],
    "related_functions": ["math.fabs", "cmath.abs"],
    "examples": [
      {
        "title": "Basic Usage with Different Number Types",
        "code": "print(abs(-5))  # Integer\nprint(abs(3.14))  # Float\nprint(abs(-3.14))  # Negative float\nprint(abs(complex(3, 4)))  # Complex number",
        "explanation": "This example demonstrates abs() with different number types: integers, positive and negative floats, and a complex number.",
        "expected_output": "5\n3.14\n3.14\n5.0"
      },
      {
        "title": "Using abs() with Zero and Near-Zero Values",
        "code": "print(abs(0))\nprint(abs(-0.0))\nprint(abs(1e-10))\nprint(abs(-1e-10))",
        "explanation": "This shows how abs() handles zero, negative zero, and very small positive and negative numbers.",
        "expected_output": "0\n0.0\n1e-10\n1e-10"
      },
      {
        "title": "abs() with Custom Objects",
        "code": "class CustomNumber:\n    def __init__(self, value):\n        self.value = value\n    \n    def __abs__(self):\n        return abs(self.value)\n\ncustom_num = CustomNumber(-42)\nprint(abs(custom_num))",
        "explanation": "This example shows how abs() can work with custom objects that implement the __abs__() method.",
        "expected_output": "42"
      },
      {
        "title": "Error Handling",
        "code": "try:\n    abs('not a number')\nexcept TypeError as e:\n    print(f\"TypeError: {e}\")",
        "explanation": "This demonstrates the TypeError raised when abs() is called with an invalid argument.",
        "expected_output": "TypeError: bad operand type for abs(): 'str'"
      }
    ]
  },
  {
    "name": "aiter",
    "module": "builtins",
    "class_name": null,
    "return_type": "AsyncIterator",
    "parameters": [
      {
        "name": "async_iterable",
        "type": "AsyncIterable"
      }
    ],
    "docstring": "Return an AsyncIterator for an AsyncIterable object.",
    "decorators": [],
    "main_category": "Iteration",
    "sub_category": "Asynchronous",
    "data_type_manipulated": ["AsyncIterable"],
    "version_added": "3.10",
    "deprecated": false,
    "extended_description": "The aiter() function is used to obtain an asynchronous iterator from an asynchronous iterable. It's particularly useful in asynchronous programming contexts, such as coroutines and async generators. This function is the asynchronous counterpart to the iter() function used for synchronous iterables.",
    "return_value": "Returns an AsyncIterator object that can be used in an 'async for' loop.",
    "parameter_details": "This function takes one parameter: async_iterable (an AsyncIterable object). This can be any object that implements the __aiter__() method.",
    "function_signature": "aiter(async_iterable: AsyncIterable) -> AsyncIterator",
    "exceptions": [
      {
        "type": "TypeError",
        "condition": "If the argument is not an async iterable (doesn't implement __aiter__())"
      }
    ],
    "related_functions": ["anext", "iter"],
    "examples": [
      {
        "title": "Basic Usage with Async Generator",
        "code": "import asyncio\n\nasync def async_gen():\n    for i in range(3):\n        await asyncio.sleep(0.1)\n        yield i\n\nasync def main():\n    async_iterator = aiter(async_gen())\n    async for item in async_iterator:\n        print(item)\n\nasyncio.run(main())",
        "explanation": "This example demonstrates how to use aiter() with an async generator. The async generator yields values with a small delay, and we use aiter() to create an async iterator that we can use in an async for loop.",
        "expected_output": "0\n1\n2"
      },
      {
        "title": "Using aiter() with a Custom Async Iterable",
        "code": "import asyncio\n\nclass CustomAsyncIterable:\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\n    def __aiter__(self):\n        return self\n\n    async def __anext__(self):\n        if self.start >= self.end:\n            raise StopAsyncIteration\n        self.start += 1\n        await asyncio.sleep(0.1)\n        return self.start - 1\n\nasync def main():\n    custom_iterable = CustomAsyncIterable(0, 3)\n    async_iterator = aiter(custom_iterable)\n    async for item in async_iterator:\n        print(item)\n\nasyncio.run(main())",
        "explanation": "This example shows how to use aiter() with a custom async iterable class. The class implements __aiter__() and __anext__() methods to make it an async iterable.",
        "expected_output": "0\n1\n2"
      },
      {
        "title": "Error Handling",
        "code": "import asyncio\n\nasync def main():\n    try:\n        aiter(\"not an async iterable\")\n    except TypeError as e:\n        print(f\"TypeError: {e}\")\n\nasyncio.run(main())",
        "explanation": "This example demonstrates the TypeError raised when aiter() is called with an invalid argument (a string, which is not an async iterable).",
        "expected_output": "TypeError: 'str' object is not an async iterable"
      }
    ]
  },
  {
    "name": "all",
    "module": "builtins",
    "class_name": null,
    "return_type": "bool",
    "parameters": [
      {
        "name": "iterable",
        "type": "Iterable"
      }
    ],
    "docstring": "Return True if all elements of the iterable are true (or if the iterable is empty).",
    "decorators": [],
    "main_category": "Iteration",
    "sub_category": "Evaluation",
    "data_type_manipulated": ["Iterable"],
    "version_added": "2.5",
    "deprecated": false,
    "extended_description": "The all() function returns True if all elements in the given iterable are true. If the iterable is empty, it returns True. It's equivalent to using the and operator between all elements in the iterable. The function short-circuits; it stops iterating as soon as it finds a false value.",
    "return_value": "Returns a boolean value. True if all elements are true (or if the iterable is empty), False otherwise.",
    "parameter_details": "This function takes one parameter: iterable (an Iterable object). This can be any iterable such as a list, tuple, set, or generator.",
    "function_signature": "all(iterable: Iterable) -> bool",
    "exceptions": [
      {
        "type": "TypeError",
        "condition": "If the argument is not iterable"
      }
    ],
    "related_functions": ["any"],
    "examples": [
      {
        "title": "Basic Usage with Different Iterables",
        "code": "print(all([True, True, True]))  # List of booleans\nprint(all((1, 2, 3)))  # Tuple of non-zero numbers\nprint(all({0, False, None}))  # Set with falsy values\nprint(all([]))  # Empty list",
        "explanation": "This example shows how all() behaves with different types of iterables, including an empty iterable.",
        "expected_output": "True\nTrue\nFalse\nTrue"
      },
      {
        "title": "Using all() with a Generator Expression",
        "code": "numbers = [1, 2, 3, 4, 5]\nprint(all(num > 0 for num in numbers))  # All positive\nprint(all(num % 2 == 0 for num in numbers))  # All even",
        "explanation": "This demonstrates using all() with a generator expression to check conditions on all elements of a list.",
        "expected_output": "True\nFalse"
      },
      {
        "title": "Short-circuiting Behavior",
        "code": "def check(x):\n    print(f\"Checking {x}\")\n    return x > 0\n\nnumbers = [1, 2, 0, 3, 4]\nprint(all(check(num) for num in numbers))",
        "explanation": "This example shows how all() short-circuits, stopping iteration as soon as it encounters a false value.",
        "expected_output": "Checking 1\nChecking 2\nChecking 0\nFalse"
      },
      {
        "title": "Using all() with Custom Objects",
        "code": "class CustomBool:\n    def __init__(self, value):\n        self.value = value\n    \n    def __bool__(self):\n        return self.value\n\nobjs = [CustomBool(True), CustomBool(True), CustomBool(False)]\nprint(all(objs))",
        "explanation": "This demonstrates how all() works with custom objects that implement the __bool__() method.",
        "expected_output": "False"
      },
      {
        "title": "Error Handling",
        "code": "try:\n    all(123)  # Integer is not iterable\nexcept TypeError as e:\n    print(f\"TypeError: {e}\")",
        "explanation": "This shows the TypeError raised when all() is called with a non-iterable argument.",
        "expected_output": "TypeError: 'int' object is not iterable"
      }
    ]
  },
  {
    "name": "anext",
    "module": "builtins",
    "class_name": null,
    "return_type": "Any",
    "parameters": [
      {
        "name": "async_iterator",
        "type": "AsyncIterator"
      },
      {
        "name": "default",
        "type": "Any",
        "default": "None"
      }
    ],
    "docstring": "Return the next item from an async iterator.",
    "decorators": [],
    "main_category": "Iteration",
    "sub_category": "Asynchronous",
    "data_type_manipulated": ["AsyncIterator"],
    "version_added": "3.10",
    "deprecated": false,
    "extended_description": "The anext() function is used to retrieve the next item from an async iterator. If a default value is provided and the iterator is exhausted, it returns the default value instead of raising a StopAsyncIteration exception. This function is the asynchronous counterpart to the next() function used for synchronous iterators.",
    "return_value": "Returns the next item from the async iterator. If the iterator is exhausted and no default is provided, it raises StopAsyncIteration.",
    "parameter_details": "This function takes two parameters: async_iterator (an AsyncIterator object), and default (optional, default is None). The default value is returned if the iterator is exhausted.",
    "function_signature": "anext(async_iterator: AsyncIterator, default: Any = None) -> Any",
    "exceptions": [
      {
        "type": "StopAsyncIteration",
        "condition": "If the iterator is exhausted and no default value is provided"
      },
      {
        "type": "TypeError",
        "condition": "If the first argument is not an async iterator"
      }
    ],
    "related_functions": ["aiter", "next"],
    "examples": [
      {
        "title": "Basic Usage with Async Generator",
        "code": "import asyncio\n\nasync def async_gen():\n    for i in range(3):\n        yield i\n\nasync def main():\n    agen = async_gen()\n    print(await anext(agen))\n    print(await anext(agen))\n    print(await anext(agen))\n    try:\n        print(await anext(agen))\n    except StopAsyncIteration:\n        print(\"Iterator exhausted\")\n\nasyncio.run(main())",
        "explanation": "This example demonstrates basic usage of anext() with an async generator. It shows how to retrieve values and handle StopAsyncIteration when the iterator is exhausted.",
        "expected_output": "0\n1\n2\nIterator exhausted"
      },
      {
        "title": "Using anext() with Default Value",
        "code": "import asyncio\n\nasync def async_gen():\n    yield 'a'\n    yield 'b'\n\nasync def main():\n    agen = async_gen()\n    print(await anext(agen))\n    print(await anext(agen))\n    print(await anext(agen, 'default'))\n\nasyncio.run(main())",
        "explanation": "This example shows how to use anext() with a default value. When the iterator is exhausted, it returns the default value instead of raising an exception.",
        "expected_output": "a\nb\ndefault"
      },
      {
        "title": "Error Handling",
        "code": "import asyncio\n\nasync def main():\n    try:\n        await anext(iter([1, 2, 3]))  # Not an async iterator\n    except TypeError as e:\n        print(f\"TypeError: {e}\")\n\nasyncio.run(main())",
        "explanation": "This example demonstrates the TypeError raised when anext() is called with a synchronous iterator instead of an async iterator.",
        "expected_output": "TypeError: anext() argument 1 must be an async iterator"
      }
    ]
  },
  {
    "name": "any",
    "module": "builtins",
    "class_name": null,
    "return_type": "bool",
    "parameters": [
      {
        "name": "iterable",
        "type": "Iterable"
      }
    ],
    "docstring": "Return True if any element of the iterable is true. If the iterable is empty, return False.",
    "decorators": [],
    "main_category": "Iteration",
    "sub_category": "Evaluation",
    "data_type_manipulated": ["Iterable"],
    "version_added": "2.5",
    "deprecated": false,
    "extended_description": "The any() function returns True if any element in the given iterable is true. If the iterable is empty, it returns False. It's equivalent to using the or operator between all elements in the iterable. The function short-circuits; it stops iterating as soon as it finds a true value.",
    "return_value": "Returns a boolean value. True if any element is true, False if all are false or if the iterable is empty.",
    "parameter_details": "This function takes one parameter: iterable (an Iterable object). This can be any iterable such as a list, tuple, set, or generator.",
    "function_signature": "any(iterable: Iterable) -> bool",
    "exceptions": [
      {
        "type": "TypeError",
        "condition": "If the argument is not iterable"
      }
    ],
    "related_functions": ["all"],
    "examples": [
      {
        "title": "Basic Usage with Different Iterables",
        "code": "print(any([False, False, True]))  # List with one True\nprint(any([0, '', False]))  # List of falsy values\nprint(any(()))  # Empty tuple\nprint(any({0: 'False', 1: 'True'}))  # Dictionary (checks keys)",
        "explanation": "This example shows how any() behaves with different types of iterables, including an empty iterable.",
        "expected_output": "True\nFalse\nFalse\nTrue"
      },
      {
        "title": "Using any() with a Generator Expression",
        "code": "numbers = [1, 2, 3, 4, 5]\nprint(any(num > 3 for num in numbers))  # Any greater than 3\nprint(any(num > 10 for num in numbers))  # Any greater than 10",
        "explanation": "This demonstrates using any() with a generator expression to check conditions on elements of a list.",
        "expected_output": "True\nFalse"
      },
      {
        "title": "Short-circuiting Behavior",
        "code": "def check(x):\n    print(f\"Checking {x}\")\n    return x > 3\n\nnumbers = [1, 2, 4, 5]\nprint(any(check(num) for num in numbers))",
        "explanation": "This example shows how any() short-circuits, stopping iteration as soon as it encounters a true value.",
        "expected_output": "Checking 1\nChecking 2\nChecking 4\nTrue"
      },
      {
        "title": "Using any() with Custom Objects",
        "code": "class CustomBool:\n    def __init__(self, value):\n        self.value = value\n    \n    def __bool__(self):\n        return self.value\n\nobjs = [CustomBool(False), CustomBool(False), CustomBool(True)]\nprint(any(objs))",
        "explanation": "This demonstrates how any() works with custom objects that implement the __bool__() method.",
        "expected_output": "True"
      },
      {
        "title": "Error Handling",
        "code": "try:\n    any(123)  # Integer is not iterable\nexcept TypeError as e:\n    print(f\"TypeError: {e}\")",
        "explanation": "This shows the TypeError raised when any() is called with a non-iterable argument.",
        "expected_output": "TypeError: 'int' object is not iterable"
      }
    ]
  },
  {
    "name": "ascii",
    "module": "builtins",
    "class_name": null,
    "return_type": "str",
    "parameters": [
      {
        "name": "object",
        "type": "Any"
      }
    ],
    "docstring": "Return a string containing a printable representation of an object, escaping non-ASCII characters.",
    "decorators": [],
    "main_category": "String Operations",
    "sub_category": "Representation",
    "data_type_manipulated": ["Any"],
    "version_added": "3.0",
    "deprecated": false,
    "extended_description": "The ascii() function returns a string representation of an object, similar to repr(), but escapes the non-ASCII characters in the string with \\x, \\u or \\U escapes. This can be useful when you need a printable representation of an object that contains only ASCII characters.",
    "return_value": "Returns a string containing a printable representation of the object, with non-ASCII characters escaped.",
    "parameter_details": "This function takes one parameter: object (any Python object). The function will return a string representation of this object.",
    "function_signature": "ascii(object: Any) -> str",
    "exceptions": [],
    "related_functions": ["repr", "str"],
    "examples": [
      {
        "title": "Basic Usage with ASCII and non-ASCII Strings",
        "code": "print(ascii('Python'))  # ASCII string\nprint(ascii('PythÃ¶n'))  # non-ASCII string\nprint(ascii('ä½ å¥½'))  # Chinese characters",
        "explanation": "This example shows how ascii() handles both ASCII and non-ASCII strings, including Unicode characters.",
        "expected_output": "'Python'\n'Pyth\\xf6n'\n'\\u4f60\\u597d'"
      },
      {
        "title": "ascii() with Different Data Types",
        "code": "print(ascii(42))  # Integer\nprint(ascii(3.14))  # Float\nprint(ascii([1, 2, '3']))  # List\nprint(ascii({'a': 1, 'b': 2}))  # Dictionary",
        "explanation": "This demonstrates how ascii() works with various Python data types.",
        "expected_output": "'42'\n'3.14'\n\"[1, 2, '3']\"\n\"{'a': 1, 'b': 2}\""
      },
      {
        "title": "Using ascii() with Custom Objects",
        "code": "class CustomClass:\n    def __repr__(self):\n        return 'CustomClass(â¤)'\n\nobj = CustomClass()\nprint(ascii(obj))",
        "explanation": "This example shows how ascii() handles custom objects with a __repr__ method that returns non-ASCII characters.",
        "expected_output": "'CustomClass(\\u2764)'"
      },
      {
        "title": "Comparison with repr()",
        "code": "s = 'Python is ðŸ'\nprint(f\"ascii: {ascii(s)}\")\nprint(f\"repr:  {repr(s)}\")",
        "explanation": "This compares the output of ascii() with repr() for a string containing emoji.",
        "expected_output": "ascii: 'Python is \\U0001f40d'\nrepr:  'Python is ðŸ'"
      },
      {
        "title": "ascii() with Nested Structures",
        "code": "nested = {'name': 'JÃ¶hn', 'data': [1, 'äºŒ', {'key': 'ðŸ”‘'}]}\nprint(ascii(nested))",
        "explanation": "This shows how ascii() handles nested structures with non-ASCII characters at various levels.",
        "expected_output": "{'name': 'J\\xf6hn', 'data': [1, '\\u4e8c', {'key': '\\U0001f511'}]}"
      }
    ]
  },
  {
    "name": "bin",
    "module": "builtins",
    "class_name": null,
    "return_type": "str",
    "parameters": [
      {
        "name": "x",
        "type": "int"
      }
    ],
    "docstring": "Return the binary representation of an integer.",
    "decorators": [],
    "main_category": "Number Operations",
    "sub_category": "Representation",
    "data_type_manipulated": ["int"],
    "version_added": "2.6",
    "deprecated": false,
    "extended_description": "The bin() function converts an integer number to a binary string prefixed with '0b'. This function provides a simple way to see the binary representation of a number. If the argument is not an integer, it must define an __index__() method that returns an integer.",
    "return_value": "Returns a string starting with '0b', which is the binary representation of the input integer.",
    "parameter_details": "This function takes one parameter: x (an integer). If x is not an integer, it should be an object that implements __index__() method returning an integer.",
    "function_signature": "bin(x: int) -> str",
    "exceptions": [
      {
        "type": "TypeError",
        "condition": "If the argument does not have an __index__() method that returns an integer"
      }
    ],
    "related_functions": ["hex", "oct"],
    "examples": [
      {
        "title": "Basic Usage with Positive and Negative Integers",
        "code": "print(bin(3))\nprint(bin(-10))\nprint(bin(0))",
        "explanation": "This example shows how bin() works with positive, negative, and zero integers.",
        "expected_output": "0b11\n-0b1010\n0b0"
      },
      {
        "title": "Using bin() with Large Numbers",
        "code": "print(bin(1000000))\nprint(bin(-1000000))",
        "explanation": "This demonstrates bin() function's behavior with larger numbers.",
        "expected_output": "0b11110100001001000000\n-0b11110100001001000000"
      },
      {
        "title": "bin() with Objects Implementing __index__()",
        "code": "class CustomInteger:\n    def __init__(self, value):\n        self.value = value\n    def __index__(self):\n        return self.value\n\ncustom_int = CustomInteger(42)\nprint(bin(custom_int))",
        "explanation": "This example shows how bin() can be used with custom objects that implement __index__() method.",
        "expected_output": "0b101010"
      },
      {
        "title": "Removing '0b' Prefix",
        "code": "num = 10\nbin_str = bin(num)\nprint(bin_str)\nprint(bin_str[2:])",
        "explanation": "This demonstrates how to remove the '0b' prefix if needed. The last line prints the binary representation without the '0b' prefix.",
        "expected_output": "0b1010\n1010"
      },
      {
        "title": "Error Handling",
        "code": "try:\n    bin(3.14)\nexcept TypeError as e:\n    print(f\"TypeError: {e}\")",
        "explanation": "This shows the TypeError raised when bin() is called with a non-integer type that doesn't implement __index__(). Floats are not allowed as direct arguments to bin().",
        "expected_output": "TypeError: 'float' object cannot be interpreted as an integer"
      }
    ]
  },
  {
    "name": "bool",
    "module": "builtins",
    "class_name": null,
    "return_type": "bool",
    "parameters": [
      {
        "name": "x",
        "type": "Any",
        "default": "False"
      }
    ],
    "docstring": "Return a Boolean value, i.e. one of True or False.",
    "decorators": [],
    "main_category": "Type Conversion",
    "sub_category": "Boolean",
    "data_type_manipulated": ["Any"],
    "version_added": "2.3",
    "deprecated": false,
    "extended_description": "The bool() function converts a value to Boolean True or False. It uses the standard truth testing procedure. If x is false or omitted, it returns False; otherwise, it returns True. The bool class is a subclass of int. It cannot be subclassed further. Its only instances are False and True.",
    "return_value": "Returns True or False, depending on the truth value of the argument.",
    "parameter_details": "This function takes one optional parameter: x (any Python object). If omitted, it defaults to False.",
    "function_signature": "bool(x: Any = False) -> bool",
    "exceptions": [],
    "related_functions": ["any", "all"],
    "examples": [
      {
        "title": "Basic Usage with Different Types",
        "code": "print(bool(1))  # Non-zero number\nprint(bool(0))  # Zero\nprint(bool([]))  # Empty list\nprint(bool([1, 2, 3]))  # Non-empty list\nprint(bool(\"\"))  # Empty string\nprint(bool(\"Hello\"))  # Non-empty string\nprint(bool(None))  # None",
        "explanation": "This example shows how bool() evaluates different types of objects.",
        "expected_output": "True\nFalse\nFalse\nTrue\nFalse\nTrue\nFalse"
      },
      {
        "title": "bool() with Custom Objects",
        "code": "class CustomClass:\n    def __init__(self, value):\n        self.value = value\n    def __bool__(self):\n        return self.value > 0\n\nobj1 = CustomClass(1)\nobj2 = CustomClass(-1)\nprint(bool(obj1))\nprint(bool(obj2))",
        "explanation": "This demonstrates how bool() works with custom objects that implement the __bool__() method.",
        "expected_output": "True\nFalse"
      },
      {
        "title": "bool() in Conditional Statements",
        "code": "value = \"\"\nif bool(value):\n    print(\"Value is truthy\")\nelse:\n    print(\"Value is falsy\")\n\nvalue = \"Hello\"\nif bool(value):\n    print(\"Value is truthy\")\nelse:\n    print(\"Value is falsy\")",
        "explanation": "This example shows how bool() can be used in conditional statements, although it's usually implicit.",
        "expected_output": "Value is falsy\nValue is truthy"
      },
      {
        "title": "bool() with No Argument",
        "code": "print(bool())",
        "explanation": "This shows the result of calling bool() with no argument, which defaults to False.",
        "expected_output": "False"
      },
      {
        "title": "bool as a Type",
        "code": "x = True\nprint(isinstance(x, bool))\nprint(issubclass(bool, int))",
        "explanation": "This demonstrates that bool is a type and a subclass of int.",
        "expected_output": "True\nTrue"
      }
    ]
  },
  {
    "name": "breakpoint",
    "module": "builtins",
    "class_name": null,
    "return_type": "None",
    "parameters": [],
    "docstring": "Drops you into the debugger at the call site.",
    "decorators": [],
    "main_category": "Debugging",
    "sub_category": "Runtime Inspection",
    "data_type_manipulated": [],
    "version_added": "3.7",
    "deprecated": false,
    "extended_description": "The breakpoint() function is a convenient way to enter the debugger at a specific point in your code. By default, it calls sys.breakpointhook(), which in turn calls pdb.set_trace(). However, this can be overridden by setting the PYTHONBREAKPOINT environment variable. This function is particularly useful for debugging complex programs or for educational purposes when explaining program flow.",
    "return_value": "This function doesn't return a value; it transfers control to the debugger.",
    "parameter_details": "This function doesn't take any parameters.",
    "function_signature": "breakpoint() -> None",
    "exceptions": [],
    "related_functions": ["pdb.set_trace"],
    "examples": [
      {
        "title": "Basic Usage in a Script",
        "code": "def complex_function(x, y):\n    result = x * y\n    breakpoint()  # Debugger will start here\n    return result * 2\n\ncomplex_function(3, 4)",
        "explanation": "When this script runs, it will pause at the breakpoint, allowing you to inspect variables and step through the code.",
        "expected_output": "-> return result * 2\n(Pdb)"
      },
      {
        "title": "Using breakpoint() in a Loop",
        "code": "for i in range(5):\n    if i == 3:\n        breakpoint()\n    print(i)",
        "explanation": "This will run the loop and pause when i equals 3, allowing you to inspect the state at that point.",
        "expected_output": "0\n1\n2\n-> print(i)\n(Pdb)"
      },
      {
        "title": "Conditional Debugging",
        "code": "def process_data(data):\n    for item in data:\n        if item < 0:\n            breakpoint()\n        # process item\n\nprocess_data([1, 2, -3, 4, -5])",
        "explanation": "This example shows how to use breakpoint() conditionally, which is useful for debugging specific scenarios.",
        "expected_output": "-> # process item\n(Pdb)"
      },
      {
        "title": "Disabling breakpoint()",
        "code": "import os\n\nos.environ['PYTHONBREAKPOINT'] = '0'\n\ndef test_function():\n    breakpoint()  # This will be ignored\n    print(\"Function executed\")\n\ntest_function()",
        "explanation": "This demonstrates how to disable breakpoint() using the PYTHONBREAKPOINT environment variable.",
        "expected_output": "Function executed"
      },
      {
        "title": "Using a Custom Debug Function",
        "code": "def custom_debug():\n    print(\"Custom debug function called\")\n\nimport sys\nsys.breakpointhook = custom_debug\n\ndef test_function():\n    breakpoint()\n    print(\"Function executed\")\n\ntest_function()",
        "explanation": "This shows how to use a custom debug function instead of the default debugger.",
        "expected_output": "Custom debug function called\nFunction executed"
      }
    ]
  },
  {
    "name": "bytearray",
    "module": "builtins",
    "class_name": null,
    "return_type": "bytearray",
    "parameters": [
      {
        "name": "source",
        "type": "Union[int, Iterable[int], str, bytes]",
        "default": "None"
      },
      {
        "name": "encoding",
        "type": "str",
        "default": "None"
      },
      {
        "name": "errors",
        "type": "str",
        "default": "None"
      }
    ],
    "docstring": "Return a new array of bytes. The bytearray type is a mutable sequence of integers in the range 0 <= x < 256.",
    "decorators": [],
    "main_category": "Data Types",
    "sub_category": "Byte Sequences",
    "data_type_manipulated": ["int", "str", "bytes"],
    "version_added": "2.6",
    "deprecated": false,
    "extended_description": "The bytearray() function creates a mutable sequence of bytes. It can be initialized in various ways: from an iterable of integers, from a string with a specified encoding, from bytes or another bytearray object, or by creating an array of null bytes of a specified length.",
    "return_value": "Returns a new bytearray object, which is a mutable sequence of integers in the range 0 <= x < 256.",
    "parameter_details": "source: Can be an integer (to create that many null bytes), an iterable of integers 0 <= x < 256, a string (requires encoding to be specified), or an object that implements the buffer protocol (like bytes).\nencoding: The encoding to use if source is a string. Common values include 'utf-8', 'ascii', etc.\nerrors: Specifies how to handle encoding errors. Common values are 'strict', 'ignore', 'replace', etc.",
    "function_signature": "bytearray(source: Union[int, Iterable[int], str, bytes] = None, encoding: str = None, errors: str = None) -> bytearray",
    "exceptions": [
      {
        "type": "ValueError",
        "condition": "If any integer in the iterable is outside the range 0 <= x < 256"
      },
      {
        "type": "TypeError",
        "condition": "If the source argument has an inappropriate type"
      }
    ],
    "related_functions": ["bytes", "memoryview"],
    "examples": [
      {
        "title": "Creating bytearray from Different Sources",
        "code": "print(bytearray([1, 2, 3]))\nprint(bytearray('hello', 'utf-8'))\nprint(bytearray(5))",
        "explanation": "This example shows how to create bytearrays from an iterable of integers, a string with encoding, and an integer (creating null bytes).",
        "expected_output": "bytearray(b'\\x01\\x02\\x03')\nbytearray(b'hello')\nbytearray(b'\\x00\\x00\\x00\\x00\\x00')"
      },
      {
        "title": "Mutable Nature of bytearray",
        "code": "ba = bytearray(b'hello')\nba[0] = 72  # ASCII code for 'H'\nprint(ba)",
        "explanation": "This demonstrates the mutable nature of bytearray objects. Individual bytes can be modified.",
        "expected_output": "bytearray(b'Hello')"
      },
      {
        "title": "Using Different Encodings",
        "code": "print(bytearray('ã“ã‚“ã«ã¡ã¯', 'utf-8'))\nprint(bytearray('ã“ã‚“ã«ã¡ã¯', 'utf-16'))",
        "explanation": "This example shows how different encodings affect the resulting bytearray when created from a string.",
        "expected_output": "bytearray(b'\\xe3\\x81\\x93\\xe3\\x82\\x93\\xe3\\x81\\xab\\xe3\\x81\\xa1\\xe3\\x81\\xaf')\nbytearray(b'\\xff\\xfe\\x53\\x30\\x93\\x30\\x6b\\x30\\x61\\x30\\x6f\\x30')"
      },
      {
        "title": "Error Handling in Encoding",
        "code": "print(bytearray('hello\\u2603', 'ascii', errors='ignore'))\nprint(bytearray('hello\\u2603', 'ascii', errors='replace'))",
        "explanation": "This demonstrates different error handling strategies when encoding a string with characters that can't be represented in the specified encoding.",
        "expected_output": "bytearray(b'hello')\nbytearray(b'hello?')"
      },
      {
        "title": "bytearray Operations",
        "code": "ba = bytearray(b'Python')\nba.extend(b' is fun')\nprint(ba)\nprint(ba.decode('utf-8'))",
        "explanation": "This example shows some operations that can be performed on bytearrays, including extending and decoding back to a string.",
        "expected_output": "bytearray(b'Python is fun')\nPython is fun"
      }
    ]
  },
  {
    "name": "bytes",
    "module": "builtins",
    "class_name": null,
    "return_type": "bytes",
    "parameters": [
      {
        "name": "source",
        "type": "Union[int, Iterable[int], str, bytes]",
        "default": "None"
      },
      {
        "name": "encoding",
        "type": "str",
        "default": "None"
      },
      {
        "name": "errors",
        "type": "str",
        "default": "None"
      }
    ],
    "docstring": "Return a new 'bytes' object, which is an immutable sequence of integers in the range 0 <= x < 256.",
    "decorators": [],
    "main_category": "Data Types",
    "sub_category": "Byte Sequences",
    "data_type_manipulated": ["int", "str", "bytes"],
    "version_added": "3.0",
    "deprecated": false,
    "extended_description": "The bytes() function creates an immutable sequence of bytes. It can be initialized in various ways: from an iterable of integers, from a string with a specified encoding, from another bytes or bytearray object, or by creating a sequence of null bytes of a specified length.",
    "return_value": "Returns a new bytes object, which is an immutable sequence of integers in the range 0 <= x < 256.",
    "parameter_details": "source: Can be an integer (to create that many null bytes), an iterable of integers 0 <= x < 256, a string (requires encoding to be specified), or an object that implements the buffer protocol.\nencoding: The encoding to use if source is a string. Common values include 'utf-8', 'ascii', etc.\nerrors: Specifies how to handle encoding errors. Common values are 'strict', 'ignore', 'replace', etc.",
    "function_signature": "bytes(source: Union[int, Iterable[int], str, bytes] = None, encoding: str = None, errors: str = None) -> bytes",
    "exceptions": [
      {
        "type": "ValueError",
        "condition": "If any integer in the iterable is outside the range 0 <= x < 256"
      },
      {
        "type": "TypeError",
        "condition": "If the source argument has an inappropriate type"
      }
    ],
    "related_functions": ["bytearray", "memoryview"],
    "examples": [
      {
        "title": "Creating bytes from Different Sources",
        "code": "print(bytes([1, 2, 3]))\nprint(bytes('hello', 'utf-8'))\nprint(bytes(5))",
        "explanation": "This example shows how to create bytes objects from an iterable of integers, a string with encoding, and an integer (creating null bytes).",
        "expected_output": "b'\\x01\\x02\\x03'\nb'hello'\nb'\\x00\\x00\\x00\\x00\\x00'"
      },
      {
        "title": "Immutable Nature of bytes",
        "code": "b = bytes(b'hello')\ntry:\n    b[0] = 72  # This will raise an error\nexcept TypeError as e:\n    print(f\"TypeError: {e}\")",
        "explanation": "This demonstrates the immutable nature of bytes objects. Unlike bytearray, individual bytes cannot be modified.",
        "expected_output": "TypeError: 'bytes' object does not support item assignment"
      },
      {
        "title": "Using Different Encodings",
        "code": "print(bytes('ã“ã‚“ã«ã¡ã¯', 'utf-8'))\nprint(bytes('ã“ã‚“ã«ã¡ã¯', 'utf-16'))",
        "explanation": "This example shows how different encodings affect the resulting bytes object when created from a string.",
        "expected_output": "b'\\xe3\\x81\\x93\\xe3\\x82\\x93\\xe3\\x81\\xab\\xe3\\x81\\xa1\\xe3\\x81\\xaf'\nb'\\xff\\xfe\\x53\\x30\\x93\\x30\\x6b\\x30\\x61\\x30\\x6f\\x30'"
      },
      {
        "title": "Error Handling in Encoding",
        "code": "print(bytes('hello\\u2603', 'ascii', errors='ignore'))\nprint(bytes('hello\\u2603', 'ascii', errors='replace'))",
        "explanation": "This demonstrates different error handling strategies when encoding a string with characters that can't be represented in the specified encoding.",
        "expected_output": "b'hello'\nb'hello?'"
      },
      {
        "title": "bytes Operations",
        "code": "b = bytes(b'Python')\nnew_b = b + b' is fun'  # Creates a new bytes object\nprint(new_b)\nprint(new_b.decode('utf-8'))",
        "explanation": "This example shows some operations that can be performed on bytes objects, including concatenation and decoding back to a string.",
        "expected_output": "b'Python is fun'\nPython is fun"
      }
    ]
  },
  {
    "name": "callable",
    "module": "builtins",
    "class_name": null,
    "return_type": "bool",
    "parameters": [
      {
        "name": "object",
        "type": "Any"
      }
    ],
    "docstring": "Return True if the object argument appears callable, False if not.",
    "decorators": [],
    "main_category": "Function Operations",
    "sub_category": "Introspection",
    "data_type_manipulated": ["Any"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The callable() function checks whether the object passed to it appears to be callable (i.e., can be called as a function). An object is considered callable if it's a function, a method, a class with a __call__ method, or an instance of a class with a __call__ method. Note that callable() returns True if the object appears callable, but calling the object may still fail.",
    "return_value": "Returns a boolean value: True if the object appears callable, False otherwise.",
    "parameter_details": "object: Any Python object to be checked for callability.",
    "function_signature": "callable(object: Any) -> bool",
    "exceptions": [],
    "related_functions": ["hasattr", "getattr"],
    "examples": [
      {
        "title": "Basic Usage with Different Types",
        "code": "print(callable(len))  # Built-in function\nprint(callable(100))  # Integer\nprint(callable(lambda x: x))  # Lambda function\nprint(callable(callable))  # Function itself\nprint(callable([1, 2].append))  # Method",
        "explanation": "This example demonstrates callable() with various types of objects, including functions, numbers, and methods.",
        "expected_output": "True\nFalse\nTrue\nTrue\nTrue"
      },
      {
        "title": "Callable Classes and Instances",
        "code": "class CallableClass:\n    def __call__(self):\n        return \"I'm callable\"\n\nclass NonCallableClass:\n    pass\n\nprint(callable(CallableClass))  # Class is callable (it's a constructor)\nprint(callable(CallableClass()))  # Instance is callable due to __call__\nprint(callable(NonCallableClass))\nprint(callable(NonCallableClass()))",
        "explanation": "This example shows how callable() behaves with classes and their instances, demonstrating the effect of the __call__ method.",
        "expected_output": "True\nTrue\nTrue\nFalse"
      },
      {
        "title": "Callable with Built-in Types and Methods",
        "code": "print(callable(str))  # str is callable (it's a constructor)\nprint(callable(\"hello\".upper))  # Method is callable\nprint(callable(\"hello\"))  # String itself is not callable",
        "explanation": "This demonstrates callable() with built-in types and their methods.",
        "expected_output": "True\nTrue\nFalse"
      },
      {
        "title": "Callable with User-defined Functions",
        "code": "def my_function():\n    pass\n\nprint(callable(my_function))\n\npartial_func = lambda x: x + 1\nprint(callable(partial_func))",
        "explanation": "This example shows that user-defined functions and lambda functions are callable.",
        "expected_output": "True\nTrue"
      },
      {
        "title": "Caution with callable()",
        "code": "class TrickyCallable:\n    def __call__(self):\n        raise NotImplementedError(\"Just kidding, not actually callable!\")\n\nobj = TrickyCallable()\nprint(callable(obj))  # Returns True\ntry:\n    obj()\nexcept NotImplementedError as e:\n    print(f\"Error: {e}\")",
        "explanation": "This example demonstrates that callable() only checks if an object appears callable, but doesn't guarantee it can be called without errors.",
        "expected_output": "True\nError: Just kidding, not actually callable!"
      }
    ]
  },
  {
    "name": "chr",
    "module": "builtins",
    "class_name": null,
    "return_type": "str",
    "parameters": [
      {
        "name": "i",
        "type": "int"
      }
    ],
    "docstring": "Return a string of one character whose Unicode code point is the integer i.",
    "decorators": [],
    "main_category": "String Operations",
    "sub_category": "Character Conversion",
    "data_type_manipulated": ["int"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The chr() function returns a string representing a character whose Unicode code point is the integer i. This function is the inverse of ord(). The valid range for the argument is from 0 to 1,114,111 (0x10FFFF in hexadecimal).",
    "return_value": "Returns a string of length 1, containing the character corresponding to the specified Unicode code point.",
    "parameter_details": "i: An integer representing a valid Unicode code point.",
    "function_signature": "chr(i: int) -> str",
    "exceptions": [
      {
        "type": "ValueError",
        "condition": "If the integer is outside the valid Unicode code point range (0 to 1,114,111)"
      }
    ],
    "related_functions": ["ord"],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "print(chr(65))\nprint(chr(97))\nprint(chr(8364))",
        "explanation": "This example shows chr() used with ASCII and Unicode code points.",
        "expected_output": "A\na\nâ‚¬"
      },
      {
        "title": "Using chr() with Various Unicode Ranges",
        "code": "print(chr(0x1F600))  # Grinning Face emoji\nprint(chr(0x03A9))   # Greek Capital Letter Omega\nprint(chr(0x20AC))   # Euro Sign",
        "explanation": "This demonstrates chr() with different Unicode ranges, including emoji and non-Latin scripts.",
        "expected_output": "ðŸ˜€\nÎ©\nâ‚¬"
      },
      {
        
            "title": "chr() with Maximum and Minimum Values",
            "code": "print(repr(chr(0)))\nprint(repr(chr(1114111)))\ntry:\n    print(chr(1114112))\nexcept ValueError as e:\n    print(f\"ValueError: {e}\")",
            "explanation": "This example shows the use of chr() with the minimum and maximum valid code points, and demonstrates the error when exceeding the maximum. We use repr() to show the string representation of the characters.",
            "expected_output": "'\\x00'\n'\\U0010ffff'\nValueError: chr() arg not in range(0x110000)"
          
      },
      {
        "title": "Using chr() in String Formation",
        "code": "start = 65\nend = 70\nprint(''.join(chr(i) for i in range(start, end + 1)))",
        "explanation": "This example demonstrates how chr() can be used in a list comprehension to generate a string of consecutive characters.",
        "expected_output": "ABCDEF"
      },
      {
        "title": "chr() and ord() Inverse Relationship",
        "code": "char = 'Z'\ncode_point = ord(char)\nprint(f\"Character: {char}, Code point: {code_point}\")\nprint(f\"chr(ord('{char}')) == '{char}': {chr(ord(char)) == char}\")",
        "explanation": "This example illustrates the inverse relationship between chr() and ord() functions.",
        "expected_output": "Character: Z, Code point: 90\nchr(ord('Z')) == 'Z': True"
      }
    ]
  },
  {
    "name": "classmethod",
    "module": "builtins",
    "class_name": null,
    "return_type": "classmethod",
    "parameters": [
      {
        "name": "function",
        "type": "Callable"
      }
    ],
    "docstring": "Transform a method into a class method.",
    "decorators": [],
    "main_category": "Class Operations",
    "sub_category": "Method Transformation",
    "data_type_manipulated": ["Callable"],
    "version_added": "2.2",
    "deprecated": false,
    "extended_description": "The classmethod() function is a decorator that transforms a method into a class method. Unlike a regular method, a class method receives the class as an implicit first argument, instead of an instance. This can be useful for defining alternative constructors or methods that operate on the class itself rather than instances.",
    "return_value": "Returns a class method for the given function.",
    "parameter_details": "function: A callable that will be transformed into a class method.",
    "function_signature": "classmethod(function: Callable) -> classmethod",
    "exceptions": [],
    "related_functions": ["staticmethod", "property"],
    "examples": [
      {
        "title": "Basic Usage of classmethod",
        "code": "class Date:\n    def __init__(self, year, month, day):\n        self.year = year\n        self.month = month\n        self.day = day\n    \n    @classmethod\n    def from_string(cls, date_string):\n        year, month, day = map(int, date_string.split('-'))\n        return cls(year, month, day)\n\ndate = Date.from_string('2023-06-15')\nprint(f\"{date.year}-{date.month}-{date.day}\")",
        "explanation": "This example demonstrates a common use of classmethod as an alternative constructor.",
        "expected_output": "2023-6-15"
      },
      {
        "title": "Classmethod in Inheritance",
        "code": "class Animal:\n    @classmethod\n    def class_name(cls):\n        return cls.__name__\n\nclass Dog(Animal):\n    pass\n\nprint(Animal.class_name())\nprint(Dog.class_name())",
        "explanation": "This example shows how classmethods work with inheritance, demonstrating that they operate on the class they're called from.",
        "expected_output": "Animal\nDog"
      },
      {
        "title": "Classmethod vs Static Method",
        "code": "class MyClass:\n    @classmethod\n    def class_method(cls):\n        print(f\"This is a class method of {cls.__name__}\")\n    \n    @staticmethod\n    def static_method():\n        print(\"This is a static method\")\n\nMyClass.class_method()\nMyClass.static_method()",
        "explanation": "This example contrasts classmethod with staticmethod, showing that classmethod receives the class as an argument.",
        "expected_output": "This is a class method of MyClass\nThis is a static method"
      },
      {
        "title": "Classmethod for Factory Pattern",
        "code": "import random\n\nclass Die:\n    def __init__(self, sides):\n        self.sides = sides\n    \n    def roll(self):\n        return random.randint(1, self.sides)\n    \n    @classmethod\n    def create_d6(cls):\n        return cls(6)\n    \n    @classmethod\n    def create_d20(cls):\n        return cls(20)\n\nd6 = Die.create_d6()\nd20 = Die.create_d20()\nprint(f\"D6 roll: {d6.roll()}\")\nprint(f\"D20 roll: {d20.roll()}\")",
        "explanation": "This example uses classmethods to implement a factory pattern for creating different types of dice.",
        "expected_output": "D6 roll: [1-6]\nD20 roll: [1-20]"
      },
      {
        "title": "Classmethod Without Decorator Syntax",
        "code": "class MyClass:\n    def my_method(cls):\n        print(f\"This is a class method of {cls.__name__}\")\n    \nmy_method = classmethod(MyClass.my_method)\nMyClass.my_method()",
        "explanation": "This example shows how to use classmethod without the decorator syntax, which is equivalent to using the @classmethod decorator.",
        "expected_output": "This is a class method of MyClass"
      }
    ]
  },
  {
    "name": "compile",
    "module": "builtins",
    "class_name": null,
    "return_type": "code",
    "parameters": [
      {
        "name": "source",
        "type": "Union[str, bytes, AST]"
      },
      {
        "name": "filename",
        "type": "str"
      },
      {
        "name": "mode",
        "type": "str"
      },
      {
        "name": "flags",
        "type": "int",
        "default": "0"
      },
      {
        "name": "dont_inherit",
        "type": "bool",
        "default": "False"
      },
      {
        "name": "optimize",
        "type": "int",
        "default": "-1"
      }
    ],
    "docstring": "Compile the source into a code or AST object.",
    "decorators": [],
    "main_category": "Code Operations",
    "sub_category": "Compilation",
    "data_type_manipulated": ["str", "bytes", "AST"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The compile() function compiles the source into a code object or AST object. It can be used to compile Python source code that can be executed later using eval() or exec(). This function is particularly useful when you need to execute code multiple times, as compilation is done only once.",
    "return_value": "Returns a code object that can be executed by eval() or exec(), or an AST object that can be compiled and executed.",
    "parameter_details": "source: The source code to compile. Can be a string, bytes object, or an AST object.\nfilename: The filename from which the code was read. If it wasn't read from a file, you can use '<string>'.\nmode: Specifies what kind of code is being compiled; 'exec' for a module, 'eval' for expressions, or 'single' for a single interactive statement.\nflags and dont_inherit: Control which future statements affect the compilation of source.\noptimize: Optimization level of the compiler; -1 means default optimization level.",
    "function_signature": "compile(source: Union[str, bytes, AST], filename: str, mode: str, flags: int = 0, dont_inherit: bool = False, optimize: int = -1) -> code",
    "exceptions": [
      {
        "type": "SyntaxError",
        "condition": "If the source code is syntactically incorrect"
      },
      {
        "type": "ValueError",
        "condition": "If an invalid argument is passed"
      },
      {
        "type": "TypeError",
        "condition": "If the arguments have inappropriate types"
      }
    ],
    "related_functions": ["eval", "exec"],
    "examples": [
      {
        "title": "Basic Usage with eval",
        "code": "code = compile('a + b', '<string>', 'eval')\nresult = eval(code, {'a': 1, 'b': 2})\nprint(result)",
        "explanation": "This example compiles a simple expression and evaluates it using eval().",
        "expected_output": "3"
      },
      {
        "title": "Compiling and Executing a Function",
        "code": "source = '''\ndef greet(name):\n    return f\"Hello, {name}!\"\n'''\ncode = compile(source, '<string>', 'exec')\nexec(code)\nprint(greet('Alice'))",
        "explanation": "This example compiles a function definition and executes it, then calls the defined function.",
        "expected_output": "Hello, Alice!"
      },
      {
        "title": "Compiling with Different Modes",
        "code": "# 'eval' mode\neval_code = compile('2 + 2', '<string>', 'eval')\nprint(eval(eval_code))\n\n# 'exec' mode\nexec_code = compile('x = 2 + 2', '<string>', 'exec')\nexec(exec_code)\nprint(x)\n\n# 'single' mode\nsingle_code = compile('print(\"Hello\")', '<string>', 'single')\nexec(single_code)",
        "explanation": "This demonstrates the different compilation modes: 'eval' for expressions, 'exec' for statements, and 'single' for single interactive statements.",
        "expected_output": "4\n4\nHello"
      },
      {
        "title": "Compile with AST",
        "code": "import ast\n\nsource = 'print(\"Hello, World!\")'\ntree = ast.parse(source)\nmodified_tree = ast.parse('print(\"Modified:\")\\n' + ast.unparse(tree))\ncode = compile(modified_tree, '<ast>', 'exec')\nexec(code)",
        "explanation": "This example shows how to compile using an AST object, allowing for programmatic modification of the code before compilation.",
        "expected_output": "Modified:\nHello, World!"
      },
      {
        "title": "Error Handling in Compile",
        "code": "try:\n    compile('x = 10 +', '<string>', 'exec')\nexcept SyntaxError as e:\n    print(f\"SyntaxError: {e}\")\n\ntry:\n    compile('x = 10', '<string>', 'invalid_mode')\nexcept ValueError as e:\n    print(f\"ValueError: {e}\")",
        "explanation": "This example demonstrates error handling for syntax errors in the source code and invalid mode arguments.",
        "expected_output": "SyntaxError: invalid syntax (<string>, line 1)\nValueError: compile() arg 3 must be 'exec', 'eval' or 'single'"
      }
    ]
  },
  {
    "name": "complex",
    "module": "builtins",
    "class_name": null,
    "return_type": "complex",
    "parameters": [
      {
        "name": "real",
        "type": "Union[int, float, str]",
        "default": "0"
      },
      {
        "name": "imag",
        "type": "Union[int, float]",
        "default": "0"
      }
    ],
    "docstring": "Create a complex number with the value real + imag*1j or convert a string or number to a complex number.",
    "decorators": [],
    "main_category": "Number Operations",
    "sub_category": "Complex Numbers",
    "data_type_manipulated": ["int", "float", "str"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The complex() function creates a complex number or converts a string or number to a complex number. It can be called with zero, one, or two arguments. If called with no arguments, it returns 0j. If called with one argument, it can be a string representing a complex number or a number which will be converted to a complex number with zero imaginary part.",
    "return_value": "Returns a complex number.",
    "parameter_details": "real: The real part of the complex number. Can be an int, float, or str.\nimag: The imaginary part of the complex number. Can be an int or float.",
    "function_signature": "complex(real: Union[int, float, str] = 0, imag: Union[int, float] = 0) -> complex",
    "exceptions": [
      {
        "type": "ValueError",
        "condition": "If the string passed as 'real' is not a valid complex number representation"
      },
      {
        "type": "TypeError",
        "condition": "If incompatible types are provided for real or imag"
      }
    ],
    "related_functions": ["abs", "cmath.phase"],
    "examples": [
      {
        "title": "Creating Complex Numbers",
        "code": "print(complex(1, 2))\nprint(complex(3))\nprint(complex())\nprint(complex('1+2j'))",
        "explanation": "This example shows different ways to create complex numbers using the complex() function.",
        "expected_output": "(1+2j)\n(3+0j)\n0j\n(1+2j)"
      },
      {
        "title": "Complex Numbers from Strings",
        "code": "print(complex('3+4j'))\nprint(complex('-1.5-2.5j'))\nprint(complex('1e+2+3e-1j'))",
        "explanation": "This demonstrates creating complex numbers from various string representations.",
        "expected_output": "(3+4j)\n(-1.5-2.5j)\n(100+0.3j)"
      },
      {
        "title": "Using Variables and Expressions",
        "code": "x = 3\ny = 4\nprint(complex(x, y))\nprint(complex(x*2, y/2))",
        "explanation": "This example shows how to use variables and expressions when creating complex numbers.",
        "expected_output": "(3+4j)\n(6+2j)"
      },
      {
        "title": "Error Handling",
        "code": "try:\n    complex('not a number')\nexcept ValueError as e:\n    print(f\"ValueError: {e}\")\n\ntry:\n    complex(1, '2')\nexcept TypeError as e:\n    print(f\"TypeError: {e}\")",
        "explanation": "This demonstrates error handling for invalid input to the complex() function.",
        "expected_output": "ValueError: complex() arg is a malformed string\nTypeError: complex() second arg can't be a string"
      },
      {
        "title": "Complex Number Operations",
        "code": "a = complex(1, 2)\nb = complex(3, 4)\nprint(f\"a + b = {a + b}\")\nprint(f\"a * b = {a * b}\")\nprint(f\"Absolute value of a: {abs(a)}\")",
        "explanation": "This example shows some basic operations with complex numbers.",
        "expected_output": "a + b = (4+6j)\na * b = (-5+10j)\nAbsolute value of a: 2.23606797749979"
      }
    ]
  },
  {
    "name": "delattr",
    "module": "builtins",
    "class_name": null,
    "return_type": "None",
    "parameters": [
      {
        "name": "object",
        "type": "Any"
      },
      {
        "name": "name",
        "type": "str"
      }
    ],
    "docstring": "Deletes the named attribute from the given object.",
    "decorators": [],
    "main_category": "Object Manipulation",
    "sub_category": "Attribute Operations",
    "data_type_manipulated": ["Any"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The delattr() function deletes the named attribute from the given object. It is equivalent to 'del object.name'. This function is particularly useful when you need to remove an attribute dynamically, or when the attribute name is determined at runtime.",
    "return_value": "This function doesn't return a value; it modifies the object in-place.",
    "parameter_details": "object: The object from which to delete the attribute.\nname: A string containing the name of the attribute to be deleted.",
    "function_signature": "delattr(object: Any, name: str) -> None",
    "exceptions": [
      {
        "type": "AttributeError",
        "condition": "If the attribute doesn't exist"
      },
      {
        "type": "TypeError",
        "condition": "If the object does not support attribute deletion"
      }
    ],
    "related_functions": ["setattr", "getattr", "hasattr"],
    "examples": [
      {
        "title": "Basic Usage with a Class",
        "code": "class MyClass:\n    x = 1\n    y = 2\n\nobj = MyClass()\nprint(f\"Before: {obj.x}, {obj.y}\")\ndelattr(obj, 'x')\ntry:\n    print(f\"After: {obj.x}, {obj.y}\")\nexcept AttributeError as e:\n    print(f\"AttributeError: {e}\")",
        "explanation": "This example demonstrates how to use delattr() to remove an attribute from an object.",
        "expected_output": "Before: 1, 2\nAttributeError: 'MyClass' object has no attribute 'x'"
      },
      {
        "title": "Deleting Instance vs Class Attributes",
        "code": "class MyClass:\n    class_attr = 'I am a class attribute'\n\n    def __init__(self):\n        self.instance_attr = 'I am an instance attribute'\n\nobj = MyClass()\nprint(f\"Before: {obj.class_attr}, {obj.instance_attr}\")\ndelattr(obj, 'instance_attr')\ndelattr(MyClass, 'class_attr')\ntry:\n    print(f\"After: {obj.class_attr}, {obj.instance_attr}\")\nexcept AttributeError as e:\n    print(f\"AttributeError: {e}\")",
        "explanation": "This example shows the difference between deleting instance attributes and class attributes.",
        "expected_output": "Before: I am a class attribute, I am an instance attribute\nAttributeError: 'MyClass' object has no attribute 'class_attr'"
      },
      {
        "title": "Using delattr() with Dynamic Attribute Names",
        "code": "class DynamicClass:\n    pass\n\nobj = DynamicClass()\nattr_names = ['attr1', 'attr2', 'attr3']\n\nfor name in attr_names:\n    setattr(obj, name, f\"Value of {name}\")\n\nprint(f\"Before: {obj.attr1}, {obj.attr2}, {obj.attr3}\")\n\nfor name in attr_names[1:]:\n    delattr(obj, name)\n\nprint(f\"After: {obj.attr1}\")\nfor name in attr_names[1:]:\n    try:\n        getattr(obj, name)\n    except AttributeError:\n        print(f\"{name} has been deleted\")",
        "explanation": "This example demonstrates using delattr() with dynamically created attribute names.",
        "expected_output": "Before: Value of attr1, Value of attr2, Value of attr3\nAfter: Value of attr1\nattr2 has been deleted\nattr3 has been deleted"
      },
      {
        "title": "Error Handling with delattr()",
        "code": "class MyClass:\n    x = 1\n\nobj = MyClass()\n\ntry:\n    delattr(obj, 'y')\nexcept AttributeError as e:\n    print(f\"AttributeError: {e}\")\n\ntry:\n    delattr(42, 'x')\nexcept TypeError as e:\n    print(f\"TypeError: {e}\")",
        "explanation": "This example shows error handling when trying to delete non-existent attributes or when using delattr() on objects that don't support attribute deletion.",
        "expected_output": "AttributeError: y\nTypeError: 'int' object has no attribute 'x'"
      }
    ]
  },
  {
    "name": "dict",
    "module": "builtins",
    "class_name": "dict",
    "return_type": "dict",
    "parameters": [
      {
        "name": "iterable",
        "type": "Optional[Iterable]"
      },
      {
        "name": "**kwargs",
        "type": "Any"
      }
    ],
    "docstring": "Create a new dictionary.",
    "decorators": [],
    "main_category": "Data Structures",
    "sub_category": "Mapping",
    "data_type_manipulated": ["dict"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The dict() function creates a new dictionary. It can be called with various types of arguments: no argument (to create an empty dictionary), a mapping object, an iterable of key/value pairs, or keyword arguments. Dictionaries store key-value pairs and are mutable, ordered (as of Python 3.7), and do not allow duplicate keys.",
    "return_value": "Returns a new dictionary object.",
    "parameter_details": "iterable: An optional iterable of key-value pairs to initialize the dictionary.\n**kwargs: Keyword arguments to be added as key-value pairs to the dictionary.",
    "function_signature": "dict(iterable: Optional[Iterable] = None, **kwargs: Any) -> dict",
    "exceptions": [
      {
        "type": "TypeError",
        "condition": "If the iterable contains elements that are not key-value pairs"
      },
      {
        "type": "ValueError",
        "condition": "If a key is specified multiple times in the iterable"
      }
    ],
    "related_functions": ["defaultdict", "OrderedDict"],
    "examples": [
      {
        "title": "Creating Dictionaries",
        "code": "print(dict())  # Empty dictionary\nprint(dict(a=1, b=2))  # Using keyword arguments\nprint(dict([('a', 1), ('b', 2)]))  # From a list of tuples\nprint(dict({'a': 1, 'b': 2}))  # From another dictionary\nprint(dict(zip(['a', 'b'], [1, 2])))  # Using zip()",
        "explanation": "This example demonstrates various ways to create dictionaries using the dict() function.",
        "expected_output": "{}\n{'a': 1, 'b': 2}\n{'a': 1, 'b': 2}\n{'a': 1, 'b': 2}\n{'a': 1, 'b': 2}"
      },
      {
        "title": "Dict Comprehension",
        "code": "squares = {x: x**2 for x in range(5)}\nprint(squares)",
        "explanation": "This shows how to create a dictionary using a dict comprehension, which is an alternative to dict().",
        "expected_output": "{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}"
      },
      {
        "title": "Merging Dictionaries",
        "code": "d1 = {'a': 1, 'b': 2}\nd2 = {'b': 3, 'c': 4}\nmerged = dict(d1, **d2)\nprint(merged)",
        "explanation": "This example shows how to merge two dictionaries using dict(). Note that in case of duplicate keys, the value from the second dictionary is used.",
        "expected_output": "{'a': 1, 'b': 3, 'c': 4}"
      },
      {
        "title": "Dict with Custom Objects",
        "code": "class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\npeople = [Person(\"Alice\", 30), Person(\"Bob\", 25)]\nage_dict = dict((p.name, p.age) for p in people)\nprint(age_dict)",
        "explanation": "This demonstrates creating a dictionary from custom objects using a generator expression.",
        "expected_output": "{'Alice': 30, 'Bob': 25}"
      },
      {
        "title": "Error Handling",
        "code": "try:\n    dict([(1, 2), (3, 4), (1, 5)])\nexcept ValueError as e:\n    print(f\"ValueError: {e}\")\n\ntry:\n    dict([(1, 2), 3, (4, 5)])\nexcept TypeError as e:\n    print(f\"TypeError: {e}\")",
        "explanation": "This example shows error handling for duplicate keys and invalid iterable elements.",
        "expected_output": "ValueError: dictionary update sequence element #2 has a duplicate key\nTypeError: cannot convert dictionary update sequence element #1 to a sequence"
      }
    ]
  },
  {
    "name": "divmod",
    "module": "builtins",
    "class_name": null,
    "return_type": "Tuple[Number, Number]",
    "parameters": [
      {
        "name": "a",
        "type": "Number"
      },
      {
        "name": "b",
        "type": "Number"
      }
    ],
    "docstring": "Return a tuple of the quotient and remainder when dividing a by b.",
    "decorators": [],
    "main_category": "Mathematical Operations",
    "sub_category": "Arithmetic",
    "data_type_manipulated": ["int", "float"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The divmod() function takes two numbers as arguments and returns a tuple containing the quotient and the remainder when dividing the first argument by the second. For integers, the result is the same as (a // b, a % b). For floating point numbers, the result is (q, a % b), where q is usually math.floor(a / b) but may be 1 less than that.",
    "return_value": "Returns a tuple (quotient, remainder) of numbers of the same type as the input arguments.",
    "parameter_details": "a: The dividend (number to be divided).\nb: The divisor (number to divide by).",
    "function_signature": "divmod(a: Number, b: Number) -> Tuple[Number, Number]",
    "exceptions": [
      {
        "type": "ZeroDivisionError",
        "condition": "If the second argument (b) is zero"
      },
      {
        "type": "TypeError",
        "condition": "If the arguments are not numbers or are of incompatible types"
      }
    ],
    "related_functions": ["//", "%", "math.floor"],
    "examples": [
      {
        "title": "Basic Usage with Integers",
        "code": "print(divmod(7, 3))\nprint(divmod(-7, 3))\nprint(divmod(7, -3))",
        "explanation": "This example shows how divmod() works with positive and negative integers.",
        "expected_output": "(2, 1)\n(-3, 2)\n(-3, -2)"
      },
      {
        "title": "Using divmod() with Floats",
        "code": "print(divmod(8.0, 3))\nprint(divmod(8, 3.0))\nprint(divmod(8.5, 3.2))",
        "explanation": "This demonstrates divmod() behavior with floating-point numbers.",
        "expected_output": "(2.0, 2.0)\n(2.0, 2.0)\n(2.0, 2.0999999999999996)"
      },
      {
        "title": "Practical Use Case",
        "code": "def convert_seconds(seconds):\n    minutes, secs = divmod(seconds, 60)\n    hours, minutes = divmod(minutes, 60)\n    return f\"{hours:02d}:{minutes:02d}:{secs:02d}\"\n\nprint(convert_seconds(3661))",
        "explanation": "This example shows a practical use of divmod() in converting seconds to hours, minutes, and seconds.",
        "expected_output": "01:01:01"
      },
      {
        "title": "Error Handling",
        "code": "try:\n    divmod(10, 0)\nexcept ZeroDivisionError as e:\n    print(f\"ZeroDivisionError: {e}\")\n\ntry:\n    divmod(\"10\", 2)\nexcept TypeError as e:\n    print(f\"TypeError: {e}\")",
        "explanation": "This demonstrates error handling for division by zero and incompatible types.",
        "expected_output": "ZeroDivisionError: integer division or modulo by zero\nTypeError: unsupported operand type(s) for divmod(): 'str' and 'int'"
      },
      {
        "title": "Comparison with Floor Division and Modulo",
        "code": "a, b = 17, 5\ndiv_mod = divmod(a, b)\nmanual = (a // b, a % b)\nprint(f\"divmod(17, 5) = {div_mod}\")\nprint(f\"(17 // 5, 17 % 5) = {manual}\")\nprint(f\"Are they equal? {div_mod == manual}\")",
        "explanation": "This example compares the result of divmod() with manual floor division and modulo operations.",
        "expected_output": "divmod(17, 5) = (3, 2)\n(17 // 5, 17 % 5) = (3, 2)\nAre they equal? True"
      }
    ]
  },
  {
    "name": "enumerate",
    "module": "builtins",
    "class_name": "enumerate",
    "return_type": "enumerate",
    "parameters": [
      {
        "name": "iterable",
        "type": "Iterable"
      },
      {
        "name": "start",
        "type": "int",
        "default": "0"
      }
    ],
    "docstring": "Return an enumerate object.",
    "decorators": [],
    "main_category": "Iteration",
    "sub_category": "Enumeration",
    "data_type_manipulated": ["Iterable"],
    "version_added": "2.3",
    "deprecated": false,
    "extended_description": "The enumerate() function creates an iterator of tuples containing indices and values from an iterable. It's useful when you need both the index and value while iterating over a sequence. The optional start parameter specifies the start value for the counter.",
    "return_value": "Returns an enumerate object, which yields tuples containing a count (from start, which defaults to 0) and the values obtained from iterating over the given iterable.",
    "parameter_details": "iterable: Any iterable object (e.g., list, tuple, string).\nstart: The index value from which the counter is to be started, defaults to 0.",
    "function_signature": "enumerate(iterable: Iterable, start: int = 0) -> enumerate",
    "exceptions": [
      {
        "type": "TypeError",
        "condition": "If the first argument is not iterable"
      }
    ],
    "related_functions": ["zip", "iter"],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "seasons = ['Spring', 'Summer', 'Fall', 'Winter']\nprint(list(enumerate(seasons)))\nprint(list(enumerate(seasons, start=1)))",
        "explanation": "This example shows basic usage of enumerate(), both with and without a custom start value.",
        "expected_output": "[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]\n[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]"
      },
      {
        "title": "Using enumerate() in a Loop",
        "code": "fruits = ['apple', 'banana', 'cherry']\nfor index, fruit in enumerate(fruits):\n    print(f\"Index {index}: {fruit}\")",
        "explanation": "This demonstrates how to use enumerate() in a for loop to get both the index and value.",
        "expected_output": "Index 0: apple\nIndex 1: banana\nIndex 2: cherry"
      },
      {
        "title": "enumerate() with Strings",
        "code": "word = \"Python\"\nfor index, letter in enumerate(word):\n    if letter.lower() in 'aeiou':\n        print(f\"Vowel {letter} found at index {index}\")",
        "explanation": "This example shows how enumerate() can be used with strings to find the positions of specific characters.",
        "expected_output": "Vowel o found at index 4"
      },
      {
        "title": "Creating a Dictionary from enumerate()",
        "code": "items = ['apple', 'banana', 'cherry']\nitem_dict = dict(enumerate(items, 1))\nprint(item_dict)",
        "explanation": "This demonstrates how to create a dictionary using enumerate(), with custom start index.",
        "expected_output": "{1: 'apple', 2: 'banana', 3: 'cherry'}"
      },
      {
        "title": "enumerate() with Other Iterables",
        "code": "# With tuple\nprint(list(enumerate(('a', 'b', 'c'))))\n\n# With set\nprint(sorted(enumerate({'x', 'y', 'z'})))\n\n# With dictionary (enumerates over keys)\nprint(list(enumerate({'one': 1, 'two': 2, 'three': 3})))",
        "explanation": "This example shows how enumerate() works with different types of iterables.",
        "expected_output": "[(0, 'a'), (1, 'b'), (2, 'c')]\n[(0, 'x'), (1, 'y'), (2, 'z')]\n[(0, 'one'), (1, 'two'), (2, 'three')]"
      }
    ]
  },
  {
    "name": "eval",
    "module": "builtins",
    "class_name": null,
    "return_type": "Any",
    "parameters": [
      {
        "name": "expression",
        "type": "str"
      },
      {
        "name": "globals",
        "type": "Optional[dict]",
        "default": "None"
      },
      {
        "name": "locals",
        "type": "Optional[dict]",
        "default": "None"
      }
    ],
    "docstring": "Evaluate a Python expression as a string and return the result.",
    "decorators": [],
    "main_category": "Code Execution",
    "sub_category": "Expression Evaluation",
    "data_type_manipulated": ["str"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The eval() function evaluates a Python expression (as a string) and returns the result. It can be used to dynamically execute Python code. However, it should be used with caution, especially with untrusted input, as it can execute arbitrary Python code. The optional globals and locals arguments can be used to specify the environment in which the code is executed.",
    "return_value": "Returns the result of evaluating the given expression.",
    "parameter_details": "expression: A string containing a Python expression to be evaluated.\nglobals: Optional dictionary to specify global variables available to the code being evaluated.\nlocals: Optional dictionary to specify local variables available to the code being evaluated.",
    "function_signature": "eval(expression: str, globals: Optional[dict] = None, locals: Optional[dict] = None) -> Any",
    "exceptions": [
      {
        "type": "SyntaxError",
        "condition": "If the string contains invalid Python syntax"
      },
      {
        "type": "NameError",
        "condition": "If a name used in the expression is not defined"
      },
      {
        "type": "TypeError",
        "condition": "If an operation in the expression is applied to an object of inappropriate type"
      }
    ],
    "related_functions": ["exec", "compile"],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "print(eval('1 + 2'))\nprint(eval('\"Hello\" + \" World\"'))\nprint(eval('[1, 2, 3] * 2'))",
        "explanation": "This example shows basic usage of eval() with different types of expressions.",
        "expected_output": "3\nHello World\n[1, 2, 3, 1, 2, 3]"
      },
      {
        "title": "Using Variables in eval()",
        "code": "x = 10\ny = 5\nprint(eval('x * y'))\nprint(eval('x > y'))",
        "explanation": "This demonstrates how eval() can use variables from the current scope.",
        "expected_output": "50\nTrue"
      },
      {
        "title": "Using globals and locals",
        "code": "globals_dict = {'x': 10, 'y': 5}\nlocals_dict = {'y': 20}\nprint(eval('x + y', globals_dict))\nprint(eval('x + y', globals_dict, locals_dict))",
        "explanation": "This example shows how to use custom global and local dictionaries with eval().",
        "expected_output": "15\n30"
      },
      {
        "title": "Evaluating Complex Expressions",
        "code": "import math\nexpression = 'math.sin(math.pi/4) + math.cos(math.pi/4)'\nprint(eval(expression))",
        "explanation": "This demonstrates eval() with a more complex mathematical expression using the math module.",
        "expected_output": "1.4142135623730951"
      },
      {
        "title": "Error Handling",
        "code": "try:\n    eval('1 + ')\nexcept SyntaxError as e:\n    print(f\"SyntaxError: {e}\")\n\ntry:\n    eval('undefined_variable')\nexcept NameError as e:\n    print(f\"NameError: {e}\")\n\ntry:\n    eval('\"abc\" + 123')\nexcept TypeError as e:\n    print(f\"TypeError: {e}\")",
        "explanation": "This example demonstrates various types of errors that can occur when using eval() and how to handle them.",
        "expected_output": "SyntaxError: unexpected EOF while parsing (<string>, line 1)\nNameError: name 'undefined_variable' is not defined\nTypeError: can only concatenate str (not \"int\") to str"
      },
      {
        "title": "Security Considerations",
        "code": "# Potentially dangerous:\n# eval('__import__(\"os\").system(\"ls\")')\n\n# Safer approach:\ndef safe_eval(expr, variables={}):\n    allowed_names = {\n        k: v for k, v in variables.items()\n        if k.isalnum()\n    }\n    code = compile(expr, '<string>', 'eval')\n    for name in code.co_names:\n        if name not in allowed_names:\n            raise NameError(f\"Use of {name} not allowed\")\n    return eval(code, {'__builtins__': {}}, allowed_names)\n\nprint(safe_eval('x + y', {'x': 1, 'y': 2}))\ntry:\n    safe_eval('__import__(\"os\")')\nexcept NameError as e:\n    print(f\"NameError: {e}\")",
        "explanation": "This example illustrates a safer way to use eval() by restricting the available names and functions, which is important when dealing with untrusted input.",
        "expected_output": "3\nNameError: Use of __import__ not allowed"
      }
    ]
  },
  {
    "name": "exec",
    "module": "builtins",
    "class_name": null,
    "return_type": "None",
    "parameters": [
      {
        "name": "object",
        "type": "Union[str, code]"
      },
      {
        "name": "globals",
        "type": "Optional[dict]",
        "default": "None"
      },
      {
        "name": "locals",
        "type": "Optional[dict]",
        "default": "None"
      }
    ],
    "docstring": "Execute Python code dynamically.",
    "decorators": [],
    "main_category": "Code Execution",
    "sub_category": "Dynamic Execution",
    "data_type_manipulated": ["str", "code"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The exec() function is used to dynamically execute Python code. It can execute a string containing Python code, a code object, or a file. The globals and locals parameters can be used to specify the environment in which the code is executed. Unlike eval(), exec() can execute statements that don't return a value. It's important to use exec() cautiously, especially with untrusted input, as it can execute arbitrary Python code.",
    "return_value": "This function doesn't return a value; it executes the given code in place.",
    "parameter_details": "object: A string, bytes or code object containing Python code to be executed.\nglobals: Optional dictionary to specify global variables available to the code being executed.\nlocals: Optional dictionary to specify local variables available to the code being executed.",
    "function_signature": "exec(object: Union[str, code], globals: Optional[dict] = None, locals: Optional[dict] = None) -> None",
    "exceptions": [
      {
        "type": "SyntaxError",
        "condition": "If the string contains invalid Python syntax"
      },
      {
        "type": "NameError",
        "condition": "If a name used in the code is not defined"
      },
      {
        "type": "TypeError",
        "condition": "If an operation in the code is applied to an object of inappropriate type"
      }
    ],
    "related_functions": ["eval", "compile"],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "exec('print(\"Hello, World!\")')\n\nx = 5\nexec('x += 1')\nprint(x)",
        "explanation": "This example shows basic usage of exec() to execute a print statement and modify a variable.",
        "expected_output": "Hello, World!\n6"
      },
      {
        "title": "Executing Multiple Statements",
        "code": "program = '''\nfor i in range(3):\n    print(f\"Iteration {i}\")\n'''\nexec(program)",
        "explanation": "This demonstrates how exec() can execute multiple lines of code.",
        "expected_output": "Iteration 0\nIteration 1\nIteration 2"
      },
      {
        "title": "Using globals and locals",
        "code": "globals_dict = {'x': 10}\nlocals_dict = {'y': 20}\nexec('z = x + y', globals_dict, locals_dict)\nprint(f\"globals: {globals_dict}\")\nprint(f\"locals: {locals_dict}\")",
        "explanation": "This example shows how to use custom global and local dictionaries with exec().",
        "expected_output": "globals: {'x': 10, 'z': 30}\nlocals: {'y': 20}"
      },
      {
        "title": "Executing a Function Definition",
        "code": "exec('''\ndef greet(name):\n    return f\"Hello, {name}!\"\n''')\nprint(greet(\"Alice\"))",
        "explanation": "This demonstrates how exec() can be used to define functions dynamically.",
        "expected_output": "Hello, Alice!"
      },
      {
        "title": "Error Handling",
        "code": "try:\n    exec('1 + ')\nexcept SyntaxError as e:\n    print(f\"SyntaxError: {e}\")\n\ntry:\n    exec('print(undefined_variable)')\nexcept NameError as e:\n    print(f\"NameError: {e}\")",
        "explanation": "This example shows how to handle errors that may occur when using exec().",
        "expected_output": "SyntaxError: invalid syntax (<string>, line 1)\nNameError: name 'undefined_variable' is not defined"
      },
      {
        "title": "Security Considerations",
        "code": "def safe_exec(code, allowed_names={}):\n    code_obj = compile(code, '<string>', 'exec')\n    for name in code_obj.co_names:\n        if name not in allowed_names:\n            raise NameError(f\"Use of {name} not allowed\")\n    exec(code_obj, {'__builtins__': {}}, allowed_names)\n\ntry:\n    safe_exec('import os; os.system(\"ls\")')\nexcept NameError as e:\n    print(f\"NameError: {e}\")\n\nsafe_exec('x = 1; y = 2; print(x + y)', {'print': print})",
        "explanation": "This example illustrates a safer way to use exec() by restricting the available names and functions, which is important when dealing with untrusted input.",
        "expected_output": "NameError: Use of import not allowed\n3"
      }
    ]
  },
  {
    "name": "filter",
    "module": "builtins",
    "class_name": "filter",
    "return_type": "filter",
    "parameters": [
      {
        "name": "function",
        "type": "Optional[Callable]"
      },
      {
        "name": "iterable",
        "type": "Iterable"
      }
    ],
    "docstring": "Construct an iterator from elements of iterable for which function returns True.",
    "decorators": [],
    "main_category": "Iteration",
    "sub_category": "Filtering",
    "data_type_manipulated": ["Iterable"],
    "version_added": "2.0",
    "deprecated": false,
    "extended_description": "The filter() function creates an iterator from elements of the input iterable for which the given function returns True. If the function is None, the identity function is assumed, which means filter() will return the elements that are truthy. The returned filter object is itself an iterator and can be used in for loops or converted to other sequence types.",
    "return_value": "Returns a filter object, which is an iterator of the elements for which the function returns True.",
    "parameter_details": "function: A function that tests each element in the iterable. If None, returns elements that are truthy.\niterable: The iterable to be filtered.",
    "function_signature": "filter(function: Optional[Callable], iterable: Iterable) -> filter",
    "exceptions": [
      {
        "type": "TypeError",
        "condition": "If the arguments are not callable and iterable, respectively"
      }
    ],
    "related_functions": ["map", "reduce", "itertools.filterfalse"],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even_numbers)",
        "explanation": "This example uses filter() with a lambda function to get even numbers from a list.",
        "expected_output": "[2, 4, 6, 8, 10]"
      },
      {
        "title": "Using filter() with None",
        "code": "mixed_list = [0, 1, False, True, '', 'hello', [], [1, 2]]\ntruthy_values = list(filter(None, mixed_list))\nprint(truthy_values)",
        "explanation": "This demonstrates using filter() with None to keep only truthy values.",
        "expected_output": "[1, True, 'hello', [1, 2]]"
      },
      {
        "title": "Filtering with a Custom Function",
        "code": "def is_vowel(letter):\n    return letter.lower() in 'aeiou'\n\nword = 'Hello, World!'\nvowels = list(filter(is_vowel, word))\nprint(vowels)",
        "explanation": "This example uses a custom function with filter() to extract vowels from a string.",
        "expected_output": "['e', 'o', 'o']"
      },
      {
        "title": "Filtering Objects",
        "code": "class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\npeople = [Person(\"Alice\", 25), Person(\"Bob\", 17), Person(\"Charlie\", 30), Person(\"David\", 16)]\nadults = list(filter(lambda person: person.age >= 18, people))\nprint([person.name for person in adults])",
        "explanation": "This shows how to use filter() with custom objects to filter based on their attributes.",
        "expected_output": "['Alice', 'Charlie']"
      },
      {
        "title": "Using filter() as an Iterator",
        "code": "numbers = range(10)\nodd_numbers = filter(lambda x: x % 2 != 0, numbers)\nfor num in odd_numbers:\n    print(num, end=' ')",
        "explanation": "This demonstrates that the filter object is an iterator and can be used directly in a for loop.",
        "expected_output": "1 3 5 7 9 "
      },
      {
        "title": "Combining filter() with Other Functions",
        "code": "from functools import reduce\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nsum_of_squares_of_even = reduce(lambda x, y: x + y, map(lambda x: x**2, filter(lambda x: x % 2 == 0, numbers)))\nprint(sum_of_squares_of_even)",
        "explanation": "This complex example combines filter() with map() and reduce() to calculate the sum of squares of even numbers.",
        "expected_output": "220"
      }
    ]
  },
  {
    "name": "float",
    "module": "builtins",
    "class_name": "float",
    "return_type": "float",
    "parameters": [
      {
        "name": "x",
        "type": "Union[str, Number]",
        "default": "0.0"
      }
    ],
    "docstring": "Convert a string or number to a floating point number.",
    "decorators": [],
    "main_category": "Type Conversion",
    "sub_category": "Numeric",
    "data_type_manipulated": ["str", "int", "float"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The float() function converts a string or number to a floating point number. If no argument is given, it returns 0.0. The function can convert numeric strings, integers, and even special strings like 'nan' (Not a Number) and 'inf' (Infinity) to their float representations. It's commonly used for type conversion and ensuring numeric inputs are in float format.",
    "return_value": "Returns a floating point number representation of the input.",
    "parameter_details": "x: A string or number to be converted to a float. If omitted, returns 0.0.",
    "function_signature": "float(x: Union[str, Number] = 0.0) -> float",
    "exceptions": [
      {
        "type": "ValueError",
        "condition": "If the argument is a string that cannot be converted to a float"
      },
      {
        "type": "OverflowError",
        "condition": "If the argument is outside the range of representable values for a float"
      }
    ],
    "related_functions": ["int", "complex"],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "print(float(3))\nprint(float('3.14'))\nprint(float())",
        "explanation": "This example shows basic usage of float() with different types of inputs.",
        "expected_output": "3.0\n3.14\n0.0"
      },
      {
        "title": "Converting Various String Formats",
        "code": "print(float('1e-3'))\nprint(float('-Infinity'))\nprint(float('nan'))",
        "explanation": "This demonstrates float()'s ability to handle various string representations of numbers.",
        "expected_output": "0.001\n-inf\nnan"
      },
      {
        "title": "Rounding Behavior",
        "code": "print(float('1.1'))\nprint(float('1.1') + float('2.2'))\nprint(float('3.3'))",
        "explanation": "This example shows potential rounding issues with floating point arithmetic.",
        "expected_output": "1.1\n3.3000000000000003\n3.3"
      },
      {
        "title": "Error Handling",
        "code": "try:\n    float('not a number')\nexcept ValueError as e:\n    print(f\"ValueError: {e}\")\n\ntry:\n    float(float('inf') * 2)\nexcept OverflowError as e:\n    print(f\"OverflowError: {e}\")",
        "explanation": "This demonstrates error handling for invalid inputs and overflow conditions.",
        "expected_output": "ValueError: could not convert string to float: 'not a number'"
      },
      {
        "title": "Using float() in Calculations",
        "code": "radius = float(input('Enter the radius: '))\narea = 3.14159 * radius ** 2\nprint(f\"The area of the circle is {area}\")",
        "explanation": "This example shows a practical use of float() in a calculation, converting user input to a float.",
        "expected_output": "Enter the radius: 5\nThe area of the circle is 78.53975"
      },
      {
        "title": "float() with Different Numeric Types",
        "code": "from decimal import Decimal\nfrom fractions import Fraction\n\nprint(float(Decimal('1.1')))\nprint(float(Fraction(1, 3)))",
        "explanation": "This demonstrates float()'s ability to convert other numeric types like Decimal and Fraction.",
        "expected_output": "1.1\n0.3333333333333333"
      }
    ]
  },
  {
    "name": "format",
    "module": "builtins",
    "class_name": null,
    "return_type": "str",
    "parameters": [
      {
        "name": "value",
        "type": "Any"
      },
      {
        "name": "format_spec",
        "type": "str",
        "default": "''"
      }
    ],
    "docstring": "Return value.__format__(format_spec).",
    "decorators": [],
    "main_category": "String Formatting",
    "sub_category": "Value Formatting",
    "data_type_manipulated": ["Any"],
    "version_added": "2.6",
    "deprecated": false,
    "extended_description": "The format() function returns a formatted representation of a value as controlled by format_spec. It internally calls the __format__() method of the value. This function is the basis of the advanced string formatting operations in Python, allowing for precise control over the output format of various data types.",
    "return_value": "Returns a formatted string representation of the value.",
    "parameter_details": "value: The object to be formatted.\nformat_spec: A string that specifies how the value should be formatted.",
    "function_signature": "format(value: Any, format_spec: str = '') -> str",
    "exceptions": [
      {
        "type": "ValueError",
        "condition": "If an invalid format specification is provided"
      }
    ],
    "related_functions": ["str.format", "f-strings"],
    "examples": [
      {
        "title": "Basic Number Formatting",
        "code": "print(format(42, '04d'))\nprint(format(3.14159, '.2f'))\nprint(format(1234567, ','))",
        "explanation": "This example shows basic number formatting with padding, precision, and thousands separator.",
        "expected_output": "0042\n3.14\n1,234,567"
      },
      {
        "title": "String Alignment",
        "code": "print(format('hello', '^10'))\nprint(format('world', '<10'))\nprint(format('python', '>10'))",
        "explanation": "This demonstrates string alignment: center, left, and right alignment within a field of width 10.",
        "expected_output": "  hello   \nworld     \n    python"
      },
      {
        "title": "Custom Object Formatting",
        "code": "class Point:\n    def __init__(self, x, y):\n        self.x, self.y = x, y\n    def __format__(self, format_spec):\n        if format_spec == 'pair':\n            return f'({self.x}, {self.y})'\n        return f'Point at {self.x}, {self.y}'\n\np = Point(3, 4)\nprint(format(p))\nprint(format(p, 'pair'))",
        "explanation": "This example shows how to implement custom formatting for user-defined objects.",
        "expected_output": "Point at 3, 4\n(3, 4)"
      },
      {
        "title": "Date and Time Formatting",
        "code": "from datetime import datetime\nnow = datetime.now()\nprint(format(now, '%Y-%m-%d %H:%M:%S'))\nprint(format(now, '%A, %B %d, %Y'))",
        "explanation": "This demonstrates using format() with datetime objects for custom date and time representations.",
        "expected_output": "2023-06-15 14:30:00\nThursday, June 15, 2023"
      },
      {
        "title": "Binary, Octal, and Hexadecimal Formatting",
        "code": "num = 42\nprint(format(num, 'b'))\nprint(format(num, 'o'))\nprint(format(num, 'x'))\nprint(format(num, '#X'))",
        "explanation": "This example shows how to format integers in binary, octal, and hexadecimal representations.",
        "expected_output": "101010\n52\n2a\n0X2A"
      },
      {
        "title": "Error Handling",
        "code": "try:\n    format(42, 'invalid')\nexcept ValueError as e:\n    print(f\"ValueError: {e}\")",
        "explanation": "This demonstrates the error raised when an invalid format specification is provided.",
        "expected_output": "ValueError: Unknown format code 'i' for object of type 'int'"
      }
    ]
  },
  {
    "name": "frozenset",
    "module": "builtins",
    "class_name": "frozenset",
    "return_type": "frozenset",
    "parameters": [
      {
        "name": "iterable",
        "type": "Optional[Iterable]",
        "default": "None"
      }
    ],
    "docstring": "Return an immutable set object initialized from iterable.",
    "decorators": [],
    "main_category": "Data Structures",
    "sub_category": "Set",
    "data_type_manipulated": ["Iterable"],
    "version_added": "2.4",
    "deprecated": false,
    "extended_description": "The frozenset() function returns an immutable set object. Like sets, frozensets are unordered collections of unique elements, but unlike sets, frozensets are immutable and hashable. This makes them suitable for use as dictionary keys or as elements of other sets. If no argument is passed, it returns an empty frozenset.",
    "return_value": "Returns a new frozenset object containing unique elements from the input iterable.",
    "parameter_details": "iterable: An optional iterable object (e.g., list, tuple, set) to initialize the frozenset. If omitted, returns an empty frozenset.",
    "function_signature": "frozenset(iterable: Optional[Iterable] = None) -> frozenset",
    "exceptions": [
      {
        "type": "TypeError",
        "condition": "If the iterable contains unhashable objects"
      }
    ],
    "related_functions": ["set"],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "print(frozenset([1, 2, 3, 2]))\nprint(frozenset('hello'))\nprint(frozenset())",
        "explanation": "This example shows creating frozensets from a list with duplicates, a string, and an empty frozenset.",
        "expected_output": "frozenset({1, 2, 3})\nfrozenset({'h', 'e', 'l', 'o'})\nfrozenset()"
      },
      {
        "title": "Frozenset as Dictionary Key",
        "code": "fs1 = frozenset([1, 2, 3])\nfs2 = frozenset([3, 4, 5])\nd = {fs1: 'set1', fs2: 'set2'}\nprint(d[frozenset([1, 2, 3])])",
        "explanation": "This demonstrates using frozensets as dictionary keys, which is not possible with regular sets.",
        "expected_output": "set1"
      },
      {
        "title": "Set Operations with Frozensets",
        "code": "fs1 = frozenset([1, 2, 3, 4])\nfs2 = frozenset([3, 4, 5, 6])\nprint(f\"Union: {fs1 | fs2}\")\nprint(f\"Intersection: {fs1 & fs2}\")\nprint(f\"Difference: {fs1 - fs2}\")",
        "explanation": "This example shows set operations (union, intersection, difference) with frozensets.",
        "expected_output": "Union: frozenset({1, 2, 3, 4, 5, 6})\nIntersection: frozenset({3, 4})\nDifference: frozenset({1, 2})"
      },
      {
        "title": "Immutability of Frozensets",
        "code": "fs = frozenset([1, 2, 3])\ntry:\n    fs.add(4)\nexcept AttributeError as e:\n    print(f\"AttributeError: {e}\")",
        "explanation": "This demonstrates the immutability of frozensets by attempting to add an element, which raises an error.",
        "expected_output": "AttributeError: 'frozenset' object has no attribute 'add'"
      },
      {
        "title": "Frozenset with Custom Objects",
        "code": "class Person:\n    def __init__(self, name):\n        self.name = name\n    def __hash__(self):\n        return hash(self.name)\n    def __eq__(self, other):\n        return self.name == other.name\n    def __repr__(self):\n        return f\"Person('{self.name}')\"\n\npeople = frozenset([Person(\"Alice\"), Person(\"Bob\"), Person(\"Alice\")])\nprint(people)",
        "explanation": "This example shows how to use frozensets with custom objects that implement __hash__ and __eq__ methods.",
        "expected_output": "frozenset({Person('Bob'), Person('Alice')})"
      },
      {
        "title": "Comparing Frozensets",
        "code": "fs1 = frozenset([1, 2, 3])\nfs2 = frozenset([3, 2, 1])\nfs3 = frozenset([1, 2, 3, 4])\nprint(f\"fs1 == fs2: {fs1 == fs2}\")\nprint(f\"fs1 < fs3: {fs1 < fs3}\")\nprint(f\"fs1.issubset(fs3): {fs1.issubset(fs3)}\")",
        "explanation": "This demonstrates comparing frozensets and using set comparison methods.",
        "expected_output": "fs1 == fs2: True\nfs1 < fs3: True\nfs1.issubset(fs3): True"
      }
    ]
  },
  {
    "name": "getattr",
    "module": "builtins",
    "class_name": null,
    "return_type": "Any",
    "parameters": [
      {
        "name": "object",
        "type": "Any"
      },
      {
        "name": "name",
        "type": "str"
      },
      {
        "name": "default",
        "type": "Optional[Any]",
        "default": "None"
      }
    ],
    "docstring": "Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y.",
    "decorators": [],
    "main_category": "Object Manipulation",
    "sub_category": "Attribute Operations",
    "data_type_manipulated": ["Any"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The getattr() function is used to get the value of a named attribute of an object. It is useful when you need to access attributes dynamically or when you're not sure if an attribute exists. If the named attribute does not exist, getattr() will raise an AttributeError, unless a default value is provided as the third argument.",
    "return_value": "Returns the value of the named attribute of the object. If the attribute doesn't exist and a default is provided, returns the default value.",
    "parameter_details": "object: The object from which to get the attribute.\nname: A string containing the name of the attribute to get.\ndefault: An optional default value to return if the attribute does not exist.",
    "function_signature": "getattr(object: Any, name: str, default: Optional[Any] = None) -> Any",
    "exceptions": [
      {
        "type": "AttributeError",
        "condition": "If the named attribute does not exist and no default value is specified"
      }
    ],
    "related_functions": ["setattr", "hasattr", "delattr"],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "class Person:\n    name = 'John'\n    age = 30\n\nprint(getattr(Person, 'name'))\nprint(getattr(Person, 'age'))\nprint(getattr(Person, 'height', 180))",
        "explanation": "This example shows basic usage of getattr() to access existing attributes and provide a default for a non-existent attribute.",
        "expected_output": "John\n30\n180"
      },
      {
        "title": "Accessing Methods",
        "code": "class Calculator:\n    def add(self, a, b):\n        return a + b\n\ncalc = Calculator()\nmethod = getattr(calc, 'add')\nprint(method(5, 3))",
        "explanation": "This demonstrates using getattr() to access and call a method of an object.",
        "expected_output": "8"
      },
      {
        "title": "Dynamic Attribute Access",
        "code": "class DynamicClass:\n    pass\n\nobj = DynamicClass()\nobj.x = 10\nobj.y = 20\n\nfor attr in ['x', 'y', 'z']:\n    print(f\"{attr}: {getattr(obj, attr, 'Not found')}\")",
        "explanation": "This example shows how getattr() can be used for dynamic attribute access, useful when dealing with attributes determined at runtime.",
        "expected_output": "x: 10\ny: 20\nz: Not found"
      },
      {
        "title": "Error Handling",
        "code": "class EmptyClass:\n    pass\n\nobj = EmptyClass()\ntry:\n    getattr(obj, 'nonexistent')\nexcept AttributeError as e:\n    print(f\"AttributeError: {e}\")\n\nprint(getattr(obj, 'nonexistent', 'Default value'))",
        "explanation": "This demonstrates error handling when an attribute doesn't exist, both with and without a default value.",
        "expected_output": "AttributeError: 'EmptyClass' object has no attribute 'nonexistent'\nDefault value"
      },
      {
        "title": "Using getattr() with Built-in Types",
        "code": "number = 42\nprint(getattr(number, 'real'))\nprint(getattr(number, 'imag'))\n\ntext = 'Hello'\nprint(getattr(text, 'upper')())",
        "explanation": "This example shows how getattr() can be used with built-in types to access their attributes and methods.",
        "expected_output": "42\n0\nHELLO"
      },
      {
        "title": "Getattr in Inheritance",
        "code": "class Parent:\n    x = 10\n\nclass Child(Parent):\n    y = 20\n\nchild = Child()\nprint(getattr(child, 'x'))\nprint(getattr(child, 'y'))",
        "explanation": "This demonstrates how getattr() works with inheritance, accessing attributes from both the child and parent classes.",
        "expected_output": "10\n20"
      }
    ]
  },
  {
    "name": "globals",
    "module": "builtins",
    "class_name": null,
    "return_type": "dict",
    "parameters": [],
    "docstring": "Return the dictionary containing the current scope's global variables.",
    "decorators": [],
    "main_category": "Introspection",
    "sub_category": "Namespace",
    "data_type_manipulated": ["dict"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The globals() function returns a dictionary representing the current global symbol table. This is always the dictionary of the current module (inside a function or method, this is the module where it is defined, not the module from which it is called). Use locals() to get the local symbol table.",
    "return_value": "Returns a dictionary representing the current global symbol table.",
    "parameter_values": "This function takes no parameters.",
    "function_signature": "globals() -> dict",
    "related_functions": ["locals()", "vars()", "dir()"],
    "examples": [
      {
        "title": "Basic Usage - Accessing Global Variables",
        "code": "x = 10\ny = 20\n\nprint(globals())  # Prints a dictionary containing 'x' and 'y' among other global variables\n\nz = 30\nprint(globals()['z'])  # Prints 30",
        "explanation": "This example demonstrates how to use globals() to access and print global variables. It shows that newly defined variables are automatically added to the global namespace.",
        "expectedOutput": "{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, 'x': 10, 'y': 20}\n30"
      },
      {
        "title": "Using globals() in a Function",
        "code": "def modify_global():\n    globals()['new_variable'] = 'I am global'\n\nmodify_global()\nprint(new_variable)  # Prints 'I am global'\n\nprint('new_variable' in globals())  # Prints True",
        "explanation": "This example shows how to use globals() within a function to create or modify global variables. It demonstrates that changes made using globals() affect the global namespace.",
        "expectedOutput": "I am global\nTrue"
      },
      {
        "title": "Comparing globals() and locals() in Different Scopes",
        "code": "x = 'global x'\n\ndef compare_scopes():\n    x = 'local x'\n    print('globals():', globals()['x'])  # Accesses global x\n    print('locals():', locals()['x'])    # Accesses local x\n\ncompare_scopes()\nprint('Outside function:', x)",
        "explanation": "This example illustrates the difference between globals() and locals() when used within a function that has a local variable with the same name as a global variable.",
        "expectedOutput": "globals(): global x\nlocals(): local x\nOutside function: global x"
      }
    ]
  },
  {
    "name": "hasattr",
    "module": "builtins",
    "class_name": null,
    "return_type": "bool",
    "parameters": [
      {
        "name": "object",
        "type": "Any"
      },
      {
        "name": "name",
        "type": "str"
      }
    ],
    "docstring": "Return whether the object has an attribute with the given name.",
    "decorators": [],
    "main_category": "Object Manipulation",
    "sub_category": "Attribute Operations",
    "data_type_manipulated": ["Any"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The hasattr() function is used to determine if an object has a given attribute. It's equivalent to calling getattr(object, name) and seeing whether it raises an AttributeError or not.",
    "return_value": "Returns True if the object has the given named attribute, False otherwise.",
    "parameter_values": "object: Any Python object\nname: A string containing the name of the attribute to check for",
    "related_functions": ["getattr()", "setattr()", "delattr()", "isinstance()"],
    "function_signature": "hasattr(object: Any, name: str) -> bool",
    "examples": [
      {
        "title": "Basic Usage - Checking for Attribute Existence",
        "code": "class Person:\n    name = 'John'\n    age = 30\n\nperson = Person()\nprint(hasattr(person, 'name'))   # True\nprint(hasattr(person, 'age'))    # True\nprint(hasattr(person, 'gender')) # False",
        "explanation": "This example demonstrates how to use hasattr() to check for the existence of attributes in a class instance.",
        "expectedOutput": "True\nTrue\nFalse"
      },
      {
        "title": "Using hasattr() with Built-in Types",
        "code": "my_list = [1, 2, 3]\nmy_dict = {'a': 1, 'b': 2}\n\nprint(hasattr(my_list, 'append'))  # True\nprint(hasattr(my_dict, 'keys'))   # True\nprint(hasattr(my_list, 'keys'))   # False",
        "explanation": "This example shows how hasattr() can be used with built-in types to check for method existence.",
        "expectedOutput": "True\nTrue\nFalse"
      },
      {
        "title": "hasattr() with Dynamic Attribute Addition",
        "code": "class DynamicClass:\n    pass\n\nobj = DynamicClass()\nprint(hasattr(obj, 'x'))  # False\n\nobj.x = 5\nprint(hasattr(obj, 'x'))  # True\nprint(obj.x)  # 5",
        "explanation": "This example demonstrates how hasattr() reflects dynamic attribute additions to objects.",
        "expectedOutput": "False\nTrue\n5"
      }
    ]
  },
  {
    "name": "hash",
    "module": "builtins",
    "class_name": null,
    "return_type": "int",
    "parameters": [
      {
        "name": "object",
        "type": "Any"
      }
    ],
    "docstring": "Return the hash value of the object (if it has one).",
    "decorators": [],
    "main_category": "Object Operations",
    "sub_category": "Hashing",
    "data_type_manipulated": ["Any"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The hash() function returns the hash value of an object if it has one. Hash values are integers used to quickly compare dictionary keys during a dictionary lookup. Numeric values that compare equal have the same hash value (even if they are of different types, as is the case for 1 and 1.0).",
    "return_value": "Returns an integer hash value for the object. The return value is guaranteed to be the same within the same Python session for objects that are not modified.",
    "parameter_values": "object: The object to be hashed. Must be hashable (i.e., have a __hash__() method).",
    "function_signature": "hash(object: Any) -> int",
    "related_functions": ["id()", "__hash__()", "__eq__()"],
    "examples": [
      {
        "title": "Basic Usage - Hashing Different Types",
        "code": "print(hash('hello'))     # Hash of a string\nprint(hash(42))         # Hash of an integer\nprint(hash(3.14))       # Hash of a float\nprint(hash((1, 2, 3)))  # Hash of a tuple",
        "explanation": "This example shows how hash() can be used with different types of hashable objects.",
        "expectedOutput": "8771829563844916974\n42\n322818021289917443\n2528502973977326415"
      },
      {
        "title": "Hashing Mutable vs Immutable Objects",
        "code": "print(hash('hello'))  # Works fine\n\ntry:\n    print(hash([1, 2, 3]))  # Raises TypeError\nexcept TypeError as e:\n    print(f\"Error: {e}\")\n\nprint(hash((1, 2, 3)))  # Works fine (tuple is immutable)",
        "explanation": "This example demonstrates that while immutable objects are hashable, mutable objects like lists are not.",
        "expectedOutput": "8771829563844916974\nError: unhashable type: 'list'\n2528502973977326415"
      },
      {
        "title": "Custom Object Hashing",
        "code": "class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    \n    def __hash__(self):\n        return hash((self.name, self.age))\n\nperson1 = Person(\"Alice\", 30)\nperson2 = Person(\"Alice\", 30)\n\nprint(hash(person1))\nprint(hash(person2))\nprint(hash(person1) == hash(person2))  # True",
        "explanation": "This example shows how to implement a custom __hash__() method for user-defined classes, allowing instances to be hashed.",
        "expectedOutput": "-3753673991817604489\n-3753673991817604489\nTrue"
      }
    ]
  },
  {
    "name": "help",
    "module": "builtins",
    "class_name": null,
    "return_type": "None",
    "parameters": [
      {
        "name": "object",
        "type": "Optional[Any]"
      }
    ],
    "docstring": "Invoke the built-in help system.",
    "decorators": [],
    "main_category": "Introspection",
    "sub_category": "Documentation",
    "data_type_manipulated": ["Any"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The help() function invokes the built-in help system. If called without an argument, it starts an interactive help session. When called with an object as an argument, it prints help about that object. The help system uses pydoc to generate its documentation as text on the console.",
    "return_value": "This function doesn't return a value; it prints help text to the console.",
    "parameter_values": "This function takes an optional parameter: object (any Python object, including modules, functions, classes, methods, keywords, or documentation topics).",
    "function_signature": "help(object: Optional[Any] = None) -> None",
    "related_functions": [
      "dir()",
      "type()",
      "__doc__",
      "pydoc.render_doc()",
      "inspect.getdoc()",
      "sys.modules"
    ],
    "examples": [
      {
        "title": "Interactive Help Session",
        "code": "help()",
        "explanation": "This starts an interactive help session in the console. The user can type in topics to get help.",
        "expected_output": "Welcome to Python 3.x's help utility!\n\nIf this is your first time using Python, you should definitely check out\nthe tutorial on the Internet at https://docs.python.org/3.x/tutorial/.\n\nEnter the name of any module, keyword, or topic to get help on writing\nPython programs and using Python modules.  To quit this help utility and\nreturn to the interpreter, just type \"quit\".\n\nTo get a list of available modules, keywords, symbols, or topics, type\n\"modules\", \"keywords\", \"symbols\", or \"topics\".  Each module also comes\nwith a one-line summary of what it does; to list the modules whose name\nor summary contain a given string such as \"spam\", type \"modules spam\".\n\nhelp>"
      },
      {
        "title": "Getting Help on a Built-in Function",
        "code": "help(print)",
        "explanation": "This displays help information for the built-in print() function.",
        "expected_output": "Help on built-in function print in module builtins:\n\nprint(...)\n    print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n    \n    Prints the values to a stream, or to sys.stdout by default.\n    Optional keyword arguments:\n    file:  a file-like object (stream); defaults to the current sys.stdout.\n    sep:   string inserted between values, default a space.\n    end:   string appended after the last value, default a newline.\n    flush: whether to forcibly flush the stream.\n"
      },
      {
        "title": "Getting Help on a Module",
        "code": "import math\nhelp(math)",
        "explanation": "This displays help information for the entire math module.",
        "expected_output": "Help on module math:\n\nNAME\n    math\n\nDESCRIPTION\n    This module provides access to the mathematical functions\n    defined by the C standard.\n\nFUNCTIONS\n    acos(x, /)\n        Return the arc cosine (measured in radians) of x.\n        \n    acosh(x, /)\n        Return the inverse hyperbolic cosine of x.\n    ...\n"
      },
      {
        "title": "Getting Help on a Keyword",
        "code": "help('if')",
        "explanation": "This displays help information for the 'if' keyword.",
        "expected_output": "The \"if\" statement\n******************\n\nThe \"if\" statement is used for conditional execution:\n\n   if_stmt ::= \"if\" expression \":\" suite\n               (\"elif\" expression \":\" suite)*\n               [\"else\" \":\" suite]\n\nIt selects exactly one of the suites by evaluating the expressions one\nby one until one is found to be true (see section Boolean operations\nfor the definition of true and false); then that suite is executed\n(and no other part of the \"if\" statement is executed or evaluated).\nIf all expressions are false, the suite of the \"else\" clause, if\npresent, is executed.\n"
      }
    ]
  },
  {
    "name": "hex",
    "module": "builtins",
    "class_name": null,
    "return_type": "str",
    "parameters": [
      {
        "name": "x",
        "type": "int"
      }
    ],
    "docstring": "Return the hexadecimal representation of an integer.",
    "decorators": [],
    "main_category": "Type Conversion",
    "sub_category": "Numeric",
    "data_type_manipulated": ["int"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The hex() function converts an integer number to a lowercase hexadecimal string prefixed with '0x'. If x is not a Python int object, it has to define an __index__() method that returns an integer. The returned string is a valid Python expression.",
    "return_value": "Returns a string containing the hexadecimal representation of the input integer.",
    "parameter_values": "This function takes one parameter: x (an integer to be converted to hexadecimal representation).",
    "function_signature": "hex(x: int) -> str",
    "related_functions": [
      "int()",
      "bin()",
      "oct()",
      "format()",
      "int.to_bytes()",
      "int.from_bytes()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "print(hex(255))\nprint(hex(-42))",
        "explanation": "This example shows the basic usage of hex() with positive and negative integers.",
        "expected_output": "0xff\n-0x2a"
      },
      {
        "title": "Using hex() with Different Integer Types",
        "code": "print(hex(0))  # Zero\nprint(hex(1000))  # Large positive number\nprint(hex(-1000))  # Large negative number\nprint(hex(0xABCD))  # Hexadecimal input",
        "explanation": "This example demonstrates hex() function behavior with various integer inputs, including zero, large numbers, and hexadecimal input.",
        "expected_output": "0x0\n0x3e8\n-0x3e8\n0xabcd"
      },
      {
        "title": "Using hex() with Custom Objects",
        "code": "class CustomInt:\n    def __init__(self, value):\n        self.value = value\n    \n    def __index__(self):\n        return self.value\n\ncustom_num = CustomInt(42)\nprint(hex(custom_num))",
        "explanation": "This example shows how hex() can be used with custom objects that implement the __index__() method.",
        "expected_output": "0x2a"
      },
      {
        "title": "Error Handling",
        "code": "try:\n    print(hex('not an integer'))\nexcept TypeError as e:\n    print(f\"Error: {e}\")\n\ntry:\n    print(hex(3.14))\nexcept TypeError as e:\n    print(f\"Error: {e}\")",
        "explanation": "This example demonstrates how hex() handles invalid inputs, such as strings or floating-point numbers.",
        "expected_output": "Error: 'str' object cannot be interpreted as an integer\nError: 'float' object cannot be interpreted as an integer"
      }
    ]
  },
  {
    "name": "id",
    "module": "builtins",
    "class_name": null,
    "return_type": "int",
    "parameters": [
      {
        "name": "object",
        "type": "Any"
      }
    ],
    "docstring": "Return the identity of an object.",
    "decorators": [],
    "main_category": "Object Operations",
    "sub_category": "Identity",
    "data_type_manipulated": ["Any"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The id() function returns an integer representing the identity of an object. This is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value. CPython implementation detail: This is the address of the object in memory.",
    "return_value": "Returns an integer representing the unique identity of the object.",
    "parameter_values": "This function takes one parameter: object (any Python object).",
    "function_signature": "id(object: Any) -> int",
    "related_functions": [
      "is",
      "isinstance()",
      "type()",
      "sys.getrefcount()",
      "weakref.ref()",
      "gc.get_referrers()"
    ],
    "examples": [
      {
        "title": "Basic Usage with Different Types",
        "code": "x = 5\ny = 'hello'\nz = [1, 2, 3]\nprint(id(x))\nprint(id(y))\nprint(id(z))",
        "explanation": "This example shows how id() returns different values for different objects.",
        "expected_output": "140721989819888\n140721989933488\n140721989933568\n(Note: The actual numbers will vary between runs and systems)"
      },
      {
        "title": "Demonstrating Object Identity",
        "code": "a = [1, 2, 3]\nb = a\nc = [1, 2, 3]\nprint(id(a) == id(b))  # Same object\nprint(id(a) == id(c))  # Different objects with same value",
        "explanation": "This example demonstrates that id() returns the same value for aliases of the same object, but different values for distinct objects, even if they have the same value.",
        "expected_output": "True\nFalse"
      },
      {
        "title": "id() with Immutable and Mutable Objects",
        "code": "# Immutable (int)\nx = 5\ny = 5\nprint(id(x) == id(y))\n\n# Mutable (list)\na = [1, 2, 3]\nb = [1, 2, 3]\nprint(id(a) == id(b))",
        "explanation": "This example shows how id() behaves differently with immutable and mutable objects. For small integers, Python often reuses the same object, but for mutable objects like lists, new objects are always created.",
        "expected_output": "True\nFalse"
      },
      {
        "title": "id() in a Loop",
        "code": "def create_object():\n    return {}\n\nfor _ in range(3):\n    obj = create_object()\n    print(id(obj))",
        "explanation": "This example demonstrates how id() returns different values for objects created in a loop, even if they appear identical.",
        "expected_output": "140721989933568\n140721989933648\n140721989933728\n(Note: The actual numbers will vary between runs and systems)"
      }
    ]
  },
  {
    "name": "input",
    "module": "builtins",
    "class_name": null,
    "return_type": "str",
    "parameters": [
      {
        "name": "prompt",
        "type": "Optional[str]"
      }
    ],
    "docstring": "Read a string from standard input.",
    "decorators": [],
    "main_category": "Input/Output",
    "sub_category": "User Input",
    "data_type_manipulated": ["str"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The input() function prompts the user for input and returns the entered string. If the optional 'prompt' argument is provided, it is printed to the console without a trailing newline before reading input. The function always returns a string, stripping the trailing newline.",
    "return_value": "Returns a string containing the line read from the user input.",
    "parameter_values": "This function takes an optional parameter: prompt (a string to be printed to the console before reading input).",
    "function_signature": "input(prompt: Optional[str] = None) -> str",
    "related_functions": [
      "print()",
      "sys.stdin.readline()",
      "getpass.getpass()",
      "fileinput.input()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "name = input('Enter your name: ')\nprint(f'Hello, {name}!')",
        "explanation": "This example demonstrates the basic usage of input() to get a user's name and then greet them.",
        "expected_output": "Enter your name: John\nHello, John!"
      },
      {
        "title": "Input with Type Conversion",
        "code": "age = int(input('Enter your age: '))\nprint(f'In 10 years, you will be {age + 10} years old.')",
        "explanation": "This example shows how to convert the input (which is always a string) to an integer for numerical operations.",
        "expected_output": "Enter your age: 25\nIn 10 years, you will be 35 years old."
      },
      {
        "title": "Input without Prompt",
        "code": "user_input = input()\nprint(f'You entered: {user_input}')",
        "explanation": "This example shows that input() can be used without a prompt, in which case it simply waits for user input.",
        "expected_output": "Hello, World!\nYou entered: Hello, World!"
      },
      {
        "title": "Error Handling with Input",
        "code": "while True:\n    try:\n        number = float(input('Enter a number: '))\n        break\n    except ValueError:\n        print('Invalid input. Please enter a number.')\nprint(f'The number you entered is: {number}')",
        "explanation": "This example demonstrates how to handle potential ValueError exceptions when converting input to a specific type.",
        "expected_output": "Enter a number: abc\nInvalid input. Please enter a number.\nEnter a number: 3.14\nThe number you entered is: 3.14"
      }
    ]
  },
  {
    "name": "int",
    "module": "builtins",
    "class_name": "int",
    "return_type": "int",
    "parameters": [
      {
        "name": "x",
        "type": "Union[str, Number, None]"
      },
      {
        "name": "base",
        "type": "Optional[int]"
      }
    ],
    "docstring": "Convert a number or string to an integer, or return 0 if no arguments are given.",
    "decorators": [],
    "main_category": "Type Conversion",
    "sub_category": "Numeric",
    "data_type_manipulated": ["str", "float", "int"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The int() function returns an integer object constructed from a number or string x, or returns 0 if no arguments are given. If x is a number, it can be a plain integer, a float, or a number with a different base. If x is a string, it must be a sequence of digits in the given base (default 10). The optional base parameter specifies the base in which the string is interpreted.",
    "return_value": "Returns an integer object constructed from the given number or string.",
    "parameter_values": "This function takes two parameters: x (a number or string to be converted to an integer) and base (an optional integer base for the conversion when x is a string).",
    "function_signature": "int(x: Union[str, Number, None] = None, base: Optional[int] = 10) -> int",
    "related_functions": [
      "float()",
      "complex()",
      "str()",
      "bin()",
      "hex()",
      "oct()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "print(int('42'))  # String to int\nprint(int(3.14))  # Float to int\nprint(int())  # No arguments",
        "explanation": "This example shows basic usage of int() with different types of input.",
        "expected_output": "42\n3\n0"
      },
      {
        "title": "Using Different Bases",
        "code": "print(int('1010', 2))  # Binary to decimal\nprint(int('FF', 16))  # Hexadecimal to decimal\nprint(int('755', 8))  # Octal to decimal",
        "explanation": "This example demonstrates how to use int() with different number bases.",
        "expected_output": "10\n255\n493"
      },
      {
        "title": "Error Handling",
        "code": "try:\n    print(int('not a number'))\nexcept ValueError as e:\n    print(f'ValueError: {e}')\n\ntry:\n    print(int('123', 37))  # Invalid base\nexcept ValueError as e:\n    print(f'ValueError: {e}')",
        "explanation": "This example shows how int() handles invalid inputs and bases.",
        "expected_output": "ValueError: invalid literal for int() with base 10: 'not a number'\nValueError: int() base must be >= 2 and <= 36, or 0"
      },
      {
        "title": "Using int() as a Class",
        "code": "x = int(5)\ny = int('10')\nprint(isinstance(x, int))\nprint(x + y)\nprint(int.bit_length(15))  # Using a class method",
        "explanation": "This example demonstrates that int() can be used as a class to create integer objects and use integer methods.",
        "expected_output": "True\n15\n4"
      }
    ]
  },
  {
    "name": "isinstance",
    "module": "builtins",
    "class_name": null,
    "return_type": "bool",
    "parameters": [
      {
        "name": "object",
        "type": "Any"
      },
      {
        "name": "classinfo",
        "type": "Union[type, Tuple[type, ...]]"
      }
    ],
    "docstring": "Return whether an object is an instance of a class or of a subclass thereof.",
    "decorators": [],
    "main_category": "Type Checking",
    "sub_category": "Instance Checking",
    "data_type_manipulated": ["Any"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The isinstance() function checks if the first argument is an instance or subclass of the second argument. If the second argument is a tuple of classes or types, it checks if the first argument is an instance of any of those classes or types.",
    "return_value": "Returns a boolean indicating whether the object is an instance of the specified class(es) or type(s).",
    "parameter_values": "This function takes two parameters: object (the object to be checked) and classinfo (a type, class, or tuple of types/classes to check against).",
    "function_signature": "isinstance(object: Any, classinfo: Union[type, Tuple[type, ...]]) -> bool",
    "related_functions": [
      "issubclass()",
      "type()",
      "hasattr()",
      "getattr()",
      "id()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "print(isinstance(5, int))\nprint(isinstance('hello', str))\nprint(isinstance(3.14, float))\nprint(isinstance([1, 2, 3], list))",
        "explanation": "This example shows basic usage of isinstance() with different types.",
        "expected_output": "True\nTrue\nTrue\nTrue"
      },
      {
        "title": "Checking Multiple Types",
        "code": "print(isinstance(5, (int, float)))\nprint(isinstance('hello', (int, str)))\nprint(isinstance(3.14, (int, str)))",
        "explanation": "This example demonstrates how to use isinstance() to check if an object is an instance of any of multiple types.",
        "expected_output": "True\nTrue\nFalse"
      },
      {
        "title": "Inheritance and isinstance()",
        "code": "class Animal:\n    pass\n\nclass Dog(Animal):\n    pass\n\nfido = Dog()\nprint(isinstance(fido, Dog))\nprint(isinstance(fido, Animal))\nprint(isinstance(fido, (int, str, Animal)))",
        "explanation": "This example shows how isinstance() works with class inheritance.",
        "expected_output": "True\nTrue\nTrue"
      },
      {
        "title": "isinstance() vs type()",
        "code": "class Parent:\n    pass\n\nclass Child(Parent):\n    pass\n\nobj = Child()\nprint(isinstance(obj, Parent))\nprint(type(obj) is Parent)",
        "explanation": "This example illustrates the difference between isinstance() and using type() for type checking. isinstance() considers inheritance, while type() checks for exact type.",
        "expected_output": "True\nFalse"
      }
    ]
  },
  {
    "name": "issubclass",
    "module": "builtins",
    "class_name": null,
    "return_type": "bool",
    "parameters": [
      {
        "name": "class",
        "type": "type"
      },
      {
        "name": "classinfo",
        "type": "Union[type, Tuple[type, ...]]"
      }
    ],
    "docstring": "Return whether 'class' is a derived from another class or is the same class.",
    "decorators": [],
    "main_category": "Type Checking",
    "sub_category": "Class Relationship",
    "data_type_manipulated": ["type"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The issubclass() function checks if the first argument is a subclass of the second argument. If the second argument is a tuple of classes, it checks if the first argument is a subclass of any of those classes. A class is considered a subclass of itself.",
    "return_value": "Returns a boolean indicating whether the first argument is a subclass of the second argument (or any class in the tuple of the second argument).",
    "parameter_values": "This function takes two parameters: class (the class to be checked) and classinfo (a class, type, or tuple of classes/types to check against).",
    "function_signature": "issubclass(class: type, classinfo: Union[type, Tuple[type, ...]]) -> bool",
    "related_functions": [
      "isinstance()",
      "type()",
      "super()",
      "__subclasscheck__()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "class A: pass\nclass B(A): pass\nclass C(B): pass\n\nprint(issubclass(B, A))\nprint(issubclass(C, A))\nprint(issubclass(A, A))\nprint(issubclass(A, B))",
        "explanation": "This example demonstrates basic usage of issubclass() with a simple inheritance hierarchy.",
        "expected_output": "True\nTrue\nTrue\nFalse"
      },
      {
        "title": "Multiple Inheritance",
        "code": "class X: pass\nclass Y: pass\nclass Z(X, Y): pass\n\nprint(issubclass(Z, X))\nprint(issubclass(Z, Y))\nprint(issubclass(Z, (X, Y)))",
        "explanation": "This example shows how issubclass() works with multiple inheritance.",
        "expected_output": "True\nTrue\nTrue"
      },
      {
        "title": "Built-in Type Relationships",
        "code": "print(issubclass(bool, int))\nprint(issubclass(float, (int, complex)))\nprint(issubclass(list, object))",
        "explanation": "This example illustrates relationships between built-in types in Python.",
        "expected_output": "True\nFalse\nTrue"
      },
      {
        "title": "Error Handling",
        "code": "try:\n    issubclass(42, int)\nexcept TypeError as e:\n    print(f\"TypeError: {e}\")\n\ntry:\n    issubclass(int, 42)\nexcept TypeError as e:\n    print(f\"TypeError: {e}\")",
        "explanation": "This example shows how issubclass() handles invalid inputs.",
        "expected_output": "TypeError: issubclass() arg 1 must be a class\nTypeError: issubclass() arg 2 must be a class or tuple of classes"
      }
    ]
  },
  {
    "name": "iter",
    "module": "builtins",
    "class_name": null,
    "return_type": "iterator",
    "parameters": [
      {
        "name": "object",
        "type": "Union[Iterable, Callable]"
      },
      {
        "name": "sentinel",
        "type": "Optional[Any]"
      }
    ],
    "docstring": "Return an iterator object.",
    "decorators": [],
    "main_category": "Iteration",
    "sub_category": "Iterator Creation",
    "data_type_manipulated": ["Iterable", "Callable"],
    "version_added": "2.2",
    "deprecated": false,
    "extended_description": "The iter() function returns an iterator object. It can be called in two ways: with a single iterable argument, or with a callable and a sentinel. When called with a single argument, the argument must be iterable. When called with two arguments, the first must be callable and is called until it returns the sentinel value.",
    "return_value": "Returns an iterator object.",
    "parameter_values": "This function takes one or two parameters: object (an iterable or callable) and sentinel (optional, used with callable to determine when to stop iteration).",
    "function_signature": "iter(object: Union[Iterable, Callable], sentinel: Optional[Any] = None) -> iterator",
    "related_functions": [
      "next()",
      "enumerate()",
      "zip()",
      "__iter__()",
      "__next__()"
    ],
    "examples": [
      {
        "title": "Basic Usage with Iterable",
        "code": "my_list = [1, 2, 3]\nmy_iter = iter(my_list)\nprint(next(my_iter))\nprint(next(my_iter))\nprint(next(my_iter))\ntry:\n    print(next(my_iter))\nexcept StopIteration:\n    print(\"Iteration completed\")",
        "explanation": "This example demonstrates basic usage of iter() with a list and how to use next() to iterate through it.",
        "expected_output": "1\n2\n3\nIteration completed"
      },
      {
        "title": "Using iter() with a String",
        "code": "my_string = \"Hello\"\nmy_iter = iter(my_string)\nfor char in my_iter:\n    print(char)",
        "explanation": "This example shows how iter() can be used with a string, which is also an iterable.",
        "expected_output": "H\ne\nl\nl\no"
      },
      {
        "title": "iter() with Callable and Sentinel",
        "code": "import random\n\ndef random_number():\n    return random.randint(1, 10)\n\nmy_iter = iter(random_number, 5)\nfor num in my_iter:\n    print(num)",
        "explanation": "This example demonstrates using iter() with a callable and a sentinel value. It generates random numbers until 5 is generated.",
        "expected_output": "(Random numbers between 1 and 10, stopping when 5 is generated)"
      },
      {
        "title": "Custom Iterable Class",
        "code": "class CountDown:\n    def __init__(self, start):\n        self.start = start\n    \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        if self.start <= 0:\n            raise StopIteration\n        self.start -= 1\n        return self.start + 1\n\nfor num in iter(CountDown(5)):\n    print(num)",
        "explanation": "This example shows how to create a custom iterable class and use iter() with it.",
        "expected_output": "5\n4\n3\n2\n1"
      }
    ]
  },
  {
    "name": "len",
    "module": "builtins",
    "class_name": null,
    "return_type": "int",
    "parameters": [
      {
        "name": "s",
        "type": "Sized"
      }
    ],
    "docstring": "Return the length (the number of items) of an object.",
    "decorators": [],
    "main_category": "Object Operations",
    "sub_category": "Size",
    "data_type_manipulated": ["Sized"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The len() function returns the number of items in an object. The argument may be a sequence (such as a string, bytes, tuple, list, or range) or a collection (such as a dictionary, set, or frozen set). For mappings, len() returns the number of keys. For custom objects, len() calls the object's __len__() method.",
    "return_value": "Returns an integer representing the length of the object.",
    "parameter_values": "This function takes one parameter: s (an object that supports the len() operation).",
    "function_signature": "len(s: Sized) -> int",
    "related_functions": [
      "count()",
      "__len__()",
      "sys.getsizeof()"
    ],
    "examples": [
      {
        "title": "Basic Usage with Different Types",
        "code": "print(len([1, 2, 3]))  # List\nprint(len(\"Hello\"))  # String\nprint(len((1, 2, 3)))  # Tuple\nprint(len({\"a\": 1, \"b\": 2}))  # Dictionary\nprint(len({1, 2, 3}))  # Set",
        "explanation": "This example demonstrates using len() with various built-in types.",
        "expected_output": "3\n5\n3\n2\n3"
      },
      {
        "title": "len() with Custom Objects",
        "code": "class CustomContainer:\n    def __init__(self, data):\n        self.data = data\n    \n    def __len__(self):\n        return len(self.data)\n\nmy_container = CustomContainer([1, 2, 3, 4])\nprint(len(my_container))",
        "explanation": "This example shows how to implement __len__() in a custom class to make it work with len().",
        "expected_output": "4"
      },
      {
        "title": "len() with Empty Containers",
        "code": "print(len([]))  # Empty list\nprint(len(\"\"))  # Empty string\nprint(len({}))  # Empty dictionary\nprint(len(set()))  # Empty set",
        "explanation": "This example demonstrates that len() returns 0 for empty containers.",
        "expected_output": "0\n0\n0\n0"
      },
      {
        "title": "Error Handling",
        "code": "try:\n    len(42)\nexcept TypeError as e:\n    print(f\"TypeError: {e}\")\n\ntry:\n    len(None)\nexcept TypeError as e:\n    print(f\"TypeError: {e}\")",
        "explanation": "This example shows how len() handles inputs that don't support the operation.",
        "expected_output": "TypeError: object of type 'int' has no len()\nTypeError: object of type 'NoneType' has no len()"
      }
    ]
  },
  {
    "name": "list",
    "module": "builtins",
    "class_name": "list",
    "return_type": "list",
    "parameters": [
      {
        "name": "iterable",
        "type": "Optional[Iterable]"
      }
    ],
    "docstring": "Built-in mutable sequence.",
    "decorators": [],
    "main_category": "Data Structures",
    "sub_category": "Sequence",
    "data_type_manipulated": ["Iterable"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The list() function creates a list object. If no argument is given, it creates a new empty list. If an argument is given, it creates a list consisting of the items in the iterable. Changes to a list can affect other variables, and list operations have side effects.",
    "return_value": "Returns a new list object.",
    "parameter_values": "This function takes an optional parameter: iterable (a sequence, collection, or iterator object).",
    "function_signature": "list(iterable: Optional[Iterable] = None) -> list",
    "related_functions": [
      "tuple()",
      "set()",
      "dict()",
      "iter()",
      "collections.deque()"
    ],
    "examples": [
      {
        "title": "Creating Lists from Different Types",
        "code": "print(list())  # Empty list\nprint(list('hello'))  # String\nprint(list(range(5)))  # Range\nprint(list({1: 'a', 2: 'b'}))  # Dictionary (keys)\nprint(list({1, 2, 3}))  # Set",
        "explanation": "This example demonstrates creating lists from various types of iterables.",
        "expected_output": "[]\n['h', 'e', 'l', 'l', 'o']\n[0, 1, 2, 3, 4]\n[1, 2]\n[1, 2, 3]"
      },
      {
        "title": "List Comprehension vs list()",
        "code": "numbers = [1, 2, 3, 4, 5]\nsquares_list = list(map(lambda x: x**2, numbers))\nsquares_comp = [x**2 for x in numbers]\nprint(squares_list)\nprint(squares_comp)",
        "explanation": "This example compares creating a new list using list() with map() and a list comprehension.",
        "expected_output": "[1, 4, 9, 16, 25]\n[1, 4, 9, 16, 25]"
      },
      {
        "title": "Creating a List of Tuples",
        "code": "names = ['Alice', 'Bob', 'Charlie']\nages = [25, 30, 35]\ncombined = list(zip(names, ages))\nprint(combined)",
        "explanation": "This example shows how to use list() with zip() to create a list of tuples.",
        "expected_output": "[('Alice', 25), ('Bob', 30), ('Charlie', 35)]"
      },
      {
        "title": "Custom Iterator with list()",
        "code": "class CountDown:\n    def __init__(self, start):\n        self.start = start\n    \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        if self.start <= 0:\n            raise StopIteration\n        self.start -= 1\n        return self.start + 1\n\nprint(list(CountDown(5)))",
        "explanation": "This example demonstrates using list() with a custom iterator class.",
        "expected_output": "[5, 4, 3, 2, 1]"
      }
    ]
  },
  {
    "name": "locals",
    "module": "builtins",
    "class_name": null,
    "return_type": "dict",
    "parameters": [],
    "docstring": "Return a dictionary containing the current scope's local variables.",
    "decorators": [],
    "main_category": "Introspection",
    "sub_category": "Namespace",
    "data_type_manipulated": ["dict"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The locals() function returns a dictionary representing the current local symbol table. Free variables are returned by locals() when it is called in function blocks, but not in class blocks. Note that at the module level, locals() and globals() are the same dictionary.",
    "return_value": "Returns a dictionary containing the local namespace.",
    "parameter_values": "This function takes no parameters.",
    "function_signature": "locals() -> dict",
    "related_functions": [
      "globals()",
      "vars()",
      "dir()"
    ],
    "examples": [
      {
        "title": "Basic Usage in a Function",
        "code": "def example_function(a, b):\n    x = 10\n    y = 20\n    print(locals())\n\nexample_function(1, 2)",
        "explanation": "This example shows how locals() returns a dictionary of local variables in a function.",
        "expected_output": "{'a': 1, 'b': 2, 'x': 10, 'y': 20}"
      },
      {
        "title": "locals() at Module Level",
        "code": "x = 100\ny = 200\nprint(locals() == globals())  # At module level, locals() and globals() are the same\nprint('x' in locals())\nprint('y' in locals())",
        "explanation": "This example demonstrates that at the module level, locals() is the same as globals().",
        "expected_output": "True\nTrue\nTrue"
      },
      {
        "title": "Using locals() in a Class",
        "code": "class MyClass:\n    class_var = 'class variable'\n    \n    def __init__(self):\n        self.instance_var = 'instance variable'\n    \n    def method(self):\n        local_var = 'local variable'\n        print(locals())\n\nMyClass().method()",
        "explanation": "This example shows how locals() behaves in a class method, including only local variables and not class or instance variables.",
        "expected_output": "{'self': <__main__.MyClass object at ...>, 'local_var': 'local variable'}"
      },
      {
        "title": "Modifying locals()",
        "code": "def modify_locals():\n    x = 10\n    locals_dict = locals()\n    locals_dict['x'] = 20\n    print(x)  # x is not changed\n    x = 30\n    print(locals_dict['x'])  # locals_dict is not updated\n\nmodify_locals()",
        "explanation": "This example illustrates that modifying the dictionary returned by locals() does not affect the actual local variables, and vice versa.",
        "expected_output": "10\n20"
      }
    ]
  },
  {
    "name": "map",
    "module": "builtins",
    "class_name": "map",
    "return_type": "map",
    "parameters": [
      {
        "name": "function",
        "type": "Callable"
      },
      {
        "name": "iterable",
        "type": "Iterable"
      },
      {
        "name": "*iterables",
        "type": "Iterable"
      }
    ],
    "docstring": "Apply function to every item of iterable and return an iterator of the results.",
    "decorators": [],
    "main_category": "Iteration",
    "sub_category": "Mapping",
    "data_type_manipulated": ["Iterable"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The map() function applies a given function to each item of an iterable (or multiple iterables) and returns an iterator of the results. If additional iterables are passed, the function must take that many arguments and is applied to the items from all iterables in parallel. With multiple iterables, the iterator stops when the shortest iterable is exhausted.",
    "return_value": "Returns a map object (an iterator) of the results.",
    "parameter_values": "This function takes at least two parameters: function (a function to apply to each item) and iterable (an iterable of elements to which the function is applied). Additional iterables can be provided.",
    "function_signature": "map(function: Callable, iterable: Iterable, *iterables: Iterable) -> map",
    "related_functions": [
      "filter()",
      "functools.reduce()",
      "list comprehension",
      "generator expression",
      "itertools.starmap()"
    ],
    "examples": [
      {
        "title": "Basic Usage with a Single Iterable",
        "code": "numbers = [1, 2, 3, 4, 5]\nsquared = map(lambda x: x**2, numbers)\nprint(list(squared))",
        "explanation": "This example shows how to use map() with a lambda function to square each number in a list.",
        "expected_output": "[1, 4, 9, 16, 25]"
      },
      {
        "title": "Using map() with Multiple Iterables",
        "code": "list1 = [1, 2, 3]\nlist2 = [10, 20, 30]\nlist3 = [100, 200, 300]\nresult = map(lambda x, y, z: x + y + z, list1, list2, list3)\nprint(list(result))",
        "explanation": "This example demonstrates using map() with multiple iterables, adding corresponding elements from each list.",
        "expected_output": "[111, 222, 333]"
      },
      {
        "title": "map() with a Regular Function",
        "code": "def celsius_to_fahrenheit(c):\n    return (9/5) * c + 32\n\ntemperatures_c = [0, 10, 20, 30, 40]\ntemperatures_f = map(celsius_to_fahrenheit, temperatures_c)\nprint(list(temperatures_f))",
        "explanation": "This example shows how to use map() with a regular function to convert temperatures from Celsius to Fahrenheit.",
        "expected_output": "[32.0, 50.0, 68.0, 86.0, 104.0]"
      },
      {
        "title": "map() with Different Length Iterables",
        "code": "list1 = [1, 2, 3, 4, 5]\nlist2 = ['a', 'b', 'c']\nresult = map(lambda x, y: (x, y), list1, list2)\nprint(list(result))",
        "explanation": "This example illustrates that map() stops when the shortest iterable is exhausted.",
        "expected_output": "[(1, 'a'), (2, 'b'), (3, 'c')]"
      }
    ]
  },
  {
    "name": "max",
    "module": "builtins",
    "class_name": null,
    "return_type": "Any",
    "parameters": [
      {
        "name": "*args",
        "type": "Any"
      },
      {
        "name": "key",
        "type": "Optional[Callable]"
      },
      {
        "name": "default",
        "type": "Optional[Any]"
      }
    ],
    "docstring": "Return the largest item in an iterable or the largest of two or more arguments.",
    "decorators": [],
    "main_category": "Mathematical Operations",
    "sub_category": "Comparison",
    "data_type_manipulated": ["Any"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The max() function returns the largest item in an iterable or the largest of two or more arguments. It can be used with many different types, including numbers, strings, and custom objects. The optional 'key' argument specifies a function of one argument that is used to extract a comparison key from each element. The 'default' argument is returned if the iterable is empty.",
    "return_value": "Returns the maximum value from the given arguments or iterable.",
    "parameter_values": "This function can take multiple arguments directly, or a single iterable. The 'key' parameter is an optional function to customize the comparison, and 'default' is an optional value to return for empty iterables.",
    "function_signature": "max(*args, key: Optional[Callable] = None, default: Optional[Any] = None) -> Any",
    "related_functions": [
      "min()",
      "sorted()",
      "list.sort()"
    ],
    "examples": [
      {
        "title": "Basic Usage with Numbers",
        "code": "print(max(5, 3, 7))\nprint(max([1, 2, 3]))\nprint(max(range(10)))",
        "explanation": "These examples show how to use max() with direct arguments, a list, and a range object.",
        "expected_output": "7\n3\n9"
      },
      {
        "title": "Using max() with Strings",
        "code": "print(max('hello'))\nprint(max(['apple', 'banana', 'cherry']))",
        "explanation": "These examples demonstrate using max() with strings. For strings, comparison is lexicographical.",
        "expected_output": "o\ncherry"
      },
      {
        "title": "Using the 'key' Parameter",
        "code": "words = ['short', 'medium', 'longest', 'longer']\nprint(max(words, key=len))\n\nnumbers = [-5, -2, 0, 3, 7]\nprint(max(numbers, key=abs)",
        "explanation": "These examples show how to use the 'key' parameter to customize the comparison. In the first case, we find the longest word, and in the second, the number with the largest absolute value.",
        "expected_output": "longest\n-5"
      },
      {
        "title": "Using max() with Custom Objects",
        "code": "class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    \n    def __repr__(self):\n        return f'Person({self.name}, {self.age})'\n\npeople = [Person('Alice', 25), Person('Bob', 30), Person('Charlie', 20)]\noldest = max(people, key=lambda p: p.age)\nprint(oldest)",
        "explanation": "This example demonstrates using max() with custom objects, using a lambda function as the 'key' to compare ages.",
        "expected_output": "Person(Bob, 30)"
      },
      {
        "title": "Using the 'default' Parameter",
        "code": "print(max([], default='Empty'))\ntry:\n    print(max([]))\nexcept ValueError as e:\n    print(f'Error: {e}')",
        "explanation": "These examples show the use of the 'default' parameter when dealing with empty iterables, and the error raised when 'default' is not provided for an empty iterable.",
        "expected_output": "Empty\nError: max() arg is an empty sequence"
      }
    ]
  },
  {
    "name": "memoryview",
    "module": "builtins",
    "class_name": "memoryview",
    "return_type": "memoryview",
    "parameters": [
      {
        "name": "obj",
        "type": "Union[bytes, bytearray, array.array]"
      }
    ],
    "docstring": "Create a memory view object from a bytes-like object.",
    "decorators": [],
    "main_category": "Memory Management",
    "sub_category": "Memory View",
    "data_type_manipulated": ["bytes", "bytearray", "array.array"],
    "version_added": "2.7",
    "deprecated": false,
    "extended_description": "The memoryview() function creates a memory view object from a bytes-like object. It allows you to access the internal data of an object that supports the buffer protocol without copying the object's contents. This can be useful for efficient manipulation of large data structures.",
    "return_value": "Returns a memoryview object that allows direct access to an object's memory.",
    "parameter_values": "This function takes one parameter: obj (a bytes-like object that supports the buffer protocol).",
    "function_signature": "memoryview(obj: Union[bytes, bytearray, array.array]) -> memoryview",
    "related_functions": [
      "bytes()",
      "bytearray()",
      "array.array()",
      "struct.pack()",
      "struct.unpack()"
    ],
    "examples": [
      {
        "title": "Basic Usage with bytes",
        "code": "data = b'Hello, World!'\nmv = memoryview(data)\nprint(mv[0])\nprint(mv[1:5].tobytes())\nprint(mv.tolist())",
        "explanation": "This example shows basic operations with a memoryview created from a bytes object.",
        "expected_output": "72\nb'ello'\n[72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]"
      },
      {
        "title": "Using memoryview with bytearray",
        "code": "data = bytearray(b'Python')\nmv = memoryview(data)\nmv[0] = 74  # ASCII for 'J'\nprint(data)",
        "explanation": "This example demonstrates how changes to the memoryview affect the original object when using a mutable bytes-like object.",
        "expected_output": "bytearray(b'Jython')"
      },
      {
        "title": "memoryview with array.array",
        "code": "import array\n\ndata = array.array('i', [1, 2, 3, 4, 5])\nmv = memoryview(data)\nprint(mv[2])\nmv[2] = 30\nprint(data)",
        "explanation": "This example shows how to use memoryview with an array.array object, including reading and modifying values.",
        "expected_output": "3\narray('i', [1, 2, 30, 4, 5])"
      },
      {
        "title": "Slicing and Casting memoryview",
        "code": "data = bytearray(b'\\x00\\x01\\x02\\x03\\x04\\x05')\nmv = memoryview(data)\n\n# Create a new memoryview with a different item type\nmv_32 = mv.cast('I')\nprint(mv_32.tolist())\n\n# Modify the new view\nmv_32[0] = 0x0A0B0C0D\nprint(data)",
        "explanation": "This example demonstrates more advanced usage, including casting the memoryview to a different item type and how modifications affect the underlying data.",
        "expected_output": "[50462976]\nbytearray(b'\\r\\x0c\\x0b\\n\\x04\\x05')"
      }
    ]
  },
  {
    "name": "min",
    "module": "builtins",
    "class_name": null,
    "return_type": "Any",
    "parameters": [
      {
        "name": "*args",
        "type": "Any"
      },
      {
        "name": "key",
        "type": "Optional[Callable]"
      },
      {
        "name": "default",
        "type": "Optional[Any]"
      }
    ],
    "docstring": "Return the smallest item in an iterable or the smallest of two or more arguments.",
    "decorators": [],
    "main_category": "Mathematical Operations",
    "sub_category": "Comparison",
    "data_type_manipulated": ["Any"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The min() function returns the smallest item in an iterable or the smallest of two or more arguments. It can be used with many different types, including numbers, strings, and custom objects. The optional 'key' argument specifies a function of one argument that is used to extract a comparison key from each element. The 'default' argument is returned if the iterable is empty.",
    "return_value": "Returns the minimum value from the given arguments or iterable.",
    "parameter_values": "This function can take multiple arguments directly, or a single iterable. The 'key' parameter is an optional function to customize the comparison, and 'default' is an optional value to return for empty iterables.",
    "function_signature": "min(*args, key: Optional[Callable] = None, default: Optional[Any] = None) -> Any",
    "related_functions": [
      "max()",
      "sorted()",
      "list.sort()"
    ],
    "examples": [
      {
        "title": "Basic Usage with Numbers",
        "code": "print(min(5, 3, 7))\nprint(min([1, 2, 3]))\nprint(min(range(10)))",
        "explanation": "These examples show how to use min() with direct arguments, a list, and a range object.",
        "expected_output": "3\n1\n0"
      },
      {
        "title": "Using min() with Strings",
        "code": "print(min('hello'))\nprint(min(['apple', 'banana', 'cherry']))",
        "explanation": "These examples demonstrate using min() with strings. For strings, comparison is lexicographical.",
        "expected_output": "e\napple"
      },
      {
        "title": "Using the 'key' Parameter",
        "code": "words = ['short', 'medium', 'longest', 'longer']\nprint(min(words, key=len))\n\nnumbers = [-5, -2, 0, 3, 7]\nprint(min(numbers, key=abs)",
        "explanation": "These examples show how to use the 'key' parameter to customize the comparison. In the first case, we find the shortest word, and in the second, the number with the smallest absolute value.",
        "expected_output": "short\n0"
      },
      {
        "title": "Using min() with Custom Objects",
        "code": "class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    \n    def __repr__(self):\n        return f'Person({self.name}, {self.age})'\n\npeople = [Person('Alice', 25), Person('Bob', 30), Person('Charlie', 20)]\nyoungest = min(people, key=lambda p: p.age)\nprint(youngest)",
        "explanation": "This example demonstrates using min() with custom objects, using a lambda function as the 'key' to compare ages.",
        "expected_output": "Person(Charlie, 20)"
      },
      {
        "title": "Using the 'default' Parameter",
        "code": "print(min([], default='Empty'))\ntry:\n    print(min([]))\nexcept ValueError as e:\n    print(f'Error: {e}')",
        "explanation": "These examples show the use of the 'default' parameter when dealing with empty iterables, and the error raised when 'default' is not provided for an empty iterable.",
        "expected_output": "Empty\nError: min() arg is an empty sequence"
      }
    ]
  },
  {
    "name": "next",
    "module": "builtins",
    "class_name": null,
    "return_type": "Any",
    "parameters": [
      {
        "name": "iterator",
        "type": "Iterator"
      },
      {
        "name": "default",
        "type": "Optional[Any]"
      }
    ],
    "docstring": "Retrieve the next item from the iterator.",
    "decorators": [],
    "main_category": "Iteration",
    "sub_category": "Iterator Operations",
    "data_type_manipulated": ["Iterator"],
    "version_added": "2.6",
    "deprecated": false,
    "extended_description": "The next() function retrieves the next item from the given iterator. If a default value is provided, it is returned when the iterator is exhausted; otherwise, StopIteration is raised. This function is equivalent to calling the __next__() method on the iterator object.",
    "return_value": "Returns the next item from the iterator. If the iterator is exhausted, returns the default value if provided, otherwise raises StopIteration.",
    "parameter_values": "This function takes two parameters: iterator (an iterator object) and default (an optional value to return if the iterator is exhausted).",
    "function_signature": "next(iterator: Iterator, default: Optional[Any] = None) -> Any",
    "related_functions": [
      "iter()",
      "__next__()",
      "StopIteration",
      "for loop"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "numbers = [1, 2, 3]\nit = iter(numbers)\nprint(next(it))\nprint(next(it))\nprint(next(it))\ntry:\n    print(next(it))\nexcept StopIteration:\n    print('Iterator exhausted')",
        "explanation": "This example demonstrates basic usage of next() with a list iterator, including what happens when the iterator is exhausted.",
        "expected_output": "1\n2\n3\nIterator exhausted"
      },
      {
        "title": "Using the Default Value",
        "code": "it = iter([10, 20])\nprint(next(it, 'default'))\nprint(next(it, 'default'))\nprint(next(it, 'default'))",
        "explanation": "This example shows how to use the default parameter to provide a value when the iterator is exhausted.",
        "expected_output": "10\n20\ndefault"
      },
      {
        "title": "next() with a Custom Iterator",
        "code": "class CountDown:\n    def __init__(self, start):\n        self.count = start\n    \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        if self.count <= 0:\n            raise StopIteration\n        self.count -= 1\n        return self.count + 1\n\ncountdown = CountDown(3)\nprint(next(countdown))\nprint(next(countdown))\nprint(next(countdown))\nprint(next(countdown, 'Finished'))",
        "explanation": "This example demonstrates using next() with a custom iterator class.",
        "expected_output": "3\n2\n1\nFinished"
      },
      {
        "title": "next() in a Generator Expression",
        "code": "squares = (x**2 for x in range(5))\nprint(next(squares))\nprint(next(squares))\nprint(list(squares))",
        "explanation": "This example shows how next() can be used with a generator expression, and how it affects subsequent iteration.",
        "expected_output": "0\n1\n[4, 9, 16]"
      }
    ]
  },
  {
    "name": "object",
    "module": "builtins",
    "class_name": "object",
    "return_type": "object",
    "parameters": [],
    "docstring": "The base class of the class hierarchy.",
    "decorators": [],
    "main_category": "Object-Oriented Programming",
    "sub_category": "Base Class",
    "data_type_manipulated": ["Any"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The object class is the base class for all classes in Python. It provides default implementations for basic operations like printing and comparison. All classes implicitly inherit from object, even if not explicitly specified. The object class defines several special methods that can be overridden in subclasses to customize behavior.",
    "return_value": "Returns a new object instance when called.",
    "parameter_values": "The object class constructor takes no parameters.",
    "function_signature": "class object",
    "related_functions": [
      "type()",
      "isinstance()",
      "issubclass()",
      "__new__()",
      "__init__()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "obj = object()\nprint(type(obj))\nprint(isinstance(obj, object))",
        "explanation": "This example shows creating a basic object instance and checking its type.",
        "expected_output": "<class 'object'>\nTrue"
      },
      {
        "title": "Inheriting from object",
        "code": "class MyClass(object):\n    pass\n\nmy_instance = MyClass()\nprint(isinstance(my_instance, object))\nprint(issubclass(MyClass, object))",
        "explanation": "This example demonstrates explicit inheritance from object, which is actually unnecessary in modern Python as all classes implicitly inherit from object.",
        "expected_output": "True\nTrue"
      },
      {
        "title": "Overriding object Methods",
        "code": "class CustomObject:\n    def __init__(self, value):\n        self.value = value\n    \n    def __str__(self):\n        return f'CustomObject with value: {self.value}'\n    \n    def __eq__(self, other):\n        if isinstance(other, CustomObject):\n            return self.value == other.value\n        return False\n\nobj1 = CustomObject(5)\nobj2 = CustomObject(5)\nobj3 = CustomObject(10)\n\nprint(obj1)\nprint(obj1 == obj2)\nprint(obj1 == obj3)",
        "explanation": "This example shows how to override object methods like __str__ and __eq__ to customize object behavior.",
        "expected_output": "CustomObject with value: 5\nTrue\nFalse"
      },
      {
        "title": "Using object() as a Sentinel",
        "code": "sentinel = object()\n\ndef process_items(items, default=sentinel):\n    if default is sentinel:\n        print('No default provided')\n    else:\n        print(f'Default: {default}')\n    # Process items...\n\nprocess_items([1, 2, 3])\nprocess_items([1, 2, 3], default=0)",
        "explanation": "This example demonstrates using object() to create a unique sentinel value for detecting whether an optional argument was provided.",
        "expected_output": "No default provided\nDefault: 0"
      }
    ]
  },
  {
    "name": "oct",
    "module": "builtins",
    "class_name": null,
    "return_type": "str",
    "parameters": [
      {
        "name": "x",
        "type": "int"
      }
    ],
    "docstring": "Return the octal representation of an integer.",
    "decorators": [],
    "main_category": "Type Conversion",
    "sub_category": "Numeric",
    "data_type_manipulated": ["int"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The oct() function converts an integer to a string containing its octal representation. The result is always prefixed with '0o' to indicate that it's an octal number. For negative numbers, the octal representation is prefixed with a minus sign. If the argument is not an integer, it must define an __index__() method that returns an integer.",
    "return_value": "Returns a string containing the octal representation of the input integer.",
    "parameter_values": "This function takes one parameter: x (an integer to be converted to octal representation).",
    "function_signature": "oct(x: int) -> str",
    "related_functions": [
      "hex()",
      "bin()",
      "int()",
      "format()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "print(oct(8))\nprint(oct(42))\nprint(oct(-56))",
        "explanation": "These examples show basic usage of oct() with positive and negative integers.",
        "expected_output": "0o10\n0o52\n-0o70"
      },
      {
        "title": "Converting Different Number Bases to Octal",
        "code": "print(oct(0b1010))  # Binary to octal\nprint(oct(0xFF))     # Hexadecimal to octal\nprint(oct(0o100))   # Octal to octal (no change)",
        "explanation": "This example demonstrates converting numbers in different bases to octal.",
        "expected_output": "0o12\n0o377\n0o100"
      },
      {
        "title": "Using oct() with Custom Objects",
        "code": "class OctalInt:\n    def __init__(self, value):\n        self.value = value\n    \n    def __index__(self):\n        return self.value\n\ncustom_int = OctalInt(64)\nprint(oct(custom_int))",
        "explanation": "This example shows how to use oct() with a custom object that implements the __index__() method.",
        "expected_output": "0o100"
      },
      {
        "title": "Comparing oct() with format()",
        "code": "num = 42\nprint(oct(num))\nprint(format(num, '#o'))  # With prefix\nprint(format(num, 'o'))   # Without prefix",
        "explanation": "This example compares oct() with the format() function for octal representation, showing the difference in prefix handling.",
        "expected_output": "0o52\n0o52\n52"
      }
    ]
  },
  {
    "name": "open",
    "module": "builtins",
    "class_name": null,
    "return_type": "file",
    "parameters": [
      {
        "name": "file",
        "type": "Union[str, bytes, int]"
      },
      {
        "name": "mode",
        "type": "str"
      },
      {
        "name": "buffering",
        "type": "int"
      },
      {
        "name": "encoding",
        "type": "Optional[str]"
      },
      {
        "name": "errors",
        "type": "Optional[str]"
      },
      {
        "name": "newline",
        "type": "Optional[str]"
      },
      {
        "name": "closefd",
        "type": "bool"
      },
      {
        "name": "opener",
        "type": "Optional[Callable]"
      }
    ],
    "docstring": "Open file and return a corresponding file object.",
    "decorators": [],
    "main_category": "File I/O",
    "sub_category": "File Operations",
    "data_type_manipulated": ["file"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The open() function opens a file and returns a file object. It is used to create, read, write, and manipulate files. The function supports various modes for different operations and can handle text and binary files. It's recommended to use the 'with' statement when working with files to ensure proper closure.",
    "return_value": "Returns a file object of the type depending on the mode.",
    "parameter_values": "file: path-like object giving the pathname, mode: string that specifies the mode in which the file is opened, buffering: an optional integer used to set the buffering policy, encoding: the name of the encoding used to decode or encode the file, errors: string that specifies how encoding and decoding errors are to be handled, newline: controls how universal newlines mode works, closefd: if False, the underlying file descriptor will be kept open when the file is closed, opener: a custom opener function.",
    "function_signature": "open(file: Union[str, bytes, int], mode: str = 'r', buffering: int = -1, encoding: Optional[str] = None, errors: Optional[str] = None, newline: Optional[str] = None, closefd: bool = True, opener: Optional[Callable] = None) -> file",
    "related_functions": [
      "close()",
      "read()",
      "write()",
      "seek()",
      "tell()",
      "io.open()"
    ],
    "examples": [
      {
        "title": "Reading from a File",
        "code": "with open('example.txt', 'r') as file:\n    content = file.read()\n    print(content)",
        "explanation": "This example demonstrates how to open and read the contents of a text file.",
        "expected_output": "(Contents of example.txt)"
      },
      {
        "title": "Writing to a File",
        "code": "with open('output.txt', 'w') as file:\n    file.write('Hello, World!')\n    file.write('\\nThis is a new line.')\n\n# Verify the contents\nwith open('output.txt', 'r') as file:\n    print(file.read())",
        "explanation": "This example shows how to open a file in write mode and write content to it.",
        "expected_output": "Hello, World!\nThis is a new line."
      },
      {
        "title": "Appending to a File",
        "code": "with open('log.txt', 'a') as file:\n    file.write('Log entry 1\\n')\n    file.write('Log entry 2\\n')\n\n# Verify the contents\nwith open('log.txt', 'r') as file:\n    print(file.read())",
        "explanation": "This example demonstrates appending to an existing file or creating a new one if it doesn't exist.",
        "expected_output": "Log entry 1\nLog entry 2\n"
      },
      {
        "title": "Working with Binary Files",
        "code": "# Writing binary data\nwith open('binary_file.bin', 'wb') as file:\n    file.write(b'\\x48\\x65\\x6C\\x6C\\x6F')\n\n# Reading binary data\nwith open('binary_file.bin', 'rb') as file:\n    binary_data = file.read()\n    print(binary_data)\n    print(binary_data.decode('utf-8'))",
        "explanation": "This example shows how to work with binary files, writing and reading raw bytes.",
        "expected_output": "b'Hello'\nHello"
      }
    ]
  },
  {
    "name": "ord",
    "module": "builtins",
    "class_name": null,
    "return_type": "int",
    "parameters": [
      {
        "name": "c",
        "type": "str"
      }
    ],
    "docstring": "Return the Unicode code point for a one-character string.",
    "decorators": [],
    "main_category": "String Operations",
    "sub_category": "Character Conversion",
    "data_type_manipulated": ["str"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The ord() function returns an integer representing the Unicode code point of a given character. It takes a single character as an argument and returns the corresponding Unicode code point. This function is the inverse of chr().",
    "return_value": "Returns an integer representing the Unicode code point of the given character.",
    "parameter_values": "This function takes one parameter: c (a string of length 1, i.e., a single character).",
    "function_signature": "ord(c: str) -> int",
    "related_functions": [
      "chr()",
      "unicodedata.name()",
      "ascii()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "print(ord('A'))\nprint(ord('a'))\nprint(ord('0'))\nprint(ord(' '))",
        "explanation": "This example shows the Unicode code points for various ASCII characters.",
        "expected_output": "65\n97\n48\n32"
      },
      {
        "title": "Non-ASCII Characters",
        "code": "print(ord('Ã±'))\nprint(ord('â‚¬'))\nprint(ord('ðŸ'))",
        "explanation": "This example demonstrates ord() with non-ASCII characters, including an emoji.",
        "expected_output": "241\n8364\n128013"
      },
      {
        "title": "Using ord() with chr()",
        "code": "char = 'Z'\ncode_point = ord(char)\nprint(f\"The code point of '{char}' is {code_point}\")\nprint(f\"Converting back: {chr(code_point)}\")",
        "explanation": "This example shows how ord() and chr() are inverse operations.",
        "expected_output": "The code point of 'Z' is 90\nConverting back: Z"
      },
      {
        "title": "Error Handling",
        "code": "try:\n    print(ord('AB'))\nexcept TypeError as e:\n    print(f\"Error: {e}\")\n\ntry:\n    print(ord(''))\nexcept TypeError as e:\n    print(f\"Error: {e}\")",
        "explanation": "This example shows the errors raised when ord() is used incorrectly.",
        "expected_output": "Error: ord() expected a character, but string of length 2 found\nError: ord() expected a character, but string of length 0 found"
      }
    ]
  },
  {
    "name": "pow",
    "module": "builtins",
    "class_name": null,
    "return_type": "Union[int, float]",
    "parameters": [
      {
        "name": "base",
        "type": "Union[int, float]"
      },
      {
        "name": "exp",
        "type": "Union[int, float]"
      },
      {
        "name": "mod",
        "type": "Optional[int]"
      }
    ],
    "docstring": "Return base to the power exp; if mod is present, return base to the power exp, modulo mod.",
    "decorators": [],
    "main_category": "Mathematical Operations",
    "sub_category": "Exponentiation",
    "data_type_manipulated": ["int", "float"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The pow() function returns the result of raising the first argument to the power of the second argument. If a third argument is present, it returns the result modulo that argument. For two-argument pow(base, exp), the result is the same as base**exp. The two-argument form is generally more efficient for computation.",
    "return_value": "Returns base raised to the power of exp. If mod is present, returns the result modulo mod.",
    "parameter_values": "base: the number to be raised, exp: the power to which base is raised, mod: optional modulus for the result.",
    "function_signature": "pow(base: Union[int, float], exp: Union[int, float], mod: Optional[int] = None) -> Union[int, float]",
    "related_functions": [
      "math.pow()",
      "math.sqrt()",
      "operator.pow()",
      "**"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "print(pow(2, 3))  # 2^3\nprint(pow(5, 2))  # 5^2\nprint(pow(3, -2))  # 3^(-2)",
        "explanation": "These examples show basic usage of pow() with positive and negative exponents.",
        "expected_output": "8\n25\n0.1111111111111111"
      },
      {
        "title": "Using pow() with Modulus",
        "code": "print(pow(3, 4, 5))  # (3^4) % 5\nprint(pow(2, 3, 3))  # (2^3) % 3\nprint(pow(10, 100, 97))  # (10^100) % 97",
        "explanation": "These examples demonstrate using pow() with the modulus argument, which is useful for calculations in modular arithmetic.",
        "expected_output": "1\n2\n70"
      },
      {
        "title": "Comparing pow() and **",
        "code": "base, exp = 2, 10\nprint(f\"pow({base}, {exp}) = {pow(base, exp)}\")\nprint(f\"{base}**{exp} = {base**exp}\")\n\n# With very large numbers\nbase, exp = 2, 1000000\nprint(f\"pow({base}, {exp}) time:\")\n%time result1 = pow(base, exp)\nprint(f\"{base}**{exp} time:\")\n%time result2 = base**exp\nprint(f\"Results are equal: {result1 == result2}\")",
        "explanation": "This example compares pow() with the ** operator, showing that they produce the same results but pow() can be more efficient for large exponents.",
        "expected_output": "pow(2, 10) = 1024\n2**10 = 1024\npow(2, 1000000) time:\nCPU times: user 2.05 ms, sys: 0 ns, total: 2.05 ms\nWall time: 2.05 ms\n2**1000000 time:\nCPU times: user 2.86 ms, sys: 0 ns, total: 2.86 ms\nWall time: 2.87 ms\nResults are equal: True"
      },
      {
        "title": "Error Handling",
        "code": "try:\n    print(pow(2, -3, 5))\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\ntry:\n    print(pow(2, 3, 0))\nexcept ValueError as e:\n    print(f\"Error: {e}\")",
        "explanation": "This example shows error cases: using a negative exponent with modulus, and using zero as the modulus.",
        "expected_output": "Error: pow() 2nd argument cannot be negative when 3rd argument specified\nError: pow() 3rd argument cannot be 0"
      }
    ]
  },
  {
    "name": "print",
    "module": "builtins",
    "class_name": null,
    "return_type": "None",
    "parameters": [
      {
        "name": "*objects",
        "type": "Any"
      },
      {
        "name": "sep",
        "type": "Optional[str]"
      },
      {
        "name": "end",
        "type": "Optional[str]"
      },
      {
        "name": "file",
        "type": "Optional[TextIO]"
      },
      {
        "name": "flush",
        "type": "bool"
      }
    ],
    "docstring": "Print objects to the text stream file, separated by sep and followed by end.",
    "decorators": [],
    "main_category": "Input/Output",
    "sub_category": "Console Output",
    "data_type_manipulated": ["Any"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The print() function writes the given object(s) to the text stream file (default is sys.stdout). All non-keyword arguments are converted to strings and written to the stream, separated by sep and followed by end. Both sep and end must be strings; they can also be None, which means to use the default values. If no objects are given, print() will just write end. The file argument must be an object with a write(string) method; if it is not present or None, sys.stdout will be used. The flush keyword argument, if true, forces the stream to be flushed.",
    "return_value": "This function doesn't return a value; it prints to the specified output stream.",
    "parameter_values": "*objects: The object(s) to print. sep: String inserted between values, default is a space. end: String appended after the last value, default is a newline. file: A file-like object (stream); defaults to the current sys.stdout. flush: Whether to forcibly flush the stream.",
    "function_signature": "print(*objects: Any, sep: Optional[str] = ' ', end: Optional[str] = '\\n', file: Optional[TextIO] = None, flush: bool = False) -> None",
    "related_functions": [
      "sys.stdout.write()",
      "logging.info()",
      "pprint.pprint()",
      "format()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "print('Hello, World!')\nprint('Python', 'is', 'awesome')\nx = 10\ny = 20\nprint('The sum of', x, 'and', y, 'is', x + y)",
        "explanation": "These examples show basic usage of print() with different numbers and types of arguments.",
        "expected_output": "Hello, World!\nPython is awesome\nThe sum of 10 and 20 is 30"
      },
      {
        "title": "Using sep and end Parameters",
        "code": "print('a', 'b', 'c', sep='-')\nprint('Hello', end='!')\nprint('World')\nprint('One', 'Two', 'Three', sep=' | ', end=' ***\\n')",
        "explanation": "These examples demonstrate how to use the sep and end parameters to control the output format.",
        "expected_output": "a-b-c\nHello!World\nOne | Two | Three ***"
      },
      {
        "title": "Printing to a File",
        "code": "with open('output.txt', 'w') as f:\n    print('This will be written to a file', file=f)\n    print('This will be printed to console')\n\n# Verify the file contents\nwith open('output.txt', 'r') as f:\n    print(f.read())",
        "explanation": "This example shows how to use the file parameter to print to a file instead of the console.",
        "expected_output": "This will be printed to console\nThis will be written to a file"
      },
      {
        "title": "Using flush Parameter",
        "code": "import time\n\nprint('This will be printed immediately')\nprint('This might be buffered', flush=True)\ntime.sleep(1)  # Simulate some processing\nprint('This comes after a delay')",
        "explanation": "This example demonstrates the use of the flush parameter to force immediate output, which can be useful in scenarios where buffering might delay the output.",
        "expected_output": "This will be printed immediately\nThis might be buffered\nThis comes after a delay"
      }
    ]
  },
  {
    "name": "property",
    "module": "builtins",
    "class_name": "property",
    "return_type": "property",
    "parameters": [
      {
        "name": "fget",
        "type": "Optional[Callable]"
      },
      {
        "name": "fset",
        "type": "Optional[Callable]"
      },
      {
        "name": "fdel",
        "type": "Optional[Callable]"
      },
      {
        "name": "doc",
        "type": "Optional[str]"
      }
    ],
    "docstring": "Property attribute.",
    "decorators": [],
    "main_category": "Object-Oriented Programming",
    "sub_category": "Attributes",
    "data_type_manipulated": ["Any"],
    "version_added": "2.2",
    "deprecated": false,
    "extended_description": "The property() function returns a property object. Properties are a way to manage attribute access in classes. They allow you to define methods that will be called when an attribute is accessed, set, or deleted. This provides a way to customize attribute behavior without changing the class interface. Properties can be used for data validation, computed attributes, or to make attributes read-only.",
    "return_value": "Returns a property object that can be used as a decorator or assigned directly to a class attribute.",
    "parameter_values": "fget: Function to be used for getting the attribute value. fset: Function to be used for setting the attribute value. fdel: Function to be used for deleting the attribute. doc: A string containing the docstring for the property.",
    "function_signature": "property(fget: Optional[Callable] = None, fset: Optional[Callable] = None, fdel: Optional[Callable] = None, doc: Optional[str] = None) -> property",
    "related_functions": [
      "getattr()",
      "setattr()",
      "delattr()",
      "descriptor protocol"
    ],
    "examples": [
      {
        "title": "Basic Property Usage",
        "code": "class Circle:\n    def __init__(self, radius):\n        self._radius = radius\n\n    @property\n    def radius(self):\n        return self._radius\n\n    @radius.setter\n    def radius(self, value):\n        if value < 0:\n            raise ValueError(\"Radius cannot be negative\")\n        self._radius = value\n\n    @property\n    def area(self):\n        return 3.14 * self._radius ** 2\n\nc = Circle(5)\nprint(c.radius)\nc.radius = 10\nprint(c.radius)\nprint(c.area)\ntry:\n    c.radius = -1\nexcept ValueError as e:\n    print(f\"Error: {e}\")",
        "explanation": "This example demonstrates how to use properties for getter, setter, and computed attributes.",
        "expected_output": "5\n10\n314.0\nError: Radius cannot be negative"
      },
      {
        "title": "Property with Only Getter",
        "code": "class User:\n    def __init__(self, username):\n        self._username = username\n\n    @property\n    def username(self):\n        return self._username\n\nuser = User(\"alice\")\nprint(user.username)\ntry:\n    user.username = \"bob\"\nexcept AttributeError as e:\n    print(f\"Error: {e}\")",
        "explanation": "This example shows how to create a read-only property using only a getter method.",
        "expected_output": "alice\nError: can't set attribute"
      },
      {
        "title": "Property with Deleter",
        "code": "class Account:\n    def __init__(self, balance):\n        self._balance = balance\n\n    @property\n    def balance(self):\n        return self._balance\n\n    @balance.setter\n    def balance(self, value):\n        if value < 0:\n            raise ValueError(\"Balance cannot be negative\")\n        self._balance = value\n\n    @balance.deleter\n    def balance(self):\n        print(\"Deleting balance\")\n        del self._balance\n\naccount = Account(100)\nprint(account.balance)\naccount.balance = 200\nprint(account.balance)\ndel account.balance\ntry:\n    print(account.balance)\nexcept AttributeError as e:\n    print(f\"Error: {e}\")",
        "explanation": "This example demonstrates the use of a property deleter in addition to getter and setter methods.",
        "expected_output": "100\n200\nDeleting balance\nError: 'Account' object has no attribute '_balance'"
      },
      {
        "title": "Non-Decorator Style Property",
        "code": "class Temperature:\n    def __init__(self, celsius):\n        self._celsius = celsius\n\n    def get_fahrenheit(self):\n        return (self._celsius * 9/5) + 32\n\n    def set_fahrenheit(self, value):\n        self._celsius = (value - 32) * 5/9\n\n    fahrenheit = property(get_fahrenheit, set_fahrenheit)\n\ntemp = Temperature(25)\nprint(f\"{temp.fahrenheit:.2f}Â°F\")\ntemp.fahrenheit = 68\nprint(f\"{temp._celsius:.2f}Â°C\")",
        "explanation": "This example shows how to create a property without using decorators, which can be useful when working with existing methods.",
        "expected_output": "77.00Â°F\n20.00Â°C"
      }
    ]
  },
  {
    "name": "range",
    "module": "builtins",
    "class_name": "range",
    "return_type": "range",
    "parameters": [
      {
        "name": "start",
        "type": "int"
      },
      {
        "name": "stop",
        "type": "int"
      },
      {
        "name": "step",
        "type": "int"
      }
    ],
    "docstring": "Return an object that produces a sequence of integers from start to stop by step.",
    "decorators": [],
    "main_category": "Sequence Generation",
    "sub_category": "Numeric Sequence",
    "data_type_manipulated": ["int"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The range() function returns a sequence of numbers, starting from 0 by default, and increments by 1 (by default), and stops before a specified number. It's commonly used in for loops and for creating lists of numbers. range objects are immutable sequences and support most common sequence operations.",
    "return_value": "Returns a range object that represents an immutable sequence of numbers.",
    "parameter_values": "start: The starting value of the sequence (default is 0). stop: The end value of the sequence (exclusive). step: The step or increment between each number in the sequence (default is 1).",
    "function_signature": "range(start: int, stop: int, step: int = 1) -> range",
    "related_functions": [
      "enumerate()",
      "list()",
      "xrange() (Python 2)",
      "itertools.count()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "print(list(range(5)))\nprint(list(range(1, 6)))\nprint(list(range(0, 10, 2)))\nprint(list(range(5, 0, -1)))",
        "explanation": "These examples show basic usage of range() with different combinations of start, stop, and step values.",
        "expected_output": "[0, 1, 2, 3, 4]\n[1, 2, 3, 4, 5]\n[0, 2, 4, 6, 8]\n[5, 4, 3, 2, 1]"
      },
      {
        "title": "Using range() in a for loop",
        "code": "for i in range(3):\n    print(f\"Iteration {i}\")\n\nfor i in range(10, 0, -2):\n    print(i, end=' ')\nprint()",
        "explanation": "This example demonstrates how range() is commonly used in for loops for iteration and countdown.",
        "expected_output": "Iteration 0\nIteration 1\nIteration 2\n10 8 6 4 2 "
      },
      {
        "title": "range() with large numbers",
        "code": "large_range = range(1000000)\nprint(f\"Type: {type(large_range)}\")\nprint(f\"Size: {large_range.__sizeof__()} bytes\")\nprint(f\"First 5 elements: {list(large_range[:5])}\")\nprint(f\"Last 5 elements: {list(large_range[-5:])}\")",
        "explanation": "This example shows how range() efficiently handles large sequences without storing all values in memory.",
        "expected_output": "Type: <class 'range'>\nSize: 48 bytes\nFirst 5 elements: [0, 1, 2, 3, 4]\nLast 5 elements: [999995, 999996, 999997, 999998, 999999]"
      },
      {
        "title": "range() operations",
        "code": "r = range(0, 20, 2)\nprint(3 in r)\nprint(10 in r)\nprint(r.index(6))\nprint(r.count(10))\nprint(r[4])\nprint(len(r))",
        "explanation": "This example demonstrates various operations supported by range objects, including membership testing, indexing, and length.",
        "expected_output": "False\nTrue\n3\n1\n8\n10"
      }
    ]
  },
  {
    "name": "repr",
    "module": "builtins",
    "class_name": null,
    "return_type": "str",
    "parameters": [
      {
        "name": "object",
        "type": "Any"
      }
    ],
    "docstring": "Return a string containing a printable representation of an object.",
    "decorators": [],
    "main_category": "Object Representation",
    "sub_category": "String Conversion",
    "data_type_manipulated": ["Any"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The repr() function returns a string containing a printable representation of an object. For many types, this function makes an attempt to return a string that would yield an object with the same value when passed to eval(). If this is not possible, a string of the form <...some useful description...> is returned. repr() is often used for debugging as it provides more information about the object than str().",
    "return_value": "Returns a string representation of the object.",
    "parameter_values": "This function takes one parameter: object (any Python object).",
    "function_signature": "repr(object: Any) -> str",
    "related_functions": [
      "str()",
      "ascii()",
      "__repr__()",
      "pprint.pformat()"
    ],
    "examples": [
      {
        "title": "Basic Usage with Different Types",
        "code": "print(repr('hello'))\nprint(repr([1, 2, 3]))\nprint(repr({'a': 1, 'b': 2}))\nprint(repr(42))\nprint(repr(3.14))",
        "explanation": "These examples show how repr() works with different types of objects.",
        "expected_output": "'hello'\n[1, 2, 3]\n{'a': 1, 'b': 2}\n42\n3.14"
      },
      {
        "title": "repr() vs str()",
        "code": "s = 'Hello, World!'\nprint(f\"str: {str(s)}\")\nprint(f\"repr: {repr(s)}\")\n\nd = datetime.datetime(2023, 4, 1, 12, 30)\nprint(f\"str: {str(d)}\")\nprint(f\"repr: {repr(d)}\")",
        "explanation": "This example demonstrates the difference between str() and repr() for strings and datetime objects.",
        "expected_output": "str: Hello, World!\nrepr: 'Hello, World!'\nstr: 2023-04-01 12:30:00\nrepr: datetime.datetime(2023, 4, 1, 12, 30)"
      },
      {
        "title": "Custom __repr__ Method",
        "code": "class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    \n    def __repr__(self):\n        return f\"Person(name='{self.name}', age={self.age})\"\n\np = Person('Alice', 30)\nprint(repr(p))",
        "explanation": "This example shows how to define a custom __repr__ method for a class, which is used by repr().",
        "expected_output": "Person(name='Alice', age=30)"
      },
      {
        "title": "Using repr() for Debugging",
        "code": "def debug_print(obj):\n    print(f\"Type: {type(obj)}\")\n    print(f\"Repr: {repr(obj)}\")\n\ndebug_print('hello')\ndebug_print([1, 2, 3])\ndebug_print({'a': 1, 'b': 2})",
        "explanation": "This example demonstrates how repr() can be used in debugging to get detailed information about objects.",
        "expected_output": "Type: <class 'str'>\nRepr: 'hello'\nType: <class 'list'>\nRepr: [1, 2, 3]\nType: <class 'dict'>\nRepr: {'a': 1, 'b': 2}"
      }
    ]
  },
  {
    "name": "reversed",
    "module": "builtins",
    "class_name": "reversed",
    "return_type": "Iterator",
    "parameters": [
      {
        "name": "seq",
        "type": "Sequence"
      }
    ],
    "docstring": "Return a reverse iterator over the values of the given sequence.",
    "decorators": [],
    "main_category": "Iteration",
    "sub_category": "Sequence Reversal",
    "data_type_manipulated": ["Sequence"],
    "version_added": "2.4",
    "deprecated": false,
    "extended_description": "The reversed() function returns a reverse iterator over the values of the given sequence. It works with any object that has a __reversed__() method or supports the sequence protocol (the __len__() method and the __getitem__() method with integer arguments starting at 0). The reversed object returned is an iterator, so it can be used in for loops or converted to other sequence types.",
    "return_value": "Returns a reverse iterator over the sequence.",
    "parameter_values": "This function takes one parameter: seq (a sequence or any object with a __reversed__() method).",
    "function_signature": "reversed(seq: Sequence) -> Iterator",
    "related_functions": [
      "iter()",
      "list.reverse()",
      "sorted(reverse=True)",
      "__reversed__()"
    ],
    "examples": [
      {
        "title": "Basic Usage with Different Types",
        "code": "print(list(reversed([1, 2, 3, 4, 5])))\nprint(list(reversed('hello')))\nprint(tuple(reversed((10, 20, 30, 40, 50))))",
        "explanation": "These examples show how reversed() works with lists, strings, and tuples.",
        "expected_output": "[5, 4, 3, 2, 1]\n['o', 'l', 'l', 'e', 'h']\n(50, 40, 30, 20, 10)"
      },
      {
        "title": "Using reversed() in a for loop",
        "code": "for num in reversed(range(1, 6)):\n    print(num, end=' ')\nprint()\n\nfor char in reversed('Python'):\n    print(char, end='')\nprint()",
        "explanation": "This example demonstrates how to use reversed() in for loops for countdown and string reversal.",
        "expected_output": "5 4 3 2 1 \nnohtyP"
      },
      {
        "title": "reversed() with Custom Objects",
        "code": "class CountDown:\n    def __init__(self, start):\n        self.start = start\n    \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        if self.start <= 0:\n            raise StopIteration\n        self.start -= 1\n        return self.start + 1\n    \n    def __reversed__(self):\n        return range(1, self.start + 1)\n\ncd = CountDown(5)\nprint(list(cd))\nprint(list(reversed(cd)))",
        "explanation": "This example shows how to implement a __reversed__() method in a custom class to work with reversed().",
        "expected_output": "[5, 4, 3, 2, 1]\n[1, 2, 3, 4, 5]"
      },
      {
        "title": "Memory Efficiency of reversed()",
        "code": "import sys\n\noriginal = range(1000000)\nreversed_range = reversed(original)\n\nprint(f\"Size of original: {sys.getsizeof(original)} bytes\")\nprint(f\"Size of reversed: {sys.getsizeof(reversed_range)} bytes\")\n\nprint(f\"First 5 of reversed: {list(reversed_range)[:5]}\")",
        "explanation": "This example demonstrates the memory efficiency of reversed(), which creates an iterator without storing the entire reversed sequence in memory.",
        "expected_output": "Size of original: 48 bytes\nSize of reversed: 48 bytes\nFirst 5 of reversed: [999999, 999998, 999997, 999996, 999995]"
      }
    ]
  },
  {
    "name": "round",
    "module": "builtins",
    "class_name": null,
    "return_type": "Union[int, float]",
    "parameters": [
      {
        "name": "number",
        "type": "Union[int, float]"
      },
      {
        "name": "ndigits",
        "type": "Optional[int]"
      }
    ],
    "docstring": "Round a number to a given precision in decimal digits.",
    "decorators": [],
    "main_category": "Mathematical Operations",
    "sub_category": "Rounding",
    "data_type_manipulated": ["int", "float"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The round() function returns the number rounded to ndigits precision after the decimal point. If ndigits is omitted or is None, it returns the nearest integer to its input. For built-in types supporting round(), values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done toward the even choice (so, for example, both round(0.5) and round(-0.5) are 0, and round(1.5) is 2).",
    "return_value": "Returns the rounded number. The result is an integer if ndigits is omitted or None. Otherwise, the result has the same type as the input.",
    "parameter_values": "number: The number to be rounded. ndigits: The number of decimal places to round to (default is None, which rounds to the nearest integer).",
    "function_signature": "round(number: Union[int, float], ndigits: Optional[int] = None) -> Union[int, float]",
    "related_functions": [
      "math.floor()",
      "math.ceil()",
      "math.trunc()",
      "decimal.Decimal.quantize()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "print(round(3.14159))\nprint(round(3.14159, 2))\nprint(round(3.14159, 4))\nprint(round(3.5))\nprint(round(4.5))",
        "explanation": "These examples show basic usage of round() with different precisions and demonstrate the 'round to even' rule for .5 cases.",
        "expected_output": "3\n3.14\n3.1416\n4\n4"
      },
      {
        "title": "Rounding Negative Numbers",
        "code": "print(round(-3.14159))\nprint(round(-3.14159, 2))\nprint(round(-3.5))\nprint(round(-4.5))",
        "explanation": "This example demonstrates how round() works with negative numbers.",
        "expected_output": "-3\n-3.14\n-4\n-4"
      },
      {
        "title": "Rounding to Tens, Hundreds, etc.",
        "code": "print(round(153, -1))\nprint(round(153, -2))\nprint(round(1534, -3))\nprint(round(1534, -4))",
        "explanation": "This example shows how to use negative ndigits to round to tens, hundreds, etc.",
        "expected_output": "150\n200\n2000\n0"
      },
      {
        "title": "Floating Point Precision Issues",
        "code": "print(round(2.675, 2))\nprint(round(2.675, 2) == 2.68)\nprint(f\"{2.675:.20f}\")\n\nfrom decimal import Decimal\nprint(round(Decimal('2.675'), 2))",
        "explanation": "This example highlights potential issues with floating-point precision and demonstrates how using the Decimal type can provide more accurate results.",
        "expected_output": "2.67\nFalse\n2.67499999999999982236\n2.68"
      }
    ]
  },
  {
    "name": "set",
    "module": "builtins",
    "class_name": "set",
    "return_type": "set",
    "parameters": [
      {
        "name": "iterable",
        "type": "Optional[Iterable]"
      }
    ],
    "docstring": "Return a new set object, optionally with elements taken from iterable.",
    "decorators": [],
    "main_category": "Data Structures",
    "sub_category": "Set",
    "data_type_manipulated": ["Iterable"],
    "version_added": "2.4",
    "deprecated": false,
    "extended_description": "The set() function creates a new set object. Sets are unordered collections with no duplicate elements. They support mathematical operations like union, intersection, difference, and symmetric difference. Sets are mutable, and elements must be immutable (hashable). If an iterable is provided, it creates a set with elements from the iterable.",
    "return_value": "Returns a new set object.",
    "parameter_values": "This function takes one optional parameter: iterable (any iterable object).",
    "function_signature": "set(iterable: Optional[Iterable] = None) -> set",
    "related_functions": [
      "frozenset()",
      "list()",
      "tuple()",
      "dict()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "print(set([1, 2, 3, 2, 1]))\nprint(set('hello'))\nprint(set((1, 2, 3, 2, 1)))\nprint(set())",
        "explanation": "These examples show how to create sets from different types of iterables and how duplicates are automatically removed.",
        "expected_output": "{1, 2, 3}\n{'h', 'e', 'l', 'o'}\n{1, 2, 3}\nset()"
      },
      {
        "title": "Set Operations",
        "code": "set1 = {1, 2, 3, 4, 5}\nset2 = {4, 5, 6, 7, 8}\nprint(f\"Union: {set1 | set2}\")\nprint(f\"Intersection: {set1 & set2}\")\nprint(f\"Difference: {set1 - set2}\")\nprint(f\"Symmetric Difference: {set1 ^ set2}\")",
        "explanation": "This example demonstrates various set operations.",
        "expected_output": "Union: {1, 2, 3, 4, 5, 6, 7, 8}\nIntersection: {4, 5}\nDifference: {1, 2, 3}\nSymmetric Difference: {1, 2, 3, 6, 7, 8}"
      },
      {
        "title": "Set Methods",
        "code": "s = {1, 2, 3}\ns.add(4)\nprint(s)\ns.remove(2)\nprint(s)\ns.discard(5)  # No error if element not found\nprint(s)\npopped = s.pop()\nprint(f\"Popped: {popped}, Set: {s}\")\ns.clear()\nprint(s)",
        "explanation": "This example shows various methods available for set objects.",
        "expected_output": "{1, 2, 3, 4}\n{1, 3, 4}\n{1, 3, 4}\nPopped: 1, Set: {3, 4}\nset()"
      },
      {
        "title": "Set Comprehension",
        "code": "numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_squares = {x**2 for x in numbers if x % 2 == 0}\nprint(even_squares)",
        "explanation": "This example demonstrates how to use set comprehension to create a set of even squares.",
        "expected_output": "{4, 16, 36, 64, 100}"
      }
    ]
  },
  {
    "name": "setattr",
    "module": "builtins",
    "class_name": null,
    "return_type": "None",
    "parameters": [
      {
        "name": "object",
        "type": "Any"
      },
      {
        "name": "name",
        "type": "str"
      },
      {
        "name": "value",
        "type": "Any"
      }
    ],
    "docstring": "Set a named attribute on an object with the given value.",
    "decorators": [],
    "main_category": "Object Manipulation",
    "sub_category": "Attribute Operations",
    "data_type_manipulated": ["Any"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The setattr() function sets the value of the named attribute of an object. It's the counterpart to getattr(). If the object allows it, setattr() sets the named attribute to the given value. This is equivalent to object.name = value. If the object doesn't allow setting the attribute, it raises an AttributeError.",
    "return_value": "This function doesn't return a value (None).",
    "parameter_values": "object: The object whose attribute is to be set. name: A string containing the name of the attribute to be set. value: The value to be assigned to the attribute.",
    "function_signature": "setattr(object: Any, name: str, value: Any) -> None",
    "related_functions": [
      "getattr()",
      "hasattr()",
      "delattr()",
      "__setattr__()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "class Person:\n    pass\n\np = Person()\nsetattr(p, 'name', 'Alice')\nsetattr(p, 'age', 30)\nprint(p.name)\nprint(p.age)",
        "explanation": "This example shows how to use setattr() to add attributes to an object dynamically.",
        "expected_output": "Alice\n30"
      },
      {
        "title": "Using setattr() with Existing Methods",
        "code": "class Calculator:\n    def add(self, x, y):\n        return x + y\n\ncalc = Calculator()\nsetattr(calc, 'multiply', lambda x, y: x * y)\nprint(calc.add(3, 4))\nprint(calc.multiply(3, 4))",
        "explanation": "This example demonstrates how to use setattr() to add a new method to an existing class instance.",
        "expected_output": "7\n12"
      },
      {
        "title": "setattr() vs Direct Assignment",
        "code": "class Config:\n    pass\n\nconfig = Config()\n\n# Using setattr\nsetattr(config, 'debug', True)\n\n# Direct assignment\nconfig.verbose = False\n\nprint(f\"Debug: {config.debug}\")\nprint(f\"Verbose: {config.verbose}\")\n\n# Using setattr with a variable attribute name\nattr_name = 'log_level'\nsetattr(config, attr_name, 'INFO')\nprint(f\"Log Level: {config.log_level}\")",
        "explanation": "This example compares using setattr() with direct attribute assignment and shows how setattr() can be used with variable attribute names.",
        "expected_output": "Debug: True\nVerbose: False\nLog Level: INFO"
      },
      {
        "title": "Error Handling with setattr()",
        "code": "class ProtectedClass:\n    __slots__ = ['allowed_attr']\n\nobj = ProtectedClass()\n\ntry:\n    setattr(obj, 'allowed_attr', 10)\n    print(f\"Allowed attribute: {obj.allowed_attr}\")\n    \n    setattr(obj, 'forbidden_attr', 20)\nexcept AttributeError as e:\n    print(f\"Error: {e}\")",
        "explanation": "This example shows how setattr() behaves with classes that use __slots__ to restrict attribute creation.",
        "expected_output": "Allowed attribute: 10\nError: 'ProtectedClass' object has no attribute 'forbidden_attr'"
      }
    ]
  },
  {
    "name": "slice",
    "module": "builtins",
    "class_name": "slice",
    "return_type": "slice",
    "parameters": [
      {
        "name": "start",
        "type": "Optional[int]"
      },
      {
        "name": "stop",
        "type": "Optional[int]"
      },
      {
        "name": "step",
        "type": "Optional[int]"
      }
    ],
    "docstring": "Create a slice object. Used for extended slicing (e.g. a[start:stop:step]).",
    "decorators": [],
    "main_category": "Sequence Operations",
    "sub_category": "Slicing",
    "data_type_manipulated": ["Sequence"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The slice() function returns a slice object representing the set of indices specified by range(start, stop, step). It's used for extended slicing of sequences. A slice object can be used with any sequence type (string, list, tuple, etc.) to extract a subset of elements. The slice object itself is immutable.",
    "return_value": "Returns a slice object.",
    "parameter_values": "start: The starting index of the slice (default is None). stop: The ending index of the slice (exclusive). step: The step or stride between each item in the slice (default is None).",
    "function_signature": "slice(start: Optional[int], stop: Optional[int], step: Optional[int] = None) -> slice",
    "related_functions": [
      "range()",
      "__getitem__()",
      "__setitem__()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "s = slice(1, 5, 2)\nlist1 = [0, 1, 2, 3, 4, 5]\nprint(list1[s])\n\nstring = \"Hello, World!\"\nprint(string[s])",
        "explanation": "This example shows how to create and use a slice object with different sequence types.",
        "expected_output": "[1, 3]\nel,"
      },
      {
        "title": "Slice with Negative Indices",
        "code": "s = slice(-5, -1)\nlist1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(list1[s])\n\ns_reverse = slice(None, None, -1)\nprint(list1[s_reverse])",
        "explanation": "This example demonstrates using slice with negative indices and for reversing a sequence.",
        "expected_output": "[5, 6, 7, 8]\n[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]"
      },
      {
        "title": "Slice Attributes",
        "code": "s = slice(1, 10, 2)\nprint(f\"Start: {s.start}, Stop: {s.stop}, Step: {s.step}\")\n\nindices = s.indices(15)\nprint(f\"Indices: {indices}\")\n\nfor i in range(*s.indices(15)):\n    print(i, end=' ')\nprint()",
        "explanation": "This example shows how to access slice attributes and use the indices method to get the actual indices for a given sequence length.",
        "expected_output": "Start: 1, Stop: 10, Step: 2\nIndices: (1, 10, 2)\n1 3 5 7 9 "
      },
      {
        "title": "Using slice() in Custom Classes",
        "code": "class MyList:\n    def __init__(self, data):\n        self.data = data\n    \n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            return [self.data[i] for i in range(*key.indices(len(self.data)))]\n        return self.data[key]\n\nmy_list = MyList([0, 1, 2, 3, 4, 5])\nprint(my_list[1:5:2])\nprint(my_list[slice(1, 5, 2)])",
        "explanation": "This example demonstrates how to implement slicing support in a custom class using the slice object.",
        "expected_output": "[1, 3]\n[1, 3]"
      }
    ]
  },
  {
    "name": "sorted",
    "module": "builtins",
    "class_name": null,
    "return_type": "List",
    "parameters": [
      {
        "name": "iterable",
        "type": "Iterable"
      },
      {
        "name": "key",
        "type": "Optional[Callable]"
      },
      {
        "name": "reverse",
        "type": "bool"
      }
    ],
    "docstring": "Return a new sorted list from the items in iterable.",
    "decorators": [],
    "main_category": "Sorting",
    "sub_category": "Sequence Sorting",
    "data_type_manipulated": ["Iterable"],
    "version_added": "2.4",
    "deprecated": false,
    "extended_description": "The sorted() function returns a new sorted list from the items in the given iterable. It does not modify the original iterable. The function uses a stable sorting algorithm, meaning that when multiple records have the same key, their original order is preserved. The 'key' parameter specifies a function of one argument that is used to extract a comparison key from each element. The 'reverse' parameter, if set to True, sorts the list in descending order.",
    "return_value": "Returns a new sorted list containing all items from the iterable.",
    "parameter_values": "iterable: The sequence to be sorted. key: Optional function to be called on each element prior to making comparisons. reverse: If True, sort in descending order, otherwise ascending (default).",
    "function_signature": "sorted(iterable: Iterable, *, key: Optional[Callable] = None, reverse: bool = False) -> List",
    "related_functions": [
      "list.sort()",
      "reversed()",
      "min()",
      "max()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "print(sorted([3, 1, 4, 1, 5, 9, 2]))\nprint(sorted('hello'))\nprint(sorted((5, 2, 3, 1, 4)))",
        "explanation": "These examples show sorting different types of iterables.",
        "expected_output": "[1, 1, 2, 3, 4, 5, 9]\n['e', 'h', 'l', 'l', 'o']\n[1, 2, 3, 4, 5]"
      },
      {
        "title": "Sorting with Key Function",
        "code": "words = ['banana', 'pie', 'Washington', 'book']\nprint(sorted(words, key=len))\n\nnumbers = [-4, -2, 1, 3, 5]\nprint(sorted(numbers, key=abs))",
        "explanation": "These examples demonstrate using a key function for custom sorting behavior.",
        "expected_output": "['pie', 'book', 'banana', 'Washington']\n[1, -2, 3, -4, 5]"
      },
      {
        "title": "Sorting in Reverse Order",
        "code": "print(sorted([1, 3, 2, 5, 4], reverse=True))\nprint(sorted('hello', reverse=True))",
        "explanation": "This example shows how to sort in descending order using the reverse parameter.",
        "expected_output": "[5, 4, 3, 2, 1]\n['o', 'l', 'l', 'h', 'e']"
      },
      {
        "title": "Sorting Complex Objects",
        "code": "class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    \n    def __repr__(self):\n        return f\"Person('{self.name}', {self.age})\"\n\npeople = [Person('Alice', 30), Person('Bob', 25), Person('Charlie', 35)]\nprint(sorted(people, key=lambda p: p.age))\nprint(sorted(people, key=lambda p: p.name, reverse=True))",
        "explanation": "This example demonstrates sorting a list of custom objects using different attributes.",
        "expected_output": "[Person('Bob', 25), Person('Alice', 30), Person('Charlie', 35)]\n[Person('Charlie', 35), Person('Bob', 25), Person('Alice', 30)]"
      }
    ]
  },
  {
    "name": "staticmethod",
    "module": "builtins",
    "class_name": "staticmethod",
    "return_type": "staticmethod",
    "parameters": [
      {
        "name": "function",
        "type": "Callable"
      }
    ],
    "docstring": "Transform a method into a static method.",
    "decorators": [],
    "main_category": "Object-Oriented Programming",
    "sub_category": "Method Types",
    "data_type_manipulated": ["Callable"],
    "version_added": "2.2",
    "deprecated": false,
    "extended_description": "The staticmethod decorator is used to declare a method as a static method. Unlike regular methods, static methods don't receive an implicit first argument (usually named 'self' for instance methods or 'cls' for class methods). They can be called on the class or an instance of the class, but they don't have access to the instance or class through an implicit first parameter. Static methods are often used for utility functions that don't need to access or modify the class state.",
    "return_value": "Returns a static method for the given function.",
    "parameter_values": "function: The function to be converted into a static method.",
    "function_signature": "@staticmethod\ndef function(*args, **kwargs) -> Any",
    "related_functions": [
      "classmethod",
      "property",
      "__init__"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "class MathOperations:\n    @staticmethod\n    def add(x, y):\n        return x + y\n    \n    @staticmethod\n    def multiply(x, y):\n        return x * y\n\nprint(MathOperations.add(5, 3))\nprint(MathOperations.multiply(4, 2))\n\n# Can also be called on an instance\nmath_ops = MathOperations()\nprint(math_ops.add(2, 2))",
        "explanation": "This example shows how to define and use static methods in a class.",
        "expected_output": "8\n8\n4"
      },
      {
        "title": "Static Method vs. Instance Method",
        "code": "class MyClass:\n    def __init__(self, value):\n        self.value = value\n    \n    def instance_method(self):\n        return f\"Instance method, value: {self.value}\"\n    \n    @staticmethod\n    def static_method():\n        return \"Static method\"\n\nobj = MyClass(42)\nprint(obj.instance_method())\nprint(obj.static_method())\nprint(MyClass.static_method())\ntry:\n    print(MyClass.instance_method())\nexcept TypeError as e:\n    print(f\"Error: {e}\")",
        "explanation": "This example compares static methods with instance methods, showing how they can be called and their limitations.",
        "expected_output": "Instance method, value: 42\nStatic method\nStatic method\nError: instance_method() missing 1 required positional argument: 'self'"
      },
      {
        "title": "Using Static Methods for Utility Functions",
        "code": "import math\n\nclass Circle:\n    def __init__(self, radius):\n        self.radius = radius\n    \n    def area(self):\n        return Circle.circle_area(self.radius)\n    \n    @staticmethod\n    def circle_area(radius):\n        return math.pi * radius ** 2\n\n# Using the static method directly\nprint(f\"Area of circle with radius 5: {Circle.circle_area(5):.2f}\")\n\n# Using the static method via an instance method\ncircle = Circle(3)\nprint(f\"Area of circle with radius 3: {circle.area():.2f}\")",
        "explanation": "This example demonstrates using a static method as a utility function, both directly and through an instance method.",
        "expected_output": "Area of circle with radius 5: 78.54\nArea of circle with radius 3: 28.27"
      }
    ]
  },
  {
    "name": "str",
    "module": "builtins",
    "class_name": "str",
    "return_type": "str",
    "parameters": [
      {
        "name": "object",
        "type": "Any"
      },
      {
        "name": "encoding",
        "type": "Optional[str]"
      },
      {
        "name": "errors",
        "type": "Optional[str]"
      }
    ],
    "docstring": "Return a string version of object.",
    "decorators": [],
    "main_category": "Type Conversion",
    "sub_category": "String Conversion",
    "data_type_manipulated": ["Any"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The str() function returns a string representation of an object. If the object has a __str__() method, it calls that method to obtain the string representation. For strings, str() returns the string itself. When used with no arguments, it returns an empty string. If encoding and/or errors are given, str() is used to decode the object, which must be bytes or bytearray, into a string.",
    "return_value": "Returns a string representation of the given object.",
    "parameter_values": "object: The object to be converted to a string. encoding: The encoding to use if object is bytes or bytearray. errors: The error handling scheme to use for encoding errors.",
    "function_signature": "str(object: Any = '', encoding: Optional[str] = None, errors: Optional[str] = 'strict') -> str",
    "related_functions": [
      "repr()",
      "format()",
      "__str__()",
      "bytes.decode()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "print(str(123))\nprint(str(3.14))\nprint(str(True))\nprint(str([1, 2, 3]))\nprint(str({'a': 1, 'b': 2}))\nprint(str())",
        "explanation": "These examples show how str() works with different types of objects.",
        "expected_output": "123\n3.14\nTrue\n[1, 2, 3]\n{'a': 1, 'b': 2}\n"
      },
      {
        "title": "Custom __str__ Method",
        "code": "class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    \n    def __str__(self):\n        return f\"Person named {self.name}, aged {self.age}\"\n\nperson = Person(\"Alice\", 30)\nprint(str(person))\nprint(f\"{person}\")",
        "explanation": "This example demonstrates how the __str__ method affects the string representation of an object.",
        "expected_output": "Person named Alice, aged 30\nPerson named Alice, aged 30"
      },
      {
        "title": "Decoding Bytes to String",
        "code": "byte_string = b'Hello, World!'\nprint(str(byte_string, encoding='utf-8'))\n\n# Using different encodings\nprint(str(b'\\xc3\\xa9', encoding='utf-8'))\nprint(str(b'\\xc3\\xa9', encoding='ascii', errors='ignore'))\nprint(str(b'\\xc3\\xa9', encoding='ascii', errors='replace'))",
        "explanation": "This example shows how to use str() to decode bytes into strings, demonstrating different encodings and error handling options.",
        "expected_output": "Hello, World!\nÃ©\n\n?"
      },
      {
        "title": "str() vs repr()",
        "code": "class ComplexNumber:\n    def __init__(self, real, imag):\n        self.real = real\n        self.imag = imag\n    \n    def __str__(self):\n        return f\"{self.real} + {self.imag}i\"\n    \n    def __repr__(self):\n        return f\"ComplexNumber({self.real}, {self.imag})\"\n\nc = ComplexNumber(3, 4)\nprint(f\"str(c): {str(c)}\")\nprint(f\"repr(c): {repr(c)}\")",
        "explanation": "This example illustrates the difference between str() and repr() when both __str__ and __repr__ methods are defined in a class.",
        "expected_output": "str(c): 3 + 4i\nrepr(c): ComplexNumber(3, 4)"
      }
    ]
  },
  {
    "name": "sum",
    "module": "builtins",
    "class_name": null,
    "return_type": "Union[int, float]",
    "parameters": [
      {
        "name": "iterable",
        "type": "Iterable"
      },
      {
        "name": "start",
        "type": "Union[int, float]"
      }
    ],
    "docstring": "Return the sum of a 'start' value (default: 0) plus an iterable of numbers.",
    "decorators": [],
    "main_category": "Mathematical Operations",
    "sub_category": "Summation",
    "data_type_manipulated": ["Iterable"],
    "version_added": "2.3",
    "deprecated": false,
    "extended_description": "The sum() function adds the items of an iterable from left to right and returns the total. It starts with the optional 'start' value (which defaults to 0) and adds each item from the iterable to it. For numbers, it's equivalent to using the + operator in a loop. However, sum() is preferred for better performance and readability. Note that sum() is not recommended for concatenating strings; it's better to use ''.join(sequence) for that purpose.",
    "return_value": "Returns the sum of all items in the iterable plus the start value.",
    "parameter_values": "iterable: An iterable containing numbers. start: An optional starting value (default is 0).",
    "function_signature": "sum(iterable: Iterable, start: Union[int, float] = 0) -> Union[int, float]",
    "related_functions": [
      "math.fsum()",
      "itertools.accumulate()",
      "reduce()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "print(sum([1, 2, 3, 4, 5]))\nprint(sum((1.5, 2.5, 3.5)))\nprint(sum(range(1, 101)))",
        "explanation": "These examples show how sum() works with different types of iterables.",
        "expected_output": "15\n7.5\n5050"
      },
      {
        "title": "Using the 'start' Parameter",
        "code": "print(sum([1, 2, 3], 10))\nprint(sum([], 5))",
        "explanation": "This example demonstrates using the 'start' parameter to provide an initial value.",
        "expected_output": "16\n5"
      },
      {
        "title": "Summing Complex Data Structures",
        "code": "items = [(1, 'a'), (2, 'b'), (3, 'c')]\nprint(sum(item[0] for item in items))\n\ndict_items = {'a': 1, 'b': 2, 'c': 3}\nprint(sum(dict_items.values()))",
        "explanation": "These examples show how to use sum() with more complex data structures by extracting numeric values.",
        "expected_output": "6\n6"
      },
      {
        "title": "Precision Issues and Alternative",
        "code": "print(sum([0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]))\n\nimport math\nprint(math.fsum([0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]))",
        "explanation": "This example highlights potential floating-point precision issues with sum() and shows math.fsum() as a more precise alternative for floating-point numbers.",
        "expected_output": "0.9999999999999999\n1.0"
      }
    ]
  },
  {
    "name": "super",
    "module": "builtins",
    "class_name": "super",
    "return_type": "super",
    "parameters": [
      {
        "name": "type",
        "type": "Optional[type]"
      },
      {
        "name": "object_or_type",
        "type": "Optional[Union[object, type]]"
      }
    ],
    "docstring": "Return a proxy object that delegates method calls to a parent or sibling class of type.",
    "decorators": [],
    "main_category": "Object-Oriented Programming",
    "sub_category": "Inheritance",
    "data_type_manipulated": ["type", "object"],
    "version_added": "2.2",
    "deprecated": false,
    "extended_description": "The super() function returns a proxy object that allows you to refer to the superclass implicitly. It's commonly used in class inheritance to call methods from a parent or sibling class. When called without arguments, it returns an unbound super object. When called with two arguments, it returns a bound super object; the type parameter should be a subclass of object_or_type. The most common use is in the __init__ method of a subclass to call the __init__ method of the superclass.",
    "return_value": "Returns a proxy object that delegates method calls to a parent or sibling class.",
    "parameter_values": "type: The class in which super() is being called (optional in Python 3). object_or_type: The object or type for which super() is being called (optional in Python 3).",
    "function_signature": "super([type[, object_or_type]]) -> super",
    "related_functions": [
      "__mro__",
      "isinstance()",
      "issubclass()"
    ],
    "examples": [
      {
        "title": "Basic Usage in Inheritance",
        "code": "class Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def speak(self):\n        return f\"{self.name} makes a sound\"\n\nclass Dog(Animal):\n    def __init__(self, name):\n        super().__init__(name)\n\n    def speak(self):\n        return f\"{super().speak()} - Woof!\"\n\ndog = Dog(\"Buddy\")\nprint(dog.speak())",
        "explanation": "This example shows how to use super() to call methods from a parent class in a subclass.",
        "expected_output": "Buddy makes a sound - Woof!"
      },
      {
        "title": "Multiple Inheritance",
        "code": "class A:\n    def method(self):\n        print(\"A's method\")\n\nclass B(A):\n    def method(self):\n        print(\"B's method\")\n        super().method()\n\nclass C(A):\n    def method(self):\n        print(\"C's method\")\n        super().method()\n\nclass D(B, C):\n    def method(self):\n        print(\"D's method\")\n        super().method()\n\nD().method()",
        "explanation": "This example demonstrates how super() works with multiple inheritance, following the method resolution order (MRO).",
        "expected_output": "D's method\nB's method\nC's method\nA's method"
      },
      {
        "title": "Using super() with Arguments",
        "code": "class Base:\n    def __init__(self, x):\n        self.x = x\n\nclass Derived(Base):\n    def __init__(self, x, y):\n        super(Derived, self).__init__(x)\n        self.y = y\n\nd = Derived(1, 2)\nprint(f\"d.x = {d.x}, d.y = {d.y}\")\n\n# In Python 3, this can be simplified to:\nclass DerivedSimple(Base):\n    def __init__(self, x, y):\n        super().__init__(x)\n        self.y = y\n\nds = DerivedSimple(3, 4)\nprint(f\"ds.x = {ds.x}, ds.y = {ds.y}\")",
        "explanation": "This example shows how to use super() with arguments, and how it can be simplified in Python 3.",
        "expected_output": "d.x = 1, d.y = 2\nds.x = 3, ds.y = 4"
      }
    ]
  },
  {
    "name": "tuple",
    "module": "builtins",
    "class_name": "tuple",
    "return_type": "tuple",
    "parameters": [
      {
        "name": "iterable",
        "type": "Optional[Iterable]"
      }
    ],
    "docstring": "Return a tuple whose items are the same and in the same order as iterable's items.",
    "decorators": [],
    "main_category": "Data Structures",
    "sub_category": "Sequence",
    "data_type_manipulated": ["Iterable"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The tuple() function creates a tuple object. Tuples are immutable sequences, typically used to store collections of heterogeneous data. If no argument is given, it returns an empty tuple. If the argument is a sequence (string, list, or tuple), it returns a tuple with the same items in the same order. For any other iterable, it returns a tuple containing the items returned by repeatedly calling the iterable's __next__() method.",
    "return_value": "Returns a tuple containing items from the given iterable.",
    "parameter_values": "iterable: An optional iterable object to be converted into a tuple.",
    "function_signature": "tuple(iterable: Optional[Iterable] = None) -> tuple",
    "related_functions": [
      "list()",
      "set()",
      "dict()",
      "namedtuple()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "print(tuple())\nprint(tuple([1, 2, 3]))\nprint(tuple('hello'))\nprint(tuple((1, 2, 3)))",
        "explanation": "These examples show how tuple() works with different types of input.",
        "expected_output": "()\n(1, 2, 3)\n('h', 'e', 'l', 'l', 'o')\n(1, 2, 3)"
      },
      {
        "title": "Tuple Packing and Unpacking",
        "code": "# Packing\nt = 1, 2, 3\nprint(t)\n\n# Unpacking\na, b, c = t\nprint(f\"a = {a}, b = {b}, c = {c}\")\n\n# Extended unpacking\nx, *y = (1, 2, 3, 4)\nprint(f\"x = {x}, y = {y}\")",
        "explanation": "This example demonstrates tuple packing and unpacking, including extended unpacking.",
        "expected_output": "(1, 2, 3)\na = 1, b = 2, c = 3\nx = 1, y = [2, 3, 4]"
      },
      {
        "title": "Tuples vs Lists",
        "code": "import sys\n\ntuple_example = tuple(range(1000))\nlist_example = list(range(1000))\n\nprint(f\"Tuple size: {sys.getsizeof(tuple_example)} bytes\")\nprint(f\"List size: {sys.getsizeof(list_example)} bytes\")\n\n# Attempt to modify\ntry:\n    tuple_example[0] = 100\nexcept TypeError as e:\n    print(f\"Tuple modification error: {e}\")\n\nlist_example[0] = 100\nprint(f\"Modified list: {list_example[:5]}\")",
        "explanation": "This example compares tuples and lists, showing the size difference and immutability of tuples.",
        "expected_output": "Tuple size: 8056 bytes\nList size: 9112 bytes\nTuple modification error: 'tuple' object does not support item assignment\nModified list: [100, 1, 2, 3, 4]"
      },
      {
        "title": "Using Tuples as Dictionary Keys",
        "code": "# Tuples can be used as dictionary keys\ncoord_dict = {(0, 0): 'origin', (1, 0): 'right', (0, 1): 'up'}\nprint(coord_dict[(0, 0)])\n\n# Lists cannot be used as dictionary keys\ntry:\n    bad_dict = {[0, 0]: 'origin'}\nexcept TypeError as e:\n    print(f\"List as key error: {e}\")",
        "explanation": "This example shows that tuples can be used as dictionary keys due to their immutability, while lists cannot.",
        "expected_output": "origin\nList as key error: unhashable type: 'list'"
      }
    ]
  },
  {
    "name": "type",
    "module": "builtins",
    "class_name": "type",
    "return_type": "Union[type, Type]",
    "parameters": [
      {
        "name": "object",
        "type": "Any"
      },
      {
        "name": "bases",
        "type": "Optional[Tuple[type, ...]]"
      },
      {
        "name": "dict",
        "type": "Optional[Dict[str, Any]]"
      }
    ],
    "docstring": "Return the type of an object, or create a new type object.",
    "decorators": [],
    "main_category": "Type Operations",
    "sub_category": "Type Information",
    "data_type_manipulated": ["Any"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The type() function has two distinct behaviors: 1) With one argument, it returns the type of the object. 2) With three arguments, it creates a new type object (a class). It's the metaclass of all classes in Python, and can be used to dynamically create classes. When creating a new type, the first argument is the class name, the second is a tuple of base classes, and the third is a dictionary defining the namespace of the class.",
    "return_value": "With one argument, returns the type of the object. With three arguments, returns a new type object.",
    "parameter_values": "object: Any Python object to get the type of, or the name of the new class. bases: A tuple of base classes for the new type. dict: A dictionary containing the namespace for the new type.",
    "function_signature": "type(object: Any) -> type\ntype(name: str, bases: Tuple[type, ...], dict: Dict[str, Any]) -> Type",
    "related_functions": [
      "isinstance()",
      "issubclass()",
      "__class__",
      "metaclass"
    ],
    "examples": [
      {
        "title": "Basic Usage - Getting Object Type",
        "code": "print(type(42))\nprint(type('hello'))\nprint(type([1, 2, 3]))\nprint(type({1, 2, 3}))\nprint(type({'a': 1, 'b': 2}))\nprint(type(lambda x: x*2))",
        "explanation": "These examples show how type() is used to get the type of various objects.",
        "expected_output": "<class 'int'>\n<class 'str'>\n<class 'list'>\n<class 'set'>\n<class 'dict'>\n<class 'function'>"
      },
      {
        "title": "Creating a New Type (Class)",
        "code": "MyClass = type('MyClass', (object,), {'x': 42, 'print_x': lambda self: print(self.x)})\n\nobj = MyClass()\nprint(type(obj))\nobj.print_x()",
        "explanation": "This example demonstrates how to use type() to dynamically create a new class.",
        "expected_output": "<class '__main__.MyClass'>\n42"
      },
      {
        "title": "Comparing Types",
        "code": "class MyClass:\n    pass\n\nobj = MyClass()\nprint(type(obj) == MyClass)\nprint(type(obj) == type(MyClass()))\nprint(type(MyClass) == type)",
        "explanation": "This example shows how to compare types and demonstrates that classes are instances of type.",
        "expected_output": "True\nTrue\nTrue"
      },
      {
        "title": "Using type() in Conditional Statements",
        "code": "def process_data(data):\n    if type(data) == list:\n        return sum(data)\n    elif type(data) == dict:\n        return sum(data.values())\n    elif type(data) == str:\n        return len(data)\n    else:\n        return None\n\nprint(process_data([1, 2, 3]))\nprint(process_data({'a': 1, 'b': 2}))\nprint(process_data('hello'))\nprint(process_data(42))",
        "explanation": "This example demonstrates using type() in conditional statements to handle different data types.",
        "expected_output": "6\n3\n5\nNone"
      }
    ]
  },
  {
    "name": "vars",
    "module": "builtins",
    "class_name": null,
    "return_type": "dict",
    "parameters": [
      {
        "name": "object",
        "type": "Optional[Any]"
      }
    ],
    "docstring": "Return the __dict__ attribute for a module, class, instance, or any other object with a __dict__ attribute.",
    "decorators": [],
    "main_category": "Introspection",
    "sub_category": "Object Information",
    "data_type_manipulated": ["Any"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The vars() function returns the __dict__ attribute of an object. If no argument is passed, it returns a dictionary representing the current local symbol table. This is equivalent to locals(). If an object is passed as an argument, the object must have a __dict__ attribute, or a TypeError will be raised. vars() is useful for introspection and debugging, allowing you to examine the attributes of an object.",
    "return_value": "Returns a dictionary representing the __dict__ attribute of the object, or the current local symbol table if no argument is given.",
    "parameter_values": "object: Optional. Any object with a __dict__ attribute.",
    "function_signature": "vars(object: Optional[Any] = None) -> dict",
    "related_functions": [
      "locals()",
      "globals()",
      "dir()",
      "__dict__"
    ],
    "examples": [
      {
        "title": "Basic Usage with Objects",
        "code": "class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nperson = Person('Alice', 30)\nprint(vars(person))\n\n# Adding a new attribute\nperson.job = 'Engineer'\nprint(vars(person))",
        "explanation": "This example shows how vars() returns the __dict__ of an object, including dynamically added attributes.",
        "expected_output": "{'name': 'Alice', 'age': 30}\n{'name': 'Alice', 'age': 30, 'job': 'Engineer'}"
      },
      {
        "title": "Using vars() with No Arguments",
        "code": "x = 10\ny = 'hello'\nprint(vars())",
        "explanation": "When called without arguments, vars() returns the current local symbol table.",
        "expected_output": "{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, 'x': 10, 'y': 'hello'}"
      },
      {
        "title": "vars() with Modules and Classes",
        "code": "import math\n\nprint(vars(math)['pi'])\n\nclass MyClass:\n    class_var = 'I am a class variable'\n    \n    def __init__(self):\n        self.instance_var = 'I am an instance variable'\n\nprint(vars(MyClass)['class_var'])\nobj = MyClass()\nprint(vars(obj)['instance_var'])",
        "explanation": "This example demonstrates using vars() with modules and classes to access their attributes.",
        "expected_output": "3.141592653589793\nI am a class variable\nI am an instance variable"
      },
      {
        "title": "Error Handling with vars()",
        "code": "try:\n    print(vars(42))\nexcept TypeError as e:\n    print(f\"TypeError: {e}\")\n\nclass NoDict:\n    __slots__ = ['x', 'y']\n\nnd = NoDict()\ntry:\n    print(vars(nd))\nexcept TypeError as e:\n    print(f\"TypeError: {e}\")",
        "explanation": "This example shows the errors raised when vars() is used with objects that don't have a __dict__ attribute.",
        "expected_output": "TypeError: 'int' object has no attribute '__dict__'\nTypeError: vars() argument must have __dict__ attribute"
      }
    ]
  },
  {
    "name": "zip",
    "module": "builtins",
    "class_name": "zip",
    "return_type": "zip",
    "parameters": [
      {
        "name": "*iterables",
        "type": "Iterable"
      }
    ],
    "docstring": "Return an iterator of tuples where the i-th tuple contains the i-th element from each of the argument sequences or iterables.",
    "decorators": [],
    "main_category": "Iteration",
    "sub_category": "Sequence Combination",
    "data_type_manipulated": ["Iterable"],
    "version_added": "2.0",
    "deprecated": false,
    "extended_description": "The zip() function creates an iterator of tuples where each tuple contains the i-th element from each of the input iterables. The iterator stops when the shortest input iterable is exhausted. With a single iterable argument, it returns an iterator of 1-tuples. With no arguments, it returns an empty iterator. The left-to-right evaluation order of the iterables is guaranteed. This can be used to transpose a matrix, or to create a dictionary from two parallel sequences.",
    "return_value": "Returns a zip object, which is an iterator of tuples.",
    "parameter_values": "*iterables: Any number of iterables.",
    "function_signature": "zip(*iterables: Iterable) -> zip",
    "related_functions": [
      "itertools.zip_longest()",
      "map()",
      "enumerate()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "numbers = [1, 2, 3]\nletters = ['a', 'b', 'c']\nzipped = zip(numbers, letters)\nprint(list(zipped))\n\n# Unpacking zip\nnumbers, letters = zip(*zip(numbers, letters))\nprint(f\"Numbers: {numbers}\")\nprint(f\"Letters: {letters}\")",
        "explanation": "This example shows basic zipping of two lists and then unzipping them back.",
        "expected_output": "[(1, 'a'), (2, 'b'), (3, 'c')]\nNumbers: (1, 2, 3)\nLetters: ('a', 'b', 'c')"
      },
      {
        "title": "Creating a Dictionary",
        "code": "keys = ['name', 'age', 'city']\nvalues = ['Alice', 30, 'New York']\nuser_dict = dict(zip(keys, values))\nprint(user_dict)",
        "explanation": "This example demonstrates how to use zip() to create a dictionary from two lists.",
        "expected_output": "{'name': 'Alice', 'age': 30, 'city': 'New York'}"
      },
      {
        "title": "Handling Unequal Length Iterables",
        "code": "list1 = [1, 2, 3, 4, 5]\nlist2 = ['a', 'b', 'c']\nlist3 = [True, False]\n\nprint(list(zip(list1, list2, list3)))\n\n# Using itertools.zip_longest\nfrom itertools import zip_longest\nprint(list(zip_longest(list1, list2, list3, fillvalue=None)))",
        "explanation": "This example shows how zip() handles iterables of different lengths, and compares it with itertools.zip_longest().",
        "expected_output": "[(1, 'a', True), (2, 'b', False)]\n[(1, 'a', True), (2, 'b', False), (3, 'c', None), (4, None, None), (5, None, None)]"
      },
      {
        "title": "Parallel Iteration",
        "code": "names = ['Alice', 'Bob', 'Charlie']\nages = [25, 30, 35]\n\nfor name, age in zip(names, ages):\n    print(f\"{name} is {age} years old.\")",
        "explanation": "This example demonstrates using zip() for parallel iteration over multiple lists.",
        "expected_output": "Alice is 25 years old.\nBob is 30 years old.\nCharlie is 35 years old."
      }
    ]
  },
  {
    "name": "__import__",
    "module": "builtins",
    "class_name": null,
    "return_type": "module",
    "parameters": [
      {
        "name": "name",
        "type": "str"
      },
      {
        "name": "globals",
        "type": "Optional[dict]"
      },
      {
        "name": "locals",
        "type": "Optional[dict]"
      },
      {
        "name": "fromlist",
        "type": "List[str]"
      },
      {
        "name": "level",
        "type": "int"
      }
    ],
    "docstring": "Import a module. This is an advanced function that is not needed in everyday Python programming.",
    "decorators": [],
    "main_category": "Module Operations",
    "sub_category": "Dynamic Import",
    "data_type_manipulated": ["str", "module"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The __import__() function is a low-level function used by the import statement. It can be used to implement custom importing strategies. It's not recommended for general use; the import statement should be used instead. The function is useful in scenarios where you need to import modules dynamically based on runtime conditions. The 'globals' and 'locals' parameters are used to determine how to interpret the 'name' parameter in the context of packages. The 'fromlist' gives the names of objects or submodules that should be imported. The 'level' parameter specifies whether to use absolute or relative imports; 0 means absolute, while a positive number is the number of parent directories to search relative to the current module.",
    "return_value": "Returns the imported module, or if 'fromlist' is given, the specified module attribute.",
    "parameter_values": "name: A string containing the name of the module to import. globals: A dictionary representing the current global symbol table. locals: A dictionary representing the current local symbol table. fromlist: A list of names to import from the module. level: Specifies whether to use absolute or relative imports.",
    "function_signature": "__import__(name: str, globals: Optional[dict] = None, locals: Optional[dict] = None, fromlist: List[str] = [], level: int = 0) -> module",
    "related_functions": [
      "importlib.import_module()",
      "imp.load_module()",
      "exec()",
      "eval()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "math = __import__('math')\nprint(math.pi)\n\nos = __import__('os')\nprint(os.name)",
        "explanation": "This example shows how to use __import__() to import standard modules.",
        "expected_output": "3.141592653589793\nposix (or nt on Windows)"
      },
      {
        "title": "Importing Specific Attributes",
        "code": "random = __import__('random', fromlist=['randint'])\nprint(random.randint(1, 10))\n\n# Equivalent to: from os import path, makedirs\nos_funcs = __import__('os', fromlist=['path', 'makedirs'])\nprint(os_funcs.path.join('usr', 'bin'))",
        "explanation": "This example demonstrates importing specific attributes or submodules from a module.",
        "expected_output": "(A random integer between 1 and 10)\nusr/bin (or usr\\bin on Windows)"
      },
      {
        "title": "Dynamic Import Based on Condition",
        "code": "def import_module(module_name):\n    try:\n        return __import__(module_name)\n    except ImportError:\n        print(f\"Module {module_name} not found.\")\n        return None\n\nfor module in ['math', 'non_existent_module', 'os']:\n    mod = import_module(module)\n    if mod:\n        print(f\"Successfully imported {module}\")",
        "explanation": "This example shows how __import__() can be used for dynamic importing based on runtime conditions.",
        "expected_output": "Successfully imported math\nModule non_existent_module not found.\nSuccessfully imported os"
      },
      {
        "title": "Relative Imports",
        "code": "# Assuming this code is in a file named 'submodule.py' inside a package 'mypackage'\n\n# Relative import of a sibling module\nsibling = __import__('sibling_module', globals(), locals(), [], level=1)\n\n# Relative import of a module from parent package\nparent_module = __import__('..parent_module', globals(), locals(), [], level=2)\n\nprint(f\"Imported: {sibling.__name__}, {parent_module.__name__}\")",
        "explanation": "This example demonstrates relative imports using the 'level' parameter. Note that this code wouldn't run standalone and is meant to illustrate the concept.",
        "expected_output": "Imported: mypackage.sibling_module, mypackage.parent_module"
      }
    ]
  },
  {
    "name": "clear_(dict)",
    "module": "builtins",
    "class_name": "dict",
    "return_type": "None",
    "parameters": [],
    "docstring": "Remove all items from the dictionary.",
    "decorators": [],
    "main_category": "Data Structure Operations",
    "sub_category": "Dictionary Manipulation",
    "data_type_manipulated": ["dict"],
    "version_added": "1.5",
    "deprecated": false,
    "extended_description": "The clear() method removes all key-value pairs from the dictionary, leaving it empty. This operation is in-place, meaning it modifies the original dictionary rather than creating a new one. After calling clear(), the dictionary will have a length of 0.",
    "return_value": "This method doesn't return a value (None).",
    "parameter_values": "This method doesn't take any parameters.",
    "function_signature": "dict.clear() -> None",
    "related_functions": [
      "dict.pop()",
      "dict.popitem()",
      "del"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "d = {'a': 1, 'b': 2, 'c': 3}\nprint(f\"Before clear: {d}\")\nd.clear()\nprint(f\"After clear: {d}\")",
        "explanation": "This example shows how clear() removes all items from a dictionary.",
        "expected_output": "Before clear: {'a': 1, 'b': 2, 'c': 3}\nAfter clear: {}"
      },
      {
        "title": "Clear Empty Dictionary",
        "code": "empty_dict = {}\nprint(f\"Before clear: {empty_dict}\")\nempty_dict.clear()\nprint(f\"After clear: {empty_dict}\")",
        "explanation": "This example demonstrates that clear() works on empty dictionaries without raising an error.",
        "expected_output": "Before clear: {}\nAfter clear: {}"
      },
      {
        "title": "Clear and References",
        "code": "original = {'x': 1, 'y': 2}\nreference = original\noriginal.clear()\nprint(f\"Original: {original}\")\nprint(f\"Reference: {reference}\")",
        "explanation": "This example shows that clear() affects all references to the same dictionary.",
        "expected_output": "Original: {}\nReference: {}"
      },
      {
        "title": "Performance Comparison",
        "code": "import timeit\n\ndef clear_method():\n    d = {i: i for i in range(1000)}\n    d.clear()\n\ndef reassignment():\n    d = {i: i for i in range(1000)}\n    d = {}\n\nprint(f\"clear() time: {timeit.timeit(clear_method, number=10000)}\")\nprint(f\"Reassignment time: {timeit.timeit(reassignment, number=10000)}\")",
        "explanation": "This example compares the performance of clear() with reassigning an empty dictionary.",
        "expected_output": "clear() time: (some value)\nReassignment time: (some value, typically larger than clear() time)"
      }
    ]
  },
  {
    "name": "clear_(list)",
    "module": "builtins",
    "class_name": "list",
    "return_type": "None",
    "parameters": [],
    "docstring": "Remove all items from the list.",
    "decorators": [],
    "main_category": "Data Structure Operations",
    "sub_category": "List Manipulation",
    "data_type_manipulated": ["list"],
    "version_added": "3.3",
    "deprecated": false,
    "extended_description": "The clear() method removes all items from the list, leaving it empty. This operation is in-place, meaning it modifies the original list rather than creating a new one. After calling clear(), the list will have a length of 0. This method is equivalent to del a[:] but it's more obvious and readable.",
    "return_value": "This method doesn't return a value (None).",
    "parameter_values": "This method doesn't take any parameters.",
    "function_signature": "list.clear() -> None",
    "related_functions": [
      "list.pop()",
      "list.remove()",
      "del"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "lst = [1, 2, 3, 4, 5]\nprint(f\"Before clear: {lst}\")\nlst.clear()\nprint(f\"After clear: {lst}\")",
        "explanation": "This example shows how clear() removes all items from a list.",
        "expected_output": "Before clear: [1, 2, 3, 4, 5]\nAfter clear: []"
      },
      {
        "title": "Clear Empty List",
        "code": "empty_list = []\nprint(f\"Before clear: {empty_list}\")\nempty_list.clear()\nprint(f\"After clear: {empty_list}\")",
        "explanation": "This example demonstrates that clear() works on empty lists without raising an error.",
        "expected_output": "Before clear: []\nAfter clear: []"
      },
      {
        "title": "Clear and References",
        "code": "original = [1, 2, 3]\nreference = original\noriginal.clear()\nprint(f\"Original: {original}\")\nprint(f\"Reference: {reference}\")",
        "explanation": "This example shows that clear() affects all references to the same list.",
        "expected_output": "Original: []\nReference: []"
      },
      {
        "title": "Performance Comparison",
        "code": "import timeit\n\ndef clear_method():\n    lst = list(range(1000))\n    lst.clear()\n\ndef slice_assignment():\n    lst = list(range(1000))\n    lst[:] = []\n\nprint(f\"clear() time: {timeit.timeit(clear_method, number=10000)}\")\nprint(f\"Slice assignment time: {timeit.timeit(slice_assignment, number=10000)}\")",
        "explanation": "This example compares the performance of clear() with slice assignment to an empty list.",
        "expected_output": "clear() time: (some value)\nSlice assignment time: (some value, typically similar to clear() time)"
      }
    ]
  },
  {
    "name": "clear_(set)",
    "module": "builtins",
    "class_name": "set",
    "return_type": "None",
    "parameters": [],
    "docstring": "Remove all elements from this set.",
    "decorators": [],
    "main_category": "Data Structure Operations",
    "sub_category": "Set Manipulation",
    "data_type_manipulated": ["set"],
    "version_added": "2.4",
    "deprecated": false,
    "extended_description": "The clear() method removes all elements from the set, leaving it empty. This operation is in-place, meaning it modifies the original set rather than creating a new one. After calling clear(), the set will have a length of 0. This method is useful when you want to empty a set without creating a new object.",
    "return_value": "This method doesn't return a value (None).",
    "parameter_values": "This method doesn't take any parameters.",
    "function_signature": "set.clear() -> None",
    "related_functions": [
      "set.pop()",
      "set.remove()",
      "set.discard()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "s = {1, 2, 3, 4, 5}\nprint(f\"Before clear: {s}\")\ns.clear()\nprint(f\"After clear: {s}\")",
        "explanation": "This example shows how clear() removes all elements from a set.",
        "expected_output": "Before clear: {1, 2, 3, 4, 5}\nAfter clear: set()"
      },
      {
        "title": "Clear Empty Set",
        "code": "empty_set = set()\nprint(f\"Before clear: {empty_set}\")\nempty_set.clear()\nprint(f\"After clear: {empty_set}\")",
        "explanation": "This example demonstrates that clear() works on empty sets without raising an error.",
        "expected_output": "Before clear: set()\nAfter clear: set()"
      },
      {
        "title": "Clear and References",
        "code": "original = {1, 2, 3}\nreference = original\noriginal.clear()\nprint(f\"Original: {original}\")\nprint(f\"Reference: {reference}\")",
        "explanation": "This example shows that clear() affects all references to the same set.",
        "expected_output": "Original: set()\nReference: set()"
      },
      {
        "title": "Performance Comparison",
        "code": "import timeit\n\ndef clear_method():\n    s = set(range(1000))\n    s.clear()\n\ndef reassignment():\n    s = set(range(1000))\n    s = set()\n\nprint(f\"clear() time: {timeit.timeit(clear_method, number=10000)}\")\nprint(f\"Reassignment time: {timeit.timeit(reassignment, number=10000)}\")",
        "explanation": "This example compares the performance of clear() with reassigning an empty set.",
        "expected_output": "clear() time: (some value)\nReassignment time: (some value, typically larger than clear() time)"
      }
    ]
  },
  {
    "name": "copy_(dict)",
    "module": "builtins",
    "class_name": "dict",
    "return_type": "dict",
    "parameters": [],
    "docstring": "Return a shallow copy of the dictionary.",
    "decorators": [],
    "main_category": "Data Structure Operations",
    "sub_category": "Dictionary Manipulation",
    "data_type_manipulated": ["dict"],
    "version_added": "1.5",
    "deprecated": false,
    "extended_description": "The copy() method returns a new dictionary containing a shallow copy of the original dictionary. A shallow copy means the structure of the dictionary is copied, but the elements are references to the same objects. For nested structures, only the references are copied, not the nested objects themselves.",
    "return_value": "Returns a new dictionary that is a shallow copy of the original.",
    "parameter_values": "This method doesn't take any parameters.",
    "function_signature": "dict.copy() -> dict",
    "related_functions": [
      "dict()",
      "copy.deepcopy()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "original = {'a': 1, 'b': 2, 'c': 3}\ncopy = original.copy()\nprint(f\"Original: {original}\")\nprint(f\"Copy: {copy}\")\noriginal['a'] = 10\nprint(f\"After modification - Original: {original}\")\nprint(f\"After modification - Copy: {copy}\")",
        "explanation": "This example shows how copy() creates a new dictionary with the same key-value pairs.",
        "expected_output": "Original: {'a': 1, 'b': 2, 'c': 3}\nCopy: {'a': 1, 'b': 2, 'c': 3}\nAfter modification - Original: {'a': 10, 'b': 2, 'c': 3}\nAfter modification - Copy: {'a': 1, 'b': 2, 'c': 3}"
      },
      {
        "title": "Shallow Copy Behavior",
        "code": "original = {'x': [1, 2, 3], 'y': {'a': 4}}\ncopy = original.copy()\noriginal['x'].append(4)\noriginal['y']['b'] = 5\nprint(f\"Original: {original}\")\nprint(f\"Copy: {copy}\")",
        "explanation": "This example demonstrates that for nested structures, the copy is shallow.",
        "expected_output": "Original: {'x': [1, 2, 3, 4], 'y': {'a': 4, 'b': 5}}\nCopy: {'x': [1, 2, 3, 4], 'y': {'a': 4, 'b': 5}}"
      },
      {
        "title": "Copy vs Assignment",
        "code": "original = {'a': 1, 'b': 2}\ncopy = original.copy()\nassignment = original\noriginal['c'] = 3\nprint(f\"Original: {original}\")\nprint(f\"Copy: {copy}\")\nprint(f\"Assignment: {assignment}\")",
        "explanation": "This example shows the difference between copying and assigning a dictionary.",
        "expected_output": "Original: {'a': 1, 'b': 2, 'c': 3}\nCopy: {'a': 1, 'b': 2}\nAssignment: {'a': 1, 'b': 2, 'c': 3}"
      },
      {
        "title": "Performance",
        "code": "import timeit\n\ndef dict_copy():\n    d = {i: i for i in range(1000)}\n    return d.copy()\n\ndef dict_constructor():\n    d = {i: i for i in range(1000)}\n    return dict(d)\n\nprint(f\"copy() time: {timeit.timeit(dict_copy, number=10000)}\")\nprint(f\"dict() time: {timeit.timeit(dict_constructor, number=10000)}\")",
        "explanation": "This example compares the performance of copy() with using the dict() constructor.",
        "expected_output": "copy() time: (some value)\ndict() time: (some value, typically slightly larger than copy() time)"
      }
    ]
  },
  {
    "name": "copy_(list)",
    "module": "builtins",
    "class_name": "list",
    "return_type": "list",
    "parameters": [],
    "docstring": "Return a shallow copy of the list.",
    "decorators": [],
    "main_category": "Data Structure Operations",
    "sub_category": "List Manipulation",
    "data_type_manipulated": ["list"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The copy() method returns a new list containing a shallow copy of the original list. A shallow copy means the structure of the list is copied, but the elements are references to the same objects. For nested lists, only the references are copied, not the nested lists themselves.",
    "return_value": "Returns a new list that is a shallow copy of the original.",
    "parameter_values": "This method doesn't take any parameters.",
    "function_signature": "list.copy() -> list",
    "related_functions": [
      "list()",
      "copy.deepcopy()",
      "list[:] (slice notation)"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "original = [1, 2, 3, 4, 5]\ncopy = original.copy()\nprint(f\"Original: {original}\")\nprint(f\"Copy: {copy}\")\noriginal[0] = 10\nprint(f\"After modification - Original: {original}\")\nprint(f\"After modification - Copy: {copy}\")",
        "explanation": "This example shows how copy() creates a new list with the same elements.",
        "expected_output": "Original: [1, 2, 3, 4, 5]\nCopy: [1, 2, 3, 4, 5]\nAfter modification - Original: [10, 2, 3, 4, 5]\nAfter modification - Copy: [1, 2, 3, 4, 5]"
      },
      {
        "title": "Shallow Copy Behavior",
        "code": "original = [1, [2, 3], {'a': 4}]\ncopy = original.copy()\noriginal[1].append(4)\noriginal[2]['b'] = 5\nprint(f\"Original: {original}\")\nprint(f\"Copy: {copy}\")",
        "explanation": "This example demonstrates that for nested structures, the copy is shallow.",
        "expected_output": "Original: [1, [2, 3, 4], {'a': 4, 'b': 5}]\nCopy: [1, [2, 3, 4], {'a': 4, 'b': 5}]"
      },
      {
        "title": "Copy vs Slice",
        "code": "original = [1, 2, 3, 4, 5]\ncopy_method = original.copy()\ncopy_slice = original[:]\nprint(f\"copy() == slice copy: {copy_method == copy_slice}\")\nprint(f\"copy() is slice copy: {copy_method is copy_slice}\")",
        "explanation": "This example compares the copy() method with slice notation for copying.",
        "expected_output": "copy() == slice copy: True\ncopy() is slice copy: False"
      },
      {
        "title": "Performance",
        "code": "import timeit\n\ndef list_copy():\n    l = list(range(1000))\n    return l.copy()\n\ndef list_slice():\n    l = list(range(1000))\n    return l[:]\n\nprint(f\"copy() time: {timeit.timeit(list_copy, number=10000)}\")\nprint(f\"Slice copy time: {timeit.timeit(list_slice, number=10000)}\")",
        "explanation": "This example compares the performance of copy() with slice notation.",
        "expected_output": "copy() time: (some value)\nSlice copy time: (some value, typically very close to copy() time)"
      }
    ]
  },
  {
    "name": "copy_(set)",
    "module": "builtins",
    "class_name": "set",
    "return_type": "set",
    "parameters": [],
    "docstring": "Return a shallow copy of the set.",
    "decorators": [],
    "main_category": "Data Structure Operations",
    "sub_category": "Set Manipulation",
    "data_type_manipulated": ["set"],
    "version_added": "2.4",
    "deprecated": false,
    "extended_description": "The copy() method returns a new set containing a shallow copy of the original set. A shallow copy means the structure of the set is copied, but the elements are references to the same objects. Since sets can only contain hashable (immutable) elements, the shallow copy behaves effectively like a deep copy for most use cases.",
    "return_value": "Returns a new set that is a shallow copy of the original.",
    "parameter_values": "This method doesn't take any parameters.",
    "function_signature": "set.copy() -> set",
    "related_functions": [
      "set()",
      "frozenset()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "original = {1, 2, 3, 4, 5}\ncopy = original.copy()\nprint(f\"Original: {original}\")\nprint(f\"Copy: {copy}\")\noriginal.add(6)\nprint(f\"After modification - Original: {original}\")\nprint(f\"After modification - Copy: {copy}\")",
        "explanation": "This example shows how copy() creates a new set with the same elements.",
        "expected_output": "Original: {1, 2, 3, 4, 5}\nCopy: {1, 2, 3, 4, 5}\nAfter modification - Original: {1, 2, 3, 4, 5, 6}\nAfter modification - Copy: {1, 2, 3, 4, 5}"
      },
      {
        "title": "Copy Behavior with Mutable Elements",
        "code": "original = {1, 2, (3, 4)}\ncopy = original.copy()\nprint(f\"Original: {original}\")\nprint(f\"Copy: {copy}\")\nprint(f\"Is (3, 4) in original the same object as in copy? {original.intersection(copy).pop() is (3, 4)}\")",
        "explanation": "This example demonstrates that for hashable elements (like tuples), the copy contains references to the same objects.",
        "expected_output": "Original: {1, 2, (3, 4)}\nCopy: {1, 2, (3, 4)}\nIs (3, 4) in original the same object as in copy? True"
      },
      {
        "title": "Copy vs Set Constructor",
        "code": "original = {1, 2, 3, 4, 5}\ncopy_method = original.copy()\ncopy_constructor = set(original)\nprint(f\"copy() == set() copy: {copy_method == copy_constructor}\")\nprint(f\"copy() is set() copy: {copy_method is copy_constructor}\")",
        "explanation": "This example compares the copy() method with using the set() constructor for copying.",
        "expected_output": "copy() == set() copy: True\ncopy() is set() copy: False"
      },
      {
        "title": "Performance",
        "code": "import timeit\n\ndef set_copy():\n    s = set(range(1000))\n    return s.copy()\n\ndef set_constructor():\n    s = set(range(1000))\n    return set(s)\n\nprint(f\"copy() time: {timeit.timeit(set_copy, number=10000)}\")\nprint(f\"set() constructor time: {timeit.timeit(set_constructor, number=10000)}\")",
        "explanation": "This example compares the performance of copy() with using the set() constructor.",
        "expected_output": "copy() time: (some value)\nset() constructor time: (some value, typically slightly larger than copy() time)"
      }
    ]
  },
  {
    "name": "fromkeys",
    "module": "dict",
    "class_name": "dictionary",
    "return_type": "dictionary",
    "parameters": [
      {
        "name": "iterable",
        "type": "Iterable"
      },
      {
        "name": "value",
        "type": "Any",
        "default": "None"
      }
    ],
    "docstring": "Create a new dictionary with keys from iterable and values set to value.",
    "decorators": [],
    "main_category": "Dictionary Operations",
    "sub_category": "Creation",
    "data_type_manipulated": ["dictionary", "Iterable"],
    "version_added": "2.3",
    "deprecated": false,
    "extended_description": "The fromkeys() method is a class method that creates a new dictionary. The first parameter is an iterable defining the keys of the new dictionary. The second optional parameter specifies the value for all keys, which defaults to None if not provided. This method is particularly useful when you want to create a dictionary with preset keys and a default value.",
    "return_value": "Returns a new dictionary with keys from the iterable and values set to the specified value.",
    "parameter_values": "iterable: An iterable containing the keys for the new dictionary. value: The value to be set for all keys (default is None).",
    "function_signature": "dict.fromkeys(iterable: Iterable, value: Any = None) -> dict",
    "related_functions": [
      "dict()",
      "dict.update()",
      "dict.setdefault()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "keys = ['a', 'b', 'c']\nd = dict.fromkeys(keys, 0)\nprint(d)",
        "explanation": "This example creates a dictionary with keys from a list and sets all values to 0.",
        "expected_output": "{'a': 0, 'b': 0, 'c': 0}"
      },
      {
        "title": "Using Default Value",
        "code": "keys = ('name', 'age', 'city')\nd = dict.fromkeys(keys)\nprint(d)",
        "explanation": "This example shows that when no value is provided, None is used as the default.",
        "expected_output": "{'name': None, 'age': None, 'city': None}"
      },
      {
        "title": "Using with Different Iterables",
        "code": "d1 = dict.fromkeys('hello', 1)\nprint(d1)\n\nd2 = dict.fromkeys(range(3), 'value')\nprint(d2)",
        "explanation": "These examples demonstrate using fromkeys() with a string and a range object.",
        "expected_output": "{'h': 1, 'e': 1, 'l': 1, 'o': 1}\n{0: 'value', 1: 'value', 2: 'value'}"
      },
      {
        "title": "Caution with Mutable Values",
        "code": "keys = ['a', 'b', 'c']\nd = dict.fromkeys(keys, [])\nprint(f\"Original: {d}\")\nd['a'].append(1)\nprint(f\"After modification: {d}\")",
        "explanation": "This example illustrates that when using a mutable value, all keys reference the same object.",
        "expected_output": "Original: {'a': [], 'b': [], 'c': []}\nAfter modification: {'a': [1], 'b': [1], 'c': [1]}"
      }
    ]
  },
  {
    "name": "get",
    "module": "dict",
    "class_name": "dictionary",
    "return_type": "Any",
    "parameters": [
      {
        "name": "key",
        "type": "Any"
      },
      {
        "name": "default",
        "type": "Any",
        "default": "None"
      }
    ],
    "docstring": "Return the value for key if key is in the dictionary, else default.",
    "decorators": [],
    "main_category": "Dictionary Operations",
    "sub_category": "Retrieval",
    "data_type_manipulated": ["dictionary"],
    "version_added": "1.5",
    "deprecated": false,
    "extended_description": "The get() method returns the value for a given key in the dictionary. If the key is not found, it returns the default value, which is None if not specified. This method provides a safe way to retrieve values from a dictionary without raising a KeyError for non-existent keys.",
    "return_value": "Returns the value associated with the key if found, otherwise returns the default value.",
    "parameter_values": "key: The key to look up in the dictionary. default: The value to return if the key is not found (optional, defaults to None).",
    "function_signature": "dict.get(key: Any, default: Any = None) -> Any",
    "related_functions": [
      "dict.__getitem__()",
      "dict.setdefault()",
      "dict.__contains__()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "d = {'a': 1, 'b': 2}\nprint(d.get('a'))\nprint(d.get('c'))\nprint(d.get('c', 3))",
        "explanation": "This example shows basic usage of get() with existing and non-existing keys.",
        "expected_output": "1\nNone\n3"
      },
      {
        "title": "Comparison with Direct Access",
        "code": "d = {'a': 1, 'b': 2}\n\n# Using get()\nprint(d.get('c'))\n\n# Direct access\ntry:\n    print(d['c'])\nexcept KeyError as e:\n    print(f\"KeyError: {e}\")",
        "explanation": "This example compares get() with direct dictionary access, showing how get() avoids KeyError.",
        "expected_output": "None\nKeyError: 'c'"
      },
      {
        "title": "Using get() in Conditional Statements",
        "code": "user = {'name': 'Alice', 'age': 30}\n\nif user.get('email'):\n    print(f\"Email: {user['email']}\")\nelse:\n    print(\"Email not provided\")\n\nrole = user.get('role', 'User')\nprint(f\"Role: {role}\")",
        "explanation": "This example demonstrates using get() in conditionals and with a default value.",
        "expected_output": "Email not provided\nRole: User"
      },
      {
        "title": "Performance Consideration",
        "code": "import timeit\n\nd = {str(i): i for i in range(1000)}\n\ndef use_get():\n    return d.get('900')\n\ndef use_direct():\n    return d['900'] if '900' in d else None\n\nprint(f\"get() time: {timeit.timeit(use_get, number=100000)}\")\nprint(f\"Direct access time: {timeit.timeit(use_direct, number=100000)}\")",
        "explanation": "This example compares the performance of get() with a conditional direct access.",
        "expected_output": "get() time: (some value)\nDirect access time: (some value, typically slightly less than get() time)"
      }
    ]
  },
  {
    "name": "items",
    "module": "dict",
    "class_name": "dictionary",
    "return_type": "dict_items",
    "parameters": [],
    "docstring": "Return a new view of the dictionary's items ((key, value) pairs).",
    "decorators": [],
    "main_category": "Dictionary Operations",
    "sub_category": "View",
    "data_type_manipulated": ["dictionary"],
    "version_added": "2.2",
    "deprecated": false,
    "extended_description": "The items() method returns a view object containing the key-value pairs of the dictionary as tuples. This view object is dynamic, meaning it reflects any changes made to the dictionary. The items view supports set operations when compared to other views, making it useful for comparing dictionaries.",
    "return_value": "Returns a dict_items object, which is a view of the dictionary's (key, value) pairs.",
    "parameter_values": "This method doesn't take any parameters.",
    "function_signature": "dict.items() -> dict_items",
    "related_functions": [
      "dict.keys()",
      "dict.values()",
      "dict.iteritems() (Python 2)"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "d = {'a': 1, 'b': 2, 'c': 3}\nitems = d.items()\nprint(items)\nprint(list(items))",
        "explanation": "This example shows how to use items() and convert the result to a list.",
        "expected_output": "dict_items([('a', 1), ('b', 2), ('c', 3)])\n[('a', 1), ('b', 2), ('c', 3)]"
      },
      {
        "title": "Iterating Over Items",
        "code": "d = {'apple': 2, 'banana': 3, 'orange': 1}\nfor key, value in d.items():\n    print(f\"{key}: {value}\")",
        "explanation": "This example demonstrates how to iterate over the items of a dictionary.",
        "expected_output": "apple: 2\nbanana: 3\norange: 1"
      },
      {
        "title": "Dynamic View",
        "code": "d = {'a': 1, 'b': 2}\nitems = d.items()\nprint(f\"Before: {list(items)}\")\nd['c'] = 3\nprint(f\"After: {list(items)}\")",
        "explanation": "This example shows that the items view dynamically reflects changes in the dictionary.",
        "expected_output": "Before: [('a', 1), ('b', 2)]\nAfter: [('a', 1), ('b', 2), ('c', 3)]"
      },
      {
        "title": "Set Operations",
        "code": "d1 = {'a': 1, 'b': 2}\nd2 = {'b': 2, 'c': 3}\nitems1 = d1.items()\nitems2 = d2.items()\nprint(f\"Common items: {list(items1 & items2)}\")\nprint(f\"All items: {list(items1 | items2)}\")\nprint(f\"Items in d1 but not in d2: {list(items1 - items2)}\")",
        "explanation": "This example demonstrates set operations on dict_items objects.",
        "expected_output": "Common items: [('b', 2)]\nAll items: [('a', 1), ('b', 2), ('c', 3)]\nItems in d1 but not in d2: [('a', 1)]"
      }
    ]
  },
  {
    "name": "keys",
    "module": "dict",
    "class_name": "dictionary",
    "return_type": "dict_keys",
    "parameters": [],
    "docstring": "Return a new view of the dictionary's keys.",
    "decorators": [],
    "main_category": "Dictionary Operations",
    "sub_category": "View",
    "data_type_manipulated": ["dictionary"],
    "version_added": "2.2",
    "deprecated": false,
    "extended_description": "The keys() method returns a view object that contains all the keys in the dictionary. This view object is dynamic, meaning it reflects any changes made to the dictionary. The keys view supports set operations when compared to other views, making it useful for comparing dictionaries. In Python 3, dict_keys objects are not directly subscriptable, but can be easily converted to a list if needed.",
    "return_value": "Returns a dict_keys object, which is a view of the dictionary's keys.",
    "parameter_values": "This method doesn't take any parameters.",
    "function_signature": "dict.keys() -> dict_keys",
    "related_functions": [
      "dict.values()",
      "dict.items()",
      "dict.iterkeys() (Python 2)"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "d = {'a': 1, 'b': 2, 'c': 3}\nkeys = d.keys()\nprint(keys)\nprint(list(keys))",
        "explanation": "This example shows how to use keys() and convert the result to a list.",
        "expected_output": "dict_keys(['a', 'b', 'c'])\n['a', 'b', 'c']"
      },
      {
        "title": "Iterating Over Keys",
        "code": "d = {'apple': 2, 'banana': 3, 'orange': 1}\nfor key in d.keys():\n    print(f\"Key: {key}, Value: {d[key]}\")",
        "explanation": "This example demonstrates how to iterate over the keys of a dictionary.",
        "expected_output": "Key: apple, Value: 2\nKey: banana, Value: 3\nKey: orange, Value: 1"
      },
      {
        "title": "Dynamic View",
        "code": "d = {'a': 1, 'b': 2}\nkeys = d.keys()\nprint(f\"Before: {list(keys)}\")\nd['c'] = 3\nprint(f\"After: {list(keys)}\")",
        "explanation": "This example shows that the keys view dynamically reflects changes in the dictionary.",
        "expected_output": "Before: ['a', 'b']\nAfter: ['a', 'b', 'c']"
      },
      {
        "title": "Set Operations",
        "code": "d1 = {'a': 1, 'b': 2, 'c': 3}\nd2 = {'b': 20, 'c': 30, 'd': 40}\nkeys1 = d1.keys()\nkeys2 = d2.keys()\nprint(f\"Common keys: {keys1 & keys2}\")\nprint(f\"All keys: {keys1 | keys2}\")\nprint(f\"Keys in d1 but not in d2: {keys1 - keys2}\")",
        "explanation": "This example demonstrates set operations on dict_keys objects.",
        "expected_output": "Common keys: {'b', 'c'}\nAll keys: {'a', 'b', 'c', 'd'}\nKeys in d1 but not in d2: {'a'}"
      }
    ]
  },
  {
    "name": "pop_(dict)",
    "module": "dict",
    "class_name": "dictionary",
    "return_type": "Any",
    "parameters": [
      {
        "name": "key",
        "type": "Any"
      },
      {
        "name": "default",
        "type": "Any",
        "default": "None"
      }
    ],
    "docstring": "Remove specified key and return the corresponding value.",
    "decorators": [],
    "main_category": "Dictionary Operations",
    "sub_category": "Modification",
    "data_type_manipulated": ["dictionary"],
    "version_added": "1.5",
    "deprecated": false,
    "extended_description": "The pop() method removes the item with the specified key from the dictionary and returns its value. If the key is not found and a default value is provided, it returns the default value. If the key is not found and no default value is provided, it raises a KeyError. This method modifies the dictionary in-place.",
    "return_value": "Returns the value associated with the removed key. If the key is not found and a default is provided, returns the default value.",
    "parameter_values": "key: The key of the item to be removed from the dictionary. default: The value to return if the key is not found (optional).",
    "function_signature": "dict.pop(key: Any, default: Any = None) -> Any",
    "related_functions": [
      "dict.popitem()",
      "dict.__delitem__()",
      "dict.clear()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "d = {'a': 1, 'b': 2, 'c': 3}\nvalue = d.pop('b')\nprint(f\"Popped value: {value}\")\nprint(f\"Dictionary after pop: {d}\")",
        "explanation": "This example shows how to use pop() to remove and return a value from the dictionary.",
        "expected_output": "Popped value: 2\nDictionary after pop: {'a': 1, 'c': 3}"
      },
      {
        "title": "Using Default Value",
        "code": "d = {'a': 1, 'b': 2}\nprint(d.pop('c', 'Not found'))\nprint(d.pop('a', 'Not found'))\nprint(d)",
        "explanation": "This example demonstrates using pop() with a default value for both existing and non-existing keys.",
        "expected_output": "Not found\n1\n{'b': 2}"
      },
      {
        "title": "Handling KeyError",
        "code": "d = {'a': 1, 'b': 2}\ntry:\n    d.pop('c')\nexcept KeyError as e:\n    print(f\"KeyError: {e}\")\n\n# Using get() for comparison\nprint(d.get('c'))",
        "explanation": "This example shows the KeyError raised when popping a non-existent key without a default value, and compares it with get().",
        "expected_output": "KeyError: 'c'\nNone"
      },
      {
        "title": "Pop in a Loop",
        "code": "d = {'a': 1, 'b': 2, 'c': 3, 'd': 4}\nwhile d:\n    key, value = d.popitem()\n    print(f\"Popped: {key} = {value}\")\nprint(f\"Final dictionary: {d}\")",
        "explanation": "This example demonstrates using pop() in a loop to empty a dictionary.",
        "expected_output": "Popped: d = 4\nPopped: c = 3\nPopped: b = 2\nPopped: a = 1\nFinal dictionary: {}"
      }
    ]
  },
  {
    "name": "pop_(list)",
    "module": "list",
    "class_name": "list",
    "return_type": "Any",
    "parameters": [
      {
        "name": "index",
        "type": "int",
        "default": "-1"
      }
    ],
    "docstring": "Remove and return item at index (default last).",
    "decorators": [],
    "main_category": "List Operations",
    "sub_category": "Modification",
    "data_type_manipulated": ["list"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The pop() method removes and returns the item at the specified index from the list. If no index is specified, it removes and returns the last item. If the index is out of range, it raises an IndexError. This method modifies the list in-place, reducing its length by one.",
    "return_value": "Returns the item that was removed from the list.",
    "parameter_values": "index: The index of the item to be removed from the list. If not provided, defaults to -1 (last item).",
    "function_signature": "list.pop(index: int = -1) -> Any",
    "related_functions": [
      "list.remove()",
      "list.clear()",
      "del statement"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "numbers = [1, 2, 3, 4, 5]\npopped = numbers.pop()\nprint(f\"Popped value: {popped}\")\nprint(f\"List after pop: {numbers}\")",
        "explanation": "This example shows how to use pop() to remove and return the last item from the list.",
        "expected_output": "Popped value: 5\nList after pop: [1, 2, 3, 4]"
      },
      {
        "title": "Pop with Index",
        "code": "fruits = ['apple', 'banana', 'cherry', 'date']\npopped = fruits.pop(1)\nprint(f\"Popped fruit: {popped}\")\nprint(f\"Fruits after pop: {fruits}\")",
        "explanation": "This example demonstrates using pop() with a specific index to remove an item from the middle of the list.",
        "expected_output": "Popped fruit: banana\nFruits after pop: ['apple', 'cherry', 'date']"
      },
      {
        "title": "Handling IndexError",
        "code": "small_list = [1, 2, 3]\ntry:\n    small_list.pop(5)\nexcept IndexError as e:\n    print(f\"IndexError: {e}\")\n\n# Popping from an empty list\nempty_list = []\ntry:\n    empty_list.pop()\nexcept IndexError as e:\n    print(f\"IndexError: {e}\")",
        "explanation": "This example shows the IndexError raised when popping from an empty list or with an out-of-range index.",
        "expected_output": "IndexError: pop index out of range\nIndexError: pop from empty list"
      },
      {
        "title": "Pop in a Loop",
        "code": "stack = [1, 2, 3, 4, 5]\nwhile stack:\n    print(f\"Popped: {stack.pop()}\")\nprint(f\"Final stack: {stack}\")",
        "explanation": "This example demonstrates using pop() in a loop to empty a list, simulating a stack data structure.",
        "expected_output": "Popped: 5\nPopped: 4\nPopped: 3\nPopped: 2\nPopped: 1\nFinal stack: []"
      }
    ]
  },
  {
    "name": "pop_(set)",
    "module": "set",
    "class_name": "set",
    "return_type": "Any",
    "parameters": [],
    "docstring": "Remove and return an arbitrary set element. Raises KeyError if the set is empty.",
    "decorators": [],
    "main_category": "Set Operations",
    "sub_category": "Modification",
    "data_type_manipulated": ["set"],
    "version_added": "2.4",
    "deprecated": false,
    "extended_description": "The pop() method removes and returns an arbitrary element from the set. Since sets are unordered, there's no 'last' element, so the specific element removed is arbitrary. If the set is empty, pop() raises a KeyError. This method modifies the set in-place, reducing its size by one.",
    "return_value": "Returns an arbitrary element that was removed from the set.",
    "parameter_values": "This method doesn't take any parameters.",
    "function_signature": "set.pop() -> Any",
    "related_functions": [
      "set.remove()",
      "set.discard()",
      "set.clear()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "numbers = {1, 2, 3, 4, 5}\npopped = numbers.pop()\nprint(f\"Popped value: {popped}\")\nprint(f\"Set after pop: {numbers}\")",
        "explanation": "This example shows how to use pop() to remove and return an arbitrary element from the set.",
        "expected_output": "Popped value: (any of 1, 2, 3, 4, or 5)\nSet after pop: (remaining four numbers)"
      },
      {
        "title": "Popping All Elements",
        "code": "fruits = {'apple', 'banana', 'cherry'}\nwhile fruits:\n    print(f\"Popped: {fruits.pop()}\")\nprint(f\"Final set: {fruits}\")",
        "explanation": "This example demonstrates using pop() in a loop to empty a set.",
        "expected_output": "Popped: (any of apple, banana, or cherry)\nPopped: (any of the two remaining fruits)\nPopped: (the last remaining fruit)\nFinal set: set()"
      },
      {
        "title": "Handling KeyError",
        "code": "empty_set = set()\ntry:\n    empty_set.pop()\nexcept KeyError as e:\n    print(f\"KeyError: {e}\")",
        "explanation": "This example shows the KeyError raised when attempting to pop from an empty set.",
        "expected_output": "KeyError: 'pop from an empty set'"
      },
      {
        "title": "Using pop() with Frozen Sets",
        "code": "from typing import FrozenSet\n\nfrozen_set: FrozenSet[int] = frozenset([1, 2, 3])\ntry:\n    frozen_set.pop()\nexcept AttributeError as e:\n    print(f\"AttributeError: {e}\")",
        "explanation": "This example demonstrates that pop() is not available for frozenset, which is immutable.",
        "expected_output": "AttributeError: 'frozenset' object has no attribute 'pop'"
      }
    ]
  }
  ,
  {
    "name": "popitem",
    "module": "dict",
    "class_name": "dictionary",
    "return_type": "Tuple",
    "parameters": [],
    "docstring": "Remove and return a (key, value) pair as a 2-tuple.",
    "decorators": [],
    "main_category": "Dictionary Operations",
    "sub_category": "Modification",
    "data_type_manipulated": ["dictionary"],
    "version_added": "2.1",
    "deprecated": false,
    "extended_description": "The popitem() method removes and returns an arbitrary (key, value) pair from the dictionary as a tuple. In Python 3.7+, popitem() removes the last inserted item, making dictionaries effectively ordered. If the dictionary is empty, popitem() raises a KeyError. This method is useful when you need to destructively iterate over a dictionary.",
    "return_value": "Returns a tuple containing the (key, value) pair that was removed from the dictionary.",
    "parameter_values": "This method doesn't take any parameters.",
    "function_signature": "dict.popitem() -> Tuple[Any, Any]",
    "related_functions": [
      "dict.pop()",
      "dict.clear()",
      "dict.items()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "d = {'a': 1, 'b': 2, 'c': 3}\nitem = d.popitem()\nprint(f\"Popped item: {item}\")\nprint(f\"Dictionary after popitem: {d}\")",
        "explanation": "This example shows how to use popitem() to remove and return a (key, value) pair from the dictionary.",
        "expected_output": "Popped item: ('c', 3)\nDictionary after popitem: {'a': 1, 'b': 2}"
      },
      {
        "title": "Ordered Behavior (Python 3.7+)",
        "code": "d = {}\nd['a'] = 1\nd['b'] = 2\nd['c'] = 3\nwhile d:\n    print(d.popitem())",
        "explanation": "This example demonstrates the LIFO (Last In First Out) behavior of popitem() in Python 3.7 and later versions.",
        "expected_output": "('c', 3)\n('b', 2)\n('a', 1)"
      },
      {
        "title": "Handling Empty Dictionary",
        "code": "d = {}\ntry:\n    d.popitem()\nexcept KeyError as e:\n    print(f\"KeyError: {e}\")",
        "explanation": "This example shows the KeyError raised when calling popitem() on an empty dictionary.",
        "expected_output": "KeyError: 'popitem(): dictionary is empty'"
      },
      {
        "title": "Using popitem() for Destructive Iteration",
        "code": "d = {'a': 1, 'b': 2, 'c': 3}\ntry:\n    while True:\n        key, value = d.popitem()\n        print(f\"Processing: {key} = {value}\")\nexcept KeyError:\n    print(\"Dictionary is now empty\")\nprint(f\"Final state of dictionary: {d}\")",
        "explanation": "This example demonstrates using popitem() to iterate over and empty a dictionary.",
        "expected_output": "Processing: c = 3\nProcessing: b = 2\nProcessing: a = 1\nDictionary is now empty\nFinal state of dictionary: {}"
      }
    ]
  },
  {
    "name": "setdefault",
    "module": "dict",
    "class_name": "dictionary",
    "return_type": "Any",
    "parameters": [
      {
        "name": "key",
        "type": "Any"
      },
      {
        "name": "default",
        "type": "Any",
        "default": "None"
      }
    ],
    "docstring": "Insert key with a value of default if key is not in the dictionary.",
    "decorators": [],
    "main_category": "Dictionary Operations",
    "sub_category": "Modification",
    "data_type_manipulated": ["dictionary"],
    "version_added": "2.0",
    "deprecated": false,
    "extended_description": "The setdefault() method returns the value of the specified key. If the key does not exist, it inserts the key with the specified default value and returns the default value. If the key already exists, it returns its value without modifying the dictionary. This method is particularly useful when you want to initialize a key with a default value if it doesn't exist, and then use or modify that value.",
    "return_value": "Returns the value of the specified key. If the key does not exist, it returns the default value.",
    "parameter_values": "key: The key to be inserted or retrieved. default: The value to be set if the key does not exist (optional, defaults to None).",
    "function_signature": "dict.setdefault(key: Any, default: Any = None) -> Any",
    "related_functions": [
      "dict.get()",
      "dict.__setitem__()",
      "dict.update()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "d = {'a': 1, 'b': 2}\nprint(d.setdefault('b', 3))  # Existing key\nprint(d.setdefault('c', 3))  # New key\nprint(d)",
        "explanation": "This example shows how setdefault() works with existing and new keys.",
        "expected_output": "2\n3\n{'a': 1, 'b': 2, 'c': 3}"
      },
      {
        "title": "Using setdefault() with Lists",
        "code": "d = {}\nd.setdefault('fruits', []).append('apple')\nd.setdefault('fruits', []).append('banana')\nprint(d)",
        "explanation": "This example demonstrates using setdefault() to initialize and append to a list value.",
        "expected_output": "{'fruits': ['apple', 'banana']}"
      },
      {
        "title": "Counting Occurrences",
        "code": "text = \"hello world hello\"\nword_count = {}\nfor word in text.split():\n    word_count.setdefault(word, 0)\n    word_count[word] += 1\nprint(word_count)",
        "explanation": "This example shows how to use setdefault() to count occurrences of words in a string.",
        "expected_output": "{'hello': 2, 'world': 1}"
      },
      {
        "title": "setdefault() vs get()",
        "code": "d = {}\n# Using setdefault()\nprint(d.setdefault('a', 1))\nprint(d)\n\n# Using get() and assignment\nd = {}\nvalue = d.get('b')\nif value is None:\n    d['b'] = 2\nprint(d.get('b'))\nprint(d)",
        "explanation": "This example compares setdefault() with the alternative of using get() and conditional assignment.",
        "expected_output": "1\n{'a': 1}\n2\n{'b': 2}"
      }
    ]
  },
  {
    "name": "update",
    "module": "dict",
    "class_name": "dictionary",
    "return_type": "None",
    "parameters": [
      {
        "name": "other",
        "type": "Union[dictionary, Iterable[Tuple[Any, Any]]]"
      }
    ],
    "docstring": "Update the dictionary with the key/value pairs from other, overwriting existing keys.",
    "decorators": [],
    "main_category": "Dictionary Operations",
    "sub_category": "Modification",
    "data_type_manipulated": ["dictionary"],
    "version_added": "1.5",
    "deprecated": false,
    "extended_description": "The update() method updates the dictionary with elements from another dictionary or an iterable of key/value pairs. If a key from the other dictionary already exists in the current dictionary, its value is overwritten. If a key doesn't exist, a new key-value pair is added. This method modifies the dictionary in place and doesn't return a value. It can also accept keyword arguments for adding new key-value pairs.",
    "return_value": "This method doesn't return a value (None).",
    "parameter_values": "other: Another dictionary or an iterable of key-value pairs (tuple pairs) to update from. Can also accept keyword arguments.",
    "function_signature": "dict.update(other: Union[dict, Iterable[Tuple[Any, Any]]], **kwargs) -> None",
    "related_functions": [
      "dict.__setitem__()",
      "dict.setdefault()",
      "dict.clear()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "d1 = {'a': 1, 'b': 2}\nd2 = {'b': 3, 'c': 4}\nd1.update(d2)\nprint(d1)",
        "explanation": "This example shows how update() merges two dictionaries, overwriting existing keys.",
        "expected_output": "{'a': 1, 'b': 3, 'c': 4}"
      },
      {
        "title": "Update with Iterable",
        "code": "d = {'a': 1, 'b': 2}\nd.update([('b', 3), ('c', 4)])\nprint(d)",
        "explanation": "This example demonstrates updating a dictionary with an iterable of key-value pairs.",
        "expected_output": "{'a': 1, 'b': 3, 'c': 4}"
      },
      {
        "title": "Update with Keyword Arguments",
        "code": "d = {'a': 1, 'b': 2}\nd.update(c=3, d=4)\nprint(d)",
        "explanation": "This example shows how to use keyword arguments with update().",
        "expected_output": "{'a': 1, 'b': 2, 'c': 3, 'd': 4}"
      },
      {
        "title": "Combining Different Update Methods",
        "code": "d = {'a': 1}\nd.update({'b': 2}, c=3, **{'d': 4})\nprint(d)",
        "explanation": "This example combines different ways of using update() in a single call.",
        "expected_output": "{'a': 1, 'b': 2, 'c': 3, 'd': 4}"
      }
    ]
  },
  {
    "name": "values",
    "module": "dict",
    "class_name": "dictionary",
    "return_type": "dict_values",
    "parameters": [],
    "docstring": "Return a new view of the dictionary's values.",
    "decorators": [],
    "main_category": "Dictionary Operations",
    "sub_category": "View",
    "data_type_manipulated": ["dictionary"],
    "version_added": "2.2",
    "deprecated": false,
    "extended_description": "The values() method returns a view object containing all values in the dictionary. This view object is dynamic, meaning it reflects any changes made to the dictionary. The values view does not support indexing, but can be converted to a list if needed. Unlike keys(), the values() view does not support set operations as values are not guaranteed to be unique or hashable.",
    "return_value": "Returns a dict_values object, which is a view of the dictionary's values.",
    "parameter_values": "This method doesn't take any parameters.",
    "function_signature": "dict.values() -> dict_values",
    "related_functions": [
      "dict.keys()",
      "dict.items()",
      "dict.itervalues() (Python 2)"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "d = {'a': 1, 'b': 2, 'c': 3}\nvalues = d.values()\nprint(values)\nprint(list(values))",
        "explanation": "This example shows how to use values() and convert the result to a list.",
        "expected_output": "dict_values([1, 2, 3])\n[1, 2, 3]"
      },
      {
        "title": "Iterating Over Values",
        "code": "d = {'apple': 2, 'banana': 3, 'orange': 1}\nfor value in d.values():\n    print(f\"Value: {value}\")",
        "explanation": "This example demonstrates how to iterate over the values of a dictionary.",
        "expected_output": "Value: 2\nValue: 3\nValue: 1"
      },
      {
        "title": "Dynamic View",
        "code": "d = {'a': 1, 'b': 2}\nvalues = d.values()\nprint(f\"Before: {list(values)}\")\nd['c'] = 3\nprint(f\"After: {list(values)}\")",
        "explanation": "This example shows that the values view dynamically reflects changes in the dictionary.",
        "expected_output": "Before: [1, 2]\nAfter: [1, 2, 3]"
      },
      {
        "title": "Values with Duplicate Entries",
        "code": "d = {'a': 1, 'b': 2, 'c': 1, 'd': 3}\nvalues = d.values()\nprint(f\"Values: {list(values)}\")\nprint(f\"Unique values: {set(values)}\")\nprint(f\"Count of 1: {list(values).count(1)}\")",
        "explanation": "This example demonstrates handling duplicate values and counting occurrences.",
        "expected_output": "Values: [1, 2, 1, 3]\nUnique values: {1, 2, 3}\nCount of 1: 2"
      }
    ]
  },
  {
    "name": "count_(tuple)",
    "module": "tuple",
    "class_name": "tuple",
    "return_type": "int",
    "parameters": [
      {
        "name": "value",
        "type": "Any"
      }
    ],
    "docstring": "Return the number of times a specified value occurs in a tuple.",
    "decorators": [],
    "main_category": "Tuple Operations",
    "sub_category": "Counting",
    "data_type_manipulated": ["tuple"],
    "version_added": "1.5",
    "deprecated": false,
    "extended_description": "The count() method returns the number of elements with the specified value in the tuple. It performs an equality comparison on each element. For objects, it uses the object's __eq__() method for comparison. The search is performed from left to right, and the order of occurrence doesn't matter.",
    "return_value": "Returns an integer representing the count of the specified value in the tuple.",
    "parameter_values": "value: The value to be counted in the tuple.",
    "function_signature": "tuple.count(value: Any) -> int",
    "related_functions": [
      "tuple.index()",
      "list.count()",
      "str.count()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "t = (1, 2, 3, 1, 4, 1)\nprint(t.count(1))\nprint(t.count(5))",
        "explanation": "This example shows counting occurrences of values that are present and not present in the tuple.",
        "expected_output": "3\n0"
      },
      {
        "title": "Counting with Different Data Types",
        "code": "t = ('apple', 1, 2.5, True, 'apple', False)\nprint(t.count('apple'))\nprint(t.count(1))  # True is considered equal to 1\nprint(t.count(False))  # False is considered equal to 0",
        "explanation": "This example demonstrates counting elements of different types, including boolean values.",
        "expected_output": "2\n2\n1"
      },
      {
        "title": "Counting Objects",
        "code": "class Person:\n    def __init__(self, name):\n        self.name = name\n    def __eq__(self, other):\n        return isinstance(other, Person) and self.name == other.name\n\np1 = Person('Alice')\np2 = Person('Bob')\np3 = Person('Alice')\nt = (p1, p2, p3, 'Alice')\nprint(t.count(Person('Alice')))\nprint(t.count('Alice'))",
        "explanation": "This example shows how count() works with custom objects that implement __eq__().",
        "expected_output": "2\n1"
      },
      {
        "title": "Performance Consideration",
        "code": "import timeit\n\nt = tuple(range(1000000)) + (1,)\n\ndef count_method():\n    return t.count(1)\n\ndef manual_count():\n    return sum(1 for item in t if item == 1)\n\nprint(f\"count() time: {timeit.timeit(count_method, number=100)}\")\nprint(f\"manual count time: {timeit.timeit(manual_count, number=100)}\")",
        "explanation": "This example compares the performance of count() with a manual counting loop for a large tuple.",
        "expected_output": "count() time: (some value)\nmanual count time: (some larger value)"
      }
    ]
  },
  {
    "name": "count_(list)",
    "module": "list",
    "class_name": "list",
    "return_type": "int",
    "parameters": [
      {
        "name": "value",
        "type": "Any"
      }
    ],
    "docstring": "Return the number of times a specified value occurs in a list.",
    "decorators": [],
    "main_category": "List Operations",
    "sub_category": "Counting",
    "data_type_manipulated": ["list"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The count() method returns the number of elements with the specified value in the list. It performs an equality comparison on each element. For objects, it uses the object's __eq__() method for comparison. The search is performed from left to right, and the order of occurrence doesn't matter.",
    "return_value": "Returns an integer representing the count of the specified value in the list.",
    "parameter_values": "value: The value to be counted in the list.",
    "function_signature": "list.count(value: Any) -> int",
    "related_functions": [
      "list.index()",
      "tuple.count()",
      "str.count()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "numbers = [1, 2, 3, 1, 4, 1, 5]\nprint(numbers.count(1))\nprint(numbers.count(6))",
        "explanation": "This example shows counting occurrences of values that are present and not present in the list.",
        "expected_output": "3\n0"
      },
      {
        "title": "Counting with Different Data Types",
        "code": "mixed = ['apple', 1, 2.5, True, 'apple', False, 1.0]\nprint(mixed.count('apple'))\nprint(mixed.count(1))  # True and 1.0 are considered equal to 1\nprint(mixed.count(False))",
        "explanation": "This example demonstrates counting elements of different types, including boolean values and floating-point numbers.",
        "expected_output": "2\n3\n1"
      },
      {
        "title": "Counting in Nested Lists",
        "code": "nested = [1, [1, 2], 3, [1, 2], [1, 2]]\nprint(nested.count([1, 2]))\nprint(nested.count(1))",
        "explanation": "This example shows how count() works with nested lists.",
        "expected_output": "3\n1"
      },
      {
        "title": "Using count() with list comprehension",
        "code": "text = \"The quick brown fox jumps over the lazy dog\"\nwords = text.split()\nword_counts = [(word, words.count(word)) for word in set(words)]\nprint(sorted(word_counts, key=lambda x: x[1], reverse=True))",
        "explanation": "This example demonstrates using count() in a list comprehension to count word frequencies.",
        "expected_output": "[('the', 2), ('The', 1), ('quick', 1), ('brown', 1), ('fox', 1), ('jumps', 1), ('over', 1), ('lazy', 1), ('dog', 1)]"
      }
    ]
  },
  {
    "name": "count_(str)",
    "module": "str",
    "class_name": "str",
    "return_type": "int",
    "parameters": [
      {
        "name": "sub",
        "type": "str"
      },
      {
        "name": "start",
        "type": "int",
        "default": "None"
      },
      {
        "name": "end",
        "type": "int",
        "default": "None"
      }
    ],
    "docstring": "Return the number of non-overlapping occurrences of substring sub in string.",
    "decorators": [],
    "main_category": "String Operations",
    "sub_category": "Counting",
    "data_type_manipulated": ["str"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The count() method returns the number of non-overlapping occurrences of a substring in the given string. Optional arguments start and end are interpreted as in slice notation and are used to limit the search to a substring of the string. The search is performed from left to right, and non-overlapping occurrences are counted.",
    "return_value": "Returns an integer representing the count of non-overlapping occurrences of the substring.",
    "parameter_values": "sub: The substring to be counted. start: Optional starting index for the search. end: Optional ending index for the search.",
    "function_signature": "str.count(sub: str, start: int = None, end: int = None) -> int",
    "related_functions": [
      "str.find()",
      "str.index()",
      "re.findall()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "text = \"banana\"\nprint(text.count('a'))\nprint(text.count('na'))",
        "explanation": "This example shows counting occurrences of a single character and a substring.",
        "expected_output": "3\n2"
      },
      {
        "title": "Using start and end parameters",
        "code": "text = \"banana\"\nprint(text.count('a', 2))  # Count 'a' starting from index 2\nprint(text.count('na', 0, 4))  # Count 'na' from index 0 to 4 (exclusive)",
        "explanation": "This example demonstrates using start and end parameters to limit the search range.",
        "expected_output": "2\n1"
      },
      {
        "title": "Counting Non-Overlapping Occurrences",
        "code": "text = \"aaaaa\"\nprint(text.count('aa'))  # Counts non-overlapping 'aa'\nprint(text.count('aaa'))  # Counts non-overlapping 'aaa'",
        "explanation": "This example illustrates the non-overlapping nature of the count() method.",
        "expected_output": "2\n1"
      },
      {
        "title": "Case Sensitivity and Empty Strings",
        "code": "text = \"The quick brown Fox jumps over the lazy Dog\"\nprint(text.count('the'))\nprint(text.count('THE'))\nprint(text.count(''))",
        "explanation": "This example shows that count() is case-sensitive and how it handles empty strings.",
        "expected_output": "1\n0\n51"
      }
    ]
  },
  {
    "name": "index_(tuple)",
    "module": "tuple",
    "class_name": "tuple",
    "return_type": "int",
    "parameters": [
      {
        "name": "value",
        "type": "Any"
      },
      {
        "name": "start",
        "type": "int",
        "default": "0"
      },
      {
        "name": "end",
        "type": "int",
        "default": "None"
      }
    ],
    "docstring": "Return the index of the first occurrence of the specified value.",
    "decorators": [],
    "main_category": "Tuple Operations",
    "sub_category": "Searching",
    "data_type_manipulated": ["tuple"],
    "version_added": "1.5",
    "deprecated": false,
    "extended_description": "The index() method returns the index of the first occurrence of the specified value in the tuple. If the value is not found, it raises a ValueError. Optional start and end parameters can be used to limit the search to a specific slice of the tuple. The search is performed from left to right.",
    "return_value": "Returns an integer representing the index of the first occurrence of the specified value.",
    "parameter_values": "value: The value to search for in the tuple. start: Optional starting index for the search (default is 0). end: Optional ending index for the search (default is None, which means the end of the tuple).",
    "function_signature": "tuple.index(value: Any, start: int = 0, end: int = None) -> int",
    "related_functions": [
      "tuple.count()",
      "list.index()",
      "str.index()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "t = (1, 2, 3, 1, 4, 1)\nprint(t.index(1))\nprint(t.index(4))",
        "explanation": "This example shows finding the index of the first occurrence of values in the tuple.",
        "expected_output": "0\n4"
      },
      {
        "title": "Using start and end parameters",
        "code": "t = (1, 2, 3, 1, 4, 1)\nprint(t.index(1, 2))  # Start searching from index 2\nprint(t.index(1, 2, 4))  # Search between index 2 (inclusive) and 4 (exclusive)",
        "explanation": "This example demonstrates using start and end parameters to limit the search range.",
        "expected_output": "3\n3"
      },
      {
        "title": "Handling ValueError",
        "code": "t = (1, 2, 3, 4, 5)\ntry:\n    print(t.index(6))\nexcept ValueError as e:\n    print(f\"ValueError: {e}\")\n\ntry:\n    print(t.index(1, 2))\nexcept ValueError as e:\n    print(f\"ValueError: {e}\")",
        "explanation": "This example shows the ValueError raised when the value is not found in the tuple or within the specified range.",
        "expected_output": "ValueError: tuple.index(x): x not in tuple\nValueError: tuple.index(x): x not in tuple"
      },
      {
        "title": "Index with Custom Objects",
        "code": "class Person:\n    def __init__(self, name):\n        self.name = name\n    def __eq__(self, other):\n        return isinstance(other, Person) and self.name == other.name\n\np1 = Person('Alice')\np2 = Person('Bob')\np3 = Person('Alice')\nt = (p1, p2, p3)\nprint(t.index(Person('Alice')))\nprint(t.index(Person('Bob')))",
        "explanation": "This example demonstrates how index() works with custom objects that implement __eq__().",
        "expected_output": "0\n1"
      }
    ]
  },
  {
    "name": "index_(list)",
    "module": "list",
    "class_name": "list",
    "return_type": "int",
    "parameters": [
      {
        "name": "value",
        "type": "Any"
      },
      {
        "name": "start",
        "type": "int",
        "default": "0"
      },
      {
        "name": "end",
        "type": "int",
        "default": "None"
      }
    ],
    "docstring": "Return the index of the first occurrence of the specified value.",
    "decorators": [],
    "main_category": "List Operations",
    "sub_category": "Searching",
    "data_type_manipulated": ["list"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The index() method returns the index of the first occurrence of the specified value in the list. If the value is not found, it raises a ValueError. Optional start and end parameters can be used to limit the search to a specific slice of the list. The search is performed from left to right.",
    "return_value": "Returns an integer representing the index of the first occurrence of the specified value.",
    "parameter_values": "value: The value to search for in the list. start: Optional starting index for the search (default is 0). end: Optional ending index for the search (default is None, which means the end of the list).",
    "function_signature": "list.index(value: Any, start: int = 0, end: int = None) -> int",
    "related_functions": [
      "list.count()",
      "tuple.index()",
      "str.index()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "numbers = [1, 2, 3, 1, 4, 1, 5]\nprint(numbers.index(1))\nprint(numbers.index(5))",
        "explanation": "This example shows finding the index of the first occurrence of values in the list.",
        "expected_output": "0\n6"
      },
      {
        "title": "Using start and end parameters",
        "code": "numbers = [1, 2, 3, 1, 4, 1, 5]\nprint(numbers.index(1, 2))  # Start searching from index 2\nprint(numbers.index(1, 2, 5))  # Search between index 2 (inclusive) and 5 (exclusive)",
        "explanation": "This example demonstrates using start and end parameters to limit the search range.",
        "expected_output": "3\n3"
      },
      {
        "title": "Handling ValueError",
        "code": "fruits = ['apple', 'banana', 'cherry']\ntry:\n    print(fruits.index('date'))\nexcept ValueError as e:\n    print(f\"ValueError: {e}\")\n\ntry:\n    print(fruits.index('apple', 1))\nexcept ValueError as e:\n    print(f\"ValueError: {e}\")",
        "explanation": "This example shows the ValueError raised when the value is not found in the list or within the specified range.",
        "expected_output": "ValueError: 'date' is not in list\nValueError: 'apple' is not in list"
      },
      {
        "title": "Index with Nested Lists",
        "code": "nested = [1, [2, 3], 4, [2, 3], 5]\nprint(nested.index([2, 3]))\nprint(nested.index(4))\n\n# Finding in nested structure\nfor i, item in enumerate(nested):\n    if isinstance(item, list) and item == [2, 3]:\n        print(f\"Found [2, 3] at index {i}\")",
        "explanation": "This example demonstrates how index() works with nested lists and shows an alternative for finding all occurrences.",
        "expected_output": "1\n2\nFound [2, 3] at index 1\nFound [2, 3] at index 3"
      }
    ]
  },
  {
    "name": "index_(str)",
    "module": "str",
    "class_name": "str",
    "return_type": "int",
    "parameters": [
      {
        "name": "sub",
        "type": "str"
      },
      {
        "name": "start",
        "type": "int",
        "default": "0"
      },
      {
        "name": "end",
        "type": "int",
        "default": "None"
      }
    ],
    "docstring": "Return the lowest index where the substring is found.",
    "decorators": [],
    "main_category": "String Operations",
    "sub_category": "Searching",
    "data_type_manipulated": ["str"],
    "version_added": "1.0",
    "deprecated": false,
    "extended_description": "The index() method returns the lowest index in the string where the substring is found. If the substring is not found, it raises a ValueError. Optional start and end parameters can be used to limit the search to a specific slice of the string. The search is performed from left to right.",
    "return_value": "Returns an integer representing the lowest index where the substring is found.",
    "parameter_values": "sub: The substring to search for in the string. start: Optional starting index for the search (default is 0). end: Optional ending index for the search (default is None, which means the end of the string).",
    "function_signature": "str.index(sub: str, start: int = 0, end: int = None) -> int",
    "related_functions": [
      "str.find()",
      "str.rindex()",
      "str.count()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "text = \"Python is awesome\"\nprint(text.index('is'))\nprint(text.index('e'))",
        "explanation": "This example shows finding the index of substrings in the string.",
        "expected_output": "7\n16"
      },
      {
        "title": "Using start and end parameters",
        "code": "text = \"Python is awesome and Python is powerful\"\nprint(text.index('Python', 10))  # Start searching from index 10\nprint(text.index('is', 10, 30))  # Search between index 10 (inclusive) and 30 (exclusive)",
        "explanation": "This example demonstrates using start and end parameters to limit the search range.",
        "expected_output": "25\n28"
      },
      {
        "title": "Handling ValueError",
        "code": "text = \"Hello, World!\"\ntry:\n    print(text.index('Python'))\nexcept ValueError as e:\n    print(f\"ValueError: {e}\")\n\ntry:\n    print(text.index('o', 8))\nexcept ValueError as e:\n    print(f\"ValueError: {e}\")",
        "explanation": "This example shows the ValueError raised when the substring is not found in the string or within the specified range.",
        "expected_output": "ValueError: substring not found\nValueError: substring not found"
      },
      {
        "title": "Case Sensitivity and Whitespace",
        "code": "text = \"  The Quick Brown Fox  \"\nprint(text.index('Quick'))\ntry:\n    print(text.index('quick'))\nexcept ValueError as e:\n    print(f\"ValueError: {e}\")\nprint(text.index(' '))\nprint(text.index(' ', 3))",
        "explanation": "This example demonstrates the case sensitivity of index() and how it handles whitespace.",
        "expected_output": "5\nValueError: substring not found\n0\n3"
      }
    ]
  },
  {
    "name": "add",
    "module": "set",
    "class_name": "set",
    "return_type": "None",
    "parameters": [
      {
        "name": "element",
        "type": "Any"
      }
    ],
    "docstring": "Add an element to the set.",
    "decorators": [],
    "main_category": "Set Operations",
    "sub_category": "Modification",
    "data_type_manipulated": ["set"],
    "version_added": "2.3",
    "deprecated": false,
    "extended_description": "The add() method adds an element to the set if it's not already present. If the element is already in the set, the method does nothing. The element must be hashable (immutable). Sets only store unique elements, so duplicates are automatically eliminated. This method modifies the set in-place and doesn't return a value.",
    "return_value": "This method doesn't return a value (None).",
    "parameter_values": "element: The element to be added to the set. It must be a hashable type.",
    "function_signature": "set.add(element: Any) -> None",
    "related_functions": [
      "set.update()",
      "set.remove()",
      "set.discard()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "s = {1, 2, 3}\ns.add(4)\nprint(s)\ns.add(2)  # Adding an existing element\nprint(s)",
        "explanation": "This example shows adding a new element and attempting to add an existing element.",
        "expected_output": "{1, 2, 3, 4}\n{1, 2, 3, 4}"
      },
      {
        "title": "Adding Different Types",
        "code": "s = set()\ns.add(1)\ns.add('hello')\ns.add((1, 2))\nprint(s)\ntry:\n    s.add([1, 2])\nexcept TypeError as e:\n    print(f\"TypeError: {e}\")",
        "explanation": "This example demonstrates adding elements of different types and shows the error when trying to add an unhashable type.",
        "expected_output": "{1, 'hello', (1, 2)}\nTypeError: unhashable type: 'list'"
      },
      {
        "title": "Using add() in a Loop",
        "code": "s = set()\nfor i in range(5):\n    s.add(i * 2)\nprint(s)",
        "explanation": "This example shows how to use add() in a loop to populate a set.",
        "expected_output": "{0, 2, 4, 6, 8}"
      },
      {
        "title": "Adding Custom Objects",
        "code": "class Person:\n    def __init__(self, name):\n        self.name = name\n    def __hash__(self):\n        return hash(self.name)\n    def __eq__(self, other):\n        return isinstance(other, Person) and self.name == other.name\n    def __repr__(self):\n        return f\"Person('{self.name}')\"\n\ns = set()\ns.add(Person('Alice'))\ns.add(Person('Bob'))\ns.add(Person('Alice'))  # This won't add a duplicate\nprint(s)",
        "explanation": "This example demonstrates adding custom objects to a set, showing how __hash__ and __eq__ methods affect the behavior.",
        "expected_output": "{Person('Alice'), Person('Bob')}"
      }
    ]
  },
  {
    "name": "difference",
    "module": "set",
    "class_name": "set",
    "return_type": "set",
    "parameters": [
      {
        "name": "other",
        "type": "Iterable"
      }
    ],
    "docstring": "Return the difference of two or more sets as a new set.",
    "decorators": [],
    "main_category": "Set Operations",
    "sub_category": "Comparison",
    "data_type_manipulated": ["set"],
    "version_added": "2.3",
    "deprecated": false,
    "extended_description": "The difference() method returns a new set containing elements that are in the original set but not in the specified iterable(s). It can take multiple iterables as arguments. If an element is in the original set and not in any of the specified iterables, it will be included in the result. This method does not modify the original set.",
    "return_value": "Returns a new set containing elements that are in the original set but not in the specified iterable(s).",
    "parameter_values": "other: An iterable (e.g., set, list, tuple) to compare against. Multiple iterables can be provided.",
    "function_signature": "set.difference(*others: Iterable) -> set",
    "related_functions": [
      "set.difference_update()",
      "set.symmetric_difference()",
      "set.__sub__()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "s1 = {1, 2, 3, 4}\ns2 = {3, 4, 5, 6}\nprint(s1.difference(s2))\nprint(s2.difference(s1))",
        "explanation": "This example shows the difference between two sets in both directions.",
        "expected_output": "{1, 2}\n{5, 6}"
      },
      {
        "title": "Multiple Iterables",
        "code": "s1 = {1, 2, 3, 4, 5}\ns2 = {2, 4, 6}\ns3 = {1, 5, 7}\nprint(s1.difference(s2, s3))",
        "explanation": "This example demonstrates using difference() with multiple iterables.",
        "expected_output": "{3}"
      },
      {
        "title": "Using with Different Types",
        "code": "s = {1, 2, 3, 4, 5}\nprint(s.difference([2, 4], (1, 5)))",
        "explanation": "This example shows that difference() can work with different iterable types.",
        "expected_output": "{3}"
      },
      {
        "title": "Difference with Empty Set",
        "code": "s1 = {1, 2, 3}\ns2 = set()\nprint(s1.difference(s2))\nprint(s2.difference(s1))",
        "explanation": "This example illustrates the behavior of difference() with an empty set.",
        "expected_output": "{1, 2, 3}\nset()"
      }
    ]
  },
  {
    "name": "difference_update",
    "module": "set",
    "class_name": "set",
    "return_type": "None",
    "parameters": [
      {
        "name": "other",
        "type": "Iterable"
      }
    ],
    "docstring": "Remove all elements of another set from this set.",
    "decorators": [],
    "main_category": "Set Operations",
    "sub_category": "Modification",
    "data_type_manipulated": ["set"],
    "version_added": "2.3",
    "deprecated": false,
    "extended_description": "The difference_update() method removes all elements from the set that are also present in the specified iterable(s). It can take multiple iterables as arguments. This method modifies the original set in-place and does not return a value. It's equivalent to using the -= operator on sets.",
    "return_value": "This method doesn't return a value (None).",
    "parameter_values": "other: An iterable (e.g., set, list, tuple) to compare against. Multiple iterables can be provided.",
    "function_signature": "set.difference_update(*others: Iterable) -> None",
    "related_functions": [
      "set.difference()",
      "set.update()",
      "set.__isub__()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "s1 = {1, 2, 3, 4, 5}\ns2 = {3, 4, 5, 6}\ns1.difference_update(s2)\nprint(s1)\nprint(s2)  # s2 remains unchanged",
        "explanation": "This example shows how difference_update() modifies the original set.",
        "expected_output": "{1, 2}\n{3, 4, 5, 6}"
      },
      {
        "title": "Multiple Iterables",
        "code": "s = {1, 2, 3, 4, 5, 6}\ns.difference_update({2, 4}, [1, 3], (5,))\nprint(s)",
        "explanation": "This example demonstrates using difference_update() with multiple iterables of different types.",
        "expected_output": "{6}"
      },
      {
        "title": "Equivalent Operation with -=",
        "code": "s1 = {1, 2, 3, 4, 5}\ns2 = {3, 4, 5, 6}\ns1 -= s2\nprint(s1)",
        "explanation": "This example shows the equivalent operation using the -= operator.",
        "expected_output": "{1, 2}"
      },
      {
        "title": "Updating with Empty Set",
        "code": "s = {1, 2, 3}\ns.difference_update(set())\nprint(s)\n\nempty_set = set()\nempty_set.difference_update({1, 2, 3})\nprint(empty_set)",
        "explanation": "This example illustrates the behavior of difference_update() with an empty set.",
        "expected_output": "{1, 2, 3}\nset()"
      }
    ]
  },
  {
    "name": "discard",
    "module": "set",
    "class_name": "set",
    "return_type": "None",
    "parameters": [
      {
        "name": "element",
        "type": "Any"
      }
    ],
    "docstring": "Remove an element from a set if it is a member.",
    "decorators": [],
    "main_category": "Set Operations",
    "sub_category": "Modification",
    "data_type_manipulated": ["set"],
    "version_added": "2.3",
    "deprecated": false,
    "extended_description": "The discard() method removes the specified element from the set if it is present. If the element is not found in the set, no error is raised. This method modifies the set in-place and does not return a value. It's a safer alternative to remove() when you're not sure if the element is in the set.",
    "return_value": "This method doesn't return a value (None).",
    "parameter_values": "element: The element to be removed from the set.",
    "function_signature": "set.discard(element: Any) -> None",
    "related_functions": [
      "set.remove()",
      "set.pop()",
      "set.clear()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "s = {1, 2, 3, 4}\ns.discard(3)\nprint(s)\ns.discard(5)  # No error raised\nprint(s)",
        "explanation": "This example shows how discard() removes an element if present and does nothing if not present.",
        "expected_output": "{1, 2, 4}\n{1, 2, 4}"
      },
      {
        "title": "Comparison with remove()",
        "code": "s = {1, 2, 3}\ns.discard(2)\nprint(s)\ntry:\n    s.remove(4)\nexcept KeyError as e:\n    print(f\"KeyError: {e}\")\ns.discard(4)  # No error\nprint(s)",
        "explanation": "This example compares discard() with remove(), showing how discard() doesn't raise an error for non-existent elements.",
        "expected_output": "{1, 3}\nKeyError: 4\n{1, 3}"
      },
      {
        "title": "Discarding Different Types",
        "code": "s = {1, 'hello', (1, 2)}\ns.discard('hello')\ns.discard((1, 2))\nprint(s)\ns.discard([1, 2])  # Unhashable type, but no error raised\nprint(s)",
        "explanation": "This example demonstrates discarding elements of different types, including unhashable types.",
        "expected_output": "{1}\n{1}"
      },
      {
        "title": "Using discard() in a Loop",
        "code": "s = {1, 2, 3, 4, 5}\nfor i in range(10):\n    s.discard(i)\nprint(s)",
        "explanation": "This example shows how to use discard() in a loop to remove multiple elements safely.",
        "expected_output": "set()"
      }
    ]
  },
  {
    "name": "intersection",
    "module": "set",
    "class_name": "set",
    "return_type": "set",
    "parameters": [
      {
        "name": "other",
        "type": "Iterable"
      }
    ],
    "docstring": "Return the intersection of two sets as a new set.",
    "decorators": [],
    "main_category": "Set Operations",
    "sub_category": "Comparison",
    "data_type_manipulated": ["set"],
    "version_added": "2.3",
    "deprecated": false,
    "extended_description": "The intersection() method returns a new set containing elements that are common to both the original set and the specified iterable(s). It can take multiple iterables as arguments. If an element is present in all sets (the original and all specified iterables), it will be included in the result. This method does not modify the original set.",
    "return_value": "Returns a new set containing elements that are common to the original set and all specified iterables.",
    "parameter_values": "other: An iterable (e.g., set, list, tuple) to intersect with. Multiple iterables can be provided.",
    "function_signature": "set.intersection(*others: Iterable) -> set",
    "related_functions": [
      "set.intersection_update()",
      "set.__and__()",
      "set.issubset()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "s1 = {1, 2, 3, 4}\ns2 = {3, 4, 5, 6}\nprint(s1.intersection(s2))",
        "explanation": "This example shows the intersection of two sets.",
        "expected_output": "{3, 4}"
      },
      {
        "title": "Multiple Iterables",
        "code": "s1 = {1, 2, 3, 4, 5}\ns2 = {2, 4, 6, 8}\ns3 = {3, 4, 5, 6}\nprint(s1.intersection(s2, s3))",
        "explanation": "This example demonstrates using intersection() with multiple iterables.",
        "expected_output": "{4}"
      },
      {
        "title": "Using with Different Types",
        "code": "s = {1, 2, 3, 4, 5}\nprint(s.intersection([2, 4, 6], (1, 3, 5)))",
        "explanation": "This example shows that intersection() can work with different iterable types.",
        "expected_output": "{3}"
      },
      {
        "title": "Intersection with Empty Set",
        "code": "s1 = {1, 2, 3}\ns2 = set()\nprint(s1.intersection(s2))\nprint(s2.intersection(s1))",
        "explanation": "This example illustrates the behavior of intersection() with an empty set.",
        "expected_output": "set()\nset()"
      }
    ]
  },
  {
    "name": "intersection_update",
    "module": "set",
    "class_name": "set",
    "return_type": "None",
    "parameters": [
      {
        "name": "other",
        "type": "Iterable"
      }
    ],
    "docstring": "Update the set with the intersection of itself and another.",
    "decorators": [],
    "main_category": "Set Operations",
    "sub_category": "Modification",
    "data_type_manipulated": ["set"],
    "version_added": "2.3",
    "deprecated": false,
    "extended_description": "The intersection_update() method updates the set, keeping only elements found in it and all specified iterables. It can take multiple iterables as arguments. This method modifies the original set in-place and does not return a value. It's equivalent to using the &= operator on sets.",
    "return_value": "This method doesn't return a value (None).",
    "parameter_values": "other: An iterable (e.g., set, list, tuple) to intersect with. Multiple iterables can be provided.",
    "function_signature": "set.intersection_update(*others: Iterable) -> None",
    "related_functions": [
      "set.intersection()",
      "set.update()",
      "set.__iand__()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "s1 = {1, 2, 3, 4, 5}\ns2 = {3, 4, 5, 6, 7}\ns1.intersection_update(s2)\nprint(s1)\nprint(s2)  # s2 remains unchanged",
        "explanation": "This example shows how intersection_update() modifies the original set.",
        "expected_output": "{3, 4, 5}\n{3, 4, 5, 6, 7}"
      },
      {
        "title": "Multiple Iterables",
        "code": "s = {1, 2, 3, 4, 5, 6}\ns.intersection_update({2, 4, 6}, [1, 2, 3], (2, 3, 5))\nprint(s)",
        "explanation": "This example demonstrates using intersection_update() with multiple iterables of different types.",
        "expected_output": "{2}"
      },
      {
        "title": "Equivalent Operation with &=",
        "code": "s1 = {1, 2, 3, 4, 5}\ns2 = {3, 4, 5, 6, 7}\ns1 &= s2\nprint(s1)",
        "explanation": "This example shows the equivalent operation using the &= operator.",
        "expected_output": "{3, 4, 5}"
      },
      {
        "title": "Updating with Empty Set",
        "code": "s = {1, 2, 3}\ns.intersection_update(set())\nprint(s)\n\nempty_set = set()\nempty_set.intersection_update({1, 2, 3})\nprint(empty_set)",
        "explanation": "This example illustrates the behavior of intersection_update() with an empty set.",
        "expected_output": "set()\nset()"
      }
    ]
  },
  {
    "name": "isdisjoint",
    "module": "set",
    "class_name": "set",
    "return_type": "bool",
    "parameters": [
      {
        "name": "other",
        "type": "Iterable"
      }
    ],
    "docstring": "Return True if two sets have a null intersection.",
    "decorators": [],
    "main_category": "Set Operations",
    "sub_category": "Comparison",
    "data_type_manipulated": ["set"],
    "version_added": "2.6",
    "deprecated": false,
    "extended_description": "The isdisjoint() method returns True if the set has no elements in common with the specified iterable. It returns False otherwise. Two sets are considered disjoint if their intersection is the empty set. This method is more efficient than computing the intersection first and then testing for emptiness.",
    "return_value": "Returns a boolean value: True if the sets are disjoint, False otherwise.",
    "parameter_values": "other: An iterable (e.g., set, list, tuple) to check for disjointness.",
    "function_signature": "set.isdisjoint(other: Iterable) -> bool",
    "related_functions": [
      "set.intersection()",
      "set.issubset()",
      "set.issuperset()"
    ],
    "examples": [
      {
        "title": "Basic Usage",
        "code": "s1 = {1, 2, 3}\ns2 = {4, 5, 6}\ns3 = {3, 4, 5}\nprint(s1.isdisjoint(s2))\nprint(s1.isdisjoint(s3))",
        "explanation": "This example shows isdisjoint() with disjoint and non-disjoint sets.",
        "expected_output": "True\nFalse"
      },
      {
        "title": "Using with Different Types",
        "code": "s = {1, 2, 3}\nprint(s.isdisjoint([4, 5, 6]))\nprint(s.isdisjoint('hello'))\nprint(s.isdisjoint('123'))",
        "explanation": "This example demonstrates using isdisjoint() with different iterable types.",
        "expected_output": "True\nTrue\nFalse"
      },
      {
        "title": "Empty Set Behavior",
        "code": "s = {1, 2, 3}\nempty_set = set()\nprint(s.isdisjoint(empty_set))\nprint(empty_set.isdisjoint(s))\nprint(empty_set.isdisjoint(empty_set))",
        "explanation": "This example shows how isdisjoint() behaves with empty sets.",
        "expected_output": "True\nTrue\nTrue"
      },
      {
        "title": "Using isdisjoint() in Conditional Statements",
        "code": "def process_sets(set1, set2):\n    if set1.isdisjoint(set2):\n        return \"Sets are disjoint\"\n    else:\n        return f\"Sets have {len(set1.intersection(set2))} elements in common\"\n\nprint(process_sets({1, 2, 3}, {4, 5, 6}))\nprint(process_sets({1, 2, 3}, {3, 4, 5}))",
        "explanation": "This example demonstrates a practical use of isdisjoint() in a function.",
        "expected_output": "Sets are disjoint\nSets have 1 elements in common"
      }
    ]
  },
  
    {
      "name": "issubset",
      "module": "set",
      "class_name": "set",
      "return_type": "bool",
      "parameters": [
        {
          "name": "other",
          "type": "Iterable",
          "description": "The iterable to check against this set"
        }
      ],
      "docstring": "Report whether another set contains this set.",
      "extended_description": "The issubset() method checks if all elements of the calling set are present in the specified iterable. It returns True if every element in the set is in the iterable, and False otherwise. This method is equivalent to the <= operator for sets.",
      "decorators": [],
      "main_category": "Set Operations",
      "sub_category": "Comparison",
      "data_type_manipulated": ["set"],
      "version_added": "2.3",
      "deprecated": false,
      "method_signature": "set.issubset(other)",
      "return_value": "Returns True if the set is a subset of the specified iterable, False otherwise.",
      "related_methods": ["issuperset", "isdisjoint", "__le__", "__lt__"],
      "examples": [
        {
          "title": "Basic Usage",
          "code": "s1 = {1, 2}\ns2 = {1, 2, 3}\nprint(s1.issubset(s2))  # Outputs: True\nprint(s2.issubset(s1))  # Outputs: False",
          "explanation": "This example demonstrates the basic usage of issubset(). s1 is a subset of s2, but s2 is not a subset of s1.",
          "expected_output": "True\nFalse"
        },
        {
          "title": "Empty Set",
          "code": "empty_set = set()\nany_set = {1, 2, 3}\nprint(empty_set.issubset(any_set))  # Outputs: True\nprint(any_set.issubset(empty_set))  # Outputs: False",
          "explanation": "An empty set is a subset of any set, including itself. However, no non-empty set is a subset of an empty set.",
          "expected_output": "True\nFalse"
        },
        {
          "title": "Using with Different Iterable Types",
          "code": "set1 = {1, 2, 3}\nlist1 = [1, 2, 3, 4]\ntuple1 = (1, 2)\nprint(set1.issubset(list1))  # Outputs: True\nprint(set1.issubset(tuple1))  # Outputs: False",
          "explanation": "issubset() can be used with any iterable, not just sets. Here we demonstrate its use with a list and a tuple.",
          "expected_output": "True\nFalse"
        },
        {
          "title": "Comparison with Other Set Operations",
          "code": "set1 = {1, 2, 3}\nset2 = {1, 2, 3, 4}\nprint(set1.issubset(set2))  # Using issubset()\nprint(set1 <= set2)  # Using <= operator\nprint(set1 < set2)  # Using < operator (strict subset)",
          "explanation": "This example shows how issubset() relates to the <= and < operators. Note that < checks for a strict subset (proper subset).",
          "expected_output": "True\nTrue\nTrue"
        },
        {
          "title": "Error Handling",
          "code": "try:\n    set1 = {1, 2, 3}\n    set1.issubset(42)\nexcept TypeError as e:\n    print(f\"Error: {e}\")",
          "explanation": "This example shows what happens when you try to use issubset() with a non-iterable argument.",
          "expected_output": "Error: 'int' object is not iterable"
        }
      ],
      "performance_considerations": "The time complexity of issubset() is O(len(self)) in the average case, where 'self' is the calling set. This is because it needs to check each element of the calling set against the other iterable.",
      "common_pitfalls": "Be cautious when using issubset() with large datasets, as it can be computationally expensive. Also, remember that while issubset() works with any iterable, the performance may vary depending on the type of the iterable passed."
    },
    {
      "name": "issuperset",
      "module": "set",
      "class_name": "set",
      "return_type": "bool",
      "parameters": [
        {
          "name": "other",
          "type": "Iterable",
          "description": "The iterable to check against this set"
        }
      ],
      "docstring": "Report whether this set contains another set.",
      "extended_description": "The issuperset() method checks if the set contains all elements of the specified iterable. It returns True if every element in the iterable is in the set, and False otherwise. This method is equivalent to the >= operator for sets.",
      "decorators": [],
      "main_category": "Set Operations",
      "sub_category": "Comparison",
      "data_type_manipulated": ["set"],
      "version_added": "2.3",
      "deprecated": false,
      "method_signature": "set.issuperset(other)",
      "return_value": "Returns True if the set is a superset of the specified iterable, False otherwise.",
      "related_methods": ["issubset", "isdisjoint", "__ge__", "__gt__"],
      "examples": [
        {
          "title": "Basic Usage",
          "code": "s1 = {1, 2, 3}\ns2 = {1, 2}\nprint(s1.issuperset(s2))  # Outputs: True\nprint(s2.issuperset(s1))  # Outputs: False",
          "explanation": "This example demonstrates the basic usage of issuperset(). s1 is a superset of s2, but s2 is not a superset of s1.",
          "expected_output": "True\nFalse"
        },
        {
          "title": "Empty Set",
          "code": "empty_set = set()\nany_set = {1, 2, 3}\nprint(any_set.issuperset(empty_set))  # Outputs: True\nprint(empty_set.issuperset(any_set))  # Outputs: False",
          "explanation": "Any set is a superset of an empty set, including the empty set itself. However, an empty set is not a superset of any non-empty set.",
          "expected_output": "True\nFalse"
        },
        {
          "title": "Using with Different Iterable Types",
          "code": "set1 = {1, 2, 3, 4}\nlist1 = [1, 2, 3]\ntuple1 = (1, 2, 3, 4, 5)\nprint(set1.issuperset(list1))  # Outputs: True\nprint(set1.issuperset(tuple1))  # Outputs: False",
          "explanation": "issuperset() can be used with any iterable, not just sets. Here we demonstrate its use with a list and a tuple.",
          "expected_output": "True\nFalse"
        },
        {
          "title": "Comparison with Other Set Operations",
          "code": "set1 = {1, 2, 3, 4}\nset2 = {1, 2, 3}\nprint(set1.issuperset(set2))  # Using issuperset()\nprint(set1 >= set2)  # Using >= operator\nprint(set1 > set2)  # Using > operator (strict superset)",
          "explanation": "This example shows how issuperset() relates to the >= and > operators. Note that > checks for a strict superset (proper superset).",
          "expected_output": "True\nTrue\nTrue"
        },
        {
          "title": "Error Handling",
          "code": "try:\n    set1 = {1, 2, 3}\n    set1.issuperset(42)\nexcept TypeError as e:\n    print(f\"Error: {e}\")",
          "explanation": "This example shows what happens when you try to use issuperset() with a non-iterable argument.",
          "expected_output": "Error: 'int' object is not iterable"
        }
      ],
      "performance_considerations": "The time complexity of issuperset() is O(len(other)) in the average case, where 'other' is the specified iterable. This is because it needs to check each element of the iterable against the set.",
      "common_pitfalls": "Be aware that while issuperset() works with any iterable, the performance may vary depending on the type of the iterable passed. Also, remember that a set is always a superset of itself."
    },
    
        {
          "name": "remove_(set)",
          "module": "set",
          "class_name": "set",
          "return_type": "None",
          "parameters": [
            {
              "name": "element",
              "type": "Any",
              "description": "The element to be removed from the set"
            }
          ],
          "docstring": "Remove an element from a set; it must be a member.",
          "extended_description": "The remove() method removes the specified element from the set. If the element is not present in the set, it raises a KeyError. This method directly modifies the set and does not return any value.",
          "decorators": [],
          "main_category": "Set Operations",
          "sub_category": "Modification",
          "data_type_manipulated": ["set"],
          "version_added": "2.3",
          "deprecated": false,
          "method_signature": "set.remove(element)",
          "return_value": "This method doesn't return a value. It modifies the set in-place.",
          "related_methods": ["discard", "pop", "clear"],
          "examples": [
            {
              "title": "Basic Usage",
              "code": "s = {1, 2, 3}\ns.remove(2)\nprint(s)  # Outputs: {1, 3}",
              "explanation": "This example demonstrates the basic usage of remove(). The element 2 is removed from the set.",
              "expected_output": "{1, 3}"
            },
            {
              "title": "Removing Non-existent Element",
              "code": "s = {1, 2, 3}\ntry:\n    s.remove(4)\nexcept KeyError as e:\n    print(f\"Error: {e}\")",
              "explanation": "This example shows what happens when you try to remove an element that doesn't exist in the set.",
              "expected_output": "Error: 4"
            },
            {
              "title": "Removing from an Empty Set",
              "code": "s = set()\ntry:\n    s.remove(1)\nexcept KeyError as e:\n    print(f\"Error: {e}\")",
              "explanation": "Attempting to remove an element from an empty set will always raise a KeyError.",
              "expected_output": "Error: 1"
            },
            {
              "title": "Removing Multiple Elements",
              "code": "s = {1, 2, 3, 4, 5}\nelements_to_remove = [2, 4]\nfor elem in elements_to_remove:\n    s.remove(elem)\nprint(s)",
              "explanation": "This example shows how to remove multiple elements from a set using a loop.",
              "expected_output": "{1, 3, 5}"
            }
          ],
          "performance_considerations": "The time complexity of remove() is O(1) on average. However, in the worst case (due to hash collisions), it can be O(n), where n is the number of elements in the set.",
          "common_pitfalls": "Be cautious when using remove() in a loop, as it modifies the set during iteration, which can lead to unexpected behavior. Consider using a list of elements to remove or the set's copy if you need to remove multiple elements in a loop."
        },
        {
          "name": "remove_(list)",
          "module": "list",
          "class_name": "list",
          "return_type": "None",
          "parameters": [
            {
              "name": "element",
              "type": "Any",
              "description": "The element to be removed from the list"
            }
          ],
          "docstring": "Remove the first occurrence of a value in the list.",
          "extended_description": "The remove() method removes the first occurrence of the specified element from the list. If the element is not present in the list, it raises a ValueError. This method directly modifies the list and does not return any value.",
          "decorators": [],
          "main_category": "List Operations",
          "sub_category": "Modification",
          "data_type_manipulated": ["list"],
          "version_added": "1.0",
          "deprecated": false,
          "method_signature": "list.remove(element)",
          "return_value": "This method doesn't return a value. It modifies the list in-place.",
          "related_methods": ["pop", "clear", "del"],
          "examples": [
            {
              "title": "Basic Usage",
              "code": "lst = [1, 2, 3, 2]\nlst.remove(2)\nprint(lst)  # Outputs: [1, 3, 2]",
              "explanation": "This example demonstrates the basic usage of remove(). The first occurrence of 2 is removed from the list.",
              "expected_output": "[1, 3, 2]"
            },
            {
              "title": "Removing Non-existent Element",
              "code": "lst = [1, 2, 3]\ntry:\n    lst.remove(4)\nexcept ValueError as e:\n    print(f\"Error: {e}\")",
              "explanation": "This example shows what happens when you try to remove an element that doesn't exist in the list.",
              "expected_output": "Error: list.remove(x): x not in list"
            },
            {
              "title": "Removing from an Empty List",
              "code": "lst = []\ntry:\n    lst.remove(1)\nexcept ValueError as e:\n    print(f\"Error: {e}\")",
              "explanation": "Attempting to remove an element from an empty list will always raise a ValueError.",
              "expected_output": "Error: list.remove(x): x not in list"
            },
            {
              "title": "Removing Multiple Occurrences",
              "code": "lst = [1, 2, 3, 2, 4, 2, 5]\nwhile 2 in lst:\n    lst.remove(2)\nprint(lst)",
              "explanation": "This example shows how to remove all occurrences of an element from a list using a while loop.",
              "expected_output": "[1, 3, 4, 5]"
            }
          ],
          "performance_considerations": "The time complexity of remove() is O(n), where n is the number of elements in the list, as it may need to search through the entire list to find the element to remove.",
          "common_pitfalls": "Be careful when using remove() in a loop to remove multiple elements, as it changes the list's size and indices during iteration. Consider using a list comprehension or creating a new list instead for such operations."
        },

    {
        "name": "symmetric_difference",
        "module": "set",
        "class_name": "set",
        "return_type": "set",
        "parameters": [
        {
            "name": "other",
            "type": "Iterable",
            "description": "The iterable to compare with the set"
        }
        ],
        "docstring": "Return the symmetric difference of two sets as a new set.",
        "extended_description": "The symmetric_difference() method returns a new set containing elements that are in either the set or the specified iterable, but not in both. It's equivalent to the ^ operator for sets.",
        "decorators": [],
        "main_category": "Set Operations",
        "sub_category": "Comparison",
        "data_type_manipulated": ["set"],
        "version_added": "2.3",
        "deprecated": false,
        "method_signature": "set.symmetric_difference(other)",
        "return_value": "Returns a new set containing elements in either the set or the iterable but not both.",
        "related_methods": ["symmetric_difference_update", "difference", "union"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s1 = {1, 2, 3}\ns2 = {3, 4, 5}\nsym_diff = s1.symmetric_difference(s2)\nprint(sym_diff)  # Outputs: {1, 2, 4, 5}",
            "explanation": "This example demonstrates the basic usage of symmetric_difference(). The resulting set contains elements that are in either s1 or s2, but not in both.",
            "expected_output": "{1, 2, 4, 5}"
        },
        {
            "title": "Using with Different Iterable Types",
            "code": "s = {1, 2, 3}\nlist1 = [3, 4, 5]\nresult = s.symmetric_difference(list1)\nprint(result)",
            "explanation": "symmetric_difference() can be used with any iterable, not just sets.",
            "expected_output": "{1, 2, 4, 5}"
        },
        {
            "title": "Symmetric Difference with Empty Set",
            "code": "s = {1, 2, 3}\nempty_set = set()\nresult = s.symmetric_difference(empty_set)\nprint(result)",
            "explanation": "The symmetric difference of a set with an empty set is the original set itself.",
            "expected_output": "{1, 2, 3}"
        },
        {
            "title": "Chaining Symmetric Differences",
            "code": "s1 = {1, 2, 3}\ns2 = {3, 4, 5}\ns3 = {5, 6, 7}\nresult = s1.symmetric_difference(s2).symmetric_difference(s3)\nprint(result)",
            "explanation": "This example shows how to chain multiple symmetric_difference() operations.",
            "expected_output": "{1, 2, 3, 4, 6, 7}"
        }
        ],
        "performance_considerations": "The time complexity is O(len(self) + len(other)) for the average case. However, the worst-case scenario (due to hash collisions) can be O(len(self) * len(other)).",
        "common_pitfalls": "Remember that symmetric_difference() returns a new set and doesn't modify the original set. If you want to modify the original set, use symmetric_difference_update() instead."
    },
    {
        "name": "symmetric_difference_update",
        "module": "set",
        "class_name": "set",
        "return_type": "None",
        "parameters": [
        {
            "name": "other",
            "type": "Iterable",
            "description": "The iterable to compare with the set"
        }
        ],
        "docstring": "Update a set with the symmetric difference of itself and another.",
        "extended_description": "The symmetric_difference_update() method updates the set, keeping only elements found in either the set or the specified iterable, but not in both. It's equivalent to the ^= operator for sets.",
        "decorators": [],
        "main_category": "Set Operations",
        "sub_category": "Modification",
        "data_type_manipulated": ["set"],
        "version_added": "2.3",
        "deprecated": false,
        "method_signature": "set.symmetric_difference_update(other)",
        "return_value": "This method doesn't return a value. It modifies the set in-place.",
        "related_methods": ["symmetric_difference", "difference_update", "update"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s1 = {1, 2, 3}\ns2 = {3, 4, 5}\ns1.symmetric_difference_update(s2)\nprint(s1)  # Outputs: {1, 2, 4, 5}",
            "explanation": "This example demonstrates the basic usage of symmetric_difference_update(). The set s1 is modified to contain elements that are in either s1 or s2, but not in both.",
            "expected_output": "{1, 2, 4, 5}"
        },
        {
            "title": "Using with Different Iterable Types",
            "code": "s = {1, 2, 3}\nlist1 = [3, 4, 5]\ns.symmetric_difference_update(list1)\nprint(s)",
            "explanation": "symmetric_difference_update() can be used with any iterable, not just sets.",
            "expected_output": "{1, 2, 4, 5}"
        },
        {
            "title": "Updating with Empty Set",
            "code": "s = {1, 2, 3}\nempty_set = set()\ns.symmetric_difference_update(empty_set)\nprint(s)",
            "explanation": "Updating a set with the symmetric difference of an empty set doesn't change the original set.",
            "expected_output": "{1, 2, 3}"
        },
        {
            "title": "Chaining Updates",
            "code": "s = {1, 2, 3}\ns.symmetric_difference_update({3, 4, 5})\ns.symmetric_difference_update({5, 6, 7})\nprint(s)",
            "explanation": "This example shows how to chain multiple symmetric_difference_update() operations.",
            "expected_output": "{1, 2, 4, 6, 7}"
        }
        ],
        "performance_considerations": "The time complexity is O(len(self) + len(other)) for the average case. However, the worst-case scenario (due to hash collisions) can be O(len(self) * len(other)).",
        "common_pitfalls": "Be aware that this method modifies the original set. If you need to keep the original set unchanged, use symmetric_difference() instead."
    },
    {
        "name": "union",
        "module": "set",
        "class_name": "set",
        "return_type": "set",
        "parameters": [
        {
            "name": "other",
            "type": "Iterable",
            "description": "The iterable to union with the set"
        }
        ],
        "docstring": "Return the union of sets as a new set.",
        "extended_description": "The union() method returns a new set containing all unique elements from the set and the specified iterable. It's equivalent to the | operator for sets.",
        "decorators": [],
        "main_category": "Set Operations",
        "sub_category": "Comparison",
        "data_type_manipulated": ["set"],
        "version_added": "2.3",
        "deprecated": false,
        "method_signature": "set.union(*others)",
        "return_value": "Returns a new set containing all unique elements from the set and the specified iterables.",
        "related_methods": ["update", "intersection", "difference"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s1 = {1, 2, 3}\ns2 = {3, 4, 5}\nunion = s1.union(s2)\nprint(union)  # Outputs: {1, 2, 3, 4, 5}",
            "explanation": "This example demonstrates the basic usage of union(). The resulting set contains all unique elements from both s1 and s2.",
            "expected_output": "{1, 2, 3, 4, 5}"
        },
        {
            "title": "Union with Multiple Iterables",
            "code": "s = {1, 2, 3}\nlist1 = [3, 4, 5]\ntuple1 = (5, 6, 7)\nresult = s.union(list1, tuple1)\nprint(result)",
            "explanation": "union() can take multiple arguments and works with different iterable types.",
            "expected_output": "{1, 2, 3, 4, 5, 6, 7}"
        },
        {
            "title": "Union with Empty Set",
            "code": "s = {1, 2, 3}\nempty_set = set()\nresult = s.union(empty_set)\nprint(result)",
            "explanation": "The union of a set with an empty set is the original set itself.",
            "expected_output": "{1, 2, 3}"
        },
        {
            "title": "Using Union Operator",
            "code": "s1 = {1, 2, 3}\ns2 = {3, 4, 5}\ns3 = {5, 6, 7}\nresult = s1 | s2 | s3\nprint(result)",
            "explanation": "This example shows how to use the | operator to perform union operations.",
            "expected_output": "{1, 2, 3, 4, 5, 6, 7}"
        }
        ],
        "performance_considerations": "The time complexity is O(len(self) + sum(len(other) for other in others)) for the average case. The union operation is generally faster than performing individual add() operations for each element.",
        "common_pitfalls": "Remember that union() returns a new set and doesn't modify the original set. If you want to modify the original set, use update() instead."
    },
    
        {
          "name": "update",
          "module": "set",
          "class_name": "set",
          "return_type": "None",
          "parameters": [
            {
              "name": "other",
              "type": "Iterable",
              "description": "The iterable(s) to update the set with"
            }
          ],
          "docstring": "Update a set with the union of itself and others.",
          "extended_description": "The update() method updates the set, adding elements from all specified iterables. It's equivalent to the |= operator for sets, but can take multiple iterables.",
          "decorators": [],
          "main_category": "Set Operations",
          "sub_category": "Modification",
          "data_type_manipulated": ["set"],
          "version_added": "2.3",
          "deprecated": false,
          "method_signature": "set.update(*others)",
          "return_value": "This method doesn't return a value. It modifies the set in-place.",
          "related_methods": ["union", "add", "extend"],
          "examples": [
            {
              "title": "Basic Usage",
              "code": "s1 = {1, 2, 3}\ns2 = {3, 4, 5}\ns1.update(s2)\nprint(s1)  # Outputs: {1, 2, 3, 4, 5}",
              "explanation": "This example demonstrates the basic usage of update(). The set s1 is modified to include all elements from s2.",
              "expected_output": "{1, 2, 3, 4, 5}"
            },
            {
              "title": "Updating with Multiple Iterables",
              "code": "s = {1, 2, 3}\nlist1 = [3, 4, 5]\ntuple1 = (5, 6, 7)\ns.update(list1, tuple1)\nprint(s)",
              "explanation": "update() can take multiple arguments and works with different iterable types.",
              "expected_output": "{1, 2, 3, 4, 5, 6, 7}"
            },
            {
              "title": "Updating with Empty Iterable",
              "code": "s = {1, 2, 3}\nempty_list = []\ns.update(empty_list)\nprint(s)",
              "explanation": "Updating a set with an empty iterable doesn't change the original set.",
              "expected_output": "{1, 2, 3}"
            },
            {
              "title": "Using Update Operator",
              "code": "s1 = {1, 2, 3}\ns2 = {3, 4, 5}\ns1 |= s2\nprint(s1)",
              "explanation": "This example shows how to use the |= operator to perform the update operation.",
              "expected_output": "{1, 2, 3, 4, 5}"
            }
          ],
          "performance_considerations": "The time complexity is O(len(self) + sum(len(other) for other in others)) for the average case. update() is generally faster than adding elements one by one using add().",
          "common_pitfalls": "Be aware that this method modifies the original set. If you need to keep the original set unchanged, use union() instead to create a new set."
        },
        {
          "name": "close",
          "module": "io",
          "class_name": "TextIOWrapper",
          "return_type": "None",
          "parameters": [],
          "docstring": "Close the file. A closed file cannot be read or written any more.",
          "extended_description": "The close() method closes the file and frees up any system resources taken up by the open file. After calling close(), attempts to read from or write to the file will raise a ValueError.",
          "decorators": [],
          "main_category": "File Operations",
          "sub_category": "Management",
          "data_type_manipulated": ["file"],
          "version_added": "1.5",
          "deprecated": false,
          "method_signature": "file.close()",
          "return_value": "This method doesn't return a value.",
          "related_methods": ["open", "flush", "read", "write"],
          "examples": [
            {
              "title": "Basic Usage",
              "code": "f = open('example.txt', 'r')\nf.close()",
              "explanation": "This example demonstrates the basic usage of close(). The file is opened and then immediately closed.",
              "expected_output": "No output (file is closed)"
            },
            {
              "title": "Using with Statement",
              "code": "with open('example.txt', 'r') as f:\n    content = f.read()\nprint(f.closed)  # Outputs: True",
              "explanation": "Using a 'with' statement automatically closes the file when exiting the block, even if an exception is raised.",
              "expected_output": "True"
            },
            {
              "title": "Attempting to Use Closed File",
              "code": "f = open('example.txt', 'r')\nf.close()\ntry:\n    f.read()\nexcept ValueError as e:\n    print(f\"Error: {e}\")",
              "explanation": "This example shows what happens when you try to read from a closed file.",
              "expected_output": "Error: I/O operation on closed file."
            }
          ],
          "performance_considerations": "Closing a file is generally a quick operation, but it's important to close files to free up system resources and ensure all data is written to disk.",
          "common_pitfalls": "Forgetting to close files can lead to resource leaks. Always close files when you're done with them, or use a 'with' statement to ensure they're closed automatically."
        },
        {
          "name": "fileno",
          "module": "io",
          "class_name": "TextIOWrapper",
          "return_type": "int",
          "parameters": [],
          "docstring": "Return the underlying file descriptor (an integer).",
          "extended_description": "The fileno() method returns the file descriptor number for the file. File descriptors are small, non-negative integers used to represent opened files in UNIX-like systems.",
          "decorators": [],
          "main_category": "File Operations",
          "sub_category": "Information",
          "data_type_manipulated": ["file"],
          "version_added": "1.5",
          "deprecated": false,
          "method_signature": "file.fileno()",
          "return_value": "Returns an integer representing the file descriptor.",
          "related_methods": ["open", "isatty", "seekable"],
          "examples": [
            {
              "title": "Basic Usage",
              "code": "f = open('example.txt', 'r')\nprint(f.fileno())\nf.close()",
              "explanation": "This example demonstrates the basic usage of fileno(). It prints the file descriptor number for the opened file.",
              "expected_output": "3  # The actual number may vary"
            },
            {
              "title": "Comparing File Descriptors",
              "code": "f1 = open('example1.txt', 'r')\nf2 = open('example2.txt', 'r')\nprint(f1.fileno() != f2.fileno())\nf1.close()\nf2.close()",
              "explanation": "This example shows that different files have different file descriptors.",
              "expected_output": "True"
            },
            {
              "title": "Using fileno with sys.stdin",
              "code": "import sys\nprint(sys.stdin.fileno())\nprint(sys.stdout.fileno())\nprint(sys.stderr.fileno())",
              "explanation": "This example shows the file descriptors for standard input, output, and error streams.",
              "expected_output": "0\n1\n2"
            }
          ],
          "performance_considerations": "fileno() is a lightweight operation and should not have significant performance impact.",
          "common_pitfalls": "The file descriptor returned by fileno() is valid only as long as the file is open. Using it after the file is closed may lead to unexpected results or errors."
        },

    {
        "name": "flush",
        "module": "io",
        "class_name": "TextIOWrapper",
        "return_type": "None",
        "parameters": [],
        "docstring": "Flush the write buffers of the stream if applicable.",
        "extended_description": "The flush() method forces a write of all buffered data to the underlying stream. It's particularly useful when you need to ensure that all data has been written to the file or device, especially before closing the file or when you need the data to be immediately available to other processes.",
        "decorators": [],
        "main_category": "File Operations",
        "sub_category": "Management",
        "data_type_manipulated": ["file"],
        "version_added": "1.5",
        "deprecated": false,
        "method_signature": "file.flush()",
        "return_value": "This method doesn't return a value.",
        "related_methods": ["write", "close", "open"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "f = open('example.txt', 'w')\nf.write('Hello')\nf.flush()\nf.close()",
            "explanation": "This example demonstrates the basic usage of flush(). After writing 'Hello' to the file, flush() is called to ensure the data is written to disk immediately.",
            "expected_output": "No output (file is written and flushed)"
        },
        {
            "title": "Flushing for Immediate Visibility",
            "code": "import os\n\nf = open('example.txt', 'w')\nf.write('Hello')\nf.flush()\n\n# Open the file in another process (simulated here)\nwith open('example.txt', 'r') as f2:\n    print(f2.read())\n\nf.close()",
            "explanation": "This example shows how flush() can be used to make written data immediately visible to other processes or file handles.",
            "expected_output": "Hello"
        },
        {
            "title": "Flushing System Stdout",
            "code": "import sys\n\nsys.stdout.write('Hello')\nsys.stdout.flush()\n# Output appears immediately, even without a newline",
            "explanation": "This example demonstrates flushing the standard output stream, which can be useful for displaying progress indicators or log messages in real-time.",
            "expected_output": "Hello"
        }
        ],
        "performance_considerations": "Frequent flushing can impact performance, especially when writing large amounts of data. It's generally more efficient to let the system handle buffering, except when immediate writing is necessary.",
        "common_pitfalls": "Overuse of flush() can lead to decreased performance. In most cases, you don't need to call flush() explicitly, as Python will flush the buffers when necessary or when the file is closed."
    },
    {
        "name": "isatty",
        "module": "io",
        "class_name": "TextIOWrapper",
        "return_type": "bool",
        "parameters": [],
        "docstring": "Return True if the file is connected to a tty(-like) device.",
        "extended_description": "The isatty() method checks whether the file stream is interactive, typically meaning it's connected to a terminal or console. This can be useful for determining whether a program is being run interactively or if its input/output is being redirected.",
        "decorators": [],
        "main_category": "File Operations",
        "sub_category": "Information",
        "data_type_manipulated": ["file"],
        "version_added": "1.5",
        "deprecated": false,
        "method_signature": "file.isatty()",
        "return_value": "Returns True if the file is connected to a terminal-like device, False otherwise.",
        "related_methods": ["fileno", "seekable", "readable", "writable"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "f = open('example.txt', 'r')\nprint(f.isatty())\nf.close()",
            "explanation": "This example demonstrates the basic usage of isatty(). For a regular file, it will return False.",
            "expected_output": "False"
        },
        {
            "title": "Checking Standard Streams",
            "code": "import sys\n\nprint(f\"stdin isatty: {sys.stdin.isatty()}\")\nprint(f\"stdout isatty: {sys.stdout.isatty()}\")\nprint(f\"stderr isatty: {sys.stderr.isatty()}\")",
            "explanation": "This example checks whether the standard input, output, and error streams are connected to a terminal. The results may vary depending on how the script is run.",
            "expected_output": "stdin isatty: True\nstdout isatty: True\nstderr isatty: True"
        },
        {
            "title": "Using isatty for Conditional Behavior",
            "code": "import sys\n\nif sys.stdout.isatty():\n    print(\"Running in an interactive terminal\")\nelse:\n    print(\"Output is being redirected\")",
            "explanation": "This example shows how isatty() can be used to alter program behavior based on whether it's running in an interactive terminal or not.",
            "expected_output": "Running in an interactive terminal  # or 'Output is being redirected' if the output is piped"
        }
        ],
        "performance_considerations": "isatty() is a lightweight operation and should not have significant performance impact.",
        "common_pitfalls": "The result of isatty() can vary depending on the operating system and how the program is being run. It's not always a reliable way to determine if a program is being run interactively."
    },
    {
        "name": "read",
        "module": "io",
        "class_name": "TextIOWrapper",
        "return_type": "str",
        "parameters": [
        {
            "name": "size",
            "type": "int",
            "default": "-1",
            "description": "The maximum number of characters to read. If negative or None, read until EOF."
        }
        ],
        "docstring": "Read at most size characters from stream. If size is negative or None, read until EOF.",
        "extended_description": "The read() method reads and returns the specified number of characters from the file, or the entire file if size is not specified or is negative. It's important to note that for text files, the number of characters may not correspond exactly to the number of bytes, due to character encoding.",
        "decorators": [],
        "main_category": "File Operations",
        "sub_category": "Reading",
        "data_type_manipulated": ["file"],
        "version_added": "1.5",
        "deprecated": false,
        "method_signature": "file.read(size=-1)",
        "return_value": "Returns a string containing the characters read. Returns an empty string if EOF is hit immediately.",
        "related_methods": ["readline", "readlines", "write"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "f = open('example.txt', 'r')\ncontent = f.read()\nprint(content)\nf.close()",
            "explanation": "This example demonstrates the basic usage of read(). It reads the entire contents of the file.",
            "expected_output": "Contents of example.txt"
        },
        {
            "title": "Reading Specific Number of Characters",
            "code": "f = open('example.txt', 'r')\nfirst_10 = f.read(10)\nprint(first_10)\nf.close()",
            "explanation": "This example reads only the first 10 characters from the file.",
            "expected_output": "First 10 characters of example.txt"
        },
        {
            "title": "Reading in Chunks",
            "code": "f = open('example.txt', 'r')\nchunk = f.read(5)\nwhile chunk:\n    print(chunk, end='')\n    chunk = f.read(5)\nf.close()",
            "explanation": "This example demonstrates how to read a file in chunks, which can be useful for large files.",
            "expected_output": "Contents of example.txt (printed in 5-character chunks)"
        },
        {
            "title": "Handling EOF",
            "code": "f = open('example.txt', 'r')\nf.read()  # Read entire file\nprint(f.read())  # Try to read again\nf.close()",
            "explanation": "This example shows what happens when you try to read from a file after reaching EOF.",
            "expected_output": "  (empty string)"
        }
        ],
        "performance_considerations": "For large files, reading the entire file into memory at once (by not specifying a size) can be memory-intensive. Consider reading in chunks for better memory management with large files.",
        "common_pitfalls": "Remember to close the file after reading. Also, be aware that read() returns an empty string when it reaches EOF, which can be mistaken for an empty file if not handled correctly."
    },
    
    {
        "name": "readable",
        "module": "io",
        "class_name": "TextIOWrapper",
        "return_type": "bool",
        "parameters": [],
        "docstring": "Return True if the file stream can be read from.",
        "extended_description": "The readable() method checks whether the file stream is readable. It returns True if the stream can be read from, and False otherwise. This is useful for determining if operations like read() or readline() can be performed on the file.",
        "decorators": [],
        "main_category": "File Operations",
        "sub_category": "Information",
        "data_type_manipulated": ["file"],
        "version_added": "2.6",
        "deprecated": false,
        "method_signature": "file.readable()",
        "return_value": "Returns True if the file is readable, False otherwise.",
        "related_methods": ["writable", "seekable", "isatty"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "f = open('example.txt', 'r')\nprint(f.readable())\nf.close()",
            "explanation": "This example demonstrates the basic usage of readable(). For a file opened in read mode, it will return True.",
            "expected_output": "True"
        },
        {
            "title": "Checking Write-Only File",
            "code": "f = open('example.txt', 'w')\nprint(f.readable())\nf.close()",
            "explanation": "This example shows that a file opened in write-only mode is not readable.",
            "expected_output": "False"
        },
        {
            "title": "Checking Standard Streams",
            "code": "import sys\n\nprint(f\"stdin readable: {sys.stdin.readable()}\")\nprint(f\"stdout readable: {sys.stdout.readable()}\")\nprint(f\"stderr readable: {sys.stderr.readable()}\")",
            "explanation": "This example checks the readability of standard input, output, and error streams.",
            "expected_output": "stdin readable: True\nstdout readable: False\nstderr readable: False"
        }
        ],
        "performance_considerations": "readable() is a lightweight operation and should not have significant performance impact.",
        "common_pitfalls": "Remember that a file being readable doesn't guarantee that there's content to read. It only indicates that read operations are allowed on the file stream."
    },
    {
        "name": "readline",
        "module": "io",
        "class_name": "TextIOWrapper",
        "return_type": "str",
        "parameters": [
        {
            "name": "size",
            "type": "int",
            "default": "-1",
            "description": "The maximum number of characters/bytes to read. If negative or None, read until newline or EOF."
        }
        ],
        "docstring": "Read until newline or EOF and return a single line of text.",
        "extended_description": "The readline() method reads a single line from the file stream. A line is defined as a sequence of characters terminated by a newline ('\\n') or EOF. If a size argument is provided, it reads at most size characters.",
        "decorators": [],
        "main_category": "File Operations",
        "sub_category": "Reading",
        "data_type_manipulated": ["file"],
        "version_added": "1.5",
        "deprecated": false,
        "method_signature": "file.readline(size=-1)",
        "return_value": "Returns a string containing the line read. Returns an empty string if EOF is hit immediately.",
        "related_methods": ["read", "readlines", "write"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "f = open('example.txt', 'r')\nline = f.readline()\nprint(line)\nf.close()",
            "explanation": "This example demonstrates the basic usage of readline(). It reads and prints the first line of the file.",
            "expected_output": "First line of example.txt"
        },
        {
            "title": "Reading Multiple Lines",
            "code": "f = open('example.txt', 'r')\nfor i in range(3):\n    line = f.readline()\n    print(f\"Line {i+1}: {line.strip()}\")\nf.close()",
            "explanation": "This example reads and prints the first three lines of the file.",
            "expected_output": "Line 1: [content of first line]\nLine 2: [content of second line]\nLine 3: [content of third line]"
        },
        {
            "title": "Using Size Parameter",
            "code": "f = open('example.txt', 'r')\npart_line = f.readline(5)\nprint(part_line)\nf.close()",
            "explanation": "This example reads only the first 5 characters of the first line.",
            "expected_output": "First"
        },
        {
            "title": "Handling EOF",
            "code": "f = open('example.txt', 'r')\nwhile True:\n    line = f.readline()\n    if not line:\n        break\n    print(line.strip())\nf.close()",
            "explanation": "This example demonstrates how to read all lines until EOF is reached.",
            "expected_output": "[All lines of the file, one per line]"
        }
        ],
        "performance_considerations": "readline() is more memory-efficient than read() when dealing with large files line by line, as it doesn't load the entire file into memory.",
        "common_pitfalls": "Remember that readline() includes the newline character at the end of each line. Use strip() or rstrip() to remove it if needed. Also, be aware that an empty string is returned when EOF is reached."
    },
    {
        "name": "readlines",
        "module": "io",
        "class_name": "TextIOWrapper",
        "return_type": "List[str]",
        "parameters": [
        {
            "name": "hint",
            "type": "int",
            "default": "-1",
            "description": "If specified, reads until approximately hint bytes have been read. Actual number may exceed this due to line boundaries."
        }
        ],
        "docstring": "Read and return a list of lines from the stream.",
        "extended_description": "The readlines() method reads all the lines of a file and returns them as a list of strings. Each string in the list represents a single line from the file, including the newline character. If a hint is specified, it reads approximately that many bytes before returning the list.",
        "decorators": [],
        "main_category": "File Operations",
        "sub_category": "Reading",
        "data_type_manipulated": ["file"],
        "version_added": "1.5",
        "deprecated": false,
        "method_signature": "file.readlines(hint=-1)",
        "return_value": "Returns a list of strings, each representing a line from the file.",
        "related_methods": ["read", "readline", "writelines"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "f = open('example.txt', 'r')\nlines = f.readlines()\nprint(lines)\nf.close()",
            "explanation": "This example demonstrates the basic usage of readlines(). It reads all lines from the file into a list.",
            "expected_output": "['line1\\n', 'line2\\n', 'line3\\n']"
        },
        {
            "title": "Using Hint Parameter",
            "code": "f = open('example.txt', 'r')\npartial_lines = f.readlines(15)\nprint(partial_lines)\nf.close()",
            "explanation": "This example uses the hint parameter to read approximately 15 bytes worth of lines.",
            "expected_output": "['line1\\n', 'line2\\n']  # Assuming each line is shorter than 15 bytes"
        },
        {
            "title": "Processing Lines",
            "code": "f = open('example.txt', 'r')\nlines = f.readlines()\nfor i, line in enumerate(lines, 1):\n    print(f\"Line {i}: {line.strip()}\")\nf.close()",
            "explanation": "This example shows how to process each line after reading them all.",
            "expected_output": "Line 1: [content of first line]\nLine 2: [content of second line]\n..."
        },
        {
            "title": "Memory-Efficient Reading",
            "code": "with open('example.txt', 'r') as f:\n    for line in f:  # This is more memory-efficient than readlines() for large files\n        print(line.strip())",
            "explanation": "This example demonstrates a more memory-efficient way to read lines from a large file.",
            "expected_output": "[All lines of the file, one per line]"
        }
        ],
        "performance_considerations": "readlines() reads the entire file into memory, which can be inefficient for very large files. For large files, it's often better to iterate over the file object directly.",
        "common_pitfalls": "Be cautious when using readlines() on very large files, as it may consume a lot of memory. Each line in the returned list includes the newline character, so you may need to use strip() when processing the lines."
    },

    {
        "name": "seek",
        "module": "io",
        "class_name": "TextIOWrapper",
        "return_type": "int",
        "parameters": [
        {
            "name": "offset",
            "type": "int",
            "description": "The number of bytes to move. For text files, only values returned from tell() are safe to use."
        },
        {
            "name": "whence",
            "type": "int",
            "default": "0",
            "description": "The position to seek from. 0 (default) is the start, 1 is the current position, and 2 is the end of the file."
        }
        ],
        "docstring": "Change the stream position to the given byte offset.",
        "extended_description": "The seek() method changes the current file position. For text files, the offset should be a number returned from tell(), or zero. The whence argument is optional and defaults to 0 (absolute file positioning).",
        "decorators": [],
        "main_category": "File Operations",
        "sub_category": "Positioning",
        "data_type_manipulated": ["file"],
        "version_added": "1.5",
        "deprecated": false,
        "method_signature": "file.seek(offset, whence=0)",
        "return_value": "Returns the new absolute position.",
        "related_methods": ["tell", "read", "write"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "f = open('example.txt', 'r')\nf.seek(5)\nprint(f.read())\nf.close()",
            "explanation": "This example moves the file pointer 5 bytes from the beginning and then reads the rest of the file.",
            "expected_output": "Contents of the file starting from the 6th byte"
        },
        {
            "title": "Seeking from Current Position",
            "code": "f = open('example.txt', 'r')\nf.read(3)\nf.seek(5, 1)  # Move 5 bytes forward from current position\nprint(f.read(10))\nf.close()",
            "explanation": "This example demonstrates seeking relative to the current position.",
            "expected_output": "10 characters starting from 8 bytes into the file"
        },
        {
            "title": "Seeking from End of File",
            "code": "f = open('example.txt', 'r')\nf.seek(0, 2)  # Move to the end of the file\nprint(f.tell())  # Print the file size\nf.close()",
            "explanation": "This example shows how to move to the end of the file and get its size.",
            "expected_output": "Size of the file in bytes"
        },
        {
            "title": "Seeking in Binary Mode",
            "code": "f = open('example.bin', 'rb')\nf.seek(10)\nprint(f.read(1))\nf.close()",
            "explanation": "In binary mode, you can seek to any byte position safely.",
            "expected_output": "The 11th byte of the file"
        }
        ],
        "performance_considerations": "seek() is generally fast, but excessive seeking in large files can impact performance. For text files, it's safer and more efficient to use readline() or read() with small chunks instead of seeking to arbitrary positions.",
        "common_pitfalls": "In text mode, only seeks relative to the beginning of the file are guaranteed to work. Seeking to arbitrary positions can lead to incorrect results due to character encoding issues."
    },
    {
        "name": "seekable",
        "module": "io",
        "class_name": "TextIOWrapper",
        "return_type": "bool",
        "parameters": [],
        "docstring": "Return True if the stream supports random access.",
        "extended_description": "The seekable() method checks whether the file stream supports random access. If True, the stream supports seek(), tell(), and truncate() operations. This is useful for determining if you can move around within the file.",
        "decorators": [],
        "main_category": "File Operations",
        "sub_category": "Information",
        "data_type_manipulated": ["file"],
        "version_added": "2.6",
        "deprecated": false,
        "method_signature": "file.seekable()",
        "return_value": "Returns True if the stream supports random access, False otherwise.",
        "related_methods": ["readable", "writable", "seek", "tell"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "f = open('example.txt', 'r')\nprint(f.seekable())\nf.close()",
            "explanation": "This example demonstrates the basic usage of seekable(). For a regular file, it will typically return True.",
            "expected_output": "True"
        },
        {
            "title": "Checking Standard Streams",
            "code": "import sys\n\nprint(f\"stdin seekable: {sys.stdin.seekable()}\")\nprint(f\"stdout seekable: {sys.stdout.seekable()}\")\nprint(f\"stderr seekable: {sys.stderr.seekable()}\")",
            "explanation": "This example checks if standard input, output, and error streams are seekable. Results may vary depending on the system and how the script is run.",
            "expected_output": "stdin seekable: False\nstdout seekable: False\nstderr seekable: False"
        },
        {
            "title": "Checking Network Socket",
            "code": "import socket\n\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nprint(sock.makefile().seekable())\nsock.close()",
            "explanation": "This example shows that network sockets are typically not seekable.",
            "expected_output": "False"
        },
        {
            "title": "Using seekable() for Conditional Operations",
            "code": "def process_file(f):\n    if f.seekable():\n        f.seek(0, 2)  # Go to end of file\n        print(f\"File size: {f.tell()} bytes\")\n        f.seek(0)  # Go back to start\n    else:\n        print(\"File is not seekable\")\n\nwith open('example.txt', 'r') as f:\n    process_file(f)",
            "explanation": "This example demonstrates how to use seekable() to conditionally perform operations that require random access.",
            "expected_output": "File size: [size in bytes]"
        }
        ],
        "performance_considerations": "seekable() is a lightweight operation and should not have significant performance impact.",
        "common_pitfalls": "Even if a file is seekable, certain seek operations might not work as expected, especially in text mode due to character encoding. Always check the documentation for specific limitations."
    },
    {
        "name": "tell",
        "module": "io",
        "class_name": "TextIOWrapper",
        "return_type": "int",
        "parameters": [],
        "docstring": "Return the current stream position.",
        "extended_description": "The tell() method returns the current position of the file read/write pointer within the file. This position represents the number of bytes from the beginning of the file. For text files, the returned value may not represent the exact byte offset due to character encoding.",
        "decorators": [],
        "main_category": "File Operations",
        "sub_category": "Positioning",
        "data_type_manipulated": ["file"],
        "version_added": "1.5",
        "deprecated": false,
        "method_signature": "file.tell()",
        "return_value": "Returns an integer representing the current position of the file pointer.",
        "related_methods": ["seek", "read", "write"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "f = open('example.txt', 'r')\nf.read(5)\nprint(f.tell())\nf.close()",
            "explanation": "This example demonstrates the basic usage of tell(). It reads 5 characters and then prints the current position.",
            "expected_output": "5"
        },
        {
            "title": "Tracking Position While Reading",
            "code": "f = open('example.txt', 'r')\nwhile True:\n    pos = f.tell()\n    line = f.readline()\n    if not line:\n        break\n    print(f\"Line at position {pos}: {line.strip()}\")\nf.close()",
            "explanation": "This example shows how to use tell() to track the position of each line in a file.",
            "expected_output": "Line at position 0: [content of first line]\nLine at position [n]: [content of next line]\n..."
        },
        {
            "title": "Using tell() with seek()",
            "code": "f = open('example.txt', 'r')\nstart_pos = f.tell()\nf.read(10)\nmid_pos = f.tell()\nf.seek(start_pos)\nprint(f\"Start: {start_pos}, After reading 10 chars: {mid_pos}\")\nf.close()",
            "explanation": "This example demonstrates using tell() in conjunction with seek() to navigate within a file.",
            "expected_output": "Start: 0, After reading 10 chars: 10"
        },
        {
            "title": "tell() in Binary Mode",
            "code": "f = open('example.bin', 'rb')\nf.read(1)\nprint(f.tell())\nf.close()",
            "explanation": "In binary mode, tell() always returns the exact byte position.",
            "expected_output": "1"
        }
        ],
        "performance_considerations": "tell() is generally a fast operation. However, for very large files, frequent calls to tell() might have a slight performance impact.",
        "common_pitfalls": "In text mode, the value returned by tell() may not represent the exact byte offset due to character encoding and line ending translations. It's safest to use this value only with seek() on the same file object."
    },

    {
        "name": "truncate",
        "module": "io",
        "class_name": "TextIOWrapper",
        "return_type": "int",
        "parameters": [
        {
            "name": "size",
            "type": "int",
            "default": "None",
            "description": "The size to truncate the file to. If not specified, truncates to the current position."
        }
        ],
        "docstring": "Resize the stream to the given size in bytes (or the current position if size is not specified).",
        "extended_description": "The truncate() method resizes the file to the given size. If size is not specified, it truncates the file at the current position. This method can be used to shrink or extend the size of the file. If extended, the contents of the new file area are undefined.",
        "decorators": [],
        "main_category": "File Operations",
        "sub_category": "Modification",
        "data_type_manipulated": ["file"],
        "version_added": "1.5",
        "deprecated": false,
        "method_signature": "file.truncate(size=None)",
        "return_value": "Returns the new size of the file.",
        "related_methods": ["seek", "tell", "write"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "with open('example.txt', 'r+') as f:\n    f.truncate(10)\n    print(f.tell())",
            "explanation": "This example truncates the file to 10 bytes. The file pointer remains at the end of the file.",
            "expected_output": "10"
        },
        {
            "title": "Truncate at Current Position",
            "code": "with open('example.txt', 'r+') as f:\n    f.seek(5)\n    f.truncate()\n    print(f.tell())",
            "explanation": "This example moves the file pointer to position 5 and then truncates the file at that position.",
            "expected_output": "5"
        },
        {
            "title": "Extending File Size",
            "code": "with open('example.txt', 'r+') as f:\n    original_size = f.seek(0, 2)\n    f.truncate(original_size + 10)\n    print(f.tell())",
            "explanation": "This example extends the file size by 10 bytes. The new area will contain undefined data.",
            "expected_output": "[original_size + 10]"
        },
        {
            "title": "Truncate and Write",
            "code": "with open('example.txt', 'r+') as f:\n    f.truncate(0)  # Clear the file\n    f.write('New content')\n    print(f.tell())",
            "explanation": "This example clears the file by truncating to size 0, then writes new content.",
            "expected_output": "11"
        }
        ],
        "performance_considerations": "truncate() is generally fast, but may have performance implications on very large files or when frequently resizing files.",
        "common_pitfalls": "Be cautious when using truncate(), as it can lead to data loss if used incorrectly. Always ensure you have the correct file permissions. In text mode, the size might not exactly match the number of characters due to encoding."
    },
    {
        "name": "writable",
        "module": "io",
        "class_name": "TextIOWrapper",
        "return_type": "bool",
        "parameters": [],
        "docstring": "Return True if the stream supports writing.",
        "extended_description": "The writable() method checks whether the file stream supports writing operations. It returns True if write operations can be performed on the stream, and False otherwise. This is useful for determining if you can write to the file without raising an exception.",
        "decorators": [],
        "main_category": "File Operations",
        "sub_category": "Information",
        "data_type_manipulated": ["file"],
        "version_added": "2.6",
        "deprecated": false,
        "method_signature": "file.writable()",
        "return_value": "Returns True if the stream is writable, False otherwise.",
        "related_methods": ["readable", "seekable", "write"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "with open('example.txt', 'w') as f:\n    print(f.writable())",
            "explanation": "This example demonstrates the basic usage of writable(). For a file opened in write mode, it will return True.",
            "expected_output": "True"
        },
        {
            "title": "Checking Read-Only File",
            "code": "with open('example.txt', 'r') as f:\n    print(f.writable())",
            "explanation": "This example shows that a file opened in read-only mode is not writable.",
            "expected_output": "False"
        },
        {
            "title": "Checking Standard Streams",
            "code": "import sys\n\nprint(f\"stdin writable: {sys.stdin.writable()}\")\nprint(f\"stdout writable: {sys.stdout.writable()}\")\nprint(f\"stderr writable: {sys.stderr.writable()}\")",
            "explanation": "This example checks the writability of standard input, output, and error streams.",
            "expected_output": "stdin writable: False\nstdout writable: True\nstderr writable: True"
        },
        {
            "title": "Using writable() for Conditional Operations",
            "code": "def write_data(f, data):\n    if f.writable():\n        f.write(data)\n        print(\"Data written successfully\")\n    else:\n        print(\"File is not writable\")\n\nwith open('example.txt', 'r') as f:\n    write_data(f, 'Hello')\n\nwith open('example.txt', 'w') as f:\n    write_data(f, 'Hello')",
            "explanation": "This example demonstrates how to use writable() to conditionally perform write operations.",
            "expected_output": "File is not writable\nData written successfully"
        }
        ],
        "performance_considerations": "writable() is a lightweight operation and should not have significant performance impact.",
        "common_pitfalls": "Remember that a file being writable doesn't guarantee successful writes. Other factors like disk space or permissions can still cause write operations to fail."
    },
    {
        "name": "write",
        "module": "io",
        "class_name": "TextIOWrapper",
        "return_type": "int",
        "parameters": [
        {
            "name": "s",
            "type": "str",
            "description": "The string to be written to the file"
        }
        ],
        "docstring": "Write string s to the stream and return the number of characters written.",
        "extended_description": "The write() method writes the specified string to the file stream. It returns the number of characters written. In text mode, the string is encoded before writing. The file must be opened in a write mode ('w', 'a', or 'r+').",
        "decorators": [],
        "main_category": "File Operations",
        "sub_category": "Writing",
        "data_type_manipulated": ["file"],
        "version_added": "1.5",
        "deprecated": false,
        "method_signature": "file.write(s)",
        "return_value": "Returns an integer representing the number of characters written.",
        "related_methods": ["writelines", "read", "tell"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "with open('example.txt', 'w') as f:\n    n = f.write('Hello, World!')\n    print(n)",
            "explanation": "This example demonstrates the basic usage of write(). It writes a string to the file and prints the number of characters written.",
            "expected_output": "13"
        },
        {
            "title": "Appending to a File",
            "code": "with open('example.txt', 'a') as f:\n    f.write('First line\\n')\n    f.write('Second line\\n')\n\nwith open('example.txt', 'r') as f:\n    print(f.read())",
            "explanation": "This example shows how to append multiple lines to a file using write().",
            "expected_output": "First line\nSecond line\n"
        },
        {
            "title": "Writing Non-ASCII Characters",
            "code": "with open('example.txt', 'w', encoding='utf-8') as f:\n    n = f.write('Hello, ä¸–ç•Œ!')\n    print(n)\n\nwith open('example.txt', 'r', encoding='utf-8') as f:\n    print(f.read())",
            "explanation": "This example demonstrates writing and reading non-ASCII characters using a specific encoding.",
            "expected_output": "9\nHello, ä¸–ç•Œ!"
        },
        {
            "title": "Writing to a Binary File",
            "code": "with open('example.bin', 'wb') as f:\n    n = f.write(b'\\x48\\x65\\x6c\\x6c\\x6f')\n    print(n)\n\nwith open('example.bin', 'rb') as f:\n    print(f.read())",
            "explanation": "This example shows how to write binary data to a file.",
            "expected_output": "5\nb'Hello'"
        }
        ],
        "performance_considerations": "For better performance when writing large amounts of data, consider using a buffer or writing in chunks. Frequent small writes can be inefficient.",
        "common_pitfalls": "Remember to open the file in write mode before calling write(). In text mode, write() may not immediately write to disk due to buffering. Use flush() or close() to ensure all data is written. Be cautious of encoding issues when writing non-ASCII characters."
    },

    {
        "name": "writelines",
        "module": "io",
        "class_name": "TextIOWrapper",
        "return_type": "None",
        "parameters": [
        {
            "name": "lines",
            "type": "List[str]",
            "description": "A list of strings to be written to the file"
        }
        ],
        "docstring": "Write a list of lines to the stream. Line separators are not added.",
        "extended_description": "The writelines() method writes a sequence of strings to the file. Unlike its name might suggest, it doesn't add line separators automatically. If you want each string to be on a new line, you need to add the newline characters yourself. This method is more efficient than calling write() multiple times for a sequence of strings.",
        "decorators": [],
        "main_category": "File Operations",
        "sub_category": "Writing",
        "data_type_manipulated": ["file"],
        "version_added": "1.5",
        "deprecated": false,
        "method_signature": "file.writelines(lines)",
        "return_value": "This method doesn't return a value.",
        "related_methods": ["write", "readlines"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "with open('example.txt', 'w') as f:\n    f.writelines(['Line 1\\n', 'Line 2\\n', 'Line 3\\n'])\n\nwith open('example.txt', 'r') as f:\n    print(f.read())",
            "explanation": "This example demonstrates the basic usage of writelines(). It writes a list of strings to the file, each ending with a newline character.",
            "expected_output": "Line 1\nLine 2\nLine 3\n"
        },
        {
            "title": "Writing Without Line Separators",
            "code": "with open('example.txt', 'w') as f:\n    f.writelines(['Hello', 'World', '!'])\n\nwith open('example.txt', 'r') as f:\n    print(f.read())",
            "explanation": "This example shows that writelines() doesn't add line separators automatically.",
            "expected_output": "HelloWorld!"
        },
        {
            "title": "Using List Comprehension",
            "code": "lines = ['apple', 'banana', 'cherry']\nwith open('example.txt', 'w') as f:\n    f.writelines(line + '\\n' for line in lines)\n\nwith open('example.txt', 'r') as f:\n    print(f.read())",
            "explanation": "This example uses a list comprehension to add newline characters to each item before writing.",
            "expected_output": "apple\nbanana\ncherry\n"
        },
        {
            "title": "Writing Non-String Iterables",
            "code": "numbers = [1, 2, 3, 4, 5]\nwith open('example.txt', 'w') as f:\n    f.writelines(str(num) + '\\n' for num in numbers)\n\nwith open('example.txt', 'r') as f:\n    print(f.read())",
            "explanation": "This example shows how to write non-string iterables by converting each item to a string.",
            "expected_output": "1\n2\n3\n4\n5\n"
        }
        ],
        "performance_considerations": "writelines() is generally more efficient than multiple write() calls for a sequence of strings. However, for very large lists, consider writing in chunks to manage memory usage.",
        "common_pitfalls": "Remember that writelines() doesn't add newline characters automatically. If you want each string on a new line, you need to add '\\n' yourself. Also, ensure all elements in the input sequence are strings, or convert them to strings before calling writelines()."
    },
    {
        "name": "append",
        "module": "list",
        "class_name": "list",
        "return_type": "None",
        "parameters": [
        {
            "name": "object",
            "type": "Any",
            "description": "The object to be appended to the end of the list"
        }
        ],
        "docstring": "Add an item to the end of the list.",
        "extended_description": "The append() method adds a single item to the end of the list. It modifies the list in-place and doesn't return a new list. The time complexity of this operation is O(1) on average, making it an efficient way to add elements to a list.",
        "decorators": [],
        "main_category": "List Operations",
        "sub_category": "Modification",
        "data_type_manipulated": ["list"],
        "version_added": "1.0",
        "deprecated": false,
        "method_signature": "list.append(object)",
        "return_value": "This method doesn't return a value. It modifies the list in-place.",
        "related_methods": ["extend", "insert", "remove"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "lst = [1, 2, 3]\nlst.append(4)\nprint(lst)",
            "explanation": "This example demonstrates the basic usage of append(). It adds the integer 4 to the end of the list.",
            "expected_output": "[1, 2, 3, 4]"
        },
        {
            "title": "Appending Different Data Types",
            "code": "lst = [1, 'two', 3.0]\nlst.append([4, 5])\nprint(lst)",
            "explanation": "This example shows that you can append any data type to a list, including another list.",
            "expected_output": "[1, 'two', 3.0, [4, 5]]"
        },
        {
            "title": "Appending in a Loop",
            "code": "squares = []\nfor i in range(5):\n    squares.append(i**2)\nprint(squares)",
            "explanation": "This example demonstrates how to use append() in a loop to build a list of squares.",
            "expected_output": "[0, 1, 4, 9, 16]"
        },
        {
            "title": "Appending vs Extending",
            "code": "lst1 = [1, 2, 3]\nlst2 = [4, 5]\nlst1.append(lst2)\nprint(lst1)\n\nlst3 = [1, 2, 3]\nlst3.extend(lst2)\nprint(lst3)",
            "explanation": "This example shows the difference between append() and extend(). append() adds the entire object as a single element, while extend() adds each element of the iterable.",
            "expected_output": "[1, 2, 3, [4, 5]]\n[1, 2, 3, 4, 5]"
        }
        ],
        "performance_considerations": "append() has a time complexity of O(1) on average, making it very efficient for adding single elements to the end of a list. For adding multiple elements, consider using extend() instead.",
        "common_pitfalls": "Be careful not to confuse append() with extend(). append([1, 2]) will add the entire list as a single element, not individual elements. If you want to add multiple elements, use extend() or the += operator instead."
    },
    {
        "name": "extend",
        "module": "list",
        "class_name": "list",
        "return_type": "None",
        "parameters": [
          {
            "name": "iterable",
            "type": "Iterable",
            "description": "An iterable object whose elements will be added to the end of the list"
          }
        ],
        "docstring": "Extend the list by appending all the items from the iterable.",
        "extended_description": "The extend() method adds all elements from the given iterable to the end of the list. It modifies the list in-place and doesn't return a new list. This method is more efficient than using multiple append() calls or concatenation when adding multiple elements.",
        "decorators": [],
        "main_category": "List Operations",
        "sub_category": "Modification",
        "data_type_manipulated": ["list"],
        "version_added": "1.0",
        "deprecated": false,
        "method_signature": "list.extend(iterable)",
        "return_value": "This method doesn't return a value. It modifies the list in-place.",
        "related_methods": ["append", "insert", "+= operator"],
        "examples": [
          {
            "title": "Basic Usage",
            "code": "lst = [1, 2, 3]\nlst.extend([4, 5])\nprint(lst)",
            "explanation": "This example demonstrates the basic usage of extend(). It adds all elements from the [4, 5] list to the end of lst.",
            "expected_output": "[1, 2, 3, 4, 5]"
          },
          {
            "title": "Extending with Different Iterable Types",
            "code": "lst = [1, 2, 3]\nlst.extend((4, 5))  # Tuple\nprint(lst)\nlst.extend('abc')  # String\nprint(lst)",
            "explanation": "This example shows that extend() works with different types of iterables, including tuples and strings.",
            "expected_output": "[1, 2, 3, 4, 5]\n[1, 2, 3, 4, 5, 'a', 'b', 'c']"
          },
          {
            "title": "Extending vs Appending",
            "code": "lst1 = [1, 2, 3]\nlst2 = [4, 5]\nlst1.extend(lst2)\nprint(lst1)\n\nlst3 = [1, 2, 3]\nlst3.append(lst2)\nprint(lst3)",
            "explanation": "This example illustrates the difference between extend() and append(). extend() adds each element individually, while append() adds the entire object as a single element.",
            "expected_output": "[1, 2, 3, 4, 5]\n[1, 2, 3, [4, 5]]"
          },
          {
            "title": "Using extend() with Generator Expression",
            "code": "lst = [1, 2, 3]\nlst.extend(x**2 for x in range(3))\nprint(lst)",
            "explanation": "This example demonstrates using extend() with a generator expression, which can be memory-efficient for large datasets.",
            "expected_output": "[1, 2, 3, 0, 1, 4]"
          }
        ],
        "performance_considerations": "extend() is generally more efficient than using multiple append() calls or repeated concatenation when adding multiple elements. It has a time complexity of O(k), where k is the number of elements in the iterable being added.",
        "common_pitfalls": "Remember that extend() modifies the original list in-place. If you need a new list, use the + operator or list concatenation instead. Also, be cautious when extending a list with itself, as it can lead to unexpected results due to the in-place modification."
      },
      {
        "name": "insert",
        "module": "list",
        "class_name": "list",
        "return_type": "None",
        "parameters": [
          {
            "name": "index",
            "type": "int",
            "description": "The index at which the object is to be inserted. The item is inserted before this index."
          },
          {
            "name": "object",
            "type": "Any",
            "description": "The object to be inserted into the list"
          }
        ],
        "docstring": "Insert an item at a given position.",
        "extended_description": "The insert() method adds an item to the list at a specified position. It modifies the list in-place and doesn't return a new list. The index specifies where the new element should be inserted, and all elements after this position are shifted to the right.",
        "decorators": [],
        "main_category": "List Operations",
        "sub_category": "Modification",
        "data_type_manipulated": ["list"],
        "version_added": "1.0",
        "deprecated": false,
        "method_signature": "list.insert(index, object)",
        "return_value": "This method doesn't return a value. It modifies the list in-place.",
        "related_methods": ["append", "extend", "remove"],
        "examples": [
          {
            "title": "Basic Usage",
            "code": "lst = [1, 2, 3]\nlst.insert(1, 4)\nprint(lst)",
            "explanation": "This example demonstrates the basic usage of insert(). It adds the element 4 at index 1, shifting the existing elements to the right.",
            "expected_output": "[1, 4, 2, 3]"
          },
          {
            "title": "Inserting at the Beginning",
            "code": "lst = [1, 2, 3]\nlst.insert(0, 'start')\nprint(lst)",
            "explanation": "This example shows how to insert an element at the beginning of the list.",
            "expected_output": "['start', 1, 2, 3]"
          },
          {
            "title": "Inserting at the End",
            "code": "lst = [1, 2, 3]\nlst.insert(len(lst), 'end')\nprint(lst)",
            "explanation": "This example demonstrates inserting an element at the end of the list, which is equivalent to using append().",
            "expected_output": "[1, 2, 3, 'end']"
          },
          {
            "title": "Inserting with Negative Index",
            "code": "lst = [1, 2, 3]\nlst.insert(-1, 'before last')\nprint(lst)",
            "explanation": "This example shows how negative indices work with insert(). The element is inserted before the item at the specified negative index.",
            "outputexpected_output": "[1, 2, 'before last', 3]"
          },
          {
            "title": "Inserting Beyond List Bounds",
            "code": "lst = [1, 2, 3]\nlst.insert(100, 'far')\nprint(lst)",
            "explanation": "This example demonstrates what happens when you try to insert at an index beyond the list's length. The item is simply appended to the end.",
            "expected_output": "[1, 2, 3, 'far']"
          }
        ],
        "performance_considerations": "insert() has a time complexity of O(n), where n is the number of elements in the list, because it may need to shift all elements after the insertion point. For frequent insertions at the beginning of large lists, consider using collections.deque which offers O(1) performance for this operation.",
        "common_pitfalls": "Remember that insert() modifies the list in-place. If you need to insert multiple items, multiple insert() calls can be inefficient - consider creating a new list or using slice assignment instead. Also, be aware that inserting at the beginning of a large list can be slow due to the need to shift all other elements."
      },
      
        {
          "name": "reverse",
          "module": "list",
          "class_name": "list",
          "return_type": "None",
          "parameters": [],
          "docstring": "Reverse the elements of the list in place.",
          "extended_description": "The reverse() method reverses the order of the elements in the list. It modifies the list in-place and doesn't return a new list. This operation is done in linear time.",
          "decorators": [],
          "main_category": "List Operations",
          "sub_category": "Modification",
          "data_type_manipulated": ["list"],
          "version_added": "1.0",
          "deprecated": false,
          "method_signature": "list.reverse()",
          "return_value": "This method doesn't return a value. It modifies the list in-place.",
          "related_methods": ["reversed", "sort"],
          "examples": [
            {
              "title": "Basic Usage",
              "code": "lst = [1, 2, 3]\nlst.reverse()\nprint(lst)",
              "explanation": "This example demonstrates the basic usage of reverse(). It reverses the order of elements in the list.",
              "expected_output": "[3, 2, 1]"
            },
            {
              "title": "Reversing a List with Different Data Types",
              "code": "lst = [1, 'a', True, 3.14]\nlst.reverse()\nprint(lst)",
              "explanation": "This example shows that reverse() works with lists containing different data types.",
              "expected_output": "[3.14, True, 'a', 1]"
            },
            {
              "title": "Reversing an Empty List",
              "code": "lst = []\nlst.reverse()\nprint(lst)",
              "explanation": "This example demonstrates that reversing an empty list has no effect.",
              "expected_output": "[]"
            },
            {
              "title": "Reverse vs Reversed",
              "code": "lst = [1, 2, 3]\nreversed_iter = reversed(lst)\nprint(list(reversed_iter))\nprint(lst)",
              "explanation": "This example shows the difference between reverse() and reversed(). reversed() returns an iterator and doesn't modify the original list.",
              "expected_output": "[3, 2, 1]\n[1, 2, 3]"
            }
          ],
          "performance_considerations": "reverse() has a time complexity of O(n), where n is the number of elements in the list. It's an in-place operation, so it's memory-efficient.",
          "common_pitfalls": "Remember that reverse() modifies the list in-place. If you need a reversed copy without modifying the original list, use reversed() or a slice with a step of -1 (e.g., lst[::-1])."
        },
        {
          "name": "sort",
          "module": "list",
          "class_name": "list",
          "return_type": "None",
          "parameters": [
            {
              "name": "key",
              "type": "Optional[Callable]",
              "default": "None",
              "description": "A function that serves as a key for the sort comparison"
            },
            {
              "name": "reverse",
              "type": "bool",
              "default": "False",
              "description": "If True, sort the list in descending order"
            }
          ],
          "docstring": "Sort the list in ascending order and return None.",
          "extended_description": "The sort() method sorts the elements of a list in place. By default, it sorts in ascending order. It uses the Timsort algorithm, which is a hybrid sorting algorithm derived from merge sort and insertion sort, designed to perform well on many kinds of real-world data.",
          "decorators": [],
          "main_category": "List Operations",
          "sub_category": "Sorting",
          "data_type_manipulated": ["list"],
          "version_added": "1.0",
          "deprecated": false,
          "method_signature": "list.sort(key=None, reverse=False)",
          "return_value": "This method doesn't return a value. It modifies the list in-place.",
          "related_methods": ["sorted", "reverse"],
          "examples": [
            {
              "title": "Basic Usage",
              "code": "lst = [3, 1, 4, 1, 5, 9, 2]\nlst.sort()\nprint(lst)",
              "explanation": "This example demonstrates the basic usage of sort(). It sorts the list in ascending order.",
              "expected_output": "[1, 1, 2, 3, 4, 5, 9]"
            },
            {
              "title": "Sorting in Descending Order",
              "code": "lst = [3, 1, 4, 1, 5, 9, 2]\nlst.sort(reverse=True)\nprint(lst)",
              "explanation": "This example shows how to sort a list in descending order using the reverse parameter.",
              "expected_output": "[9, 5, 4, 3, 2, 1, 1]"
            },
            {
              "title": "Sorting with a Key Function",
              "code": "lst = ['apple', 'banana', 'cherry', 'date']\nlst.sort(key=len)\nprint(lst)",
              "explanation": "This example demonstrates sorting using a key function. Here, we sort the list based on the length of each string.",
              "expected_output": "['date', 'apple', 'banana', 'cherry']"
            },
            {
              "title": "Sorting Complex Objects",
              "code": "class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\npeople = [Person('Alice', 30), Person('Bob', 25), Person('Charlie', 35)]\npeople.sort(key=lambda p: p.age)\nprint([p.name for p in people])",
              "explanation": "This example shows how to sort a list of custom objects using a lambda function as the key.",
              "expected_output": "['Bob', 'Alice', 'Charlie']"
            }
          ],
          "performance_considerations": "sort() has a time complexity of O(n log n), where n is the number of elements in the list. It's an in-place operation, which makes it memory-efficient for large lists.",
          "common_pitfalls": "Remember that sort() modifies the list in-place. If you need a sorted copy without modifying the original list, use the sorted() function instead. Also, be cautious when sorting lists with mixed types, as it can lead to unexpected results or errors."
        },
        {
          "name": "capitalize",
          "module": "builtins",
          "class_name": "str",
          "data_structure": "string",
          "return_type": "str",
          "parameters": [],
          "docstring": "Return a capitalized version of the string.",
          "extended_description": "The capitalize() method returns a copy of the string with its first character capitalized and the rest lowercased. This method doesn't modify the original string, as strings are immutable in Python.",
          "decorators": [],
          "main_category": "String Operations",
          "sub_category": "Case Conversion",
          "data_type_manipulated": ["string"],
          "version_added": "1.0",
          "deprecated": false,
          "method_signature": "str.capitalize()",
          "return_value": "Returns a new string with the first character capitalized and the rest lowercased.",
          "related_methods": ["title", "upper", "lower"],
          "examples": [
            {
              "title": "Basic Usage",
              "code": "s = 'hello'\nprint(s.capitalize())",
              "explanation": "This example demonstrates the basic usage of capitalize(). It capitalizes the first letter of the string.",
              "expected_output": "'Hello'"
            },
            {
              "title": "Effect on Mixed Case Strings",
              "code": "s = 'hELLO wORLD'\nprint(s.capitalize())",
              "explanation": "This example shows that capitalize() lowercases all characters except the first one.",
              "expected_output": "'Hello world'"
            },
            {
              "title": "Capitalizing Non-Letter First Character",
              "code": "s = '123abc'\nprint(s.capitalize())",
              "explanation": "This example demonstrates that if the first character is not a letter, it remains unchanged.",
              "expected_output": "'123abc'"
            },
            {
              "title": "Effect on Empty String",
              "code": "s = ''\nprint(s.capitalize())",
              "explanation": "This example shows that capitalizing an empty string returns an empty string.",
              "expected_output": "''"
            }
          ],
          "performance_considerations": "capitalize() has a time complexity of O(n), where n is the length of the string. It creates a new string, so it uses additional memory proportional to the length of the string.",
          "common_pitfalls": "Remember that capitalize() only affects the first character of the string. It's not the same as title(), which capitalizes the first character of each word. Also, it doesn't modify the original string, so you need to assign the result to a variable if you want to keep it."
        },
        
    {
        "name": "casefold",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "str",
        "parameters": [],
        "docstring": "Return a casefolded copy of the string.",
        "extended_description": "The casefold() method returns a casefolded copy of the string, which is a more aggressive form of lowercasing. It's primarily used for caseless matching. Casefolding is similar to lowercasing but more thorough, as it's designed to remove all case distinctions in a string. For most use cases, lowercase() is sufficient, but casefold() can be useful when dealing with certain Unicode characters.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Case Conversion",
        "data_type_manipulated": ["string"],
        "version_added": "3.3",
        "deprecated": false,
        "method_signature": "str.casefold()",
        "return_value": "Returns a new string with all characters casefolded.",
        "related_methods": ["lower", "upper", "swapcase"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = 'Hello'\nprint(s.casefold())",
            "explanation": "This example demonstrates the basic usage of casefold(). It converts all characters to lowercase.",
            "expected_output": "'hello'"
        },
        {
            "title": "Casefold vs Lowercase",
            "code": "s = 'ÃŸ'\nprint(f\"Lowercase: {s.lower()}\")\nprint(f\"Casefold: {s.casefold()}\")",
            "explanation": "This example shows the difference between casefold() and lower() for the German eszett character.",
            "expected_output": "Lowercase: ÃŸ\nCasefold: ss"
        },
        {
            "title": "Casefold for Unicode",
            "code": "s = 'StraÃŸe'\nprint(s.casefold())",
            "explanation": "This example demonstrates casefolding a string with a Unicode character.",
            "expected_output": "'strasse'"
        },
        {
            "title": "Caseless Comparison",
            "code": "s1 = 'GROSS'\ns2 = 'groÃŸ'\nprint(s1.casefold() == s2.casefold())",
            "explanation": "This example shows how casefold() can be used for caseless comparison of strings.",
            "expected_output": "True"
        }
        ],
        "performance_considerations": "casefold() has a time complexity of O(n), where n is the length of the string. It creates a new string, so it uses additional memory proportional to the length of the string.",
        "common_pitfalls": "While casefold() is more thorough than lower(), it's not always necessary and can be slower. Use it when you specifically need its Unicode-aware casefolding capabilities, otherwise lower() is usually sufficient."
    },
    {
        "name": "center",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "str",
        "parameters": [
        {
            "name": "width",
            "type": "int",
            "description": "The total width of the resulting string"
        },
        {
            "name": "fillchar",
            "type": "str",
            "default": "' '",
            "description": "The character to pad the string with"
        }
        ],
        "docstring": "Return a centered string of length width.",
        "extended_description": "The center() method returns a new string padded with specified characters (spaces by default) to make it centered within a string of specified width. If the specified width is less than or equal to the length of the string, the original string is returned.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Formatting",
        "data_type_manipulated": ["string"],
        "version_added": "1.0",
        "deprecated": false,
        "method_signature": "str.center(width[, fillchar])",
        "return_value": "Returns a new string of specified width with the original string centered.",
        "related_methods": ["ljust", "rjust", "zfill"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = 'hello'\nprint(s.center(10, '-'))",
            "explanation": "This example demonstrates the basic usage of center(). It centers 'hello' in a string of width 10, padding with '-'.",
            "expected_output": "'--hello---'"
        },
        {
            "title": "Centering with Default Padding",
            "code": "s = 'python'\nprint(s.center(10))",
            "explanation": "This example shows centering with the default padding character (space).",
            "expected_output": "'  python  '"
        },
        {
            "title": "Centering with Odd Width",
            "code": "s = 'odd'\nprint(s.center(7, '*'))",
            "explanation": "This example demonstrates centering when the width is odd and the string length is odd.",
            "expected_output": "'**odd**'"
        },
        {
            "title": "Width Smaller Than String Length",
            "code": "s = 'long string'\nprint(s.center(5))",
            "explanation": "This example shows what happens when the specified width is less than the string length.",
            "expected_output": "'long string'"
        }
        ],
        "performance_considerations": "center() has a time complexity of O(n), where n is the width specified. It creates a new string, so it uses additional memory proportional to the specified width.",
        "common_pitfalls": "Remember that if the specified width is less than or equal to the length of the string, the original string is returned unchanged. Also, the fillchar parameter must be a single character string; using a longer string will raise a TypeError."
    },

    {
        "name": "encode",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "bytes",
        "parameters": [
        {
            "name": "encoding",
            "type": "str",
            "default": "'utf-8'",
            "description": "The encoding to use. The default is UTF-8."
        },
        {
            "name": "errors",
            "type": "str",
            "default": "'strict'",
            "description": "The error handling scheme to use for encoding errors."
        }
        ],
        "docstring": "Return an encoded version of the string as a bytes object.",
        "extended_description": "The encode() method returns an encoded version of the string as a bytes object. By default, it uses UTF-8 encoding. The errors parameter specifies the error handling scheme: 'strict' (default) raises a UnicodeEncodeError for encoding errors, 'ignore' ignores errors, 'replace' replaces errors with a suitable replacement character, and 'xmlcharrefreplace' replaces with the appropriate XML character reference.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Encoding",
        "data_type_manipulated": ["string"],
        "version_added": "2.0",
        "deprecated": false,
        "method_signature": "str.encode(encoding='utf-8', errors='strict')",
        "return_value": "Returns a bytes object representing the encoded string.",
        "related_methods": ["decode", "bytes"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = 'hello'\nprint(s.encode('utf-8'))",
            "explanation": "This example demonstrates the basic usage of encode(). It encodes the string 'hello' using UTF-8 encoding.",
            "expected_output": "b'hello'"
        },
        {
            "title": "Encoding Non-ASCII Characters",
            "code": "s = 'ã“ã‚“ã«ã¡ã¯'\nprint(s.encode('utf-8'))",
            "explanation": "This example shows encoding a string containing non-ASCII characters.",
            "expected_output": "b'\\xe3\\x81\\x93\\xe3\\x82\\x93\\xe3\\x81\\xab\\xe3\\x81\\xa1\\xe3\\x81\\xaf'"
        },
        {
            "title": "Using Different Encodings",
            "code": "s = 'cafÃ©'\nprint(s.encode('ascii', errors='ignore'))\nprint(s.encode('ascii', errors='replace'))",
            "explanation": "This example demonstrates using different error handling schemes when encoding with ASCII, which doesn't support the 'Ã©' character.",
            "expected_output": "b'caf'\nb'caf?'"
        },
        {
            "title": "Handling Encoding Errors",
            "code": "s = 'â‚¬'\ntry:\n    print(s.encode('ascii'))\nexcept UnicodeEncodeError as e:\n    print(f\"Encoding error: {e}\")",
            "explanation": "This example shows what happens when trying to encode a character that's not supported by the specified encoding.",
            "expected_output": "Encoding error: 'ascii' codec can't encode character '\\u20ac' in position 0: ordinal not in range(128)"
        }
        ],
        "performance_considerations": "encode() has a time complexity of O(n), where n is the length of the string. The space complexity depends on the chosen encoding.",
        "common_pitfalls": "Be careful when encoding strings with characters that aren't supported by the chosen encoding. Always handle potential UnicodeEncodeError exceptions when using 'strict' error handling."
    },
    {
        "name": "endswith",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "bool",
        "parameters": [
        {
            "name": "suffix",
            "type": "Union[str, Tuple[str]]",
            "description": "The suffix or tuple of suffixes to check for"
        },
        {
            "name": "start",
            "type": "int",
            "default": "None",
            "description": "The starting position to check from"
        },
        {
            "name": "end",
            "type": "int",
            "default": "None",
            "description": "The ending position to check up to"
        }
        ],
        "docstring": "Return True if the string ends with the specified suffix, False otherwise.",
        "extended_description": "The endswith() method checks if the string ends with the specified suffix. It returns True if the string ends with the specified suffix and False otherwise. If a tuple of suffixes is provided, it returns True if the string ends with any of the suffixes. The optional start and end parameters allow you to check only a slice of the string.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Checking",
        "data_type_manipulated": ["string"],
        "version_added": "2.0",
        "deprecated": false,
        "method_signature": "str.endswith(suffix[, start[, end]])",
        "return_value": "Returns a boolean indicating whether the string ends with the specified suffix.",
        "related_methods": ["startswith", "find", "index"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = 'hello.txt'\nprint(s.endswith('.txt'))",
            "explanation": "This example demonstrates the basic usage of endswith(). It checks if the string ends with '.txt'.",
            "expected_output": "True"
        },
        {
            "title": "Using a Tuple of Suffixes",
            "code": "s = 'image.png'\nprint(s.endswith(('.jpg', '.jpeg', '.png', '.gif')))",
            "explanation": "This example shows how to check for multiple possible suffixes using a tuple.",
            "expected_output": "True"
        },
        {
            "title": "Using Start and End Parameters",
            "code": "s = 'hello.txt'\nprint(s.endswith('lo', 0, 5))",
            "explanation": "This example demonstrates using the start and end parameters to check only a portion of the string.",
            "expected_output": "True"
        },
        {
            "title": "Case Sensitivity",
            "code": "s = 'Hello.TXT'\nprint(s.endswith('.txt'))\nprint(s.lower().endswith('.txt'))",
            "explanation": "This example shows that endswith() is case-sensitive. To perform a case-insensitive check, you can convert the string to lowercase first.",
            "expected_output": "False\nTrue"
        }
        ],
        "performance_considerations": "endswith() has a time complexity of O(n), where n is the length of the suffix being checked. When using a tuple of suffixes, the complexity becomes O(k*n), where k is the number of suffixes.",
        "common_pitfalls": "Remember that endswith() is case-sensitive. If you need a case-insensitive check, convert the string and the suffix to the same case first. Also, when using a tuple of suffixes, make sure to pass a tuple, not a list."
    },
    {
        "name": "expandtabs",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "str",
        "parameters": [
        {
            "name": "tabsize",
            "type": "int",
            "default": "8",
            "description": "The number of spaces to replace each tab character with"
        }
        ],
        "docstring": "Return a copy of the string where all tab characters are replaced by one or more spaces.",
        "extended_description": "The expandtabs() method returns a copy of the string where all tab characters (\\t) are replaced by one or more spaces, depending on the current column and the specified tab size. The default tab size is 8 spaces. This method is useful for formatting text, especially when dealing with data that uses tabs for alignment.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Formatting",
        "data_type_manipulated": ["string"],
        "version_added": "1.0",
        "deprecated": false,
        "method_signature": "str.expandtabs(tabsize=8)",
        "return_value": "Returns a new string with tabs expanded to spaces.",
        "related_methods": ["replace", "ljust", "rjust"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = 'hello\\tworld'\nprint(s.expandtabs(4))",
            "explanation": "This example demonstrates the basic usage of expandtabs(). It replaces the tab with 4 spaces.",
            "expected_output": "'hello   world'"
        },
        {
            "title": "Multiple Tabs",
            "code": "s = 'col1\\tcol2\\tcol3'\nprint(s.expandtabs(4))",
            "explanation": "This example shows how expandtabs() handles multiple tabs in a string.",
            "expected_output": "'col1    col2    col3'"
        },
        {
            "title": "Tabs at Different Positions",
            "code": "s = 'a\\tb\\tc\\n123\\t456\\t789'\nprint(s.expandtabs(4))",
            "explanation": "This example demonstrates how expandtabs() aligns columns when tabs are at different positions.",
            "expected_output": "'a   b   c\\n123 456 789'"
        },
        {
            "title": "Using Default Tab Size",
            "code": "s = '\\t\\t'\nprint(repr(s.expandtabs()))",
            "explanation": "This example shows the effect of using the default tab size (8 spaces).",
            "expected_output": "'        '"
        }
        ],
        "performance_considerations": "expandtabs() has a time complexity of O(n), where n is the length of the string. It creates a new string, so it uses additional memory proportional to the length of the expanded string.",
        "common_pitfalls": "Remember that expandtabs() doesn't modify the original string; it returns a new string. Also, be aware that the resulting string might be longer than expected, especially with large tab sizes or many tab characters."
    },

    {
        "name": "find",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "int",
        "parameters": [
        {
            "name": "sub",
            "type": "str",
            "description": "The substring to search for in the string"
        },
        {
            "name": "start",
            "type": "int",
            "default": "None",
            "description": "The index from which to start the search"
        },
        {
            "name": "end",
            "type": "int",
            "default": "None",
            "description": "The index at which to end the search"
        }
        ],
        "docstring": "Return the lowest index in the string where substring sub is found.",
        "extended_description": "The find() method searches for the specified substring within the string and returns the lowest index where the substring is found. If the substring is not found, it returns -1. The optional start and end parameters allow you to limit the search to a specific portion of the string.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Searching",
        "data_type_manipulated": ["string"],
        "version_added": "1.0",
        "deprecated": false,
        "method_signature": "str.find(sub[, start[, end]])",
        "return_value": "Returns the lowest index where the substring is found, or -1 if not found.",
        "related_methods": ["index", "rfind", "count"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = 'hello world'\nprint(s.find('world'))",
            "explanation": "This example demonstrates the basic usage of find(). It searches for 'world' in the string.",
            "expected_output": "6"
        },
        {
            "title": "Substring Not Found",
            "code": "s = 'hello world'\nprint(s.find('python'))",
            "explanation": "This example shows what happens when the substring is not found in the string.",
            "expected_output": "-1"
        },
        {
            "title": "Using Start and End Parameters",
            "code": "s = 'hello world hello'\nprint(s.find('hello', 5))\nprint(s.find('hello', 5, 15))",
            "explanation": "This example demonstrates using the start and end parameters to limit the search range.",
            "expected_output": "12\n-1"
        },
        {
            "title": "Case Sensitivity",
            "code": "s = 'Hello World'\nprint(s.find('world'))\nprint(s.lower().find('world'))",
            "explanation": "This example shows that find() is case-sensitive. To perform a case-insensitive search, you can convert the string to lowercase first.",
            "expected_output": "-1\n6"
        }
        ],
        "performance_considerations": "find() has a time complexity of O(n*m) where n is the length of the string and m is the length of the substring. For very long strings or frequent searches, consider using more efficient string searching algorithms.",
        "common_pitfalls": "Remember that find() returns -1 if the substring is not found, not None or an exception. Also, be aware of its case sensitivity when searching for substrings."
    },
    {
        "name": "format",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "str",
        "parameters": [
        {
            "name": "*args",
            "type": "Any",
            "description": "The positional arguments to be formatted into the string"
        },
        {
            "name": "**kwargs",
            "type": "Any",
            "description": "The keyword arguments to be formatted into the string"
        }
        ],
        "docstring": "Perform a string formatting operation.",
        "extended_description": "The format() method formats the specified value(s) and inserts them inside the string's placeholder. The placeholder is defined using curly brackets: {}. You can use positional arguments or keyword arguments to specify the order of inserted arguments.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Formatting",
        "data_type_manipulated": ["string"],
        "version_added": "2.6",
        "deprecated": false,
        "method_signature": "str.format(*args, **kwargs)",
        "return_value": "Returns a formatted version of the string.",
        "related_methods": ["f-strings", "%"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = '{} {}'\nprint(s.format('hello', 'world'))",
            "explanation": "This example demonstrates the basic usage of format(). It inserts 'hello' and 'world' into the placeholders.",
            "expected_output": "'hello world'"
        },
        {
            "title": "Using Positional Arguments",
            "code": "s = '{0} {1} {0}'\nprint(s.format('hello', 'world'))",
            "explanation": "This example shows how to use positional arguments to control the order and repetition of inserted values.",
            "expected_output": "'hello world hello'"
        },
        {
            "title": "Using Keyword Arguments",
            "code": "s = '{greeting} {name}'\nprint(s.format(greeting='Hello', name='Alice'))",
            "explanation": "This example demonstrates using keyword arguments for more readable format strings.",
            "expected_output": "'Hello Alice'"
        },
        {
            "title": "Formatting Numbers",
            "code": "s = 'The value is {:.2f}'\nprint(s.format(3.14159))",
            "explanation": "This example shows how to format numbers, in this case limiting a float to two decimal places.",
            "expected_output": "'The value is 3.14'"
        },
        {
            "title": "Accessing Object Attributes",
            "code": "class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nperson = Person('Alice', 30)\ns = 'My name is {0.name} and I am {0.age} years old'\nprint(s.format(person))",
            "explanation": "This example demonstrates how to access object attributes in format strings.",
            "expected_output": "'My name is Alice and I am 30 years old'"
        }
        ],
        "performance_considerations": "format() is generally fast, but for simple string concatenation, using '+' operator or f-strings (in Python 3.6+) might be more efficient.",
        "common_pitfalls": "Be careful with the number and order of arguments when using unnamed placeholders. Always ensure that the number of arguments matches the number of placeholders. When using named placeholders, make sure the names in the format string match the keyword argument names."
    },

    {
        "name": "isalnum",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "bool",
        "parameters": [],
        "docstring": "Return True if all characters in the string are alphanumeric and there is at least one character, False otherwise.",
        "extended_description": "The isalnum() method checks if all the characters in the string are alphanumeric (letters or numbers). It returns True if all characters are alphanumeric and the string is not empty, and False otherwise. Spaces, symbols, and punctuations are not considered alphanumeric.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Checking",
        "data_type_manipulated": ["string"],
        "version_added": "1.0",
        "deprecated": false,
        "method_signature": "str.isalnum()",
        "return_value": "Returns a boolean indicating whether all characters in the string are alphanumeric.",
        "related_methods": ["isalpha", "isnumeric", "isdigit"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = 'hello123'\nprint(s.isalnum())",
            "explanation": "This example demonstrates the basic usage of isalnum(). It returns True because all characters are either letters or numbers.",
            "expected_output": "True"
        },
        {
            "title": "String with Spaces",
            "code": "s = 'hello 123'\nprint(s.isalnum())",
            "explanation": "This example shows that spaces are not considered alphanumeric.",
            "expected_output": "False"
        },
        {
            "title": "String with Symbols",
            "code": "s = 'hello123!'\nprint(s.isalnum())",
            "explanation": "This example demonstrates that symbols are not considered alphanumeric.",
            "expected_output": "False"
        },
        {
            "title": "Empty String",
            "code": "s = ''\nprint(s.isalnum())",
            "explanation": "This example shows that an empty string returns False.",
            "expected_output": "False"
        }
        ],
        "performance_considerations": "isalnum() has a time complexity of O(n), where n is the length of the string, as it needs to check each character.",
        "common_pitfalls": "Remember that isalnum() returns False for strings containing spaces or any non-alphanumeric characters, even if they also contain alphanumeric characters. Also, it returns False for empty strings."
    },
    {
        "name": "isalpha",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "bool",
        "parameters": [],
        "docstring": "Return True if all characters in the string are alphabetic and there is at least one character, False otherwise.",
        "extended_description": "The isalpha() method checks if all the characters in the string are alphabetic (letters). It returns True if all characters are alphabetic and the string is not empty, and False otherwise. Numbers, spaces, symbols, and punctuations are not considered alphabetic.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Checking",
        "data_type_manipulated": ["string"],
        "version_added": "1.0",
        "deprecated": false,
        "method_signature": "str.isalpha()",
        "return_value": "Returns a boolean indicating whether all characters in the string are alphabetic.",
        "related_methods": ["isalnum", "isupper", "islower"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = 'hello'\nprint(s.isalpha())",
            "explanation": "This example demonstrates the basic usage of isalpha(). It returns True because all characters are letters.",
            "expected_output": "True"
        },
        {
            "title": "String with Numbers",
            "code": "s = 'hello123'\nprint(s.isalpha())",
            "explanation": "This example shows that numbers are not considered alphabetic.",
            "expected_output": "False"
        },
        {
            "title": "String with Spaces",
            "code": "s = 'hello world'\nprint(s.isalpha())",
            "explanation": "This example demonstrates that spaces are not considered alphabetic.",
            "expected_output": "False"
        },
        {
            "title": "Unicode Characters",
            "code": "s = 'Ã¤Ã¶Ã¼'\nprint(s.isalpha())",
            "explanation": "This example shows that isalpha() works with Unicode characters as well.",
            "expected_output": "True"
        }
        ],
        "performance_considerations": "isalpha() has a time complexity of O(n), where n is the length of the string, as it needs to check each character.",
        "common_pitfalls": "Remember that isalpha() returns False for strings containing any non-alphabetic characters, including numbers and spaces. Also, it returns False for empty strings."
    },
    {
        "name": "isascii",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "bool",
        "parameters": [],
        "docstring": "Return True if all characters in the string are ASCII, False otherwise.",
        "extended_description": "The isascii() method checks if all the characters in the string are ASCII characters. ASCII characters have points in the range 0-127. It returns True if all characters in the string are ASCII, including for an empty string.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Checking",
        "data_type_manipulated": ["string"],
        "version_added": "3.7",
        "deprecated": false,
        "method_signature": "str.isascii()",
        "return_value": "Returns a boolean indicating whether all characters in the string are ASCII.",
        "related_methods": ["isalnum", "isalpha", "isprintable"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = 'hello'\nprint(s.isascii())",
            "explanation": "This example demonstrates the basic usage of isascii(). It returns True because all characters are ASCII.",
            "expected_output": "True"
        },
        {
            "title": "Non-ASCII Characters",
            "code": "s = 'hÃ©llo'\nprint(s.isascii())",
            "explanation": "This example shows that a string with non-ASCII characters returns False.",
            "expected_output": "False"
        },
        {
            "title": "ASCII Symbols and Numbers",
            "code": "s = 'Hello, World! 123'\nprint(s.isascii())",
            "explanation": "This example demonstrates that ASCII includes symbols and numbers.",
            "expected_output": "True"
        },
        {
            "title": "Empty String",
            "code": "s = ''\nprint(s.isascii())",
            "explanation": "This example shows that an empty string is considered ASCII.",
            "expected_output": "True"
        }
        ],
        "performance_considerations": "isascii() has a time complexity of O(n), where n is the length of the string, as it needs to check each character. However, it's generally faster than other string checking methods as it only needs to verify that each character's code point is below 128.",
        "common_pitfalls": "Remember that isascii() only checks for ASCII characters, not printable or alphanumeric characters. A string can be ASCII but contain control characters or spaces. Also, note that this method was introduced in Python 3.7, so it's not available in earlier versions."
    },

    {
        "name": "isdecimal",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "bool",
        "parameters": [],
        "docstring": "Return True if all characters in the string are decimal characters and there is at least one character, False otherwise.",
        "extended_description": "The isdecimal() method checks if all the characters in the string are decimal characters. Decimal characters are those that can be used to form numbers in base 10. This method is more restrictive than isdigit() and isnumeric(). It only considers characters that are decimal digits, which are the numbers 0-9.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Checking",
        "data_type_manipulated": ["string"],
        "version_added": "2.0",
        "deprecated": false,
        "method_signature": "str.isdecimal()",
        "return_value": "Returns a boolean indicating whether all characters in the string are decimal digits.",
        "related_methods": ["isdigit", "isnumeric"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = '12345'\nprint(s.isdecimal())",
            "explanation": "This example demonstrates the basic usage of isdecimal(). It returns True because all characters are decimal digits.",
            "expected_output": "True"
        },
        {
            "title": "Non-Decimal Characters",
            "code": "s = '12345.67'\nprint(s.isdecimal())",
            "explanation": "This example shows that isdecimal() returns False for strings containing non-decimal characters, like the decimal point.",
            "expected_output": "False"
        },
        {
            "title": "Unicode Digits",
            "code": "s = 'à¹‘à¹’à¹“à¹”à¹•'  # Thai numerals\nprint(s.isdecimal())",
            "explanation": "This example demonstrates that isdecimal() works with decimal digits from other Unicode sets.",
            "expected_output": "True"
        },
        {
            "title": "Empty String",
            "code": "s = ''\nprint(s.isdecimal())",
            "explanation": "This example shows that an empty string returns False.",
            "expected_output": "False"
        }
        ],
        "performance_considerations": "isdecimal() has a time complexity of O(n), where n is the length of the string, as it needs to check each character.",
        "common_pitfalls": "Remember that isdecimal() is more restrictive than isdigit() and isnumeric(). It will return False for strings containing fractions, exponents, or other numeric representations that aren't strictly decimal digits."
    },
    {
        "name": "isdigit",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "bool",
        "parameters": [],
        "docstring": "Return True if all characters in the string are digits and there is at least one character, False otherwise.",
        "extended_description": "The isdigit() method checks if all the characters in the string are digits. This includes decimal digits and digits from other number systems. It's less restrictive than isdecimal() but more restrictive than isnumeric(). It considers characters to be digits if they have the Unicode property value Numeric_Type=Digit or Numeric_Type=Decimal.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Checking",
        "data_type_manipulated": ["string"],
        "version_added": "1.0",
        "deprecated": false,
        "method_signature": "str.isdigit()",
        "return_value": "Returns a boolean indicating whether all characters in the string are digits.",
        "related_methods": ["isdecimal", "isnumeric"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = '12345'\nprint(s.isdigit())",
            "explanation": "This example demonstrates the basic usage of isdigit(). It returns True because all characters are digits.",
            "expected_output": "True"
        },
        {
            "title": "Superscript Digits",
            "code": "s = 'Â²Â³'\nprint(s.isdigit())",
            "explanation": "This example shows that isdigit() returns True for superscript digits, unlike isdecimal().",
            "expected_output": "True"
        },
        {
            "title": "Non-Digit Characters",
            "code": "s = '12345a'\nprint(s.isdigit())",
            "explanation": "This example demonstrates that isdigit() returns False if the string contains any non-digit character.",
            "expected_output": "False"
        },
        {
            "title": "Unicode Digits",
            "code": "s = 'à¹‘à¹’à¹“à¹”à¹•'  # Thai numerals\nprint(s.isdigit())",
            "explanation": "This example shows that isdigit() works with digits from other Unicode sets.",
            "expected_output": "True"
        }
        ],
        "performance_considerations": "isdigit() has a time complexity of O(n), where n is the length of the string, as it needs to check each character.",
        "common_pitfalls": "Remember that isdigit() is more inclusive than isdecimal() but less inclusive than isnumeric(). It will return True for some characters that isdecimal() considers false, like superscript digits, but False for some characters that isnumeric() considers true, like fraction characters."
    },
    {
        "name": "isidentifier",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "bool",
        "parameters": [],
        "docstring": "Return True if the string is a valid Python identifier, False otherwise.",
        "extended_description": "The isidentifier() method checks if the string is a valid identifier according to the language definition. A string is considered a valid identifier if it only contains alphanumeric letters (a-z) and (0-9), or underscores (_). An identifier cannot start with a number, or contain any spaces.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Checking",
        "data_type_manipulated": ["string"],
        "version_added": "3.0",
        "deprecated": false,
        "method_signature": "str.isidentifier()",
        "return_value": "Returns a boolean indicating whether the string is a valid Python identifier.",
        "related_methods": ["iskeyword"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = 'valid_identifier'\nprint(s.isidentifier())",
            "explanation": "This example demonstrates the basic usage of isidentifier(). It returns True because the string is a valid Python identifier.",
            "expected_output": "True"
        },
        {
            "title": "Invalid Identifier (Starts with Number)",
            "code": "s = '123invalid'\nprint(s.isidentifier())",
            "explanation": "This example shows that isidentifier() returns False for strings starting with a number.",
            "expected_output": "False"
        },
        {
            "title": "Invalid Identifier (Contains Space)",
            "code": "s = 'invalid identifier'\nprint(s.isidentifier())",
            "explanation": "This example demonstrates that isidentifier() returns False for strings containing spaces.",
            "expected_output": "False"
        },
        {
            "title": "Reserved Keyword",
            "code": "s = 'if'\nprint(s.isidentifier())",
            "explanation": "This example shows that isidentifier() returns True for reserved keywords. Use the keyword module to check for reserved words.",
            "expected_output": "True"
        }
        ],
        "performance_considerations": "isidentifier() has a time complexity of O(n), where n is the length of the string, as it needs to check each character.",
        "common_pitfalls": "Remember that isidentifier() only checks if a string could be used as an identifier, not if it should be. It returns True for Python keywords, which are valid identifiers but cannot be used as variable names. Use the keyword.iskeyword() function to check if a string is a reserved keyword."
    },
    
        {
          "name": "islower",
          "module": "builtins",
          "class_name": "str",
          "data_structure": "string",
          "return_type": "bool",
          "parameters": [],
          "docstring": "Return True if all cased characters in the string are lowercase and there is at least one cased character, False otherwise.",
          "extended_description": "The islower() method checks if all the cased characters (letters) in the string are lowercase. It returns True if all cased characters are lowercase and there is at least one cased character, False otherwise. Numbers, symbols, and spaces are not checked.",
          "decorators": [],
          "main_category": "String Operations",
          "sub_category": "Checking",
          "data_type_manipulated": ["string"],
          "version_added": "1.0",
          "deprecated": false,
          "method_signature": "str.islower()",
          "return_value": "Returns a boolean indicating whether all cased characters in the string are lowercase.",
          "related_methods": ["isupper", "istitle", "lower"],
          "examples": [
            {
              "title": "Basic Usage",
              "code": "s = 'hello'\nprint(s.islower())",
              "explanation": "This example demonstrates the basic usage of islower(). It returns True because all characters are lowercase.",
              "expected_output": "True"
            },
            {
              "title": "Mixed Case",
              "code": "s = 'Hello'\nprint(s.islower())",
              "explanation": "This example shows that islower() returns False if any cased character is uppercase.",
              "expected_output": "False"
            },
            {
              "title": "With Numbers and Symbols",
              "code": "s = 'hello123!'\nprint(s.islower())",
              "explanation": "This example demonstrates that numbers and symbols don't affect the result of islower().",
              "expected_output": "True"
            },
            {
              "title": "Empty String",
              "code": "s = ''\nprint(s.islower())",
              "explanation": "This example shows that an empty string returns False because there are no cased characters.",
              "expected_output": "False"
            }
          ],
          "performance_considerations": "islower() has a time complexity of O(n), where n is the length of the string, as it needs to check each character.",
          "common_pitfalls": "Remember that islower() only considers cased characters. Strings containing only numbers, symbols, or spaces will return False. Also, it requires at least one cased character to return True."
        },
        {
          "name": "isnumeric",
          "module": "builtins",
          "class_name": "str",
          "data_structure": "string",
          "return_type": "bool",
          "parameters": [],
          "docstring": "Return True if all characters in the string are numeric characters, and there is at least one character, False otherwise.",
          "extended_description": "The isnumeric() method checks if all the characters in the string are numeric characters. This includes digits, numeric characters from various Unicode sets, and characters that have the Unicode numeric value property. It's more inclusive than isdigit() and isdecimal().",
          "decorators": [],
          "main_category": "String Operations",
          "sub_category": "Checking",
          "data_type_manipulated": ["string"],
          "version_added": "2.0",
          "deprecated": false,
          "method_signature": "str.isnumeric()",
          "return_value": "Returns a boolean indicating whether all characters in the string are numeric.",
          "related_methods": ["isdigit", "isdecimal"],
          "examples": [
            {
              "title": "Basic Usage",
              "code": "s = '12345'\nprint(s.isnumeric())",
              "explanation": "This example demonstrates the basic usage of isnumeric(). It returns True because all characters are numeric.",
              "expected_output": "True"
            },
            {
              "title": "Unicode Fractions",
              "code": "s = 'Â½'\nprint(s.isnumeric())",
              "explanation": "This example shows that isnumeric() returns True for Unicode fractions, unlike isdigit() and isdecimal().",
              "expected_output": "True"
            },
            {
              "title": "Unicode Numerals",
              "code": "s = 'äºŒåƒäºŒå'\nprint(s.isnumeric())",
              "explanation": "This example demonstrates that isnumeric() works with numeric characters from other writing systems.",
              "expected_output": "True"
            },
            {
              "title": "Non-Numeric Characters",
              "code": "s = '12.34'\nprint(s.isnumeric())",
              "explanation": "This example shows that isnumeric() returns False for strings containing any non-numeric character, like the decimal point.",
              "expected_output": "False"
            }
          ],
          "performance_considerations": "isnumeric() has a time complexity of O(n), where n is the length of the string, as it needs to check each character.",
          "common_pitfalls": "Remember that isnumeric() is more inclusive than isdigit() and isdecimal(). It will return True for some characters that the others consider false, like fraction characters or numeric characters from other writing systems. However, it still returns False for strings containing any non-numeric character, including spaces or decimal points."
        },
        {
          "name": "isprintable",
          "module": "builtins",
          "class_name": "str",
          "data_structure": "string",
          "return_type": "bool",
          "parameters": [],
          "docstring": "Return True if all characters in the string are printable or the string is empty, False otherwise.",
          "extended_description": "The isprintable() method checks if all the characters in the string are printable or if the string is empty. Printable characters are those that can be printed and do not include certain whitespace characters. This includes all ASCII characters from 0x20 (space) to 0x7E (~), as well as Unicode printable characters.",
          "decorators": [],
          "main_category": "String Operations",
          "sub_category": "Checking",
          "data_type_manipulated": ["string"],
          "version_added": "3.0",
          "deprecated": false,
          "method_signature": "str.isprintable()",
          "return_value": "Returns a boolean indicating whether all characters in the string are printable or the string is empty.",
          "related_methods": ["isascii", "isalnum"],
          "examples": [
            {
              "title": "Basic Usage",
              "code": "s = 'Hello, World!'\nprint(s.isprintable())",
              "explanation": "This example demonstrates the basic usage of isprintable(). It returns True because all characters are printable.",
              "expected_output": "True"
            },
            {
              "title": "With Non-Printable Characters",
              "code": "s = 'Hello\\nWorld'\nprint(s.isprintable())",
              "explanation": "This example shows that isprintable() returns False for strings containing non-printable characters like newline.",
              "expected_output": "False"
            },
            {
              "title": "Empty String",
              "code": "s = ''\nprint(s.isprintable())",
              "explanation": "This example demonstrates that an empty string is considered printable.",
              "expected_output": "True"
            },
            {
              "title": "Unicode Printable Characters",
              "code": "s = 'ä½ å¥½ï¼Œä¸–ç•Œï¼'\nprint(s.isprintable())",
              "explanation": "This example shows that isprintable() works with printable Unicode characters from other writing systems.",
              "expected_output": "True"
            }
          ],
          "performance_considerations": "isprintable() has a time complexity of O(n), where n is the length of the string, as it needs to check each character.",
          "common_pitfalls": "Remember that some whitespace characters (like space) are considered printable, while others (like newline or tab) are not. Also, note that an empty string is considered printable. Be cautious when using this method with user input or data from external sources, as it may contain non-printable characters that could affect output or processing."
        },

    {
        "name": "isspace",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "bool",
        "parameters": [],
        "docstring": "Return True if there are only whitespace characters in the string and there is at least one character, False otherwise.",
        "extended_description": "The isspace() method checks if all the characters in the string are whitespace characters. Whitespace characters include space, tab, newline, return, formfeed, and vertical tab. It returns True if all characters in the string are whitespace and there is at least one character, False otherwise.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Checking",
        "data_type_manipulated": ["string"],
        "version_added": "1.0",
        "deprecated": false,
        "method_signature": "str.isspace()",
        "return_value": "Returns a boolean indicating whether all characters in the string are whitespace characters.",
        "related_methods": ["strip", "lstrip", "rstrip"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = '   '\nprint(s.isspace())",
            "explanation": "This example demonstrates the basic usage of isspace(). It returns True because all characters are whitespace (spaces in this case).",
            "expected_output": "True"
        },
        {
            "title": "Mixed Whitespace Characters",
            "code": "s = ' \\n\\t'\nprint(s.isspace())",
            "explanation": "This example shows that isspace() returns True for strings containing different types of whitespace characters.",
            "expected_output": "True"
        },
        {
            "title": "Non-Whitespace Characters",
            "code": "s = '   a   '\nprint(s.isspace())",
            "explanation": "This example demonstrates that isspace() returns False if there's any non-whitespace character in the string.",
            "expected_output": "False"
        },
        {
            "title": "Empty String",
            "code": "s = ''\nprint(s.isspace())",
            "explanation": "This example shows that an empty string returns False because there must be at least one whitespace character for isspace() to return True.",
            "expected_output": "False"
        }
        ],
        "performance_considerations": "isspace() has a time complexity of O(n), where n is the length of the string, as it needs to check each character.",
        "common_pitfalls": "Remember that isspace() requires at least one character to return True. An empty string will always return False. Also, be aware that some Unicode characters that visually appear as whitespace may not be considered whitespace by this method."
    },
    {
        "name": "istitle",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "bool",
        "parameters": [],
        "docstring": "Return True if the string is a titlecased string and there is at least one character, False otherwise.",
        "extended_description": "The istitle() method checks if the string follows the rules of title case. In title case, every word starts with an uppercase letter, and the remaining letters are lowercase. Words are considered to be separated by any characters that are not letters. The method returns True if the string is in title case and contains at least one character, False otherwise.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Checking",
        "data_type_manipulated": ["string"],
        "version_added": "1.0",
        "deprecated": false,
        "method_signature": "str.istitle()",
        "return_value": "Returns a boolean indicating whether the string is in title case.",
        "related_methods": ["title", "capitalize", "upper", "lower"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = 'This Is Title Case'\nprint(s.istitle())",
            "explanation": "This example demonstrates the basic usage of istitle(). It returns True because each word starts with an uppercase letter and the rest are lowercase.",
            "expected_output": "True"
        },
        {
            "title": "Not Title Case",
            "code": "s = 'This is not title case'\nprint(s.istitle())",
            "explanation": "This example shows that istitle() returns False when not all words start with an uppercase letter.",
            "expected_output": "False"
        },
        {
            "title": "With Numbers and Punctuation",
            "code": "s = \"What's The 2nd Title?\"\nprint(s.istitle())",
            "explanation": "This example demonstrates that istitle() works correctly with apostrophes, numbers, and punctuation.",
            "expected_output": "True"
        },
        {
            "title": "Single Letter Words",
            "code": "s = 'A B C D'\nprint(s.istitle())",
            "explanation": "This example shows that istitle() considers single uppercase letters as valid title case words.",
            "expected_output": "True"
        }
        ],
        "performance_considerations": "istitle() has a time complexity of O(n), where n is the length of the string, as it needs to check each character.",
        "common_pitfalls": "Remember that istitle() is quite strict. It requires every word to start with an uppercase letter and all other letters to be lowercase. Words like 'McDonald' or 'IPv6' would not be considered title case. Also, an empty string will always return False."
    },
    {
        "name": "isupper",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "bool",
        "parameters": [],
        "docstring": "Return True if all cased characters in the string are uppercase and there is at least one cased character, False otherwise.",
        "extended_description": "The isupper() method checks if all the cased characters (letters) in the string are uppercase. It returns True if all cased characters are uppercase and there is at least one cased character, False otherwise. Numbers, symbols, and spaces are not checked.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Checking",
        "data_type_manipulated": ["string"],
        "version_added": "1.0",
        "deprecated": false,
        "method_signature": "str.isupper()",
        "return_value": "Returns a boolean indicating whether all cased characters in the string are uppercase.",
        "related_methods": ["islower", "istitle", "upper"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = 'HELLO'\nprint(s.isupper())",
            "explanation": "This example demonstrates the basic usage of isupper(). It returns True because all characters are uppercase.",
            "expected_output": "True"
        },
        {
            "title": "Mixed Case",
            "code": "s = 'HeLLO'\nprint(s.isupper())",
            "explanation": "This example shows that isupper() returns False if any cased character is lowercase.",
            "expected_output": "False"
        },
        {
            "title": "With Numbers and Symbols",
            "code": "s = 'HELLO123!'\nprint(s.isupper())",
            "explanation": "This example demonstrates that numbers and symbols don't affect the result of isupper().",
            "expected_output": "True"
        },
        {
            "title": "Empty String",
            "code": "s = ''\nprint(s.isupper())",
            "explanation": "This example shows that an empty string returns False because there are no cased characters.",
            "expected_output": "False"
        }
        ],
        "performance_considerations": "isupper() has a time complexity of O(n), where n is the length of the string, as it needs to check each character.",
        "common_pitfalls": "Remember that isupper() only considers cased characters. Strings containing only numbers, symbols, or spaces will return False. Also, it requires at least one cased character to return True."
    },

    {
        "name": "join",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "str",
        "parameters": [
        {
            "name": "iterable",
            "type": "Iterable[str]",
            "description": "An iterable object containing strings to be joined"
        }
        ],
        "docstring": "Return a string which is the concatenation of the strings in iterable.",
        "extended_description": "The join() method concatenates all the strings in the given iterable, using the string on which the method is called as a separator between each item. This method is often used to efficiently concatenate a large number of strings. The iterable must contain only string objects, or TypeError will be raised.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Joining",
        "data_type_manipulated": ["string"],
        "version_added": "1.0",
        "deprecated": false,
        "method_signature": "str.join(iterable)",
        "return_value": "Returns a new string which is the concatenation of the strings in the iterable, separated by the string on which the method was called.",
        "related_methods": ["split", "partition"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = '-'\nprint(s.join(['a', 'b', 'c']))",
            "explanation": "This example demonstrates the basic usage of join(). It joins the list of strings using '-' as the separator.",
            "expected_output": "'a-b-c'"
        },
        {
            "title": "Joining with Empty Separator",
            "code": "s = ''\nprint(s.join(['Hello', 'World']))",
            "explanation": "This example shows how to concatenate strings without any separator.",
            "expected_output": "'HelloWorld'"
        },
        {
            "title": "Joining a String",
            "code": "s = ','\nprint(s.join('abc'))",
            "explanation": "This example demonstrates that a string can be treated as an iterable of its characters.",
            "expected_output": "'a,b,c'"
        },
        {
            "title": "Error Case: Non-string Iterable",
            "code": "s = ','\ntry:\n    print(s.join([1, 2, 3]))\nexcept TypeError as e:\n    print(f\"Error: {e}\")",
            "explanation": "This example shows what happens when trying to join non-string elements.",
            "expected_output": "Error: sequence item 0: expected str instance, int found"
        }
        ],
        "performance_considerations": "join() is generally more efficient than using the + operator for concatenating multiple strings, especially for a large number of strings. It has a time complexity of O(n), where n is the total length of the resulting string.",
        "common_pitfalls": "Remember that all items in the iterable must be strings, or a TypeError will be raised. Also, be careful when joining very large iterables, as it may consume a lot of memory."
    },
    {
        "name": "ljust",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "str",
        "parameters": [
        {
            "name": "width",
            "type": "int",
            "description": "The width of the resulting string"
        },
        {
            "name": "fillchar",
            "type": "str",
            "default": "' '",
            "description": "The character to pad the string with"
        }
        ],
        "docstring": "Return left-justified string of length width.",
        "extended_description": "The ljust() method returns a left-justified string of specified width. If the original string is shorter than the specified width, it pads the string on the right with the specified fill character (space by default) to reach the desired width. If the original string is longer than or equal to the specified width, it returns the original string unchanged.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Formatting",
        "data_type_manipulated": ["string"],
        "version_added": "1.0",
        "deprecated": false,
        "method_signature": "str.ljust(width[, fillchar])",
        "return_value": "Returns a new string of specified width with the original string left-justified.",
        "related_methods": ["rjust", "center", "zfill"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = 'hello'\nprint(s.ljust(10, '-'))",
            "explanation": "This example demonstrates the basic usage of ljust(). It pads the string on the right with '-' to reach a width of 10.",
            "expected_output": "'hello-----'"
        },
        {
            "title": "Using Default Fill Character",
            "code": "s = 'python'\nprint(s.ljust(10))",
            "explanation": "This example shows ljust() using the default fill character (space).",
            "expected_output": "'python    '"
        },
        {
            "title": "Width Smaller Than String Length",
            "code": "s = 'long string'\nprint(s.ljust(5, '*'))",
            "explanation": "This example demonstrates what happens when the specified width is smaller than the string length.",
            "expected_output": "'long string'"
        },
        {
            "title": "Using with Format",
            "code": "data = ['apple', 'banana', 'cherry']\nfor item in data:\n    print(item.ljust(10), 'is a fruit.')",
            "explanation": "This example shows a practical use of ljust() for formatting output.",
            "expected_output": "apple      is a fruit.\nbanana     is a fruit.\ncherry     is a fruit."
        }
        ],
        "performance_considerations": "ljust() has a time complexity of O(n), where n is the width specified. It creates a new string, so it uses additional memory proportional to the specified width.",
        "common_pitfalls": "Remember that if the specified width is less than or equal to the length of the string, the original string is returned unchanged. Also, the fillchar parameter must be a single character string; using a longer string will raise a TypeError."
    },
    {
        "name": "lower",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "str",
        "parameters": [],
        "docstring": "Return a copy of the string converted to lowercase.",
        "extended_description": "The lower() method returns a copy of the string with all the cased characters converted to lowercase. Symbols and numbers remain unaffected. This method is useful for case-insensitive comparisons.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Case Conversion",
        "data_type_manipulated": ["string"],
        "version_added": "1.0",
        "deprecated": false,
        "method_signature": "str.lower()",
        "return_value": "Returns a new string with all cased characters converted to lowercase.",
        "related_methods": ["upper", "capitalize", "swapcase", "casefold"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = 'HELLO'\nprint(s.lower())",
            "explanation": "This example demonstrates the basic usage of lower(). It converts all uppercase letters to lowercase.",
            "expected_output": "'hello'"
        },
        {
            "title": "Mixed Case",
            "code": "s = 'HeLLo WoRLd'\nprint(s.lower())",
            "explanation": "This example shows how lower() handles mixed case strings.",
            "expected_output": "'hello world'"
        },
        {
            "title": "With Numbers and Symbols",
            "code": "s = 'HELLO 123!'\nprint(s.lower())",
            "explanation": "This example demonstrates that lower() only affects letters, leaving numbers and symbols unchanged.",
            "expected_output": "'hello 123!'"
        },
        {
            "title": "Case-Insensitive Comparison",
            "code": "s1 = 'HELLO'\ns2 = 'hello'\nprint(s1.lower() == s2.lower())",
            "explanation": "This example shows how lower() can be used for case-insensitive string comparison.",
            "expected_output": "True"
        }
        ],
        "performance_considerations": "lower() has a time complexity of O(n), where n is the length of the string. It creates a new string, so it uses additional memory proportional to the length of the string.",
        "common_pitfalls": "Remember that lower() returns a new string and doesn't modify the original string. Also, be aware that some Unicode characters may have unexpected behavior when converted to lowercase. For more aggressive lowercasing, consider using the casefold() method."
    },

    {
        "name": "lstrip",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "str",
        "parameters": [
        {
            "name": "chars",
            "type": "str",
            "default": "None",
            "description": "A string specifying the set of characters to be removed"
        }
        ],
        "docstring": "Return a copy of the string with leading characters removed.",
        "extended_description": "The lstrip() method returns a copy of the string with leading characters removed. If the chars argument is not provided, it removes leading whitespace characters (spaces, tabs, newlines, etc.). If chars is provided, it removes any leading characters that are in the chars string.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Stripping",
        "data_type_manipulated": ["string"],
        "version_added": "1.0",
        "deprecated": false,
        "method_signature": "str.lstrip([chars])",
        "return_value": "Returns a new string with specified leading characters removed.",
        "related_methods": ["rstrip", "strip"],
        "examples": [
        {
            "title": "Basic Usage (Removing Whitespace)",
            "code": "s = '   hello'\nprint(s.lstrip())",
            "explanation": "This example demonstrates the basic usage of lstrip(). It removes leading whitespace characters.",
            "expected_output": "'hello'"
        },
        {
            "title": "Removing Specific Characters",
            "code": "s = '...hello'\nprint(s.lstrip('.'))",
            "explanation": "This example shows how to remove specific leading characters using the chars parameter.",
            "expected_output": "'hello'"
        },
        {
            "title": "No Characters to Remove",
            "code": "s = 'hello'\nprint(s.lstrip('x'))",
            "explanation": "This example demonstrates that if no specified characters are found at the start, the original string is returned.",
            "expected_output": "'hello'"
        },
        {
            "title": "Removing Multiple Types of Characters",
            "code": "s = '   ***hello'\nprint(s.lstrip(' *'))",
            "explanation": "This example shows how to remove multiple types of leading characters.",
            "expected_output": "'hello'"
        }
        ],
        "performance_considerations": "lstrip() has a time complexity of O(n), where n is the length of the string. It creates a new string, so it uses additional memory proportional to the length of the resulting string.",
        "common_pitfalls": "Remember that lstrip() only removes characters from the left side of the string. If you need to remove characters from both sides, use strip(). Also, be cautious when using lstrip() with user input, as it might remove more characters than intended if the input starts with the specified characters."
    },
    {
        "name": "maketrans",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "dict",
        "parameters": [
        {
            "name": "x",
            "type": "Union[dict, str]",
            "description": "If a dict, it's directly used as the translation table. If a string, it's the string of characters to replace."
        },
        {
            "name": "y",
            "type": "str",
            "default": "None",
            "description": "The string of characters that replace those specified in x. Must be specified if x is a string."
        },
        {
            "name": "z",
            "type": "str",
            "default": "None",
            "description": "A string of characters to be removed from the string during translation."
        }
        ],
        "docstring": "Return a translation table usable for str.translate().",
        "extended_description": "The maketrans() method creates a translation table that can be used with the translate() method to replace specified characters. It can be called in two ways: with a dictionary mapping characters to their replacements, or with two strings of equal length where characters in the first string are replaced by the corresponding characters in the second string.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Translation",
        "data_type_manipulated": ["string"],
        "version_added": "2.6",
        "deprecated": false,
        "method_signature": "str.maketrans(x[, y[, z]])",
        "return_value": "Returns a dictionary suitable for use with translate().",
        "related_methods": ["translate"],
        "examples": [
        {
            "title": "Basic Usage with Two Strings",
            "code": "trans = str.maketrans('abc', '123')\ns = 'abcdef'\nprint(s.translate(trans))",
            "explanation": "This example demonstrates creating a translation table to replace 'a' with '1', 'b' with '2', and 'c' with '3'.",
            "expected_output": "'123def'"
        },
        {
            "title": "Using a Dictionary",
            "code": "trans = str.maketrans({'a': '1', 'b': '2', 'c': '3'})\ns = 'abcdef'\nprint(s.translate(trans))",
            "explanation": "This example shows how to use a dictionary to create the translation table.",
            "expected_output": "'123def'"
        },
        {
            "title": "Removing Characters",
            "code": "trans = str.maketrans('abc', '123', 'def')\ns = 'abcdefghi'\nprint(s.translate(trans))",
            "explanation": "This example demonstrates how to remove characters ('def') during translation.",
            "expected_output": "'123ghi'"
        },
        {
            "title": "Unicode Translation",
            "code": "trans = str.maketrans('aeiou', '12345', 'sh')\ns = 'hello world'\nprint(s.translate(trans))",
            "explanation": "This example shows translation with Unicode characters and character removal.",
            "expected_output": "'2ll4 w4rld'"
        }
        ],
        "performance_considerations": "maketrans() is efficient for creating translation tables. The time complexity of creating the table is O(n), where n is the number of characters being mapped. Using the resulting table with translate() is more efficient than multiple replace() operations.",
        "common_pitfalls": "When using two strings to create the translation table, ensure they are of equal length, or a ValueError will be raised. Also, remember that maketrans() is a static method of the str class, so it should be called as str.maketrans(), not on a string instance."
    },
    {
        "name": "partition",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "Tuple[str, str, str]",
        "parameters": [
        {
            "name": "sep",
            "type": "str",
            "description": "The separator to use for partitioning the string"
        }
        ],
        "docstring": "Partition the string into three parts using the given separator.",
        "extended_description": "The partition() method splits the string at the first occurrence of the specified separator and returns a tuple containing three elements: the part before the separator, the separator itself, and the part after the separator. If the separator is not found, it returns a tuple containing the original string and two empty strings.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Splitting",
        "data_type_manipulated": ["string"],
        "version_added": "2.5",
        "deprecated": false,
        "method_signature": "str.partition(sep)",
        "return_value": "Returns a tuple of three strings: (part_before_separator, separator, part_after_separator)",
        "related_methods": ["split", "rsplit", "rpartition"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = 'hello-world'\nprint(s.partition('-'))",
            "explanation": "This example demonstrates the basic usage of partition(). It splits the string at the first occurrence of '-'.",
            "expected_output": "('hello', '-', 'world')"
        },
        {
            "title": "Separator Not Found",
            "code": "s = 'hello world'\nprint(s.partition('x'))",
            "explanation": "This example shows what happens when the separator is not found in the string.",
            "expected_output": "('hello world', '', '')"
        },
        {
            "title": "Multiple Occurrences of Separator",
            "code": "s = 'a-b-c'\nprint(s.partition('-'))",
            "explanation": "This example demonstrates that partition() only splits at the first occurrence of the separator.",
            "expected_output": "('a', '-', 'b-c')"
        },
        {
            "title": "Using with Unpacking",
            "code": "s = 'key=value'\nbefore, sep, after = s.partition('=')\nprint(f\"Key: {before}, Value: {after}\")",
            "explanation": "This example shows a practical use of partition() with tuple unpacking.",
            "expected_output": "Key: key, Value: value"
        }
        ],
        "performance_considerations": "partition() has a time complexity of O(n), where n is the length of the string, as it needs to search through the string for the separator. It's generally more efficient than using index() and slicing for this purpose.",
        "common_pitfalls": "Remember that partition() always returns a tuple of three elements, even if the separator is not found. Also, be aware that it only splits at the first occurrence of the separator. If you need to split at the last occurrence, use rpartition() instead."
    },

    {
        "name": "replace",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "str",
        "parameters": [
        {
            "name": "old",
            "type": "str",
            "description": "The substring to be replaced"
        },
        {
            "name": "new",
            "type": "str",
            "description": "The substring to replace the old substring"
        },
        {
            "name": "count",
            "type": "int",
            "default": "-1",
            "description": "The maximum number of occurrences to replace. -1 (default) means replace all occurrences"
        }
        ],
        "docstring": "Return a copy with all occurrences of substring old replaced by new.",
        "extended_description": "The replace() method returns a new string where all occurrences of a specified substring are replaced with another specified string. If the 'count' parameter is provided, it replaces only the first 'count' occurrences.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Replacing",
        "data_type_manipulated": ["string"],
        "version_added": "1.0",
        "deprecated": false,
        "method_signature": "str.replace(old, new[, count])",
        "return_value": "Returns a new string with specified replacements.",
        "related_methods": ["translate", "maketrans"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = 'hello hello'\nprint(s.replace('hello', 'hi'))",
            "explanation": "This example demonstrates the basic usage of replace(). It replaces all occurrences of 'hello' with 'hi'.",
            "expected_output": "'hi hi'"
        },
        {
            "title": "Limiting Replacements",
            "code": "s = 'hello hello hello'\nprint(s.replace('hello', 'hi', 2))",
            "explanation": "This example shows how to limit the number of replacements using the 'count' parameter.",
            "expected_output": "'hi hi hello'"
        },
        {
            "title": "Replacing with Empty String",
            "code": "s = 'hello world'\nprint(s.replace('o', ''))",
            "explanation": "This example demonstrates using replace() to remove all occurrences of a substring.",
            "expected_output": "'hell wrld'"
        },
        {
            "title": "Case Sensitivity",
            "code": "s = 'Hello HELLO hello'\nprint(s.replace('hello', 'hi'))",
            "explanation": "This example shows that replace() is case-sensitive.",
            "expected_output": "'Hello HELLO hi'"
        }
        ],
        "performance_considerations": "replace() has a time complexity of O(n), where n is the length of the string. For multiple replacements, consider using re.sub() from the re module, which can be more efficient.",
        "common_pitfalls": "Remember that replace() is case-sensitive. If you need case-insensitive replacement, you might need to use regular expressions. Also, be cautious when replacing substrings that might overlap, as the behavior might not be what you expect."
    },
    {
        "name": "rfind",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "int",
        "parameters": [
        {
            "name": "sub",
            "type": "str",
            "description": "The substring to search for"
        },
        {
            "name": "start",
            "type": "int",
            "default": "None",
            "description": "The position to start the search. Default is 0."
        },
        {
            "name": "end",
            "type": "int",
            "default": "None",
            "description": "The position to end the search. Default is the end of the string."
        }
        ],
        "docstring": "Return the highest index in the string where substring sub is found.",
        "extended_description": "The rfind() method finds the last occurrence of the specified substring in the string. It returns the highest index where the substring is found. If the substring is not found, it returns -1. The search is performed backwards from the end of the string or from the position specified by the 'end' parameter.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Searching",
        "data_type_manipulated": ["string"],
        "version_added": "1.0",
        "deprecated": false,
        "method_signature": "str.rfind(sub[, start[, end]])",
        "return_value": "Returns the highest index where the substring is found, or -1 if not found.",
        "related_methods": ["find", "index", "rindex"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = 'hello hello'\nprint(s.rfind('hello'))",
            "explanation": "This example demonstrates the basic usage of rfind(). It finds the last occurrence of 'hello'.",
            "expected_output": "6"
        },
        {
            "title": "Substring Not Found",
            "code": "s = 'hello world'\nprint(s.rfind('python'))",
            "explanation": "This example shows what rfind() returns when the substring is not found.",
            "expected_output": "-1"
        },
        {
            "title": "Using Start and End Parameters",
            "code": "s = 'hello hello hello'\nprint(s.rfind('hello', 0, 10))",
            "explanation": "This example demonstrates using the start and end parameters to limit the search range.",
            "expected_output": "6"
        },
        {
            "title": "Case Sensitivity",
            "code": "s = 'Hello HELLO hello'\nprint(s.rfind('hello'))",
            "explanation": "This example shows that rfind() is case-sensitive.",
            "expected_output": "12"
        }
        ],
        "performance_considerations": "rfind() has a time complexity of O(n), where n is the length of the string. It's generally efficient for searching from the end of the string.",
        "common_pitfalls": "Remember that rfind() is case-sensitive. If you need case-insensitive searching, you might need to use regular expressions or convert the string to lowercase before searching. Also, be aware that rfind() returns -1 if the substring is not found, not None or an exception."
    },
    {
        "name": "rindex",
        "module": "builtins",
        "class_name": "str",
        "data_structure": "string",
        "return_type": "int",
        "parameters": [
        {
            "name": "sub",
            "type": "str",
            "description": "The substring to search for"
        },
        {
            "name": "start",
            "type": "int",
            "default": "None",
            "description": "The position to start the search. Default is 0."
        },
        {
            "name": "end",
            "type": "int",
            "default": "None",
            "description": "The position to end the search. Default is the end of the string."
        }
        ],
        "docstring": "Return the highest index in the string where substring sub is found.",
        "extended_description": "The rindex() method finds the last occurrence of the specified substring in the string. It returns the highest index where the substring is found. If the substring is not found, it raises a ValueError. The search is performed backwards from the end of the string or from the position specified by the 'end' parameter.",
        "decorators": [],
        "main_category": "String Operations",
        "sub_category": "Searching",
        "data_type_manipulated": ["string"],
        "version_added": "1.0",
        "deprecated": false,
        "method_signature": "str.rindex(sub[, start[, end]])",
        "return_value": "Returns the highest index where the substring is found.",
        "related_methods": ["rfind", "index", "find"],
        "examples": [
        {
            "title": "Basic Usage",
            "code": "s = 'hello hello'\nprint(s.rindex('hello'))",
            "explanation": "This example demonstrates the basic usage of rindex(). It finds the last occurrence of 'hello'.",
            "expected_output": "6"
        },
        {
            "title": "Substring Not Found",
            "code": "s = 'hello world'\ntry:\n    print(s.rindex('python'))\nexcept ValueError as e:\n    print(f\"Error: {e}\")",
            "explanation": "This example shows what happens when the substring is not found.",
            "expected_output": "Error: substring not found"
        },
        {
            "title": "Using Start and End Parameters",
            "code": "s = 'hello hello hello'\nprint(s.rindex('hello', 0, 10))",
            "explanation": "This example demonstrates using the start and end parameters to limit the search range.",
            "expected_output": "6"
        },
        {
            "title": "Case Sensitivity",
            "code": "s = 'Hello HELLO hello'\nprint(s.rindex('hello'))",
            "explanation": "This example shows that rindex() is case-sensitive.",
            "expected_output": "12"
        }
        ],
        "performance_considerations": "rindex() has a time complexity of O(n), where n is the length of the string. It's generally efficient for searching from the end of the string.",
        "common_pitfalls": "Remember that rindex() is case-sensitive. If you need case-insensitive searching, you might need to use regular expressions or convert the string to lowercase before searching. Also, be aware that rindex() raises a ValueError if the substring is not found, unlike rfind() which returns -1."
    },
    {
      "name": "rjust",
      "module": "builtins",
      "class_name": "str",
      "data_structure": "string",
      "return_type": "str",
      "parameters": [
        {
          "name": "width",
          "type": "int",
          "description": "The total width of the returned string"
        },
        {
          "name": "fillchar",
          "type": "str",
          "default": "' '",
          "description": "The character to use for padding (default is space)"
        }
      ],
      "docstring": "Return right-justified string of length width.",
      "extended_description": "The rjust() method returns a right-justified version of the string. It pads the string on the left with the specified fillchar (space by default) so that the resulting string has the specified width. If the input string is already longer than the specified width, it returns the original string unchanged.",
      "decorators": [],
      "main_category": "String Operations",
      "sub_category": "Formatting",
      "data_type_manipulated": ["string"],
      "version_added": "1.0",
      "deprecated": false,
      "return_value": "Returns a new string of the specified width with the original string right-justified and padded on the left with the fillchar.",
      "exceptions": [
        {
          "type": "TypeError",
          "condition": "If width is not an integer or fillchar is not a single character string"
        }
      ],
      "notes": [
        "If the input string is longer than the specified width, the original string is returned unchanged.",
        "The method does not modify the original string; it returns a new string.",
        "For left-justification, use the ljust() method instead."
      ],
      "related_functions": ["ljust", "center", "zfill"],
      "examples": [
        {
          "title": "Basic Usage",
          "code": "text = 'Python'\nresult = text.rjust(10)\nprint(result)",
          "explanation": "Basic usage of rjust() to right-justify 'Python' in a field of width 10.",
          "expected_output": "    Python"
        },
        {
          "title": "Custom Fill Character",
          "code": "text = 'Python'\nresult = text.rjust(10, '*')\nprint(result)",
          "explanation": "Using a custom fill character ('*') instead of the default space.",
          "expected_output": "****Python"
        },
        {
          "title": "Width Smaller Than String",
          "code": "text = 'Python'\nresult = text.rjust(4)\nprint(result)",
          "explanation": "When width is smaller than the string length, the original string is returned.",
          "expected_output": "Python"
        },
        {
          "title": "Error Handling",
          "code": "text = 'Python'\ntry:\n    result = text.rjust('10')\nexcept TypeError as e:\n    print(f\"Error: {e}\")",
          "explanation": "Demonstrates TypeError when an invalid width argument is passed.",
          "expected_output": "Error: 'str' object cannot be interpreted as an integer"
        }
      ],

      "performance_considerations": "rjust() has a time complexity of O(n), where n is the width specified. It's generally efficient for formatting strings, but for very large widths, it may consume more memory and time.",
      "common_pitfalls": "Remember that rjust() always returns a new string and doesn't modify the original. Also, be cautious when using it with very large width values, as it may lead to excessive memory usage. If you need to right-justify numbers with leading zeros, consider using zfill() instead."
    },
    
    {
      "name": "rpartition",
      "module": "builtins",
      "class_name": "str",
      "data_structure": "string",
      "return_type": "Tuple[str, str, str]",
      "parameters": [
        {
          "name": "sep",
          "type": "str",
          "description": "The separator to use for partitioning the string"
        }
      ],
      "docstring": "Partition the string into three parts using the given separator.",
      "extended_description": "The rpartition() method searches for the last occurrence of the separator in the string and returns a tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, it returns a tuple containing two empty strings and the entire original string.",
      "decorators": [],
      "main_category": "String Operations",
      "sub_category": "Splitting",
      "data_type_manipulated": ["string"],
      "version_added": "2.5",
      "deprecated": false,
      "return_value": "Returns a tuple of three strings: (head, separator, tail)",
      "exceptions": [
        {
          "type": "ValueError",
          "condition": "If the separator is an empty string"
        }
      ],
      "notes": [
        "The method searches for the separator from right to left.",
        "If the separator is not found, it returns ('', '', original_string).",
        "For left-to-right partitioning, use the partition() method instead."
      ],
      "related_functions": ["partition", "split", "rsplit"],
      "examples": [
        {
          "title": "Basic Usage",
          "code": "text = 'python,programming,language'\nresult = text.rpartition(',')\nprint(result)",
          "explanation": "Basic usage of rpartition() to split the string at the last comma.",
          "expected_output": "('python,programming', ',', 'language')"
        },
        {
          "title": "Separator Not Found",
          "code": "text = 'python'\nresult = text.rpartition(',')\nprint(result)",
          "explanation": "When the separator is not found in the string.",
          "expected_output": "('', '', 'python')"
        },
        {
          "title": "Multiple Occurrences",
          "code": "text = 'a=b=c=d'\nresult = text.rpartition('=')\nprint(result)",
          "explanation": "When there are multiple occurrences of the separator, it splits at the last one.",
          "expected_output": "('a=b=c', '=', 'd')"
        },
        {
          "title": "Error Handling",
          "code": "text = 'python'\ntry:\n    result = text.rpartition('')\nexcept ValueError as e:\n    print(f\"Error: {e}\")",
          "explanation": "Demonstrates ValueError when an empty separator is used.",
          "expected_output": "Error: empty separator"
        }
      ],
      "performance_considerations": "rpartition() has a time complexity of O(n), where n is the length of the string. It's generally efficient as it only needs to traverse the string once from right to left.",
      "common_pitfalls": "Be aware that rpartition() always returns a 3-tuple, even when the separator is not found. This behavior differs from methods like split(). Also, remember that it's case-sensitive; for case-insensitive partitioning, you might need to convert the string and separator to lowercase first."
    },
    {
      "name": "rsplit",
      "module": "builtins",
      "class_name": "str",
      "data_structure": "string",
      "return_type": "List[str]",
      "parameters": [
        {
          "name": "sep",
          "type": "str",
          "default": "None",
          "description": "The delimiter to use for splitting the string"
        },
        {
          "name": "maxsplit",
          "type": "int",
          "default": "-1",
          "description": "The maximum number of splits to perform"
        }
      ],
      "docstring": "Return a list of the words in the string, using sep as the delimiter string.",
      "extended_description": "The rsplit() method splits a string into a list of substrings based on the specified separator. It starts splitting from the right side of the string. If a maxsplit value is specified, it performs at most maxsplit splits. If sep is not specified or is None, any whitespace string is a separator.",
      "decorators": [],
      "main_category": "String Operations",
      "sub_category": "Splitting",
      "data_type_manipulated": ["string"],
      "version_added": "2.4",
      "deprecated": false,
      "return_value": "Returns a list of substrings",
      "exceptions": [],
      "notes": [
        "If sep is not specified, consecutive whitespace characters are treated as a single separator.",
        "The rsplit() method splits from right to left, which is the main difference from split().",
        "If maxsplit is -1 (default), there is no limit on the number of splits."
      ],
      "related_functions": ["split", "partition", "rpartition"],
      "examples": [
        {
          "title": "Basic Usage",
          "code": "text = 'python,java,c++,javascript'\nresult = text.rsplit(',')\nprint(result)",
          "explanation": "Basic usage of rsplit() to split a string by commas.",
          "expected_output": "['python', 'java', 'c++', 'javascript']"
        },
        {
          "title": "With maxsplit",
          "code": "text = 'python,java,c++,javascript'\nresult = text.rsplit(',', 2)\nprint(result)",
          "explanation": "Using rsplit() with maxsplit=2, splitting only the last two occurrences.",
          "expected_output": "['python,java', 'c++', 'javascript']"
        },
        {
          "title": "Splitting Whitespace",
          "code": "text = '   python   java   c++   '\nresult = text.rsplit()\nprint(result)",
          "explanation": "When sep is not specified, it splits on whitespace.",
          "expected_output": "['python', 'java', 'c++']"
        },
        {
          "title": "Empty Separator",
          "code": "text = 'python'\nresult = text.rsplit('')\nprint(result)",
          "explanation": "Using an empty string as separator splits between each character.",
          "expected_output": "['p', 'y', 't', 'h', 'o', 'n']"
        }
      ],
      "performance_considerations": "rsplit() has a time complexity of O(n), where n is the length of the string. It's generally efficient, but for very long strings with many splits, it may consume more time and memory than other methods.",
      "common_pitfalls": "Remember that rsplit() behaves differently from split() when maxsplit is specified, as it starts from the right. Also, be aware that if sep is not specified, it splits on whitespace, which might lead to unexpected results if your string contains multiple types of whitespace characters."
    
    },
    {
      "name": "rstrip",
      "module": "builtins",
      "class_name": "str",
      "data_structure": "string",
      "return_type": "str",
      "parameters": [
        {
          "name": "chars",
          "type": "str",
          "default": "None",
          "description": "The characters to remove from the right side of the string"
        }
      ],
      "docstring": "Return a copy of the string with trailing characters removed.",
      "extended_description": "The rstrip() method returns a copy of the string with trailing characters removed. If the chars argument is not provided, it removes trailing whitespace characters (space, tab, newline, return, formfeed).",
      "decorators": [],
      "main_category": "String Operations",
      "sub_category": "Stripping",
      "data_type_manipulated": ["string"],
      "version_added": "1.0",
      "deprecated": false,
      "examples": [
        {
          "title": "Basic Usage - Removing Whitespace",
          "code": "s = 'hello   '\nprint(s.rstrip())",
          "expected_output": "hello"
        },
        {
          "title": "Removing Specific Characters",
          "code": "s = 'hello...'\nprint(s.rstrip('.'))",
          "expected_output": "hello"
        },
        {
          "title": "No Characters to Remove",
          "code": "s = 'hello'\nprint(s.rstrip('x'))",
          "expected_output": "hello"
        }
      ],
      "performance_considerations": "rstrip() has a time complexity of O(n), where n is the length of the string. It's generally efficient for most use cases.",
      "common_pitfalls": "Remember that rstrip() only removes characters from the right side of the string. If you need to remove characters from both sides, use strip() instead. Also, when specifying chars, any combination of the characters will be removed, not just the exact sequence."
    },
    {
      "name": "split",
      "module": "builtins",
      "class_name": "str",
      "data_structure": "string",
      "return_type": "List[str]",
      "parameters": [
        {
          "name": "sep",
          "type": "str",
          "default": "None",
          "description": "The delimiter string used to split the string"
        },
        {
          "name": "maxsplit",
          "type": "int",
          "default": "-1",
          "description": "The maximum number of splits to perform. -1 means no limit"
        }
      ],
      "docstring": "Return a list of the words in the string, using sep as the delimiter string.",
      "extended_description": "The split() method splits a string into a list of substrings based on the specified separator. If sep is not specified or is None, any whitespace string is a separator. If maxsplit is given, at most maxsplit splits are done.",
      "decorators": [],
      "main_category": "String Operations",
      "sub_category": "Splitting",
      "data_type_manipulated": ["string"],
      "version_added": "1.0",
      "deprecated": false,
      "examples": [
        {
          "title": "Basic Usage - Splitting on Whitespace",
          "code": "s = 'hello world python'\nprint(s.split())",
          "expected_output": "['hello', 'world', 'python']"
        },
        {
          "title": "Splitting with Specific Separator",
          "code": "s = 'apple,banana,cherry'\nprint(s.split(','))",
          "expected_output": "['apple', 'banana', 'cherry']"
        },
        {
          "title": "Using maxsplit",
          "code": "s = 'one two three four'\nprint(s.split(' ', 2))",
          "expected_output": "['one', 'two', 'three four']"
        }
      ],
      "performance_considerations": "split() has a time complexity of O(n), where n is the length of the string. It's generally efficient, but for very long strings with many splits, it may consume more time and memory.",
      "common_pitfalls": "Be aware that if sep is not specified, split() will use any whitespace as a separator, which might lead to unexpected results if your string contains multiple types of whitespace characters. Also, empty strings are not ignored as split fields."
    },
    {
      "name": "splitlines",
      "module": "builtins",
      "class_name": "str",
      "data_structure": "string",
      "return_type": "List[str]",
      "parameters": [
        {
          "name": "keepends",
          "type": "bool",
          "default": "False",
          "description": "If True, line breaks are included in the resulting list items"
        }
      ],
      "docstring": "Return a list of the lines in the string, breaking at line boundaries.",
      "extended_description": "The splitlines() method splits a string into a list of lines. It breaks the string at line boundaries (\\n, \\r\\n, \\r). If keepends is False (default), the line breaks are not included in the resulting list items.",
      "decorators": [],
      "main_category": "String Operations",
      "sub_category": "Splitting",
      "data_type_manipulated": ["string"],
      "version_added": "1.5",
      "deprecated": false,
      "examples": [
        {
          "title": "Basic Usage",
          "code": "s = 'hello\\nworld\\npython'\nprint(s.splitlines())",
          "expected_output": "['hello', 'world', 'python']"
        },
        {
          "title": "Keeping Line Endings",
          "code": "s = 'line1\\nline2\\r\\nline3\\rline4'\nprint(s.splitlines(True))",
          "expected_output": "['line1\\n', 'line2\\r\\n', 'line3\\r', 'line4']"
        },
        {
          "title": "Empty Lines",
          "code": "s = 'hello\\n\\nworld\\n'\nprint(s.splitlines())",
          "expected_output": "['hello', '', 'world']"
        }
      ],
      "performance_considerations": "splitlines() has a time complexity of O(n), where n is the length of the string. It's generally efficient for most use cases.",
      "common_pitfalls": "Be aware that splitlines() treats various line endings (\\n, \\r\\n, \\r) as valid line breaks. If you need to split only on a specific line ending, you might want to use split('\\n') instead. Also, remember that empty lines are included in the result."
    },
    {
      "name": "startswith",
      "module": "builtins",
      "class_name": "str",
      "data_structure": "string",
      "return_type": "bool",
      "parameters": [
        {
          "name": "prefix",
          "type": "Union[str, Tuple[str]]",
          "description": "The string or tuple of strings to check for at the start of the string"
        },
        {
          "name": "start",
          "type": "int",
          "default": "None",
          "description": "The position in the string to start the search"
        },
        {
          "name": "end",
          "type": "int",
          "default": "None",
          "description": "The position in the string to end the search"
        }
      ],
      "docstring": "Return True if string starts with the specified prefix, False otherwise.",
      "extended_description": "The startswith() method checks if the string starts with the specified prefix. If start is provided, the check begins at that position. If end is provided, the check stops at that position. The prefix can be a tuple of strings to check for any of multiple prefixes.",
      "decorators": [],
      "main_category": "String Operations",
      "sub_category": "Checking",
      "data_type_manipulated": ["string"],
      "version_added": "2.0",
      "deprecated": false,
      "examples": [
        {
          "title": "Basic Usage",
          "code": "s = 'hello world'\nprint(s.startswith('hello'))",
          "expected_output": "True"
        },
        {
          "title": "Using start parameter",
          "code": "s = 'hello world'\nprint(s.startswith('world', 6))",
          "expected_output": "True"
        },
        {
          "title": "Using tuple of prefixes",
          "code": "s = 'hello world'\nprint(s.startswith(('hello', 'hi', 'hey')))",
          "expected_output": "True"
        }
      ],
      "performance_considerations": "startswith() has a time complexity of O(n), where n is the length of the prefix or the length of the string slice being checked. It's generally efficient for most use cases.",
      "common_pitfalls": "Remember that startswith() is case-sensitive. If you need case-insensitive comparison, you might need to convert both the string and the prefix to lowercase first. Also, when using a tuple of prefixes, an empty tuple will always return False."
    },
    {
      "name": "strip",
      "module": "builtins",
      "class_name": "str",
      "data_structure": "string",
      "return_type": "str",
      "parameters": [
        {
          "name": "chars",
          "type": "str",
          "default": "None",
          "description": "The characters to remove from both ends of the string"
        }
      ],
      "docstring": "Return a copy of the string with leading and trailing characters removed.",
      "extended_description": "The strip() method returns a copy of the string with leading and trailing characters removed. If the chars argument is not provided, it removes leading and trailing whitespace characters (space, tab, newline, return, formfeed).",
      "decorators": [],
      "main_category": "String Operations",
      "sub_category": "Stripping",
      "data_type_manipulated": ["string"],
      "version_added": "1.0",
      "deprecated": false,
      "examples": [
        {
          "title": "Basic Usage - Removing Whitespace",
          "code": "s = '  hello  '\nprint(s.strip())",
          "expected_output": "hello"
        },
        {
          "title": "Removing Specific Characters",
          "code": "s = '...hello..'\nprint(s.strip('.'))",
          "expected_output": "hello"
        },
        {
          "title": "Removing Multiple Characters",
          "code": "s = '...hello...'\nprint(s.strip('.!?'))",
          "expected_output": "hello"
        }
      ],
      "performance_considerations": "strip() has a time complexity of O(n), where n is the length of the string. It's generally efficient for most use cases.",
      "common_pitfalls": "Remember that strip() removes all combinations of the specified characters, not just the exact sequence. If you need to remove a specific substring from the start or end, you might need to use other string methods like replace() or slicing."
    },
    {
      "name": "swapcase",
      "module": "builtins",
      "class_name": "str",
      "data_structure": "string",
      "return_type": "str",
      "parameters": [],
      "docstring": "Return a copy of the string with uppercase characters converted to lowercase and vice versa.",
      "extended_description": "The swapcase() method returns a new string where all uppercase characters are converted to lowercase and all lowercase characters are converted to uppercase. Characters that are not letters remain unchanged.",
      "decorators": [],
      "main_category": "String Operations",
      "sub_category": "Case Conversion",
      "data_type_manipulated": ["string"],
      "version_added": "1.0",
      "deprecated": false,
      "examples": [
        {
          "title": "Basic Usage",
          "code": "s = 'Hello World'\nprint(s.swapcase())",
          "expected_output": "hELLO wORLD"
        },
        {
          "title": "Mixed Case with Numbers and Symbols",
          "code": "s = 'AbC123!@#'\nprint(s.swapcase())",
          "expected_output": "aBc123!@#"
        },
        {
          "title": "Unicode Characters",
          "code": "s = 'Ãœber CafÃ©'\nprint(s.swapcase())",
          "expected_output": "Ã¼BER cAFÃ‰"
        }
      ],
      "performance_considerations": "swapcase() has a time complexity of O(n), where n is the length of the string. It's generally efficient for most use cases.",
      "common_pitfalls": "Be aware that swapcase() may not always produce the expected results for all Unicode characters. Some characters don't have both uppercase and lowercase versions, or the relationship between cases may be complex. For critical applications involving international text, consider using more specialized Unicode libraries."
    },
    {
      "name": "title",
      "module": "builtins",
      "class_name": "str",
      "data_structure": "string",
      "return_type": "str",
      "parameters": [],
      "docstring": "Return a titlecased version of the string where words start with an uppercase character and the remaining characters are lowercase.",
      "extended_description": "The title() method returns a string where the first character of each word is uppercase and the remaining characters are lowercase. Words are separated by whitespace characters (space, tab, newline, etc.) or by specified unicode separators.",
      "decorators": [],
      "main_category": "String Operations",
      "sub_category": "Case Conversion",
      "data_type_manipulated": ["string"],
      "version_added": "1.0",
      "deprecated": false,
      "examples": [
        {
          "title": "Basic Usage",
          "code": "s = 'hello world'\nprint(s.title())",
          "expected_output": "Hello World"
        },
        {
          "title": "Mixed Case Input",
          "code": "s = 'PYTHON programming LANGuage'\nprint(s.title())",
          "expected_output": "Python Programming Language"
        },
        {
          "title": "With Numbers and Apostrophes",
          "code": "s = \"what's python 3.0?\"\nprint(s.title())",
          "expected_output": "What'S Python 3.0?"
        },
        {
          "title": "With Hyphenated Words",
          "code": "s = 'pro-actively re-engineer'\nprint(s.title())",
          "expected_output": "Pro-Actively Re-Engineer"
        }
      ],
      "performance_considerations": "title() has a time complexity of O(n), where n is the length of the string. It's generally efficient for most use cases.",
      "common_pitfalls": "Be aware that title() may not always produce grammatically correct results, especially with apostrophes and certain compound words. For more precise control, you might need to implement custom logic or use third-party libraries designed for proper title case conversion."
    },
    {
      "name": "translate",
      "module": "builtins",
      "class_name": "str",
      "data_structure": "string",
      "return_type": "str",
      "parameters": [
        {
          "name": "table",
          "type": "Union[dict, str]",
          "description": "A translation table that maps Unicode ordinals to Unicode ordinals, strings, or None"
        }
      ],
      "docstring": "Return a copy of the string in which each character has been mapped through the given translation table.",
      "extended_description": "The translate() method returns a string where each character has been mapped through the given translation table. The table must be a mapping of Unicode ordinals to Unicode ordinals, strings, or None. If a character is mapped to None, it is deleted from the string.",
      "decorators": [],
      "main_category": "String Operations",
      "sub_category": "Translation",
      "data_type_manipulated": ["string"],
      "version_added": "1.0",
      "deprecated": false,
      "examples": [
        {
          "title": "Basic Usage - Vowel Replacement",
          "code": "trans = str.maketrans('aeiou', '12345')\ns = 'hello'\nprint(s.translate(trans))",
          "expected_output": "h2ll4"
        },
        {
          "title": "Removing Specific Characters",
          "code": "trans = str.maketrans('', '', 'aeiou')\ns = 'hello world'\nprint(s.translate(trans))",
          "expected_output": "hll wrld"
        },
        {
          "title": "Using a Dictionary",
          "code": "trans = {97: '@', 101: '3', 105: '1'}\ns = 'elite'\nprint(s.translate(trans))",
          "expected_output": "3l1t3"
        },
        {
          "title": "Combining Replacement and Removal",
          "code": "trans = str.maketrans({'a': '@', 'e': '3', 'i': '1'}, ' ')\ns = 'hello world'\nprint(s.translate(trans))",
          "expected_output": "h3llo@world"
        }
      ],
      "performance_considerations": "translate() has a time complexity of O(n), where n is the length of the string. It's generally more efficient than using multiple replace() operations for complex substitutions.",
      "common_pitfalls": "Remember that the translation table works with Unicode ordinals, not characters. When using a dictionary for translation, the keys should be ordinals (integers), not characters. Also, be cautious when working with non-ASCII characters, as their behavior might be unexpected."
    },
    {
      "name": "upper",
      "module": "builtins",
      "class_name": "str",
      "data_structure": "string",
      "return_type": "str",
      "parameters": [],
      "docstring": "Return a copy of the string converted to uppercase.",
      "extended_description": "The upper() method returns a new string where all characters are converted to uppercase. Characters that are already uppercase or are not alphabetic remain unchanged.",
      "decorators": [],
      "main_category": "String Operations",
      "sub_category": "Case Conversion",
      "data_type_manipulated": ["string"],
      "version_added": "1.0",
      "deprecated": false,
      "examples": [
        {
          "title": "Basic Usage",
          "code": "s = 'hello'\nprint(s.upper())",
          "expected_output": "HELLO"
        },
        {
          "title": "Mixed Case with Numbers and Symbols",
          "code": "s = 'Hello, World! 123'\nprint(s.upper())",
          "expected_output": "HELLO, WORLD! 123"
        },
        {
          "title": "Non-English Characters",
          "code": "s = 'CafÃ© Ã¼ber straÃŸe'\nprint(s.upper())",
          "expected_output": "CAFÃ‰ ÃœBER STRASSE"
        },
        {
          "title": "Empty String",
          "code": "s = ''\nprint(s.upper())",
          "expected_output": ""
        }
      ],
      "performance_considerations": "upper() has a time complexity of O(n), where n is the length of the string. It's generally efficient for most use cases.",
      "common_pitfalls": "Be aware that upper() may not produce the expected results for all Unicode characters. Some languages have unique uppercase rules or characters that don't have uppercase versions. For critical applications involving international text, consider using more specialized Unicode libraries or locale-aware methods."
    },
    {
      "name": "dir",
      "module": "builtins",
      "class_name": null,
      "return_type": "List[str]",
      "parameters": [
        {
          "name": "object",
          "type": "Optional[Any]",
          "description": "The object to inspect. If omitted, returns names from the current local scope."
        }
      ],
      "docstring": "Return a list of valid attributes for the given object.",
      "extended_description": "The dir() function returns a list of valid attributes and methods of the specified object. If no argument is given, it returns the list of names in the current local scope. The resulting list is sorted alphabetically. For most objects, dir() lists all attributes of the object, including those inherited from its class and its class's base classes.",
      "decorators": [],
      "main_category": "Introspection",
      "sub_category": "Object Information",
      "data_type_manipulated": ["Any"],
      "version_added": "1.0",
      "deprecated": false,
      "examples": [
        {
          "title": "Listing Local Scope",
          "code": "x = 1\ndef func():\n    pass\nprint(dir())",
          "expected_output": "['__builtins__', '__doc__', '__name__', 'func', 'x']"
        },
        {
          "title": "Inspecting a Built-in Type",
          "code": "print(dir(str))",
          "expected_output": "['__add__', '__class__', '__contains__', ..., 'zfill']"
        },
        {
          "title": "Inspecting a Custom Class",
          "code": "class MyClass:\n    def __init__(self):\n        self.x = 1\n    def method(self):\n        pass\n\nobj = MyClass()\nprint(dir(obj))",
          "expected_output": "['__class__', '__delattr__', ..., 'method', 'x']"
        },
        {
          "title": "Inspecting a Module",
          "code": "import math\nprint(dir(math))",
          "expected_output": "['__doc__', '__loader__', ..., 'pi', 'sin', 'sqrt']"
        }
      ],
      "performance_considerations": "dir() is generally fast for most objects, but its performance can vary depending on the complexity of the object being inspected. For large classes or modules with many attributes, it may take longer to execute.",
      "common_pitfalls": [
        "dir() may not show all attributes for objects that implement __dir__() method, as this method can customize the list of attributes returned.",
        "Some attributes returned by dir() might not be accessible due to privacy settings or other restrictions.",
        "dir() does not distinguish between methods, properties, and other types of attributes."
      ],
      "related_functions": ["vars", "type", "isinstance", "hasattr"],
      "notes": [
        "The dir() function is commonly used for debugging and exploring objects interactively.",
        "For classes, dir() will include methods from parent classes.",
        "The output of dir() can be useful for implementing autocomplete features in development environments.",
        "When used without arguments in a function, dir() will show local variables."
      ],
      "special_behavior": {
        "modules": "For modules, dir() does not list submodules that may have been imported.",
        "classes": "For classes, dir() includes class methods, static methods, and properties.",
        "instances": "For instances, dir() includes both instance variables and methods defined in the class."
      },
      "use_cases": [
        "Debugging: Quickly inspect available attributes and methods of an object.",
        "Introspection: Dynamically explore the capabilities of objects at runtime.",
        "Documentation: Generate lists of available attributes for API documentation.",
        "REPL environments: Explore objects interactively in Python shells."
      ]
    },
    {
      "name": "zfill",
      "module": "builtins",
      "class_name": "str",
      "data_structure": "string",
      "return_type": "str",
      "parameters": [
        {
          "name": "width",
          "type": "int",
          "description": "The desired width of the resulting string"
        }
      ],
      "docstring": "Return a copy of the string left filled with ASCII '0' digits to make a string of length width.",
      "extended_description": "The zfill() method returns a copy of the string padded on the left with zeros ('0') to fill the specified width. If the string is already longer than the specified width, it is returned unchanged. The method preserves any sign prefix ('+' or '-') by moving it to the beginning of the resulting string.",
      "decorators": [],
      "main_category": "String Operations",
      "sub_category": "Formatting",
      "data_type_manipulated": ["string"],
      "version_added": "2.2.2",
      "deprecated": false,
      "examples": [
        {
          "title": "Basic Usage",
          "code": "s = '42'\nprint(s.zfill(5))",
          "expected_output": "00042"
        },
        {
          "title": "With Negative Number",
          "code": "s = '-42'\nprint(s.zfill(6))",
          "expected_output": "-00042"
        },
        {
          "title": "String Longer Than Width",
          "code": "s = '12345'\nprint(s.zfill(3))",
          "expected_output": "12345"
        },
        {
          "title": "With Decimal Point",
          "code": "s = '3.14'\nprint(s.zfill(7))",
          "expected_output": "0003.14"
        },
        {
          "title": "With Non-Numeric String",
          "code": "s = 'abc'\nprint(s.zfill(5))",
          "expected_output": "00abc"
        }
      ],
      "performance_considerations": "zfill() has a time complexity of O(n), where n is the width specified. It's generally efficient for most use cases, especially when working with numeric strings.",
      "common_pitfalls": "Remember that zfill() only adds zeros to the left of the string. If you need to add zeros after a decimal point for numeric formatting, you should use other formatting methods like f-strings or the format() method. Also, be aware that zfill() doesn't validate if the string represents a valid number; it will add zeros to any string.",
      "related_functions": ["rjust", "ljust", "center"],
      "notes": [
        "zfill() is particularly useful for padding numeric strings, especially when working with fixed-width fields.",
        "For more complex numeric formatting, consider using the format() method or f-strings.",
        "zfill() preserves any existing sign (+ or -) by moving it to the left of the zero padding."
      ]
    }
      

      
]