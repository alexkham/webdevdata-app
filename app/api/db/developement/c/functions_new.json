[
  {
    "function_name": "abort",
    "include_file": "stdlib.h",
    "return_type": "void",
    "parameter_types": [],
    "main_category": "Error Handling and Debugging",
    "sub_category": "Process Termination",
    "data_type_manipulated": "none",
    "description": "Causes abnormal program termination.",
    "extended_description": "The abort function raises the SIGABRT signal, which by default causes the program to terminate abnormally. This function is typically used to handle critical errors where normal program flow cannot continue. It does not perform any clean-up operations or buffer flushing. Once abort has been called, the program terminates immediately and does not return control to the caller.",
    "return_value": "This function does not return as it terminates the program.",
    "parameter_values": "This function takes no parameters. It can be called without any arguments to immediately terminate the program.",
    "function_prototype": "void abort(void);",
    "examples": [
      {
        "title": "Basic Usage",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    printf(\"Program starting...\\n\");\n    abort();\n    printf(\"This line will never be executed.\\n\");\n    return 0;\n}",
        "explanation": "This example demonstrates the basic usage of the `abort` function. It immediately terminates the program, and any code after the `abort()` call is not executed.",
        "expectedOutput": "Program starting...\nAborted (core dumped)"
      },
      {
        "title": "Using abort in error handling",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint divide(int a, int b) {\n    if (b == 0) {\n        fprintf(stderr, \"Error: Division by zero!\\n\");\n        abort();\n    }\n    return a / b;\n}\n\nint main() {\n    printf(\"10 / 2 = %d\\n\", divide(10, 2));\n    printf(\"10 / 0 = %d\\n\", divide(10, 0));\n    printf(\"This line will never be executed.\\n\");\n    return 0;\n}",
        "explanation": "This example shows how `abort` can be used in error handling. When a division by zero is attempted, the program prints an error message and then terminates using `abort`.",
        "expectedOutput": "10 / 2 = 5\nError: Division by zero!\nAborted (core dumped)"
      }
    ]
  },
  {
    "function_name": "abs",
    "include_file": "stdlib.h",
    "return_type": "int",
    "parameter_types": ["int"],
    "main_category": "Mathematical Operations",
    "sub_category": "Basic Computation",
    "data_type_manipulated": "integers",
    "description": "Computes the absolute value of an integer.",
    "extended_description": "The abs function computes the absolute value of an integer number. It returns the non-negative value of an integer. For positive numbers and zero, it returns the same number. For negative numbers, it returns the negation of that number. This function is commonly used when the magnitude of a number is needed, regardless of its sign.",
    "return_value": "Returns the absolute value of the input integer. The returned value is always non-negative.",
    "parameter_values": "This function takes one parameter: an integer value for which the absolute value is to be computed.",
    "function_prototype": "int abs(int n);",
    "examples": [
      {
        "title": "Basic Usage",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    printf(\"abs(5) = %d\\n\", abs(5));\n    printf(\"abs(-5) = %d\\n\", abs(-5));\n    printf(\"abs(0) = %d\\n\", abs(0));\n    return 0;\n}",
        "explanation": "This example demonstrates the basic usage of the `abs` function with positive, negative, and zero values.",
        "expectedOutput": "abs(5) = 5\nabs(-5) = 5\nabs(0) = 0"
      },
      {
        "title": "Edge Case: INT_MIN",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint main() {\n    printf(\"abs(INT_MIN) = %d\\n\", abs(INT_MIN));\n    return 0;\n}",
        "explanation": "This example shows the behavior of `abs` with INT_MIN, which is a special case because its absolute value cannot be represented as a positive int.",
        "expectedOutput": "abs(INT_MIN) = -2147483648"
      }
    ]
  },
  {
    "function_name": "acos",
    "include_file": "math.h",
    "return_type": "double",
    "parameter_types": ["double"],
    "main_category": "Mathematical Operations",
    "sub_category": "Advanced Computation",
    "data_type_manipulated": "floating-point numbers",
    "description": "Calculates the arc cosine of the specified number.",
    "extended_description": "The acos function, also known as the inverse cosine function, takes a number between -1 and 1 and returns the angle whose cosine is equal to that number. The result is given in radians, within the range from 0 to π (0 to 180 degrees). If the input is outside the valid range, the function cannot calculate an angle and instead returns NaN, indicating an invalid result.",
    "return_value": "Returns the arc cosine of the input value, in radians, in the range [0, π]. If the input is outside the range [-1, 1], it returns NaN.",
    "parameter_values": "This function takes one parameter: a double value representing the cosine of an angle, which should be in the range [-1, 1].",
    "function_prototype": "double acos(double x);",
    "examples": [
      {
        "title": "Basic Usage",
        "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    printf(\"acos(1) = %.6f radians\\n\", acos(1));\n    printf(\"acos(0) = %.6f radians\\n\", acos(0));\n    printf(\"acos(-1) = %.6f radians\\n\", acos(-1));\n    return 0;\n}",
        "explanation": "This example demonstrates the basic usage of the `acos` function with different input values within the valid range.",
        "expectedOutput": "acos(1) = 0.000000 radians\nacos(0) = 1.570796 radians\nacos(-1) = 3.141593 radians"
      },
      {
        "title": "Edge Case: Out of Range",
        "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    printf(\"acos(1.1) = %.6f\\n\", acos(1.1));\n    printf(\"acos(-1.1) = %.6f\\n\", acos(-1.1));\n    return 0;\n}",
        "explanation": "This example shows what happens when `acos` is called with values outside its valid input range.",
        "expectedOutput": "acos(1.1) = nan\nacos(-1.1) = nan"
      }
    ]
  },
  {
    "function_name": "asctime",
    "include_file": "time.h",
    "return_type": "char*",
    "parameter_types": ["const struct tm*"],
    "main_category": "Time and Date Management",
    "sub_category": "Conversion and Calculation",
    "data_type_manipulated": "strings",
    "description": "Converts a time structure to a string representation.",
    "extended_description": "The asctime function converts a time structure (struct tm) to a string representation. It returns a pointer to a static character string of the form: 'Day Mon dd hh:mm:ss yyyy\\n'. Note that this function is not thread-safe as it returns a pointer to a static buffer. For a thread-safe version, consider using asctime_r or strftime.",
    "return_value": "Returns a pointer to a null-terminated string containing the date and time information in a standard format. This pointer is to a static buffer that may be overwritten by subsequent calls to asctime.",
    "parameter_values": "This function takes one parameter: a pointer to a struct tm that contains a calendar time broken down into its components.",
    "function_prototype": "char *asctime(const struct tm *timeptr);",
    "examples": [
      {
        "title": "Basic Usage",
        "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    time_t rawtime;\n    struct tm *timeinfo;\n\n    time(&rawtime);\n    timeinfo = localtime(&rawtime);\n    printf(\"Current local time and date: %s\", asctime(timeinfo));\n\n    return 0;\n}",
        "explanation": "This example demonstrates the basic usage of the `asctime` function to convert the current local time to a string representation.",
        "expectedOutput": "Current local time and date: Wed Jul 03 12:34:56 2024\n"
      },
      {
        "title": "Custom Time",
        "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    struct tm custom_time = {0};\n    custom_time.tm_year = 120;  // Year 2020 (1900 + 120)\n    custom_time.tm_mon = 0;     // January (0-11)\n    custom_time.tm_mday = 1;    // 1st day of the month\n    custom_time.tm_hour = 12;   // 12 PM\n    custom_time.tm_min = 0;\n    custom_time.tm_sec = 0;\n\n    printf(\"Custom time: %s\", asctime(&custom_time));\n\n    return 0;\n}",
        "explanation": "This example shows how to use `asctime` with a custom time structure.",
        "expectedOutput": "Custom time: Wed Jan 01 12:00:00 2020\n"
      }
    ]
  },
  
    {
      "function_name": "asctime_r",
      "include_file": "time.h",
      "return_type": "char*",
      "parameter_types": ["const struct tm*", "char*"],
      "main_category": "Time and Date Management",
      "sub_category": "Conversion and Calculation",
      "data_type_manipulated": "strings",
      "description": "Thread-safe version of asctime.",
      "extended_description": "The asctime_r function is a thread-safe version of asctime. It converts a time structure (struct tm) to a string representation and stores the result in a user-provided buffer. This function is reentrant and can be used safely in multi-threaded programs. The resulting string has the form 'Day Mon dd hh:mm:ss yyyy\\n'.",
      "return_value": "Returns a pointer to the string result if successful, or NULL if an error occurred.",
      "parameter_values": "This function takes two parameters: a pointer to a struct tm that contains a calendar time broken down into its components, and a pointer to a character array where the resulting string will be stored. The buffer should be at least 26 bytes long.",
      "function_prototype": "char *asctime_r(const struct tm *tm, char *buf);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    time_t rawtime;\n    struct tm *timeinfo;\n    char buffer[26];\n\n    time(&rawtime);\n    timeinfo = localtime(&rawtime);\n    \n    if (asctime_r(timeinfo, buffer) != NULL) {\n        printf(\"Current local time and date: %s\", buffer);\n    } else {\n        printf(\"Error converting time to string\\n\");\n    }\n\n    return 0;\n}",
          "explanation": "This example demonstrates the basic usage of the `asctime_r` function to convert the current local time to a string representation in a thread-safe manner.",
          "expectedOutput": "Current local time and date: Wed Jul 03 12:34:56 2024\n"
        },
        {
          "title": "Custom Time with Error Checking",
          "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    struct tm custom_time = {0};\n    char buffer[26];\n\n    custom_time.tm_year = 120;  // Year 2020 (1900 + 120)\n    custom_time.tm_mon = 0;     // January (0-11)\n    custom_time.tm_mday = 1;    // 1st day of the month\n    custom_time.tm_hour = 12;   // 12 PM\n    custom_time.tm_min = 0;\n    custom_time.tm_sec = 0;\n\n    if (asctime_r(&custom_time, buffer) != NULL) {\n        printf(\"Custom time: %s\", buffer);\n    } else {\n        printf(\"Error converting time to string\\n\");\n    }\n\n    return 0;\n}",
          "explanation": "This example shows how to use `asctime_r` with a custom time structure and includes error checking.",
          "expectedOutput": "Custom time: Wed Jan 01 12:00:00 2020\n"
        }
      ]
    },
    {
      "function_name": "asin",
      "include_file": "math.h",
      "return_type": "double",
      "parameter_types": ["double"],
      "main_category": "Mathematical Operations",
      "sub_category": "Advanced Computation",
      "data_type_manipulated": "floating-point numbers",
      "description": "Calculates the arc sine of the specified number.",
      "extended_description": "The asin function computes the principal value of the arc sine of the input. The arc sine is the inverse function of sine. This function expects the input to be in the range [-1, 1], and it returns a value in the range [-π/2, π/2]. If the input is outside the range [-1, 1], the function returns NaN (Not a Number).",
      "return_value": "Returns the arc sine of the input value, in radians, in the range [-π/2, π/2]. If the input is outside the range [-1, 1], it returns NaN.",
      "parameter_values": "This function takes one parameter: a double value representing the sine of an angle, which should be in the range [-1, 1].",
      "function_prototype": "double asin(double x);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    printf(\"asin(0) = %.6f radians\\n\", asin(0));\n    printf(\"asin(1) = %.6f radians\\n\", asin(1));\n    printf(\"asin(-1) = %.6f radians\\n\", asin(-1));\n    return 0;\n}",
          "explanation": "This example demonstrates the basic usage of the `asin` function with different input values within the valid range.",
          "expectedOutput": "asin(0) = 0.000000 radians\nasin(1) = 1.570796 radians\nasin(-1) = -1.570796 radians"
        },
        {
          "title": "Edge Case: Out of Range",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    printf(\"asin(1.1) = %.6f\\n\", asin(1.1));\n    printf(\"asin(-1.1) = %.6f\\n\", asin(-1.1));\n    return 0;\n}",
          "explanation": "This example shows what happens when `asin` is called with values outside its valid input range.",
          "expectedOutput": "asin(1.1) = nan\nasin(-1.1) = nan"
        }
      ]
    },
    {
      "function_name": "assert",
      "include_file": "assert.h",
      "return_type": "void",
      "parameter_types": ["int"],
      "main_category": "Error Handling and Debugging",
      "sub_category": "Program Validation",
      "data_type_manipulated": "none",
      "description": "Tests the given condition and causes a program abort if false.",
      "extended_description": "The assert macro is used to verify assumptions made by the program and print a diagnostic message if this assumption is false. If the assertion fails, the program will terminate by calling abort(). Assertions are often used to check for programming errors and should not be used to handle expected runtime errors. In release builds, assertions can be disabled by defining the NDEBUG macro.",
      "return_value": "This macro does not return a value. If the assertion fails, the program terminates.",
      "parameter_values": "This macro takes one parameter: an integer expression that is expected to be true. If the expression evaluates to 0 (false), the assertion fails.",
      "function_prototype": "void assert(int expression);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <assert.h>\n\nint divide(int a, int b) {\n    assert(b != 0);  // Ensure we're not dividing by zero\n    return a / b;\n}\n\nint main() {\n    printf(\"10 / 2 = %d\\n\", divide(10, 2));\n    printf(\"10 / 0 = %d\\n\", divide(10, 0));\n    return 0;\n}",
          "explanation": "This example demonstrates the basic usage of the `assert` macro to check for a division by zero error. The program will run normally for the first division, but will terminate when attempting to divide by zero.",
          "expectedOutput": "10 / 2 = 5\nAssertion failed: b != 0, file example.c, line 5\nAborted (core dumped)"
        },
        {
          "title": "Disabling Assertions",
          "code": "#define NDEBUG  // Disable assertions\n#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int x = 0;\n    assert(x != 0);  // This assertion will be ignored\n    printf(\"x = %d\\n\", x);\n    return 0;\n}",
          "explanation": "This example shows how to disable assertions by defining the NDEBUG macro. The assertion in this program will be ignored, and the program will run to completion even though the assertion condition is false.",
          "expectedOutput": "x = 0"
        }
      ]
    },

    
      {
        "function_name": "atan",
        "include_file": "math.h",
        "return_type": "double",
        "parameter_types": ["double"],
        "main_category": "Mathematical Operations",
        "sub_category": "Advanced Computation",
        "data_type_manipulated": "floating-point numbers",
        "description": "Calculates the arc tangent of the specified number.",
        "extended_description": "The atan function computes the principal value of the arc tangent of the input. The arc tangent is the inverse function of tangent. This function can take any real number as input and returns a value in the range [-π/2, π/2]. It's particularly useful when you need to find an angle from a ratio of sides in a right-angled triangle.",
        "return_value": "Returns the arc tangent of the input value, in radians, in the range [-π/2, π/2].",
        "parameter_values": "This function takes one parameter: a double value representing the tangent of an angle. This can be any real number.",
        "function_prototype": "double atan(double x);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    printf(\"atan(0) = %.6f radians\\n\", atan(0));\n    printf(\"atan(1) = %.6f radians\\n\", atan(1));\n    printf(\"atan(-1) = %.6f radians\\n\", atan(-1));\n    return 0;\n}",
            "explanation": "This example demonstrates the basic usage of the `atan` function with different input values.",
            "expectedOutput": "atan(0) = 0.000000 radians\natan(1) = 0.785398 radians\natan(-1) = -0.785398 radians"
          },
          {
            "title": "Using atan with large values",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    printf(\"atan(1000000) = %.6f radians\\n\", atan(1000000));\n    printf(\"atan(-1000000) = %.6f radians\\n\", atan(-1000000));\n    return 0;\n}",
            "explanation": "This example shows how `atan` behaves with very large positive and negative values, demonstrating its asymptotic behavior.",
            "expectedOutput": "atan(1000000) = 1.570796 radians\natan(-1000000) = -1.570796 radians"
          }
        ]
      },
      {
        "function_name": "atan2",
        "include_file": "math.h",
        "return_type": "double",
        "parameter_types": ["double", "double"],
        "main_category": "Mathematical Operations",
        "sub_category": "Advanced Computation",
        "data_type_manipulated": "floating-point numbers",
        "description": "Calculates the arc tangent of two variables representing the quotient.",
        "extended_description": "The atan2 function computes the principal value of the arc tangent of y/x, using the signs of both arguments to determine the quadrant of the return value. It is similar to calculating the arc tangent of y/x, but it has a wider range of validity and is more robust. This function returns a value in the range [-π, π].",
        "return_value": "Returns the arc tangent of y/x, in radians, in the range [-π, π].",
        "parameter_values": "This function takes two parameters: y and x, both of type double. These represent the y and x coordinates of a point, respectively. The function essentially computes the angle this point makes with the positive x-axis.",
        "function_prototype": "double atan2(double y, double x);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    printf(\"atan2(1, 1) = %.6f radians\\n\", atan2(1, 1));\n    printf(\"atan2(-1, 1) = %.6f radians\\n\", atan2(-1, 1));\n    printf(\"atan2(-1, -1) = %.6f radians\\n\", atan2(-1, -1));\n    printf(\"atan2(1, -1) = %.6f radians\\n\", atan2(1, -1));\n    return 0;\n}",
            "explanation": "This example demonstrates the basic usage of the `atan2` function with points in all four quadrants.",
            "expectedOutput": "atan2(1, 1) = 0.785398 radians\natan2(-1, 1) = -0.785398 radians\natan2(-1, -1) = -2.356194 radians\natan2(1, -1) = 2.356194 radians"
          },
          {
            "title": "Special Cases",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    printf(\"atan2(0, 1) = %.6f radians\\n\", atan2(0, 1));\n    printf(\"atan2(1, 0) = %.6f radians\\n\", atan2(1, 0));\n    printf(\"atan2(0, -1) = %.6f radians\\n\", atan2(0, -1));\n    printf(\"atan2(-1, 0) = %.6f radians\\n\", atan2(-1, 0));\n    return 0;\n}",
            "explanation": "This example shows how `atan2` handles special cases, including when x or y is zero.",
            "expectedOutput": "atan2(0, 1) = 0.000000 radians\natan2(1, 0) = 1.570796 radians\natan2(0, -1) = 3.141593 radians\natan2(-1, 0) = -1.570796 radians"
          }
        ]
      },
      {
        "function_name": "atexit",
        "include_file": "stdlib.h",
        "return_type": "int",
        "parameter_types": ["void (*)()"],
        "main_category": "Error Handling and Debugging",
        "sub_category": "Process Termination",
        "data_type_manipulated": "none",
        "description": "Registers a function to be called at program termination.",
        "extended_description": "The atexit function registers the given function to be called automatically when the program terminates normally. This is useful for performing cleanup operations, closing files, or freeing resources. Multiple functions can be registered, and they will be called in the reverse order of their registration. The registered functions should not use their return value and should not take any parameters.",
        "return_value": "Returns 0 if the function is successfully registered, non-zero if it fails.",
        "parameter_values": "This function takes one parameter: a pointer to a function that takes no arguments and returns void. This is the function that will be called at program termination.",
        "function_prototype": "int atexit(void (*function)(void));",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid cleanup1(void) {\n    printf(\"Cleanup function 1 called\\n\");\n}\n\nvoid cleanup2(void) {\n    printf(\"Cleanup function 2 called\\n\");\n}\n\nint main() {\n    atexit(cleanup1);\n    atexit(cleanup2);\n    \n    printf(\"Main function executing\\n\");\n    \n    return 0;\n}",
            "explanation": "This example demonstrates registering multiple functions with `atexit`. These functions will be called in reverse order when the program terminates.",
            "expectedOutput": "Main function executing\nCleanup function 2 called\nCleanup function 1 called"
          },
          {
            "title": "Error Handling",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid cleanup(void) {\n    printf(\"Cleanup function called\\n\");\n}\n\nint main() {\n    if (atexit(cleanup) != 0) {\n        fprintf(stderr, \"Failed to register cleanup function\\n\");\n        return 1;\n    }\n    \n    printf(\"Main function executing\\n\");\n    \n    return 0;\n}",
            "explanation": "This example shows how to handle potential errors when registering a function with `atexit`.",
            "expectedOutput": "Main function executing\nCleanup function called"
          }
        ]
      },
      
        {
          "function_name": "atof",
          "include_file": "stdlib.h",
          "return_type": "double",
          "parameter_types": ["const char*"],
          "main_category": "Data Conversion and Formatting",
          "sub_category": "Type Conversion",
          "data_type_manipulated": "floating-point numbers",
          "description": "Converts a string to a floating-point number.",
          "extended_description": "The atof function converts the initial portion of the string pointed to by str to a double. The function discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid floating-point number representation and converts them to a double value. The rest of the string is ignored.",
          "return_value": "Returns the converted double value. If no valid conversion could be performed, it returns 0.0.",
          "parameter_values": "This function takes one parameter: a pointer to a null-terminated string of characters that represents a floating-point number.",
          "function_prototype": "double atof(const char *str);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char *str1 = \"3.14159\";\n    char *str2 = \"  -2.718\";\n    char *str3 = \"invalid\";\n    \n    printf(\"%s -> %f\\n\", str1, atof(str1));\n    printf(\"%s -> %f\\n\", str2, atof(str2));\n    printf(\"%s -> %f\\n\", str3, atof(str3));\n    \n    return 0;\n}",
              "explanation": "This example demonstrates the basic usage of the `atof` function with different input strings, including a positive number, a negative number with leading whitespace, and an invalid input.",
              "expectedOutput": "3.14159 -> 3.141590\n  -2.718 -> -2.718000\ninvalid -> 0.000000"
            },
            {
              "title": "Handling Special Cases",
              "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char *str1 = \"INF\";\n    char *str2 = \"-INF\";\n    char *str3 = \"NAN\";\n    char *str4 = \"1.23e-4\";\n    \n    printf(\"%s -> %f\\n\", str1, atof(str1));\n    printf(\"%s -> %f\\n\", str2, atof(str2));\n    printf(\"%s -> %f\\n\", str3, atof(str3));\n    printf(\"%s -> %f\\n\", str4, atof(str4));\n    \n    return 0;\n}",
              "explanation": "This example shows how `atof` handles special cases like infinity, negative infinity, NaN (Not a Number), and scientific notation.",
              "expectedOutput": "INF -> inf\n-INF -> -inf\nNAN -> nan\n1.23e-4 -> 0.000123"
            }
          ]
        },
        {
          "function_name": "atoi",
          "include_file": "stdlib.h",
          "return_type": "int",
          "parameter_types": ["const char*"],
          "main_category": "Data Conversion and Formatting",
          "sub_category": "Type Conversion",
          "data_type_manipulated": "integers",
          "description": "Converts a string to an integer.",
          "extended_description": "The atoi function converts the initial portion of the string pointed to by str to an integer representation. It skips any whitespace characters at the beginning of the string, then takes an optional plus or minus sign followed by as many base-10 digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.",
          "return_value": "Returns the converted integer value. If no valid conversion could be performed, it returns 0.",
          "parameter_values": "This function takes one parameter: a pointer to a null-terminated string of characters that represents an integer.",
          "function_prototype": "int atoi(const char *str);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char *str1 = \"123\";\n    char *str2 = \"  -456\";\n    char *str3 = \"789abc\";\n    char *str4 = \"invalid\";\n    \n    printf(\"%s -> %d\\n\", str1, atoi(str1));\n    printf(\"%s -> %d\\n\", str2, atoi(str2));\n    printf(\"%s -> %d\\n\", str3, atoi(str3));\n    printf(\"%s -> %d\\n\", str4, atoi(str4));\n    \n    return 0;\n}",
              "explanation": "This example demonstrates the basic usage of the `atoi` function with different input strings, including a positive number, a negative number with leading whitespace, a number followed by non-numeric characters, and an invalid input.",
              "expectedOutput": "123 -> 123\n  -456 -> -456\n789abc -> 789\ninvalid -> 0"
            },
            {
              "title": "Handling Overflow",
              "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint main() {\n    char str[20];\n    \n    sprintf(str, \"%d\", INT_MAX);\n    printf(\"INT_MAX: %s -> %d\\n\", str, atoi(str));\n    \n    sprintf(str, \"%d\", INT_MIN);\n    printf(\"INT_MIN: %s -> %d\\n\", str, atoi(str));\n    \n    sprintf(str, \"%lld\", (long long)INT_MAX + 1);\n    printf(\"INT_MAX + 1: %s -> %d\\n\", str, atoi(str));\n    \n    return 0;\n}",
              "explanation": "This example shows how `atoi` handles cases at the limits of the int type and beyond. Note that behavior for out-of-range values is undefined and may vary between implementations.",
              "expectedOutput": "INT_MAX: 2147483647 -> 2147483647\nINT_MIN: -2147483648 -> -2147483648\nINT_MAX + 1: 2147483648 -> 2147483647"
            }
          ]
        },
        {
          "function_name": "atol",
          "include_file": "stdlib.h",
          "return_type": "long",
          "parameter_types": ["const char*"],
          "main_category": "Data Conversion and Formatting",
          "sub_category": "Type Conversion",
          "data_type_manipulated": "integers",
          "description": "Converts a string to a long integer.",
          "extended_description": "The atol function converts the initial portion of the string pointed to by str to a long integer representation. It operates similarly to atoi, but returns a long int instead of an int. It skips any whitespace characters at the beginning of the string, then takes an optional plus or minus sign followed by as many base-10 digits as possible, and interprets them as a numerical value.",
          "return_value": "Returns the converted long integer value. If no valid conversion could be performed, it returns 0L.",
          "parameter_values": "This function takes one parameter: a pointer to a null-terminated string of characters that represents a long integer.",
          "function_prototype": "long atol(const char *str);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char *str1 = \"1234567890\";\n    char *str2 = \"  -9876543210\";\n    char *str3 = \"123456789012345\";\n    char *str4 = \"invalid\";\n    \n    printf(\"%s -> %ld\\n\", str1, atol(str1));\n    printf(\"%s -> %ld\\n\", str2, atol(str2));\n    printf(\"%s -> %ld\\n\", str3, atol(str3));\n    printf(\"%s -> %ld\\n\", str4, atol(str4));\n    \n    return 0;\n}",
              "explanation": "This example demonstrates the basic usage of the `atol` function with different input strings, including a positive number, a negative number with leading whitespace, a very large number, and an invalid input.",
              "expectedOutput": "1234567890 -> 1234567890\n  -9876543210 -> -9876543210\n123456789012345 -> 123456789012345\ninvalid -> 0"
            },
            {
              "title": "Handling Overflow",
              "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint main() {\n    char str[30];\n    \n    sprintf(str, \"%ld\", LONG_MAX);\n    printf(\"LONG_MAX: %s -> %ld\\n\", str, atol(str));\n    \n    sprintf(str, \"%ld\", LONG_MIN);\n    printf(\"LONG_MIN: %s -> %ld\\n\", str, atol(str));\n    \n    sprintf(str, \"%lld\", (long long)LONG_MAX + 1);\n    printf(\"LONG_MAX + 1: %s -> %ld\\n\", str, atol(str));\n    \n    return 0;\n}",
              "explanation": "This example shows how `atol` handles cases at the limits of the long type and beyond. Note that behavior for out-of-range values is undefined and may vary between implementations.",
              "expectedOutput": "LONG_MAX: 9223372036854775807 -> 9223372036854775807\nLONG_MIN: -9223372036854775808 -> -9223372036854775808\nLONG_MAX + 1: 9223372036854775808 -> 9223372036854775807"
            }
          ]
        },
        {
          "function_name": "bsearch",
          "include_file": "stdlib.h",
          "return_type": "void*",
          "parameter_types": ["const void*", "const void*", "size_t", "size_t", "int (*)(const void*, const void*)"],
          "main_category": "Data Search and Sorting",
          "sub_category": "Search Algorithms",
          "data_type_manipulated": "generic pointers",
          "description": "Performs binary search over an array.",
          "extended_description": "The bsearch function searches an array of nmemb objects, the initial member of which is pointed to by base, for a member that matches the object pointed to by key. The size of each member is specified by size. The contents of the array should be in ascending sorted order according to the comparison function pointed to by compar. The function returns a pointer to a matching member of the array, or a null pointer if no match is found.",
          "return_value": "Returns a pointer to the matching element if found, or NULL if not found.",
          "parameter_values": "This function takes five parameters: key (pointer to the object to search for), base (pointer to the first object of the array to search), nmemb (number of elements in the array), size (size of each element), and compar (pointer to a comparison function).",
          "function_prototype": "void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare_ints(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int key = 5;\n    int *result;\n    \n    result = (int*)bsearch(&key, arr, n, sizeof(int), compare_ints);\n    \n    if (result != NULL)\n        printf(\"%d found at position %ld\\n\", key, (result - arr));\n    else\n        printf(\"%d not found in the array\\n\", key);\n    \n    return 0;\n}",
              "explanation": "This example demonstrates the basic usage of the `bsearch` function to search for an integer in a sorted array of integers.",
              "expectedOutput": "5 found at position 4"
            },
            {
              "title": "Searching Custom Structures",
              "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int id;\n    char name[20];\n} Person;\n\nint compare_persons(const void *a, const void *b) {\n    return ((Person*)a)->id - ((Person*)b)->id;\n}\n\nint main() {\n    Person people[] = {\n        {1, \"Alice\"},\n        {3, \"Bob\"},\n        {5, \"Charlie\"},\n        {7, \"David\"},\n        {9, \"Eve\"}\n    };\n    int n = sizeof(people) / sizeof(people[0]);\n    Person key = {5, \"\"};\n    Person *result;\n    \n    result = (Person*)bsearch(&key, people, n, sizeof(Person), compare_persons);\n    \n    if (result != NULL)\n        printf(\"Person with ID %d found: %s\\n\", key.id, result->name);\n    else\n        printf(\"Person with ID %d not found\\n\", key.id);\n    \n    return 0;\n}",
              "explanation": "This example shows how to use `bsearch` with custom structures, searching for a person by their ID in a sorted array of Person structures.",
              "expectedOutput": "Person with ID 5 found: Charlie"
            }
          ]
        },

        
          {
            "function_name": "btowc",
            "include_file": "wchar.h",
            "return_type": "wint_t",
            "parameter_types": ["int"],
            "main_category": "Character Type and Conversion",
            "sub_category": "Wide Character Conversion",
            "data_type_manipulated": "wide characters",
            "description": "Converts a single-byte character to a wide character.",
            "extended_description": "The btowc function determines the wide character corresponding to c, if c is a valid single-byte character in the initial shift state. This function is useful when working with mixed single-byte and wide character strings. It's important to note that this function is affected by the LC_CTYPE category of the current locale.",
            "return_value": "Returns the wide character corresponding to c if c is a valid single-byte character in the initial shift state. If c is EOF or if c is not a valid single-byte character in the initial shift state, the function returns WEOF.",
            "parameter_values": "This function takes one parameter: an int representing a single-byte character or EOF.",
            "function_prototype": "wint_t btowc(int c);",
            "examples": [
              {
                "title": "Basic Usage",
                "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");  // Set the locale to the system default\n\n    char c = 'A';\n    wint_t wc = btowc(c);\n\n    if (wc != WEOF) {\n        printf(\"'%c' converted to wide character: %lc\\n\", c, wc);\n    } else {\n        printf(\"Conversion failed\\n\");\n    }\n\n    return 0;\n}",
                "explanation": "This example demonstrates the basic usage of the `btowc` function to convert a single-byte character 'A' to its wide character equivalent.",
                "expectedOutput": "'A' converted to wide character: A"
              },
              {
                "title": "Handling Special Cases",
                "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");  // Set the locale to the system default\n\n    int values[] = {'A', 0xA0, EOF};\n    const char *labels[] = {\"Valid character\", \"Possibly invalid character\", \"EOF\"};\n\n    for (int i = 0; i < 3; i++) {\n        wint_t wc = btowc(values[i]);\n        if (wc != WEOF) {\n            printf(\"%s: '%c' converted to wide character: %lc\\n\", labels[i], values[i], wc);\n        } else {\n            printf(\"%s: Conversion failed\\n\", labels[i]);\n        }\n    }\n\n    return 0;\n}",
                "explanation": "This example shows how `btowc` handles different inputs: a valid ASCII character, a possibly invalid character (depending on the locale), and EOF.",
                "expectedOutput": "Valid character: 'A' converted to wide character: A\nPossibly invalid character: Conversion failed\nEOF: Conversion failed"
              }
            ]
          },
          {
            "function_name": "calloc",
            "include_file": "stdlib.h",
            "return_type": "void*",
            "parameter_types": ["size_t", "size_t"],
            "main_category": "Memory Management",
            "sub_category": "Allocation",
            "data_type_manipulated": "memory",
            "description": "Allocates memory for an array of elements, initializing them to zero.",
            "extended_description": "The calloc function allocates memory for an array of nmemb elements of size bytes each and returns a pointer to the allocated memory. The memory is set to zero. This function is particularly useful when you need an array of elements initialized to zero, as it combines allocation and initialization in one step.",
            "return_value": "Returns a pointer to the allocated memory if successful, or NULL if the memory allocation fails.",
            "parameter_values": "This function takes two parameters: nmemb (the number of elements to allocate) and size (the size of each element in bytes).",
            "function_prototype": "void *calloc(size_t nmemb, size_t size);",
            "examples": [
              {
                "title": "Basic Usage",
                "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr;\n    size_t n = 5;\n\n    // Allocate memory for 5 integers\n    arr = (int*)calloc(n, sizeof(int));\n\n    if (arr == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        return 1;\n    }\n\n    // Print the allocated array\n    for (size_t i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n\n    // Free the allocated memory\n    free(arr);\n\n    return 0;\n}",
                "explanation": "This example demonstrates the basic usage of `calloc` to allocate an array of integers. Note that all elements are initialized to zero.",
                "expectedOutput": "0 0 0 0 0"
              },
              {
                "title": "Allocating Structures",
                "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int id;\n    char name[20];\n} Person;\n\nint main() {\n    Person *people;\n    size_t n = 3;\n\n    // Allocate memory for 3 Person structures\n    people = (Person*)calloc(n, sizeof(Person));\n\n    if (people == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        return 1;\n    }\n\n    // Initialize the structures\n    for (size_t i = 0; i < n; i++) {\n        people[i].id = i + 1;\n        sprintf(people[i].name, \"Person %zu\", i + 1);\n    }\n\n    // Print the allocated structures\n    for (size_t i = 0; i < n; i++) {\n        printf(\"ID: %d, Name: %s\\n\", people[i].id, people[i].name);\n    }\n\n    // Free the allocated memory\n    free(people);\n\n    return 0;\n}",
                "explanation": "This example shows how to use `calloc` to allocate an array of structures. It demonstrates that while `calloc` initializes the memory to zero, we can still assign values to the allocated structures.",
                "expectedOutput": "ID: 1, Name: Person 1\nID: 2, Name: Person 2\nID: 3, Name: Person 3"
              }
            ]
          },
          {
            "function_name": "catclose",
            "include_file": "nl_types.h",
            "return_type": "int",
            "parameter_types": ["nl_catd"],
            "main_category": "System Interaction",
            "sub_category": "Localization Support",
            "data_type_manipulated": "catalog descriptors",
            "description": "Closes a message catalog.",
            "extended_description": "The catclose function closes the message catalog specified by the catalog descriptor catd. This function is used to free resources associated with an open message catalog. It's important to call this function when you're done using a catalog to prevent resource leaks.",
            "return_value": "Returns 0 if successful, or -1 if an error occurred (in which case, errno is set to indicate the error).",
            "parameter_values": "This function takes one parameter: catd (a catalog descriptor returned by a previous call to catopen).",
            "function_prototype": "int catclose(nl_catd catd);",
            "examples": [
              {
                "title": "Basic Usage",
                "code": "#include <stdio.h>\n#include <nl_types.h>\n\nint main() {\n    nl_catd catd;\n    \n    // Open a message catalog\n    catd = catopen(\"messages\", 0);\n    if (catd == (nl_catd)-1) {\n        perror(\"catopen\");\n        return 1;\n    }\n\n    // Use the catalog...\n\n    // Close the catalog\n    if (catclose(catd) == -1) {\n        perror(\"catclose\");\n        return 1;\n    }\n\n    printf(\"Message catalog closed successfully\\n\");\n    return 0;\n}",
                "explanation": "This example demonstrates the basic usage of `catclose` to close a message catalog that was previously opened with `catopen`.",
                "expectedOutput": "Message catalog closed successfully"
              },
              {
                "title": "Error Handling",
                "code": "#include <stdio.h>\n#include <nl_types.h>\n#include <errno.h>\n#include <string.h>\n\nint main() {\n    nl_catd catd;\n    \n    // Open a message catalog\n    catd = catopen(\"messages\", 0);\n    if (catd == (nl_catd)-1) {\n        fprintf(stderr, \"Error opening catalog: %s\\n\", strerror(errno));\n        return 1;\n    }\n\n    // Use the catalog...\n\n    // Close the catalog\n    if (catclose(catd) == -1) {\n        fprintf(stderr, \"Error closing catalog: %s\\n\", strerror(errno));\n        return 1;\n    }\n\n    printf(\"Message catalog closed successfully\\n\");\n    return 0;\n}",
                "explanation": "This example shows how to handle errors when using `catclose`. It uses strerror to print a descriptive error message if catclose fails.",
                "expectedOutput": "Message catalog closed successfully"
              }
            ]
          },
          {
            "function_name": "catgets",
            "include_file": "nl_types.h",
            "return_type": "char*",
            "parameter_types": ["nl_catd", "int", "int", "const char*"],
            "main_category": "System Interaction",
            "sub_category": "Localization Support",
            "data_type_manipulated": "strings",
            "description": "Reads a string from a message catalog.",
            "extended_description": "The catgets function retrieves a message string from an open message catalog. It attempts to retrieve the message corresponding to set_id and msg_id from the message catalog referenced by catd. If the message is found, catgets returns a pointer to the message string. If the message is not found, it returns a pointer to s.",
            "return_value": "Returns a pointer to the message string if found, or a pointer to s if the message is not found.",
            "parameter_values": "This function takes four parameters: catd (a catalog descriptor returned by catopen), set_id (the set identifier), msg_id (the message identifier within the set), and s (the default message string to be returned if the requested message is not found).",
            "function_prototype": "char *catgets(nl_catd catd, int set_id, int msg_id, const char *s);",
            "examples": [
              {
                "title": "Basic Usage",
                "code": "#include <stdio.h>\n#include <nl_types.h>\n\nint main() {\n    nl_catd catd;\n    char *message;\n\n    // Open the message catalog\n    catd = catopen(\"messages\", 0);\n    if (catd == (nl_catd)-1) {\n        perror(\"catopen\");\n        return 1;\n    }\n\n    // Retrieve a message\n    message = catgets(catd, 1, 1, \"Default message\");\n    printf(\"Retrieved message: %s\\n\", message);\n\n    // Close the catalog\n    if (catclose(catd) == -1) {\n        perror(\"catclose\");\n        return 1;\n    }\n\n    return 0;\n}",
                "explanation": "This example demonstrates the basic usage of `catgets` to retrieve a message from a catalog. If the message is not found, it will return the default message.",
                "expectedOutput": "Retrieved message: [Content of message 1 in set 1, or 'Default message' if not found]"
              },
              {
                "title": "Multiple Messages",
                "code": "#include <stdio.h>\n#include <nl_types.h>\n\nint main() {\n    nl_catd catd;\n    char *message;\n\n    catd = catopen(\"messages\", 0);\n    if (catd == (nl_catd)-1) {\n        perror(\"catopen\");\n        return 1;\n    }\n\n    // Retrieve multiple messages\n    message = catgets(catd, 1, 1, \"Hello\");\n    printf(\"Greeting: %s\\n\", message);\n\n    message = catgets(catd, 1, 2, \"Goodbye\");\n    printf(\"Farewell: %s\\n\", message);\n\n    message = catgets(catd, 2, 1, \"Error\");\n    printf(\"Error message: %s\\n\", message);\n\n    if (catclose(catd) == -1) {\n        perror(\"catclose\");\n        return 1;\n    }\n\n    return 0;\n}",
                "explanation": "This example shows how to retrieve multiple messages from different sets in the catalog. It demonstrates that if a message is not found, the default message is returned.",
                "expectedOutput": "Greeting: [Content of message 1 in set 1, or 'Hello' if not found]\nFarewell: [Content of message 2 in set 1, or 'Goodbye' if not found]\nError message: [Content of message 1 in set 2, or 'Error' if not found]"
              }
            ]
          },

          
            {
              "function_name": "catopen",
              "include_file": "nl_types.h",
              "return_type": "nl_catd",
              "parameter_types": ["const char*", "int"],
              "main_category": "System Interaction",
              "sub_category": "Localization Support",
              "data_type_manipulated": "catalog descriptors",
              "description": "Opens a message catalog.",
              "extended_description": "The catopen function opens a message catalog and returns a catalog descriptor. This descriptor can be used with subsequent calls to catgets to retrieve messages from the catalog. The function uses the NLSPATH environment variable to find the message catalog unless a full pathname is given. The oflag parameter is used to specify the type of access, usually set to 0 for default behavior.",
              "return_value": "Returns a catalog descriptor if successful, or (nl_catd) -1 if an error occurred (in which case, errno is set to indicate the error).",
              "parameter_values": "This function takes two parameters: name (a pointer to a string containing the name of the message catalog to open) and oflag (flag to specify the type of access, usually set to 0).",
              "function_prototype": "nl_catd catopen(const char *name, int oflag);",
              "examples": [
                {
                  "title": "Basic Usage",
                  "code": "#include <stdio.h>\n#include <nl_types.h>\n\nint main() {\n    nl_catd catd;\n    \n    // Open a message catalog\n    catd = catopen(\"messages\", 0);\n    if (catd == (nl_catd)-1) {\n        perror(\"catopen\");\n        return 1;\n    }\n\n    printf(\"Message catalog opened successfully\\n\");\n\n    // Use the catalog...\n\n    // Don't forget to close the catalog when done\n    if (catclose(catd) == -1) {\n        perror(\"catclose\");\n        return 1;\n    }\n\n    return 0;\n}",
                  "explanation": "This example demonstrates the basic usage of `catopen` to open a message catalog named 'messages'. It also shows proper error checking and closing of the catalog.",
                  "expectedOutput": "Message catalog opened successfully"
                },
                {
                  "title": "Using Environment Variables",
                  "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <nl_types.h>\n\nint main() {\n    nl_catd catd;\n    char *nlspath;\n    \n    // Set NLSPATH environment variable\n    nlspath = getenv(\"NLSPATH\");\n    if (nlspath == NULL) {\n        setenv(\"NLSPATH\", \"/usr/share/locale/%L/%N:/usr/local/share/locale/%L/%N\", 1);\n    }\n\n    // Open a message catalog\n    catd = catopen(\"myapp\", 0);\n    if (catd == (nl_catd)-1) {\n        perror(\"catopen\");\n        return 1;\n    }\n\n    printf(\"Message catalog 'myapp' opened successfully\\n\");\n\n    // Use the catalog...\n\n    if (catclose(catd) == -1) {\n        perror(\"catclose\");\n        return 1;\n    }\n\n    return 0;\n}",
                  "explanation": "This example shows how `catopen` uses the NLSPATH environment variable to locate message catalogs. It sets NLSPATH if it's not already set, then opens a catalog named 'myapp'.",
                  "expectedOutput": "Message catalog 'myapp' opened successfully"
                }
              ]
            },
            {
              "function_name": "ceil",
              "include_file": "math.h",
              "return_type": "double",
              "parameter_types": ["double"],
              "main_category": "Mathematical Operations",
              "sub_category": "Advanced Computation",
              "data_type_manipulated": "floating-point numbers",
              "description": "Calculates the smallest integer value greater than or equal to the argument.",
              "extended_description": "The ceil function computes the smallest integral value greater than or equal to x, represented as a double. In other words, it rounds x upward, returning the smallest integral value that is not less than x. This function is particularly useful when you need to round up a floating-point number to the nearest integer.",
              "return_value": "Returns the smallest integral value greater than or equal to x, expressed as a double.",
              "parameter_values": "This function takes one parameter: x (a double precision floating-point number to be rounded up).",
              "function_prototype": "double ceil(double x);",
              "examples": [
                {
                  "title": "Basic Usage",
                  "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double numbers[] = {1.4, 1.5, 1.6, -1.4, -1.5, -1.6, 0.0, -0.0};\n    int n = sizeof(numbers) / sizeof(numbers[0]);\n\n    for (int i = 0; i < n; i++) {\n        printf(\"ceil(%.1f) = %.1f\\n\", numbers[i], ceil(numbers[i]));\n    }\n\n    return 0;\n}",
                  "explanation": "This example demonstrates the basic usage of `ceil` with various positive and negative floating-point numbers, including zero.",
                  "expectedOutput": "ceil(1.4) = 2.0\nceil(1.5) = 2.0\nceil(1.6) = 2.0\nceil(-1.4) = -1.0\nceil(-1.5) = -1.0\nceil(-1.6) = -1.0\nceil(0.0) = 0.0\nceil(-0.0) = -0.0"
                },
                {
                  "title": "Practical Application",
                  "code": "#include <stdio.h>\n#include <math.h>\n\nint calculate_pages(int items, int items_per_page) {\n    return (int)ceil((double)items / items_per_page);\n}\n\nint main() {\n    int total_items = 100;\n    int items_per_page = 30;\n\n    int pages = calculate_pages(total_items, items_per_page);\n\n    printf(\"To display %d items with %d items per page, you need %d pages.\\n\",\n           total_items, items_per_page, pages);\n\n    return 0;\n}",
                  "explanation": "This example shows a practical application of `ceil` in calculating the number of pages needed to display a certain number of items, given a fixed number of items per page.",
                  "expectedOutput": "To display 100 items with 30 items per page, you need 4 pages."
                }
              ]
            },
            {
              "function_name": "clearerr",
              "include_file": "stdio.h",
              "return_type": "void",
              "parameter_types": ["FILE*"],
              "main_category": "File and I/O Operations",
              "sub_category": "Stream Manipulation",
              "data_type_manipulated": "file streams",
              "description": "Clears the error and end-of-file indicators for a given stream.",
              "extended_description": "The clearerr function resets both the error and end-of-file indicators for the specified stream. These indicators are typically set when an error occurs during a read or write operation, or when the end of the file is reached. After calling clearerr, functions like feof and ferror will return false for the specified stream until another error occurs or end-of-file is reached again.",
              "return_value": "This function does not return a value.",
              "parameter_values": "This function takes one parameter: stream (a pointer to the FILE structure representing the stream to be cleared).",
              "function_prototype": "void clearerr(FILE *stream);",
              "examples": [
                {
                  "title": "Basic Usage",
                  "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    // Read until end of file\n    int ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n\n    if (feof(file)) {\n        printf(\"\\nEnd of file reached\\n\");\n    }\n\n    // Clear the EOF indicator\n    clearerr(file);\n\n    if (!feof(file)) {\n        printf(\"EOF indicator cleared\\n\");\n    }\n\n    fclose(file);\n    return 0;\n}",
                  "explanation": "This example demonstrates how to use `clearerr` to clear the end-of-file indicator after reading a file to its end. It shows the state of the EOF indicator before and after calling clearerr.",
                  "expectedOutput": "[Contents of example.txt]\nEnd of file reached\nEOF indicator cleared"
                },
                {
                  "title": "Clearing Error Indicator",
                  "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"nonexistent.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    // Try to read from the file (this will set the error indicator)\n    fgetc(file);\n\n    if (ferror(file)) {\n        printf(\"An error occurred while reading the file\\n\");\n    }\n\n    // Clear the error indicator\n    clearerr(file);\n\n    if (!ferror(file)) {\n        printf(\"Error indicator cleared\\n\");\n    }\n\n    fclose(file);\n    return 0;\n}",
                  "explanation": "This example shows how to use `clearerr` to clear the error indicator after an error occurs during a file operation. It attempts to read from a non-existent file, which sets the error indicator, and then clears it using clearerr.",
                  "expectedOutput": "Error opening file: No such file or directory"
                }
              ]
            },

            
              {
                "function_name": "clock",
                "include_file": "time.h",
                "return_type": "clock_t",
                "parameter_types": [],
                "main_category": "Time and Date Management",
                "sub_category": "Time Measurement",
                "data_type_manipulated": "time",
                "description": "Returns the processor time consumed by the program.",
                "extended_description": "The clock function returns an approximation of processor time used by the program. The value returned is the CPU time used so far as a clock_t; to get the number of seconds used, you'll need to divide by CLOCKS_PER_SEC. Note that if the processor time used is not available or its value cannot be represented, the function returns the value (clock_t)-1.",
                "return_value": "Returns the processor time used by the program since the beginning of an implementation-defined era related to the program invocation. To convert this into seconds, divide by CLOCKS_PER_SEC. If the processor time used is not available or its value cannot be represented, the function returns (clock_t)-1.",
                "parameter_values": "This function takes no parameters.",
                "function_prototype": "clock_t clock(void);",
                "examples": [
                  {
                    "title": "Basic Usage",
                    "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    clock_t start, end;\n    double cpu_time_used;\n\n    start = clock();\n\n    // Do some work here\n    for (int i = 0; i < 1000000; i++) {\n        // Just wasting some CPU cycles\n    }\n\n    end = clock();\n    cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;\n\n    printf(\"CPU time used: %f seconds\\n\", cpu_time_used);\n\n    return 0;\n}",
                    "explanation": "This example demonstrates the basic usage of the `clock` function to measure the CPU time used by a simple loop. It calculates the difference between the start and end times and converts it to seconds.",
                    "expectedOutput": "CPU time used: 0.001234 seconds (The exact value will vary depending on the system and CPU speed)"
                  },
                  {
                    "title": "Measuring Function Execution Time",
                    "code": "#include <stdio.h>\n#include <time.h>\n#include <math.h>\n\ndouble compute_pi(long long n) {\n    double pi = 0.0;\n    for (long long i = 0; i < n; i++) {\n        pi += 4.0 * (1 - (i % 2) * 2) / (2 * i + 1);\n    }\n    return pi;\n}\n\nint main() {\n    clock_t start, end;\n    double cpu_time_used;\n\n    start = clock();\n    double pi = compute_pi(1000000000);\n    end = clock();\n\n    cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;\n\n    printf(\"Computed PI: %.10f\\n\", pi);\n    printf(\"Actual PI:   %.10f\\n\", M_PI);\n    printf(\"CPU time used: %f seconds\\n\", cpu_time_used);\n\n    return 0;\n}",
                    "explanation": "This example uses the `clock` function to measure the execution time of a function that computes an approximation of pi. It demonstrates a more practical use of clock for performance measurement.",
                    "expectedOutput": "Computed PI: 3.1415926536\nActual PI:   3.1415926536\nCPU time used: 2.345678 seconds (The exact value will vary depending on the system and CPU speed)"
                  }
                ]
              },
              {
                "function_name": "cos",
                "include_file": "math.h",
                "return_type": "double",
                "parameter_types": ["double"],
                "main_category": "Mathematical Operations",
                "sub_category": "Advanced Computation",
                "data_type_manipulated": "floating-point numbers",
                "description": "Calculates the cosine of the specified angle in radians.",
                "extended_description": "The cos function computes the cosine of an angle of x radians. The cosine is a periodic function with a period of 2π. For any value of x, the cosine will be between -1 and 1, inclusive. This function is commonly used in various mathematical and scientific applications, particularly those involving trigonometry or periodic phenomena.",
                "return_value": "Returns the cosine of x. The return value is in the range [-1, 1].",
                "parameter_values": "This function takes one parameter: x (a double representing an angle in radians).",
                "function_prototype": "double cos(double x);",
                "examples": [
                  {
                    "title": "Basic Usage",
                    "code": "#include <stdio.h>\n#include <math.h>\n\n#define PI 3.14159265358979323846\n\nint main() {\n    double angles[] = {0, PI/6, PI/4, PI/3, PI/2, PI};\n    int n = sizeof(angles) / sizeof(angles[0]);\n\n    for (int i = 0; i < n; i++) {\n        printf(\"cos(%.4f) = %.4f\\n\", angles[i], cos(angles[i]));\n    }\n\n    return 0;\n}",
                    "explanation": "This example demonstrates the basic usage of the `cos` function for various common angles in radians. It shows the cosine values for 0°, 30°, 45°, 60°, 90°, and 180°.",
                    "expectedOutput": "cos(0.0000) = 1.0000\ncos(0.5236) = 0.8660\ncos(0.7854) = 0.7071\ncos(1.0472) = 0.5000\ncos(1.5708) = 0.0000\ncos(3.1416) = -1.0000"
                  },
                  {
                    "title": "Plotting a Cosine Wave",
                    "code": "#include <stdio.h>\n#include <math.h>\n\n#define PI 3.14159265358979323846\n\nvoid plot_cosine(int points) {\n    for (int i = 0; i <= points; i++) {\n        double x = (2 * PI * i) / points;\n        double y = cos(x);\n        int line_length = (int)((y + 1) * 30);\n        \n        printf(\"%5.2f: \", x);\n        for (int j = 0; j < line_length; j++) {\n            printf(\"*\");\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    plot_cosine(20);\n    return 0;\n}",
                    "explanation": "This example uses the `cos` function to plot a simple ASCII representation of a cosine wave. It demonstrates a more visual application of the cosine function.",
                    "expectedOutput": "0.00: ******************************\n0.31: ****************************\n0.63: ************************\n0.94: *******************\n1.26: *************\n1.57: ******\n1.88: *\n2.20: \n2.51: *\n2.83: ******\n3.14: *************\n3.46: *******************\n3.77: ************************\n4.08: ****************************\n4.40: ******************************\n4.71: ****************************\n5.03: ************************\n5.34: *******************\n5.65: *************\n5.97: ******\n6.28: ******************************"
                  }
                ]
              },
              {
                "function_name": "cosh",
                "include_file": "math.h",
                "return_type": "double",
                "parameter_types": ["double"],
                "main_category": "Mathematical Operations",
                "sub_category": "Advanced Computation",
                "data_type_manipulated": "floating-point numbers",
                "description": "Calculates the hyperbolic cosine of the specified number.",
                "extended_description": "The cosh function computes the hyperbolic cosine of x. The hyperbolic cosine is defined mathematically as (e^x + e^-x) / 2, where e is the base of natural logarithms. This function is commonly used in various mathematical and scientific applications, particularly those involving hyperbolic geometry or certain types of differential equations.",
                "return_value": "Returns the hyperbolic cosine of x. The return value is always greater than or equal to 1.",
                "parameter_values": "This function takes one parameter: x (a double representing a real number).",
                "function_prototype": "double cosh(double x);",
                "examples": [
                  {
                    "title": "Basic Usage",
                    "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double values[] = {0, 0.5, 1, 2, -1, -2};\n    int n = sizeof(values) / sizeof(values[0]);\n\n    for (int i = 0; i < n; i++) {\n        printf(\"cosh(%.2f) = %.6f\\n\", values[i], cosh(values[i]));\n    }\n\n    return 0;\n}",
                    "explanation": "This example demonstrates the basic usage of the `cosh` function for various input values, including positive, negative, and zero. It shows how the hyperbolic cosine behaves for these inputs.",
                    "expectedOutput": "cosh(0.00) = 1.000000\ncosh(0.50) = 1.127626\ncosh(1.00) = 1.543081\ncosh(2.00) = 3.762196\ncosh(-1.00) = 1.543081\ncosh(-2.00) = 3.762196"
                  },
                  {
                    "title": "Practical Application: Catenary Curve",
                    "code": "#include <stdio.h>\n#include <math.h>\n\n#define A 10.0  // Scale factor\n\ndouble catenary(double x) {\n    return A * cosh(x / A);\n}\n\nvoid plot_catenary(int points) {\n    double x_min = -10, x_max = 10;\n    double y_max = catenary(x_max);\n\n    for (int i = 0; i <= points; i++) {\n        double x = x_min + (x_max - x_min) * i / points;\n        double y = catenary(x);\n        int line_length = (int)(40 * y / y_max);\n        \n        printf(\"%6.2f: \", x);\n        for (int j = 0; j < line_length; j++) {\n            printf(\"*\");\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    plot_catenary(20);\n    return 0;\n}",
                    "explanation": "This example uses the `cosh` function to plot a catenary curve, which is the shape formed by a hanging chain or cable under its own weight. It demonstrates a practical application of the hyperbolic cosine in physics and engineering.",
                    "expectedOutput": "-10.00: ******************\n -9.00: ****************\n -8.00: **************\n -7.00: ************\n -6.00: **********\n -5.00: ********\n -4.00: *******\n -3.00: ******\n -2.00: *****\n -1.00: ****\n  0.00: ****\n  1.00: ****\n  2.00: *****\n  3.00: ******\n  4.00: *******\n  5.00: ********\n  6.00: **********\n  7.00: ************\n  8.00: **************\n  9.00: ****************\n 10.00: ******************"
                  }
                ]
              },
              
                {
                  "function_name": "ctime",
                  "include_file": "time.h",
                  "return_type": "char*",
                  "parameter_types": ["const time_t*"],
                  "main_category": "Time and Date Management",
                  "sub_category": "Conversion and Calculation",
                  "data_type_manipulated": "strings",
                  "description": "Converts the calendar time to a local time string.",
                  "extended_description": "The ctime function converts the calendar time pointed to by timer into a string of the form 'Www Mmm dd hh:mm:ss yyyy\\n', where Www is the weekday, Mmm is the month in letters, dd is the day of the month, hh:mm:ss is the time, and yyyy is the year. The string is in local time. This function is equivalent to asctime(localtime(timer)). Note that it's not thread-safe as it returns a pointer to a static buffer.",
                  "return_value": "Returns a pointer to a string containing the date and time information in a human-readable format. This pointer is to a static buffer that may be overwritten by subsequent calls to ctime.",
                  "parameter_values": "This function takes one parameter: timer (a pointer to a time_t object representing calendar time).",
                  "function_prototype": "char *ctime(const time_t *timer);",
                  "examples": [
                    {
                      "title": "Basic Usage",
                      "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    time_t current_time;\n    time(&current_time);\n    \n    printf(\"Current time: %s\", ctime(&current_time));\n    \n    return 0;\n}",
                      "explanation": "This example demonstrates the basic usage of the `ctime` function. It gets the current time using time() and then converts it to a readable string using ctime().",
                      "expectedOutput": "Current time: Wed Jul 14 15:30:45 2024\n (The exact output will depend on the current date and time)"
                    },
                    {
                      "title": "Custom Time",
                      "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    struct tm custom_time = {0};\n    custom_time.tm_year = 120;  // Year 2020 (1900 + 120)\n    custom_time.tm_mon = 0;     // January (0-11)\n    custom_time.tm_mday = 1;    // 1st day of the month\n    custom_time.tm_hour = 12;   // 12 PM\n    \n    time_t time_value = mktime(&custom_time);\n    \n    printf(\"Custom time: %s\", ctime(&time_value));\n    \n    return 0;\n}",
                      "explanation": "This example shows how to use `ctime` with a custom time. It creates a specific date and time using struct tm, converts it to time_t using mktime(), and then uses ctime() to convert it to a string.",
                      "expectedOutput": "Custom time: Wed Jan 01 12:00:00 2020\n"
                    }
                  ]
                },
                {
                  "function_name": "ctime_r",
                  "include_file": "time.h",
                  "return_type": "char*",
                  "parameter_types": ["const time_t*", "char*"],
                  "main_category": "Time and Date Management",
                  "sub_category": "Conversion and Calculation",
                  "data_type_manipulated": "strings",
                  "description": "Thread-safe version of ctime.",
                  "extended_description": "The ctime_r function is a thread-safe version of ctime. It converts the calendar time pointed to by timer into a string of the form 'Www Mmm dd hh:mm:ss yyyy\\n', where Www is the weekday, Mmm is the month in letters, dd is the day of the month, hh:mm:ss is the time, and yyyy is the year. The string is in local time. Unlike ctime, ctime_r stores the result in a user-supplied buffer, making it safe for use in multi-threaded programs.",
                  "return_value": "Returns a pointer to the string result if successful, or NULL if an error occurred.",
                  "parameter_values": "This function takes two parameters: timer (a pointer to a time_t object representing calendar time) and buf (a pointer to a character array where the resulting string will be stored). The buffer should be at least 26 bytes long.",
                  "function_prototype": "char *ctime_r(const time_t *timer, char *buf);",
                  "examples": [
                    {
                      "title": "Basic Usage",
                      "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    time_t current_time;\n    char time_str[26];\n    \n    time(&current_time);\n    \n    if (ctime_r(&current_time, time_str) != NULL) {\n        printf(\"Current time: %s\", time_str);\n    } else {\n        printf(\"Error converting time to string\\n\");\n    }\n    \n    return 0;\n}",
                      "explanation": "This example demonstrates the basic usage of the `ctime_r` function. It gets the current time using time() and then converts it to a readable string using ctime_r(), storing the result in a user-provided buffer.",
                      "expectedOutput": "Current time: Wed Jul 14 15:30:45 2024\n (The exact output will depend on the current date and time)"
                    },
                    {
                      "title": "Using ctime_r in a Multi-threaded Program",
                      "code": "#include <stdio.h>\n#include <time.h>\n#include <pthread.h>\n\nvoid *print_time(void *arg) {\n    time_t current_time;\n    char time_str[26];\n    \n    time(&current_time);\n    \n    if (ctime_r(&current_time, time_str) != NULL) {\n        printf(\"Thread %ld time: %s\", (long)arg, time_str);\n    } else {\n        printf(\"Thread %ld: Error converting time to string\\n\", (long)arg);\n    }\n    \n    return NULL;\n}\n\nint main() {\n    pthread_t thread1, thread2;\n    \n    pthread_create(&thread1, NULL, print_time, (void *)1);\n    pthread_create(&thread2, NULL, print_time, (void *)2);\n    \n    pthread_join(thread1, NULL);\n    pthread_join(thread2, NULL);\n    \n    return 0;\n}\n",
                      "explanation": "This example shows how `ctime_r` can be safely used in a multi-threaded program. Two threads are created, each calling ctime_r to convert the current time to a string.",
                      "expectedOutput": "Thread 1 time: Wed Jul 14 15:30:45 2024\nThread 2 time: Wed Jul 14 15:30:45 2024\n (The exact output and order may vary depending on thread execution)"
                    }
                  ]
                },
                {
                  "function_name": "difftime",
                  "include_file": "time.h",
                  "return_type": "double",
                  "parameter_types": ["time_t", "time_t"],
                  "main_category": "Time and Date Management",
                  "sub_category": "Time Measurement",
                  "data_type_manipulated": "floating-point numbers",
                  "description": "Computes the difference in seconds between two times.",
                  "extended_description": "The difftime function computes the difference between two calendar times: time1 - time0. This function is useful for calculating elapsed time or durations between two points in time. The result is expressed in seconds and is a floating-point value to allow for fractional seconds.",
                  "return_value": "Returns the number of seconds elapsed between time1 and time0, as a double.",
                  "parameter_values": "This function takes two parameters: time1 and time0 (both of type time_t, representing calendar times).",
                  "function_prototype": "double difftime(time_t time1, time_t time0);",
                  "examples": [
                    {
                      "title": "Basic Usage",
                      "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    time_t start, end;\n    double elapsed;\n    \n    time(&start);\n    \n    // Simulate some work\n    for(long i = 0; i < 600000000L; i++) {\n        // Just wasting some time\n    }\n    \n    time(&end);\n    \n    elapsed = difftime(end, start);\n    \n    printf(\"Time elapsed: %.2f seconds\\n\", elapsed);\n    \n    return 0;\n}",
                      "explanation": "This example demonstrates the basic usage of the `difftime` function. It measures the time taken by a loop that performs some arbitrary work.",
                      "expectedOutput": "Time elapsed: 1.23 seconds (The exact output will depend on the system and CPU speed)"
                    },
                    {
                      "title": "Calculating Age",
                      "code": "#include <stdio.h>\n#include <time.h>\n\nint calculate_age(struct tm *birthdate) {\n    time_t now, birth;\n    double seconds;\n    \n    time(&now);\n    birth = mktime(birthdate);\n    \n    seconds = difftime(now, birth);\n    \n    return (int)(seconds / (365.25 * 24 * 3600));\n}\n\nint main() {\n    struct tm birthdate = {0};\n    birthdate.tm_year = 90;  // 1990\n    birthdate.tm_mon = 0;   // January\n    birthdate.tm_mday = 1;  // 1st\n    \n    int age = calculate_age(&birthdate);\n    \n    printf(\"Age: %d years\\n\", age);\n    \n    return 0;\n}",
                      "explanation": "This example uses `difftime` to calculate a person's age based on their birthdate. It demonstrates a more practical application of measuring time differences.",
                      "expectedOutput": "Age: 34 years (The exact output will depend on the current date)"
                    }
                  ]
                },

          
            {
              "function_name": "div",
              "include_file": "stdlib.h",
              "return_type": "div_t",
              "parameter_types": ["int", "int"],
              "main_category": "Mathematical Operations",
              "sub_category": "Basic Computation",
              "data_type_manipulated": "integers",
              "description": "Divides two integers and returns both the quotient and remainder.",
              "extended_description": "The div function computes the quotient and remainder of the division of the numerator numer by the denominator denom. This function is useful when you need both the quotient and remainder of an integer division operation. The result is returned in a structure of type div_t, which contains two int members: quot (the quotient) and rem (the remainder).",
              "return_value": "Returns a structure of type div_t that contains two int members: quot (the quotient) and rem (the remainder).",
              "parameter_values": "This function takes two parameters: numer (the numerator, an int) and denom (the denominator, a non-zero int).",
              "function_prototype": "div_t div(int numer, int denom);",
              "examples": [
                {
                  "title": "Basic Usage",
                  "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int numer = 17;\n    int denom = 5;\n    div_t result = div(numer, denom);\n    \n    printf(\"%d divided by %d:\\n\", numer, denom);\n    printf(\"Quotient: %d\\n\", result.quot);\n    printf(\"Remainder: %d\\n\", result.rem);\n    \n    return 0;\n}",
                  "explanation": "This example demonstrates the basic usage of the `div` function. It divides 17 by 5 and shows both the quotient and remainder.",
                  "expectedOutput": "17 divided by 5:\nQuotient: 3\nRemainder: 2"
                },
                {
                  "title": "Handling Negative Numbers",
                  "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int numer = -17;\n    int denom = 5;\n    div_t result = div(numer, denom);\n    \n    printf(\"%d divided by %d:\\n\", numer, denom);\n    printf(\"Quotient: %d\\n\", result.quot);\n    printf(\"Remainder: %d\\n\", result.rem);\n    \n    return 0;\n}",
                  "explanation": "This example shows how `div` handles negative numbers. The behavior of div with negative numbers is implementation-defined, but most implementations follow the rule that (numer/denom)*denom + numer%denom shall equal numer.",
                  "expectedOutput": "-17 divided by 5:\nQuotient: -3\nRemainder: -2"
                },
                {
                  "title": "Using div for Time Conversion",
                  "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int total_seconds = 3661;  // 1 hour, 1 minute, and 1 second\n    div_t hours = div(total_seconds, 3600);\n    div_t minutes = div(hours.rem, 60);\n    int seconds = minutes.rem;\n    \n    printf(\"%d seconds is equivalent to:\\n\", total_seconds);\n    printf(\"%d hours, %d minutes, and %d seconds\\n\", hours.quot, minutes.quot, seconds);\n    \n    return 0;\n}",
                  "explanation": "This example demonstrates a practical use of the `div` function for time conversion. It converts a total number of seconds into hours, minutes, and seconds.",
                  "expectedOutput": "3661 seconds is equivalent to:\n1 hours, 1 minutes, and 1 seconds"
                }
              ]
            },
            {
              "function_name": "erf",
              "include_file": "math.h",
              "return_type": "double",
              "parameter_types": ["double"],
              "main_category": "Mathematical Operations",
              "sub_category": "Advanced Computation",
              "data_type_manipulated": "floating-point numbers",
              "description": "Calculates the error function of the specified number.",
              "extended_description": "The erf function computes the error function of x. The error function (also called the Gauss error function) is a special function of sigmoid shape that occurs in probability, statistics, and partial differential equations. It is defined as erf(x) = (2/√π) ∫(0 to x) exp(-t^2) dt. This function is used in various fields including physics, chemistry, and signal processing.",
              "return_value": "Returns the error function value of x. The return value is always in the range [-1, 1].",
              "parameter_values": "This function takes one parameter: x (a double representing the input to the error function).",
              "function_prototype": "double erf(double x);",
              "examples": [
                {
                  "title": "Basic Usage",
                  "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x[] = {-2.0, -1.0, 0.0, 1.0, 2.0};\n    int n = sizeof(x) / sizeof(x[0]);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"erf(%.1f) = %.6f\\n\", x[i], erf(x[i]));\n    }\n    \n    return 0;\n}",
                  "explanation": "This example demonstrates the basic usage of the `erf` function for various input values, showing how the error function behaves for negative, zero, and positive inputs.",
                  "expectedOutput": "erf(-2.0) = -0.995322\nerf(-1.0) = -0.842701\nerf(0.0) = 0.000000\nerf(1.0) = 0.842701\nerf(2.0) = 0.995322"
                },
                {
                  "title": "Probability Calculation",
                  "code": "#include <stdio.h>\n#include <math.h>\n\ndouble normal_cdf(double x, double mean, double std_dev) {\n    return 0.5 * (1 + erf((x - mean) / (std_dev * sqrt(2))));\n}\n\nint main() {\n    double x = 1.5;\n    double mean = 0.0;\n    double std_dev = 1.0;\n    \n    double probability = normal_cdf(x, mean, std_dev);\n    \n    printf(\"Probability of X <= %.2f in N(%.1f, %.1f): %.6f\\n\", x, mean, std_dev, probability);\n    \n    return 0;\n}",
                  "explanation": "This example uses the `erf` function to calculate the cumulative distribution function (CDF) of a normal distribution. It demonstrates a practical application of erf in probability and statistics.",
                  "expectedOutput": "Probability of X <= 1.50 in N(0.0, 1.0): 0.933193"
                },
                {
                  "title": "Error Function Approximation",
                  "code": "#include <stdio.h>\n#include <math.h>\n\ndouble erf_approx(double x) {\n    // Abramowitz and Stegun approximation\n    const double a1 =  0.254829592;\n    const double a2 = -0.284496736;\n    const double a3 =  1.421413741;\n    const double a4 = -1.453152027;\n    const double a5 =  1.061405429;\n    const double p  =  0.3275911;\n\n    int sign = (x >= 0) ? 1 : -1;\n    x = fabs(x);\n\n    double t = 1.0 / (1.0 + p * x);\n    double y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-x * x);\n\n    return sign * y;\n}\n\nint main() {\n    double x[] = {-2.0, -1.0, 0.0, 1.0, 2.0};\n    int n = sizeof(x) / sizeof(x[0]);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"x = %.1f: erf = %.6f, approx = %.6f\\n\", x[i], erf(x[i]), erf_approx(x[i]));\n    }\n    \n    return 0;\n}",
                  "explanation": "This example implements an approximation of the error function and compares it with the standard `erf` function. It demonstrates how erf can be approximated using simpler mathematical operations.",
                  "expectedOutput": "x = -2.0: erf = -0.995322, approx = -0.995322\nx = -1.0: erf = -0.842701, approx = -0.842701\nx = 0.0: erf = 0.000000, approx = 0.000000\nx = 1.0: erf = 0.842701, approx = 0.842701\nx = 2.0: erf = 0.995322, approx = 0.995322"
                }
              ]
            },
            {
              "function_name": "erfc",
              "include_file": "math.h",
              "return_type": "double",
              "parameter_types": ["double"],
              "main_category": "Mathematical Operations",
              "sub_category": "Advanced Computation",
              "data_type_manipulated": "floating-point numbers",
              "description": "Calculates the complementary error function of the specified number.",
              "extended_description": "The erfc function computes the complementary error function of x. The complementary error function is defined as erfc(x) = 1 - erf(x), where erf(x) is the error function. However, erfc is often more accurate than calculating 1 - erf(x) directly, especially for large values of x. This function is commonly used in various statistical computations.",
              "return_value": "Returns the complementary error function value of x. The return value is always in the range [0, 2].",
              "parameter_values": "This function takes one parameter: x (a double representing the input to the complementary error function).",
              "function_prototype": "double erfc(double x);",
              "examples": [
                {
                  "title": "Basic Usage",
                  "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x[] = {-2.0, -1.0, 0.0, 1.0, 2.0};\n    int n = sizeof(x) / sizeof(x[0]);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"erfc(%.1f) = %.6f\\n\", x[i], erfc(x[i]));\n    }\n    \n    return 0;\n}",
                  "explanation": "This example demonstrates the basic usage of the `erfc` function for various input values, showing how the complementary error function behaves for negative, zero, and positive inputs.",
                  "expectedOutput": "erfc(-2.0) = 1.995322\nerfc(-1.0) = 1.842701\nerfc(0.0) = 1.000000\nerfc(1.0) = 0.157299\nerfc(2.0) = 0.004678"
                },
                {
                  "title": "Comparison with erf",
                  "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x[] = {-2.0, -1.0, 0.0, 1.0, 2.0};\n    int n = sizeof(x) / sizeof(x[0]);\n    \n    printf(\"    x      erfc(x)   1-erf(x)  Difference\\n\");\n    printf(\"----------------------------------------\\n\");\n    \n    for (int i = 0; i < n; i++) {\n        double erfc_val = erfc(x[i]);\n        double erf_val = 1.0 - erf(x[i]);\n        printf(\"%7.2f %10.6f %10.6f %10.6e\\n\", x[i], erfc_val, erf_val, fabs(erfc_val - erf_val));\n    }\n    \n    return 0;\n}",
                  "explanation": "This example compares the results of `erfc(x)` with `1 - erf(x)` to demonstrate why `erfc` is often preferred for numerical stability, especially for large values of x.",
                  "expectedOutput": "    x      erfc(x)   1-erf(x)  Difference\n----------------------------------------\n  -2.00   1.995322   1.995322   0.000000e+00\n  -1.00   1.842701   1.842701   0.000000e+00\n   0.00   1.000000   1.000000   0.000000e+00\n   1.00   0.157299   0.157299   0.000000e+00\n   2.00   0.004678   0.004678   0.000000e+00"
                },
                {
                  "title": "Application in Statistics",
                  "code": "#include <stdio.h>\n#include <math.h>\n\ndouble normal_cdf_complement(double x, double mean, double std_dev) {\n    return 0.5 * erfc((x - mean) / (std_dev * sqrt(2)));\n}\n\nint main() {\n    double x = 2.0;\n    double mean = 0.0;\n    double std_dev = 1.0;\n    \n    double probability = normal_cdf_complement(x, mean, std_dev);\n    \n    printf(\"Probability of X > %.2f in N(%.1f, %.1f): %.6f\\n\", x, mean, std_dev, probability);\n    \n    return 0;\n}",
                  "explanation": "This example uses the `erfc` function to calculate the complement of the cumulative distribution function (CDF) of a normal distribution. It demonstrates a practical application of erfc in probability and statistics, specifically for calculating the probability in the upper tail of a normal distribution.",
                  "expectedOutput": "Probability of X > 2.00 in N(0.0, 1.0): 0.022750"
                }
              ]
            },
            
              {
                "function_name": "exit",
                "include_file": "stdlib.h",
                "return_type": "void",
                "parameter_types": ["int"],
                "main_category": "Error Handling and Debugging",
                "sub_category": "Process Termination",
                "data_type_manipulated": "none",
                "description": "Terminates the program and returns control to the host environment.",
                "extended_description": "The exit function terminates the calling process immediately. It first calls all functions registered with atexit() in reverse order of their registration, then flushes all open output streams, closes all open streams, and finally returns control to the host environment. The status value is typically used to return an exit status to the parent process or operating system. By convention, a status of 0 indicates successful termination, while non-zero values indicate various error conditions.",
                "return_value": "This function does not return to the calling process.",
                "parameter_values": "This function takes one parameter: status (an integer that is returned to the parent process as the exit status).",
                "function_prototype": "void exit(int status);",
                "examples": [
                  {
                    "title": "Basic Usage",
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    printf(\"Program starting...\\n\");\n    \n    // Some condition that might cause the program to exit\n    int error_occurred = 1;\n    \n    if (error_occurred) {\n        printf(\"An error occurred. Exiting program.\\n\");\n        exit(1);\n    }\n    \n    printf(\"This line will not be executed.\\n\");\n    return 0;\n}",
                    "explanation": "This example demonstrates the basic usage of the `exit` function. If an error condition is met, the program exits with a status code of 1, indicating an error occurred.",
                    "expectedOutput": "Program starting...\nAn error occurred. Exiting program."
                  },
                  {
                    "title": "Using EXIT_SUCCESS and EXIT_FAILURE",
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s <filename>\\n\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n    \n    FILE *file = fopen(argv[1], \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        exit(EXIT_FAILURE);\n    }\n    \n    printf(\"File opened successfully.\\n\");\n    fclose(file);\n    \n    exit(EXIT_SUCCESS);\n}",
                    "explanation": "This example shows the use of `EXIT_SUCCESS` and `EXIT_FAILURE` macros with the `exit` function. It demonstrates proper error handling in a C program that opens a file.",
                    "expectedOutput": "Usage: ./program <filename>\n(If run without arguments)\nOr\nFile opened successfully.\n(If run with a valid filename)"
                  },
                  {
                    "title": "Using atexit with exit",
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid cleanup1(void) {\n    printf(\"Cleanup function 1 called\\n\");\n}\n\nvoid cleanup2(void) {\n    printf(\"Cleanup function 2 called\\n\");\n}\n\nint main() {\n    atexit(cleanup1);\n    atexit(cleanup2);\n    \n    printf(\"Main function executing\\n\");\n    \n    exit(0);  // or simply return 0;\n}",
                    "explanation": "This example demonstrates how `exit` interacts with functions registered using `atexit`. The cleanup functions are called in reverse order of registration when the program exits.",
                    "expectedOutput": "Main function executing\nCleanup function 2 called\nCleanup function 1 called"
                  }
                ]
              },
              {
                "function_name": "exp",
                "include_file": "math.h",
                "return_type": "double",
                "parameter_types": ["double"],
                "main_category": "Mathematical Operations",
                "sub_category": "Advanced Computation",
                "data_type_manipulated": "floating-point numbers",
                "description": "Calculates the exponential function e raised to the power of the specified number.",
                "extended_description": "The exp function computes e raised to the power of x, where e is the base of natural logarithms (approximately 2.71828). This function is fundamental in many areas of mathematics and science, including compound interest calculations, radioactive decay modeling, and solution of differential equations.",
                "return_value": "Returns e raised to the power of x. If the result overflows, the function returns HUGE_VAL (with the appropriate sign). If the result underflows, it returns 0.",
                "parameter_values": "This function takes one parameter: x (a double representing the power to which e is to be raised).",
                "function_prototype": "double exp(double x);",
                "examples": [
                  {
                    "title": "Basic Usage",
                    "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x[] = {0, 1, 2, -1};\n    int n = sizeof(x) / sizeof(x[0]);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"exp(%.1f) = %.6f\\n\", x[i], exp(x[i]));\n    }\n    \n    return 0;\n}",
                    "explanation": "This example demonstrates the basic usage of the `exp` function for various input values, showing how the exponential function behaves for positive, negative, and zero inputs.",
                    "expectedOutput": "exp(0.0) = 1.000000\nexp(1.0) = 2.718282\nexp(2.0) = 7.389056\nexp(-1.0) = 0.367879"
                  },
                  {
                    "title": "Compound Interest Calculation",
                    "code": "#include <stdio.h>\n#include <math.h>\n\ndouble compound_interest(double principal, double rate, double time) {\n    return principal * exp(rate * time);\n}\n\nint main() {\n    double principal = 1000.0;  // Initial investment\n    double rate = 0.05;         // 5% annual interest rate\n    double time = 10.0;         // 10 years\n    \n    double amount = compound_interest(principal, rate, time);\n    \n    printf(\"$%.2f invested at %.2f%% for %.1f years\\n\", principal, rate * 100, time);\n    printf(\"Final amount: $%.2f\\n\", amount);\n    \n    return 0;\n}",
                    "explanation": "This example uses the `exp` function to calculate compound interest. It demonstrates a practical application of the exponential function in financial calculations.",
                    "expectedOutput": "$1000.00 invested at 5.00% for 10.0 years\nFinal amount: $1648.72"
                  },
                  {
                    "title": "Handling Overflow and Underflow",
                    "code": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nint main() {\n    double large_number = 1000.0;\n    double small_number = -1000.0;\n    \n    printf(\"exp(%.1f) = %.6e\\n\", large_number, exp(large_number));\n    printf(\"exp(%.1f) = %.6e\\n\", small_number, exp(small_number));\n    \n    // Test for overflow\n    if (exp(large_number) == HUGE_VAL) {\n        printf(\"exp(%.1f) resulted in overflow\\n\", large_number);\n    }\n    \n    // Test for underflow\n    if (exp(small_number) == 0.0) {\n        printf(\"exp(%.1f) resulted in underflow\\n\", small_number);\n    }\n    \n    return 0;\n}",
                    "explanation": "This example demonstrates how `exp` handles very large positive and negative inputs, which can lead to overflow and underflow conditions respectively.",
                    "expectedOutput": "exp(1000.0) = inf\nexp(-1000.0) = 0.000000e+00\nexp(1000.0) resulted in overflow\nexp(-1000.0) resulted in underflow"
                  }
                ]
              },
              {
                "function_name": "fabs",
                "include_file": "math.h",
                "return_type": "double",
                "parameter_types": ["double"],
                "main_category": "Mathematical Operations",
                "sub_category": "Basic Computation",
                "data_type_manipulated": "floating-point numbers",
                "description": "Calculates the absolute value of a floating-point number.",
                "extended_description": "The fabs function computes the absolute value of a floating-point number x. It returns |x|, which is x if x is non-negative, and -x if x is negative. This function is useful in many mathematical calculations where the magnitude of a number is needed regardless of its sign.",
                "return_value": "Returns the absolute value of x as a double.",
                "parameter_values": "This function takes one parameter: x (a double representing the floating-point number whose absolute value is to be calculated).",
                "function_prototype": "double fabs(double x);",
                "examples": [
                  {
                    "title": "Basic Usage",
                    "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double values[] = {3.14, -2.5, 0.0, -0.0, 100.25, -100.25};\n    int n = sizeof(values) / sizeof(values[0]);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"fabs(%.2f) = %.2f\\n\", values[i], fabs(values[i]));\n    }\n    \n    return 0;\n}",
                    "explanation": "This example demonstrates the basic usage of the `fabs` function for various input values, including positive, negative, and zero values.",
                    "expectedOutput": "fabs(3.14) = 3.14\nfabs(-2.50) = 2.50\nfabs(0.00) = 0.00\nfabs(-0.00) = 0.00\nfabs(100.25) = 100.25\nfabs(-100.25) = 100.25"
                  },
                  {
                    "title": "Using fabs in Calculations",
                    "code": "#include <stdio.h>\n#include <math.h>\n\ndouble calculate_distance(double x1, double y1, double x2, double y2) {\n    double dx = fabs(x2 - x1);\n    double dy = fabs(y2 - y1);\n    return sqrt(dx*dx + dy*dy);\n}\n\nint main() {\n    double x1 = 1.0, y1 = 2.0;\n    double x2 = -3.0, y2 = 4.0;\n    \n    double distance = calculate_distance(x1, y1, x2, y2);\n    \n    printf(\"Distance between (%.1f, %.1f) and (%.1f, %.1f) is %.2f\\n\", \n           x1, y1, x2, y2, distance);\n    \n    return 0;\n}",
                    "explanation": "This example uses `fabs` in a practical application to calculate the distance between two points in a 2D plane. It demonstrates how fabs can be used in more complex mathematical calculations.",
                    "expectedOutput": "Distance between (1.0, 2.0) and (-3.0, 4.0) is 5.00"
                  },
                  {
                    "title": "Comparing fabs with abs",
                    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n    int int_value = -42;\n    double double_value = -42.5;\n    \n    printf(\"Using abs (integer):  abs(%d) = %d\\n\", int_value, abs(int_value));\n    printf(\"Using fabs (integer): fabs(%d) = %.1f\\n\", int_value, fabs(int_value));\n    printf(\"Using fabs (double):  fabs(%.1f) = %.1f\\n\", double_value, fabs(double_value));\n    \n    // This will not compile:\n    // printf(\"Using abs (double):   abs(%.1f) = %d\\n\", double_value, abs(double_value));\n    \n    return 0;\n}",
                    "explanation": "This example compares `fabs` with the integer `abs` function. It demonstrates that `fabs` can be used with both integer and floating-point types, while `abs` is only for integers. This showcases the flexibility of `fabs` in handling different numeric types.",
                    "expectedOutput": "Using abs (integer):  abs(-42) = 42\nUsing fabs (integer): fabs(-42) = 42.0\nUsing fabs (double):  fabs(-42.5) = 42.5"
                  }
                ]
              } ,
            {
              "function_name": "fclose",
              "include_file": "stdio.h",
              "return_type": "int",
              "parameter_types": ["FILE*"],
              "main_category": "File and I/O Operations",
              "sub_category": "File Management",
              "data_type_manipulated": "file streams",
              "description": "Closes the file pointed to by the file pointer.",
              "extended_description": "The fclose function closes the stream pointed to by stream. All buffers associated with the stream are flushed before closing. If the associated file is open for writing, any unwritten buffered data is written to the file before it is closed. This function is important for proper resource management and should be called for every successfully opened file when it's no longer needed.",
              "return_value": "Returns 0 if the stream is successfully closed. On failure, it returns EOF and sets errno to indicate the error.",
              "parameter_values": "This function takes one parameter: stream (a pointer to the FILE structure to be closed).",
              "function_prototype": "int fclose(FILE *stream);",
              "examples": [
                {
                  "title": "Basic Usage",
                  "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"example.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    fprintf(file, \"Hello, World!\\n\");\n\n    if (fclose(file) == EOF) {\n        perror(\"Error closing file\");\n        return 1;\n    }\n\n    printf(\"File closed successfully.\\n\");\n    return 0;\n}",
                  "explanation": "This example demonstrates the basic usage of `fclose`. It opens a file, writes to it, and then closes it using fclose. It also checks for errors during closing.",
                  "expectedOutput": "File closed successfully."
                },
                {
                  "title": "Closing Multiple Files",
                  "code": "#include <stdio.h>\n\nint main() {\n    FILE *file1 = fopen(\"file1.txt\", \"w\");\n    FILE *file2 = fopen(\"file2.txt\", \"w\");\n\n    if (file1 == NULL || file2 == NULL) {\n        perror(\"Error opening files\");\n        return 1;\n    }\n\n    fprintf(file1, \"Content for file 1\\n\");\n    fprintf(file2, \"Content for file 2\\n\");\n\n    int close_status = 0;\n    if (fclose(file1) == EOF) {\n        perror(\"Error closing file1\");\n        close_status = 1;\n    }\n    if (fclose(file2) == EOF) {\n        perror(\"Error closing file2\");\n        close_status = 1;\n    }\n\n    if (close_status == 0) {\n        printf(\"All files closed successfully.\\n\");\n    }\n\n    return close_status;\n}",
                  "explanation": "This example shows how to handle closing multiple files. It demonstrates good practice by attempting to close all files even if one close operation fails.",
                  "expectedOutput": "All files closed successfully."
                },
                {
                  "title": "Handling fclose in a Function",
                  "code": "#include <stdio.h>\n\nint write_to_file(const char *filename, const char *content) {\n    FILE *file = fopen(filename, \"w\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return -1;\n    }\n\n    if (fputs(content, file) == EOF) {\n        perror(\"Error writing to file\");\n        fclose(file);  // Close the file even if writing fails\n        return -1;\n    }\n\n    if (fclose(file) == EOF) {\n        perror(\"Error closing file\");\n        return -1;\n    }\n\n    return 0;\n}\n\nint main() {\n    if (write_to_file(\"example.txt\", \"Hello, World!\\n\") == 0) {\n        printf(\"File operation successful.\\n\");\n    } else {\n        printf(\"File operation failed.\\n\");\n    }\n    return 0;\n}",
                  "explanation": "This example demonstrates how to handle `fclose` in a function that performs file operations. It shows proper error handling and ensures the file is closed even if writing fails.",
                  "expectedOutput": "File operation successful."
                }
              ]
            },
            {
              "function_name": "fdopen",
              "include_file": "stdio.h",
              "return_type": "FILE*",
              "parameter_types": ["int", "const char*"],
              "main_category": "File and I/O Operations",
              "sub_category": "Stream Manipulation",
              "data_type_manipulated": "file streams",
              "description": "Associates a file descriptor with an input/output stream.",
              "extended_description": "The fdopen function associates a stream with the existing file descriptor, fd. This is useful for creating a standard I/O stream from a file descriptor obtained from other system calls like open, pipe, or socket. The mode argument is used just as in fopen. The file position indicator of the new stream is set to the position indicated by the file offset associated with the file descriptor.",
              "return_value": "Returns a pointer to the object controlling the stream. If the open operation fails, it returns a null pointer.",
              "parameter_values": "This function takes two parameters: fd (an integer file descriptor) and mode (a string specifying the mode to open the stream, such as 'r' for read, 'w' for write, etc.).",
              "function_prototype": "FILE *fdopen(int fd, const char *mode);",
              "examples": [
                {
                  "title": "Basic Usage with File Descriptor",
                  "code": "#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nint main() {\n    int fd = open(\"example.txt\", O_WRONLY | O_CREAT, 0644);\n    if (fd == -1) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    FILE *file = fdopen(fd, \"w\");\n    if (file == NULL) {\n        perror(\"Error associating stream\");\n        close(fd);\n        return 1;\n    }\n\n    fprintf(file, \"Hello, fdopen!\\n\");\n    fclose(file);  // This also closes the underlying file descriptor\n\n    printf(\"File operation successful.\\n\");\n    return 0;\n}",
                  "explanation": "This example demonstrates the basic usage of `fdopen`. It opens a file using the low-level open function, then associates it with a stream using fdopen.",
                  "expectedOutput": "File operation successful."
                },
                {
                  "title": "Using fdopen with Pipes",
                  "code": "#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n\nint main() {\n    int pipefd[2];\n    char buf[1024];\n\n    if (pipe(pipefd) == -1) {\n        perror(\"pipe\");\n        return 1;\n    }\n\n    FILE *write_stream = fdopen(pipefd[1], \"w\");\n    FILE *read_stream = fdopen(pipefd[0], \"r\");\n\n    if (write_stream == NULL || read_stream == NULL) {\n        perror(\"fdopen\");\n        return 1;\n    }\n\n    fprintf(write_stream, \"Hello through pipe!\\n\");\n    fflush(write_stream);\n\n    if (fgets(buf, sizeof(buf), read_stream) != NULL) {\n        printf(\"Read from pipe: %s\", buf);\n    }\n\n    fclose(write_stream);\n    fclose(read_stream);\n\n    return 0;\n}",
                  "explanation": "This example shows how to use `fdopen` with pipes. It creates a pipe, then uses fdopen to create input and output streams for the pipe's file descriptors.",
                  "expectedOutput": "Read from pipe: Hello through pipe!"
                },
                {
                  "title": "Error Handling with fdopen",
                  "code": "#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n\nint main() {\n    int fd = open(\"nonexistent_file\", O_RDONLY);\n    if (fd == -1) {\n        printf(\"Error opening file: %s\\n\", strerror(errno));\n        return 1;\n    }\n\n    FILE *file = fdopen(fd, \"r\");\n    if (file == NULL) {\n        printf(\"Error in fdopen: %s\\n\", strerror(errno));\n        close(fd);\n        return 1;\n    }\n\n    // This part won't be reached if the file doesn't exist\n    char buffer[100];\n    if (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"Read from file: %s\\n\", buffer);\n    }\n\n    fclose(file);\n    return 0;\n}",
                  "explanation": "This example demonstrates error handling with `fdopen`. It attempts to open a non-existent file and shows how to handle errors from both open and fdopen.",
                  "expectedOutput": "Error opening file: No such file or directory"
                }
              ]
            },
            {
              "function_name": "feof",
              "include_file": "stdio.h",
              "return_type": "int",
              "parameter_types": ["FILE*"],
              "main_category": "File and I/O Operations",
              "sub_category": "Stream Manipulation",
              "data_type_manipulated": "file streams",
              "description": "Checks if the end of the file has been reached.",
              "extended_description": "The feof function tests the end-of-file indicator for the given stream. The end-of-file indicator is set by previous operations on the stream that reached the end of the file. It's important to note that feof does not detect the end-of-file by itself; it only reports whether the indicator has been set by a previous operation.",
              "return_value": "Returns a non-zero value if the end-of-file indicator is set for the stream. Otherwise, it returns zero.",
              "parameter_values": "This function takes one parameter: stream (a pointer to the FILE structure to be tested for end-of-file).",
              "function_prototype": "int feof(FILE *stream);",
              "examples": [
                {
                  "title": "Basic Usage",
                  "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    int ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n\n    if (feof(file)) {\n        printf(\"\\nEnd of file reached.\\n\");\n    } else {\n        printf(\"\\nSomething went wrong.\\n\");\n    }\n\n    fclose(file);\n    return 0;\n}",
                  "explanation": "This example demonstrates the basic usage of `feof`. It reads a file character by character until EOF is reached, then uses feof to confirm that the end of the file was reached.",
                  "expectedOutput": "[Contents of example.txt]\nEnd of file reached."
                },
                {
                  "title": "Using feof in a Loop",
                  "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"numbers.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    int num, sum = 0;\n    while (!feof(file)) {\n        if (fscanf(file, \"%d\", &num) == 1) {\n            sum += num;\n        }\n    }\n\n    printf(\"Sum of numbers: %d\\n\", sum);\n\n    fclose(file);\n    return 0;\n}",
                  "explanation": "This example shows how to use `feof` in a loop condition. It reads integers from a file and calculates their sum. However, this usage can lead to a common mistake where the loop may execute one extra time.",
                  "expectedOutput": "Sum of numbers: [sum of numbers in the file]"
                },
                {
                  "title": "Proper Usage with Error Checking",
                  "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    char buffer[100];\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"%s\", buffer);\n    }\n\n    if (feof(file)) {\n        printf(\"End of file reached normally.\\n\");\n    } else if (ferror(file)) {\n        perror(\"Error reading file\");\n    }\n\n    fclose(file);\n    return 0;\n}",
                  "explanation": "This example demonstrates a more proper way to use `feof` along with error checking. It reads the file line by line and checks for both EOF and read errors after the loop.",
                  "expectedOutput": "[Contents of data.txt]\nEnd of file reached normally."
                }
              ]
            },

        
          {
            "function_name": "ferror",
            "include_file": "stdio.h",
            "return_type": "int",
            "parameter_types": ["FILE*"],
            "main_category": "File and I/O Operations",
            "sub_category": "Error Handling",
            "data_type_manipulated": "file streams",
            "description": "Checks for an error in file streams.",
            "extended_description": "The ferror function tests the error indicator for the given stream. The error indicator is set by previous operations on the stream that encountered an error. This function is useful for detecting errors that occurred during file operations, especially when used in conjunction with other I/O functions.",
            "return_value": "Returns a non-zero value if the error indicator is set for the stream. Otherwise, it returns zero.",
            "parameter_values": "This function takes one parameter: stream (a pointer to the FILE structure to be tested for errors).",
            "function_prototype": "int ferror(FILE *stream);",
            "examples": [
              {
                "title": "Basic Usage",
                "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"nonexistent.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    int ch = fgetc(file);\n    if (ch == EOF) {\n        if (ferror(file)) {\n            printf(\"An error occurred while reading the file.\\n\");\n        } else if (feof(file)) {\n            printf(\"End of file reached.\\n\");\n        }\n    }\n\n    fclose(file);\n    return 0;\n}",
                "explanation": "This example demonstrates the basic usage of `ferror`. It attempts to open a non-existent file, which will likely fail, and then checks for errors using ferror.",
                "expectedOutput": "Error opening file: No such file or directory"
              },
              {
                "title": "Error Checking in a Loop",
                "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    int ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n        if (ferror(file)) {\n            printf(\"\\nAn error occurred while reading the file.\\n\");\n            clearerr(file);  // Clear the error\n            break;\n        }\n    }\n\n    fclose(file);\n    return 0;\n}",
                "explanation": "This example shows how to use `ferror` in a loop to check for errors during file reading. It also demonstrates the use of clearerr to clear the error indicator.",
                "expectedOutput": "[Contents of data.txt]\n(or an error message if an error occurs)"
              },
              {
                "title": "Combining ferror with feof",
                "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    char buffer[100];\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"%s\", buffer);\n    }\n\n    if (ferror(file)) {\n        printf(\"An error occurred while reading the file.\\n\");\n    } else if (feof(file)) {\n        printf(\"End of file reached successfully.\\n\");\n    }\n\n    fclose(file);\n    return 0;\n}",
                "explanation": "This example demonstrates how to use `ferror` in combination with `feof` to distinguish between reaching the end of the file and encountering an error during file operations.",
                "expectedOutput": "[Contents of example.txt]\nEnd of file reached successfully.\n(or an error message if an error occurs)"
              }
            ]
          },
          {
            "function_name": "fflush",
            "include_file": "stdio.h",
            "return_type": "int",
            "parameter_types": ["FILE*"],
            "main_category": "File and I/O Operations",
            "sub_category": "Stream Manipulation",
            "data_type_manipulated": "file streams",
            "description": "Flushes the output buffer of a file stream.",
            "extended_description": "The fflush function forces a write of all buffered data for the given output or update stream via the stream's underlying write function. If the stream is an input stream or an update stream in which the most recent operation was input, it has no effect and returns zero. If stream is a null pointer, fflush flushes all open output streams.",
            "return_value": "Returns 0 if the stream was successfully flushed. Otherwise, it returns EOF and sets errno to indicate the error.",
            "parameter_values": "This function takes one parameter: stream (a pointer to the FILE structure whose buffer is to be flushed, or NULL to flush all open output streams).",
            "function_prototype": "int fflush(FILE *stream);",
            "examples": [
              {
                "title": "Basic Usage",
                "code": "#include <stdio.h>\n\nint main() {\n    printf(\"This is a line without newline\");\n    fflush(stdout);\n    \n    // Simulate some delay\n    for(long i = 0; i < 100000000L; i++) {}\n    \n    printf(\"\\nThis is the next line\\n\");\n    \n    return 0;\n}",
                "explanation": "This example demonstrates the basic usage of `fflush`. It forces the first printf output to be displayed immediately, even without a newline character.",
                "expectedOutput": "This is a line without newline[delay]This is the next line"
              },
              {
                "title": "Flushing a File Stream",
                "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"example.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    fprintf(file, \"This is some data\\n\");\n    printf(\"Data written to file buffer\\n\");\n\n    if (fflush(file) != 0) {\n        perror(\"Error flushing file\");\n        fclose(file);\n        return 1;\n    }\n    printf(\"File buffer flushed\\n\");\n\n    fclose(file);\n    return 0;\n}",
                "explanation": "This example shows how to use `fflush` with a file stream. It writes data to a file and then flushes the buffer to ensure the data is written to the disk.",
                "expectedOutput": "Data written to file buffer\nFile buffer flushed"
              },
              {
                "title": "Flushing All Streams",
                "code": "#include <stdio.h>\n\nint main() {\n    FILE *file1 = fopen(\"file1.txt\", \"w\");\n    FILE *file2 = fopen(\"file2.txt\", \"w\");\n    \n    if (file1 == NULL || file2 == NULL) {\n        perror(\"Error opening files\");\n        return 1;\n    }\n\n    fprintf(file1, \"Data for file 1\\n\");\n    fprintf(file2, \"Data for file 2\\n\");\n    printf(\"Data written to stdout\\n\");\n\n    if (fflush(NULL) != 0) {\n        perror(\"Error flushing streams\");\n        return 1;\n    }\n    printf(\"All streams flushed\\n\");\n\n    fclose(file1);\n    fclose(file2);\n    return 0;\n}",
                "explanation": "This example demonstrates how to use `fflush(NULL)` to flush all open output streams. This is useful when you want to ensure all buffered data is written, regardless of which streams are open.",
                "expectedOutput": "Data written to stdout\nAll streams flushed"
              }
            ]
          },
          {
            "function_name": "fgetc",
            "include_file": "stdio.h",
            "return_type": "int",
            "parameter_types": ["FILE*"],
            "main_category": "File and I/O Operations",
            "sub_category": "File Management",
            "data_type_manipulated": "file streams",
            "description": "Reads the next character from the specified file stream.",
            "extended_description": "The fgetc function obtains the next character (if present) as an unsigned char converted to an int, from the input stream pointed to by stream, and advances the associated file position indicator for the stream (if defined). This function is commonly used for reading files character by character.",
            "return_value": "Returns the character read as an unsigned char cast to an int or EOF on end of file or error.",
            "parameter_values": "This function takes one parameter: stream (a pointer to the FILE structure from which the character is to be read).",
            "function_prototype": "int fgetc(FILE *stream);",
            "examples": [
              {
                "title": "Basic Usage",
                "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    int ch;\n    while ((ch = fgetc(file)) != EOF) {\n        putchar(ch);\n    }\n\n    if (ferror(file)) {\n        printf(\"An error occurred while reading the file.\\n\");\n    }\n\n    fclose(file);\n    return 0;\n}",
                "explanation": "This example demonstrates the basic usage of `fgetc`. It reads a file character by character and prints each character to the console.",
                "expectedOutput": "[Contents of example.txt]"
              },
              {
                "title": "Counting Characters",
                "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    FILE *file = fopen(\"text.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    int ch, count = 0, alpha = 0, digit = 0, space = 0;\n    while ((ch = fgetc(file)) != EOF) {\n        count++;\n        if (isalpha(ch)) alpha++;\n        else if (isdigit(ch)) digit++;\n        else if (isspace(ch)) space++;\n    }\n\n    printf(\"Total characters: %d\\n\", count);\n    printf(\"Alphabetic characters: %d\\n\", alpha);\n    printf(\"Numeric characters: %d\\n\", digit);\n    printf(\"Whitespace characters: %d\\n\", space);\n\n    fclose(file);\n    return 0;\n}",
                "explanation": "This example uses `fgetc` to read a file and count different types of characters. It demonstrates how fgetc can be used in conjunction with character classification functions.",
                "expectedOutput": "Total characters: [count]\nAlphabetic characters: [alpha]\nNumeric characters: [digit]\nWhitespace characters: [space]"
              },
              {
                "title": "Handling Binary Files",
                "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"binary.dat\", \"rb\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    int ch;\n    int byte_count = 0;\n    while ((ch = fgetc(file)) != EOF) {\n        printf(\"%02X \", (unsigned char)ch);\n        byte_count++;\n        if (byte_count % 16 == 0) printf(\"\\n\");\n    }\n\n    if (ferror(file)) {\n        printf(\"\\nAn error occurred while reading the file.\\n\");\n    } else {\n        printf(\"\\n%d bytes read.\\n\", byte_count);\n    }\n\n    fclose(file);\n    return 0;\n}",
                "explanation": "This example shows how to use `fgetc` with a binary file. It reads the file byte by byte and prints each byte as a hexadecimal value.",
                "expectedOutput": "[Hexadecimal representation of binary.dat contents]\n[byte_count] bytes read."
              }
            ]
          },
          
            {
              "function_name": "fgetpos",
              "include_file": "stdio.h",
              "return_type": "int",
              "parameter_types": ["FILE*", "fpos_t*"],
              "main_category": "File and I/O Operations",
              "sub_category": "Stream Manipulation",
              "data_type_manipulated": "file streams",
              "description": "Gets the current file position of the stream and stores it in a position indicator.",
              "extended_description": "The fgetpos function obtains the current value of the file position indicator for the stream pointed to by stream. The position is stored in the object pointed to by pos. This function is useful for saving the current position in a file, which can later be restored using fsetpos. It's particularly helpful when working with large files or when precise positioning is required.",
              "return_value": "Returns zero on success, or a non-zero value if an error occurred. In case of an error, errno is set to indicate the specific error.",
              "parameter_values": "This function takes two parameters: stream (a pointer to the FILE structure whose position is to be obtained) and pos (a pointer to a fpos_t object where the position will be stored).",
              "function_prototype": "int fgetpos(FILE *stream, fpos_t *pos);",
              "examples": [
                {
                  "title": "Basic Usage",
                  "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    fpos_t position;\n    if (fgetpos(file, &position) != 0) {\n        perror(\"Error getting file position\");\n        fclose(file);\n        return 1;\n    }\n\n    printf(\"Current file position obtained successfully.\\n\");\n\n    fclose(file);\n    return 0;\n}",
                  "explanation": "This example demonstrates the basic usage of `fgetpos`. It opens a file, gets its current position (which is the beginning of the file), and checks for any errors.",
                  "expectedOutput": "Current file position obtained successfully."
                },
                {
                  "title": "Saving and Restoring Position",
                  "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    char buffer[100];\n    fpos_t position;\n\n    // Read first line\n    if (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"First line: %s\", buffer);\n    }\n\n    // Save current position\n    if (fgetpos(file, &position) != 0) {\n        perror(\"Error getting file position\");\n        fclose(file);\n        return 1;\n    }\n\n    // Read next line\n    if (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"Second line: %s\", buffer);\n    }\n\n    // Restore position and read again\n    if (fsetpos(file, &position) != 0) {\n        perror(\"Error setting file position\");\n        fclose(file);\n        return 1;\n    }\n\n    if (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"Line after restoring position: %s\", buffer);\n    }\n\n    fclose(file);\n    return 0;\n}",
                  "explanation": "This example shows how to use `fgetpos` to save a file position and later restore it using fsetpos. It reads the first two lines of a file, then goes back to read the second line again.",
                  "expectedOutput": "First line: [content of first line]\nSecond line: [content of second line]\nLine after restoring position: [content of second line]"
                },
                {
                  "title": "Error Handling",
                  "code": "#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n\nint main() {\n    FILE *file = fopen(\"nonexistent.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Error opening file: %s\\n\", strerror(errno));\n        return 1;\n    }\n\n    fpos_t position;\n    if (fgetpos(file, &position) != 0) {\n        printf(\"Error getting file position: %s\\n\", strerror(errno));\n        fclose(file);\n        return 1;\n    }\n\n    // This part won't be reached if the file doesn't exist\n    printf(\"File position obtained successfully.\\n\");\n\n    fclose(file);\n    return 0;\n}",
                  "explanation": "This example demonstrates error handling with `fgetpos`. It attempts to open a non-existent file and shows how to handle errors from both fopen and fgetpos using errno and strerror.",
                  "expectedOutput": "Error opening file: No such file or directory"
                }
              ]
            },
            {
              "function_name": "fgets",
              "include_file": "stdio.h",
              "return_type": "char*",
              "parameter_types": ["char*", "int", "FILE*"],
              "main_category": "File and I/O Operations",
              "sub_category": "File Management",
              "data_type_manipulated": "strings",
              "description": "Reads a line from the specified stream and stores it into the string pointed to by str.",
              "extended_description": "The fgets function reads characters from stream and stores them as a C string into str until (num-1) characters have been read or either a newline or the end-of-file is reached, whichever happens first. A terminating null character is automatically appended after the characters copied to str. fgets is commonly used for reading lines from text files.",
              "return_value": "On success, the function returns str. If the end-of-file is encountered while attempting to read a character, the eof indicator is set (feof). If this happens before any characters could be read, the pointer returned is a null pointer (and the contents of str remain unchanged). If a read error occurs, the error indicator (ferror) is set and a null pointer is also returned.",
              "parameter_values": "This function takes three parameters: str (pointer to an array of chars where the string read is copied), num (maximum number of characters to be copied into str, including the terminating null-character), and stream (pointer to a FILE object that identifies an input stream).",
              "function_prototype": "char *fgets(char *str, int num, FILE *stream);",
              "examples": [
                {
                  "title": "Basic Usage",
                  "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    char buffer[100];\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"%s\", buffer);\n    }\n\n    fclose(file);\n    return 0;\n}",
                  "explanation": "This example demonstrates the basic usage of `fgets`. It reads a file line by line and prints each line to the console.",
                  "expectedOutput": "[Contents of example.txt]"
                },
                {
                  "title": "Handling Line Endings",
                  "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    char buffer[100];\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        // Remove newline character if present\n        size_t len = strlen(buffer);\n        if (len > 0 && buffer[len-1] == '\\n') {\n            buffer[len-1] = '\\0';\n        }\n        printf(\"Line: %s\\n\", buffer);\n    }\n\n    fclose(file);\n    return 0;\n}",
                  "explanation": "This example shows how to handle line endings when using `fgets`. It removes the newline character from the end of each line before printing.",
                  "expectedOutput": "Line: [content of first line]\nLine: [content of second line]\n..."
                },
                {
                  "title": "Reading Fixed-Length Records",
                  "code": "#include <stdio.h>\n#include <string.h>\n\n#define RECORD_SIZE 20\n\nint main() {\n    FILE *file = fopen(\"records.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    char record[RECORD_SIZE + 1];  // +1 for null terminator\n    int record_number = 0;\n\n    while (fgets(record, sizeof(record), file) != NULL) {\n        record_number++;\n        // Remove newline character if present\n        size_t len = strlen(record);\n        if (len > 0 && record[len-1] == '\\n') {\n            record[len-1] = '\\0';\n        }\n        printf(\"Record %d: %s\\n\", record_number, record);\n\n        // If we didn't read a full record, skip to the next line\n        if (strlen(record) == RECORD_SIZE - 1) {\n            int ch;\n            while ((ch = fgetc(file)) != EOF && ch != '\\n') {}\n        }\n    }\n\n    fclose(file);\n    return 0;\n}",
                  "explanation": "This example demonstrates how to use `fgets` to read fixed-length records from a file. It handles cases where a record might be longer than the specified length by skipping the rest of the line.",
                  "expectedOutput": "Record 1: [content of first record]\nRecord 2: [content of second record]\n..."
                }
              ]
            },
            
              {
                "function_name": "fgetwc",
                "include_file": "wchar.h",
                "return_type": "wint_t",
                "parameter_types": ["FILE*"],
                "main_category": "File and I/O Operations",
                "sub_category": "File Management",
                "data_type_manipulated": "wide characters",
                "description": "Reads a wide character from the given input stream.",
                "extended_description": "The fgetwc function obtains the next wide character (if present) as a wint_t from the input stream pointed to by stream, and advances the associated file position indicator for the stream (if defined). This function is similar to fgetc, but it reads a wide character instead of a single-byte character. It's particularly useful when working with Unicode text or other multi-byte character encodings.",
                "return_value": "Returns the wide character read as a wint_t, or WEOF if the end of file is reached or if an error occurs.",
                "parameter_values": "This function takes one parameter: stream (a pointer to a FILE object that identifies an input stream).",
                "function_prototype": "wint_t fgetwc(FILE *stream);",
                "examples": [
                  {
                    "title": "Basic Usage",
                    "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");  // Set the locale to the system default\n\n    FILE *file = fopen(\"wide.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    wint_t wc;\n    while ((wc = fgetwc(file)) != WEOF) {\n        putwchar(wc);\n    }\n\n    if (ferror(file)) {\n        fwprintf(stderr, L\"Error reading file\\n\");\n    }\n\n    fclose(file);\n    return 0;\n}",
                    "explanation": "This example demonstrates the basic usage of `fgetwc`. It reads a file containing wide characters and prints them to the console. Note the use of setlocale to ensure proper handling of wide characters.",
                    "expectedOutput": "[Contents of wide.txt as wide characters]"
                  },
                  {
                    "title": "Counting Wide Characters",
                    "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");  // Set the locale to the system default\n\n    FILE *file = fopen(\"wide.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    wint_t wc;\n    int total = 0, alpha = 0, digit = 0, space = 0;\n\n    while ((wc = fgetwc(file)) != WEOF) {\n        total++;\n        if (iswalpha(wc)) alpha++;\n        else if (iswdigit(wc)) digit++;\n        else if (iswspace(wc)) space++;\n    }\n\n    if (ferror(file)) {\n        fwprintf(stderr, L\"Error reading file\\n\");\n    } else {\n        fwprintf(stdout, L\"Total wide characters: %d\\n\", total);\n        fwprintf(stdout, L\"Alphabetic: %d\\n\", alpha);\n        fwprintf(stdout, L\"Numeric: %d\\n\", digit);\n        fwprintf(stdout, L\"Whitespace: %d\\n\", space);\n    }\n\n    fclose(file);\n    return 0;\n}",
                    "explanation": "This example uses `fgetwc` to read a file and count different types of wide characters. It demonstrates how fgetwc can be used in conjunction with wide character classification functions.",
                    "expectedOutput": "Total wide characters: [count]\nAlphabetic: [alpha]\nNumeric: [digit]\nWhitespace: [space]"
                  },
                  {
                    "title": "Handling Unicode Characters",
                    "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"en_US.UTF-8\");  // Set locale to support UTF-8\n\n    FILE *file = fopen(\"unicode.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    wint_t wc;\n    while ((wc = fgetwc(file)) != WEOF) {\n        if (wc > 127) {  // Non-ASCII character\n            fwprintf(stdout, L\"Unicode character U+%04X: %lc\\n\", wc, wc);\n        } else {\n            fwprintf(stdout, L\"ASCII character: %lc\\n\", wc);\n        }\n    }\n\n    if (ferror(file)) {\n        fwprintf(stderr, L\"Error reading file\\n\");\n    }\n\n    fclose(file);\n    return 0;\n}",
                    "explanation": "This example demonstrates how to use `fgetwc` to read and identify Unicode characters. It distinguishes between ASCII and non-ASCII characters and prints their Unicode code points.",
                    "expectedOutput": "ASCII character: [character]\nUnicode character U+[code]: [character]\n..."
                  }
                ]
              },
              {
                "function_name": "fgetws",
                "include_file": "wchar.h",
                "return_type": "wchar_t*",
                "parameter_types": ["wchar_t*", "int", "FILE*"],
                "main_category": "File and I/O Operations",
                "sub_category": "File Management",
                "data_type_manipulated": "wide characters",
                "description": "Reads a line of wide characters from a stream.",
                "extended_description": "The fgetws function reads wide characters from stream and stores them as a wide-character string into ws until (n-1) characters have been read or either a newline or the end-of-file is reached, whichever happens first. A null wide character is automatically appended after the characters read. This function is similar to fgets, but it reads wide characters instead of single-byte characters.",
                "return_value": "On success, the function returns ws. If the end-of-file is encountered while attempting to read a character, the eof indicator is set. If this happens before any characters could be read, the function returns NULL. If a read error occurs, the error indicator is set and NULL is returned.",
                "parameter_values": "This function takes three parameters: ws (pointer to an array of wide characters), n (maximum number of wide characters to be read, including the terminating null-character), and stream (pointer to a FILE object that identifies an input stream).",
                "function_prototype": "wchar_t *fgetws(wchar_t *ws, int n, FILE *stream);",
                "examples": [
                  {
                    "title": "Basic Usage",
                    "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");  // Set the locale to the system default\n\n    FILE *file = fopen(\"wide.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    wchar_t buffer[100];\n    while (fgetws(buffer, sizeof(buffer)/sizeof(wchar_t), file) != NULL) {\n        fputws(buffer, stdout);\n    }\n\n    if (ferror(file)) {\n        fwprintf(stderr, L\"Error reading file\\n\");\n    }\n\n    fclose(file);\n    return 0;\n}",
                    "explanation": "This example demonstrates the basic usage of `fgetws`. It reads a file containing wide characters line by line and prints each line to the console.",
                    "expectedOutput": "[Contents of wide.txt as wide character lines]"
                  },
                  {
                    "title": "Handling Line Endings",
                    "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");  // Set the locale to the system default\n\n    FILE *file = fopen(\"wide.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    wchar_t buffer[100];\n    while (fgetws(buffer, sizeof(buffer)/sizeof(wchar_t), file) != NULL) {\n        // Remove newline character if present\n        wchar_t *newline = wcschr(buffer, L'\\n');\n        if (newline != NULL) {\n            *newline = L'\\0';\n        }\n        fwprintf(stdout, L\"Line: %ls\\n\", buffer);\n    }\n\n    if (ferror(file)) {\n        fwprintf(stderr, L\"Error reading file\\n\");\n    }\n\n    fclose(file);\n    return 0;\n}",
                    "explanation": "This example shows how to handle line endings when using `fgetws`. It removes the newline character from the end of each line before printing.",
                    "expectedOutput": "Line: [content of first line]\nLine: [content of second line]\n..."
                  },
                  {
                    "title": "Reading Fixed-Length Wide Character Records",
                    "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\n#define RECORD_SIZE 20\n\nint main() {\n    setlocale(LC_ALL, \"\");  // Set the locale to the system default\n\n    FILE *file = fopen(\"wide_records.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    wchar_t record[RECORD_SIZE + 1];  // +1 for null terminator\n    int record_number = 0;\n\n    while (fgetws(record, sizeof(record)/sizeof(wchar_t), file) != NULL) {\n        record_number++;\n        // Remove newline character if present\n        wchar_t *newline = wcschr(record, L'\\n');\n        if (newline != NULL) {\n            *newline = L'\\0';\n        }\n        fwprintf(stdout, L\"Record %d: %ls\\n\", record_number, record);\n\n        // If we didn't read a full record, skip to the next line\n        if (wcslen(record) == RECORD_SIZE - 1) {\n            wint_t wc;\n            while ((wc = fgetwc(file)) != WEOF && wc != L'\\n') {}\n        }\n    }\n\n    if (ferror(file)) {\n        fwprintf(stderr, L\"Error reading file\\n\");\n    }\n\n    fclose(file);\n    return 0;\n}",
                    "explanation": "This example demonstrates how to use `fgetws` to read fixed-length records of wide characters from a file. It handles cases where a record might be longer than the specified length by skipping the rest of the line.",
                    "expectedOutput": "Record 1: [content of first record]\nRecord 2: [content of second record]\n..."
                  }
                ]
              } ,

          {
            "function_name": "fopen",
            "include_file": "stdio.h",
            "return_type": "FILE*",
            "parameter_types": ["const char*", "const char*"],
            "main_category": "File and I/O Operations",
            "sub_category": "File Management",
            "data_type_manipulated": "file streams",
            "description": "Opens the file named by filename and returns a stream associated with that file.",
            "extended_description": "The fopen function opens the file whose name is specified in the parameter filename and associates a stream with it. The mode parameter is used to determine the file access mode. This function is fundamental for file I/O operations in C, as it provides a way to create new files or open existing ones for reading, writing, or both.",
            "return_value": "Returns a FILE pointer to the file opened if successful. If the file cannot be opened, fopen returns NULL. In case of failure, errno is set to indicate the error.",
            "parameter_values": "This function takes two parameters: filename (a string containing the name of the file to be opened) and mode (a string containing a file access mode).",
            "function_prototype": "FILE *fopen(const char *filename, const char *mode);",
            "examples": [
              {
                "title": "Basic Usage - Reading a File",
                "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    char buffer[100];\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"%s\", buffer);\n    }\n\n    fclose(file);\n    return 0;\n}",
                "explanation": "This example demonstrates how to use `fopen` to open a file for reading. It opens 'example.txt' in read mode, reads its contents line by line, and prints them to the console.",
                "expectedOutput": "[Contents of example.txt]"
              },
              {
                "title": "Writing to a File",
                "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"output.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    fprintf(file, \"Hello, World!\\n\");\n    fprintf(file, \"This is a test.\\n\");\n\n    fclose(file);\n    printf(\"Data written to output.txt\\n\");\n    return 0;\n}",
                "explanation": "This example shows how to use `fopen` to create a new file (or overwrite an existing one) for writing. It opens 'output.txt' in write mode and writes two lines to it.",
                "expectedOutput": "Data written to output.txt"
              },
              {
                "title": "Appending to a File",
                "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    FILE *file = fopen(\"log.txt\", \"a\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    time_t now = time(NULL);\n    char *time_str = ctime(&now);\n    fprintf(file, \"Log entry at %s\", time_str);\n\n    fclose(file);\n    printf(\"Log entry added to log.txt\\n\");\n    return 0;\n}",
                "explanation": "This example demonstrates using `fopen` with the append mode. It opens 'log.txt' in append mode, adds a timestamped log entry, and closes the file. Each run of this program will add a new entry to the end of the file.",
                "expectedOutput": "Log entry added to log.txt"
              }
            ]
          },
          {
            "function_name": "fprintf",
            "include_file": "stdio.h",
            "return_type": "int",
            "parameter_types": ["FILE*", "const char*", "..."],
            "main_category": "File and I/O Operations",
            "sub_category": "Stream Manipulation",
            "data_type_manipulated": "file streams",
            "description": "Writes formatted output to a stream.",
            "extended_description": "The fprintf function writes output to the stream pointed to by stream, under control of the string pointed to by format that specifies how subsequent arguments are converted for output. It behaves exactly like printf, but writes to the specified stream instead of stdout.",
            "return_value": "Returns the number of characters written if successful, or a negative value if an error occurred.",
            "parameter_values": "This function takes at least two parameters: stream (a pointer to a FILE object that identifies an output stream) and format (a string that contains the text to be written to the stream, optionally containing embedded format tags), followed by additional arguments as specified by format.",
            "function_prototype": "int fprintf(FILE *stream, const char *format, ...);",
            "examples": [
              {
                "title": "Basic Usage",
                "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"output.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    int num = 42;\n    char str[] = \"Hello, World!\";\n    \n    fprintf(file, \"Number: %d\\nString: %s\\n\", num, str);\n\n    fclose(file);\n    printf(\"Data written to output.txt\\n\");\n    return 0;\n}",
                "explanation": "This example demonstrates the basic usage of `fprintf`. It writes formatted output to a file, including an integer and a string.",
                "expectedOutput": "Data written to output.txt\n(And output.txt will contain:\nNumber: 42\nString: Hello, World!)"
              },
              {
                "title": "Writing Tabular Data",
                "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    fprintf(file, \"%-10s %-10s %-10s\\n\", \"Name\", \"Age\", \"City\");\n    fprintf(file, \"%-10s %-10d %-10s\\n\", \"Alice\", 25, \"New York\");\n    fprintf(file, \"%-10s %-10d %-10s\\n\", \"Bob\", 30, \"London\");\n    fprintf(file, \"%-10s %-10d %-10s\\n\", \"Charlie\", 35, \"Paris\");\n\n    fclose(file);\n    printf(\"Tabular data written to data.txt\\n\");\n    return 0;\n}",
                "explanation": "This example shows how to use `fprintf` to write tabular data to a file. It uses field width specifiers to align the columns.",
                "expectedOutput": "Tabular data written to data.txt\n(And data.txt will contain a formatted table)"
              },
              {
                "title": "Error Logging",
                "code": "#include <stdio.h>\n#include <time.h>\n\nvoid log_error(FILE *log_file, const char *message) {\n    time_t now = time(NULL);\n    char *time_str = ctime(&now);\n    time_str[24] = '\\0';  // Remove newline\n    fprintf(log_file, \"[%s] ERROR: %s\\n\", time_str, message);\n}\n\nint main() {\n    FILE *log_file = fopen(\"error_log.txt\", \"a\");\n    if (log_file == NULL) {\n        perror(\"Error opening log file\");\n        return 1;\n    }\n\n    log_error(log_file, \"Unable to connect to database\");\n    log_error(log_file, \"File not found: data.csv\");\n\n    fclose(log_file);\n    printf(\"Errors logged to error_log.txt\\n\");\n    return 0;\n}",
                "explanation": "This example demonstrates using `fprintf` for error logging. It writes timestamped error messages to a log file.",
                "expectedOutput": "Errors logged to error_log.txt\n(And error_log.txt will contain timestamped error messages)"
              }
            ]
          },
          {
            "function_name": "fputc",
            "include_file": "stdio.h",
            "return_type": "int",
            "parameter_types": ["int", "FILE*"],
            "main_category": "File and I/O Operations",
            "sub_category": "File Management",
            "data_type_manipulated": "file streams",
            "description": "Writes a character to a file stream.",
            "extended_description": "The fputc function writes the character specified by c (converted to an unsigned char) to the output stream pointed to by stream. It advances the position indicator for the stream. This function is useful for writing individual characters to a file or output stream.",
            "return_value": "Returns the character written as an unsigned char cast to an int if successful, or EOF if a write error occurs.",
            "parameter_values": "This function takes two parameters: c (an int representing the character to be written) and stream (a pointer to a FILE object that identifies an output stream).",
            "function_prototype": "int fputc(int c, FILE *stream);",
            "examples": [
              {
                "title": "Basic Usage",
                "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"output.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    char str[] = \"Hello, World!\";\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (fputc(str[i], file) == EOF) {\n            printf(\"Error writing character\\n\");\n            fclose(file);\n            return 1;\n        }\n    }\n\n    fclose(file);\n    printf(\"Data written to output.txt\\n\");\n    return 0;\n}",
                "explanation": "This example demonstrates the basic usage of `fputc`. It writes each character of a string to a file individually.",
                "expectedOutput": "Data written to output.txt\n(And output.txt will contain: Hello, World!)"
              },
              {
                "title": "Writing ASCII Art",
                "code": "#include <stdio.h>\n\nvoid write_ascii_art(FILE *file) {\n    const char *art[] = {\n        \"  *  \",\n        \" *** \",\n        \"*****\"\n    };\n\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; art[i][j] != '\\0'; j++) {\n            fputc(art[i][j], file);\n        }\n        fputc('\\n', file);\n    }\n}\n\nint main() {\n    FILE *file = fopen(\"ascii_art.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    write_ascii_art(file);\n\n    fclose(file);\n    printf(\"ASCII art written to ascii_art.txt\\n\");\n    return 0;\n}",
                "explanation": "This example uses `fputc` to write ASCII art to a file. It demonstrates how fputc can be used to create structured text output.",
                "expectedOutput": "ASCII art written to ascii_art.txt\n(And ascii_art.txt will contain a small ASCII tree)"
              },
              {
                "title": "Writing Binary Data",
                "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"binary.dat\", \"wb\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    unsigned char data[] = {0xDE, 0xAD, 0xBE, 0xEF};\n    for (int i = 0; i < sizeof(data); i++) {\n        if (fputc(data[i], file) == EOF) {\n            printf(\"Error writing byte\\n\");\n            fclose(file);\n            return 1;\n        }\n    }\n\n    fclose(file);\n    printf(\"Binary data written to binary.dat\\n\");\n    return 0;\n}",
                "explanation": "This example shows how to use `fputc` to write binary data to a file. It writes a series of bytes to create a small binary file.",
                "expectedOutput": "Binary data written to binary.dat\n(And binary.dat will contain the bytes 0xDE, 0xAD, 0xBE, 0xEF)"
              }
            ]
          },
          
            {
              "function_name": "fputws",
              "include_file": "wchar.h",
              "return_type": "int",
              "parameter_types": ["const wchar_t*", "FILE*"],
              "main_category": "File and I/O Operations",
              "sub_category": "File Management",
              "data_type_manipulated": "wide characters",
              "description": "Writes a wide-character string to a file stream.",
              "extended_description": "The fputws function writes the wide-character string pointed to by ws to the stream. The terminating null wide character is not written. This function is useful for writing strings of wide characters to files or other output streams without formatting. It's particularly helpful when dealing with Unicode or other multibyte character encodings.",
              "return_value": "Returns a non-negative value if successful, or EOF if a write error occurs.",
              "parameter_values": "This function takes two parameters: ws (a pointer to the null-terminated wide-character string to be written) and stream (a pointer to a FILE object that identifies an output stream).",
              "function_prototype": "int fputws(const wchar_t *ws, FILE *stream);",
              "examples": [
                {
                  "title": "Basic Usage",
                  "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");  // Set the locale to the system default\n\n    FILE *file = fopen(\"wide_output.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    if (fputws(L\"Hello, Wide World!\\n\", file) == EOF) {\n        fwprintf(stderr, L\"Error writing to file\\n\");\n        fclose(file);\n        return 1;\n    }\n\n    fclose(file);\n    wprintf(L\"Data written to wide_output.txt\\n\");\n    return 0;\n}",
                  "explanation": "This example demonstrates the basic usage of `fputws`. It writes a simple wide-character string to a file and checks for errors.",
                  "expectedOutput": "Data written to wide_output.txt\n(And wide_output.txt will contain: Hello, Wide World!)"
                },
                {
                  "title": "Writing Multilingual Text",
                  "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");  // Set the locale to the system default\n\n    FILE *file = fopen(\"multilingual.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    const wchar_t *texts[] = {\n        L\"English: Hello, World!\\n\",\n        L\"Japanese: こんにちは、世界！\\n\",\n        L\"Russian: Здравствуй, мир!\\n\",\n        L\"Greek: Γειά σου, Κόσμε!\\n\"\n    };\n\n    for (int i = 0; i < 4; i++) {\n        if (fputws(texts[i], file) == EOF) {\n            fwprintf(stderr, L\"Error writing to file\\n\");\n            fclose(file);\n            return 1;\n        }\n    }\n\n    fclose(file);\n    wprintf(L\"Multilingual text written to multilingual.txt\\n\");\n    return 0;\n}",
                  "explanation": "This example shows how to use `fputws` to write multilingual text to a file. It writes 'Hello, World!' in different languages, demonstrating the function's ability to handle various character sets.",
                  "expectedOutput": "Multilingual text written to multilingual.txt\n(And multilingual.txt will contain 'Hello, World!' in four languages)"
                },
                {
                  "title": "Writing a Simple Wide-Character Log",
                  "code": "#include <stdio.h>\n#include <wchar.h>\n#include <time.h>\n#include <locale.h>\n\nvoid log_wide(FILE *file, const wchar_t *message) {\n    time_t now = time(NULL);\n    wchar_t timestamp[26];\n    wcsftime(timestamp, sizeof(timestamp)/sizeof(wchar_t), L\"%Y-%m-%d %H:%M:%S\", localtime(&now));\n\n    fputws(timestamp, file);\n    fputws(L\" - \", file);\n    fputws(message, file);\n    fputwc(L'\\n', file);\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");  // Set the locale to the system default\n\n    FILE *log_file = fopen(\"wide_log.txt\", \"w\");\n    if (log_file == NULL) {\n        perror(\"Error opening log file\");\n        return 1;\n    }\n\n    log_wide(log_file, L\"Application started\");\n    log_wide(log_file, L\"Processing data\");\n    log_wide(log_file, L\"Application ended\");\n\n    fclose(log_file);\n    wprintf(L\"Log entries written to wide_log.txt\\n\");\n    return 0;\n}",
                  "explanation": "This example demonstrates a practical use of `fputws` for creating a simple log file with wide characters. It includes timestamps and messages, showcasing how fputws can be used in more complex scenarios.",
                  "expectedOutput": "Log entries written to wide_log.txt\n(And wide_log.txt will contain timestamped log entries in wide-character format)"
                }
              ]
            },
            {
              "function_name": "fread",
              "include_file": "stdio.h",
              "return_type": "size_t",
              "parameter_types": ["void*", "size_t", "size_t", "FILE*"],
              "main_category": "File and I/O Operations",
              "sub_category": "File Management",
              "data_type_manipulated": "file streams",
              "description": "Reads data from the given stream into the array pointed to by ptr.",
              "extended_description": "The fread function reads nmemb elements of data, each size bytes long, from the stream pointed to by stream, storing them at the location given by ptr. The file position indicator for the stream is advanced by the number of bytes successfully read. This function is commonly used for reading binary data or large chunks of data from files.",
              "return_value": "Returns the number of elements successfully read (which may be less than nmemb if a read error or end-of-file is encountered). If size or nmemb is zero, fread returns zero and the contents pointed to by ptr and the state of the stream remain unchanged.",
              "parameter_values": "This function takes four parameters: ptr (pointer to a block of memory with a size of at least (size*nmemb) bytes), size (size in bytes of each element to be read), nmemb (number of elements to read), and stream (pointer to a FILE object that specifies an input stream).",
              "function_prototype": "size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);",
              "examples": [
                {
                  "title": "Basic Usage - Reading a Text File",
                  "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"sample.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    char buffer[100];\n    size_t bytesRead = fread(buffer, 1, sizeof(buffer) - 1, file);\n    \n    if (bytesRead == 0 && ferror(file)) {\n        printf(\"Error reading file\\n\");\n    } else {\n        buffer[bytesRead] = '\\0';  // Null-terminate the string\n        printf(\"Read %zu bytes: %s\\n\", bytesRead, buffer);\n    }\n\n    fclose(file);\n    return 0;\n}",
                  "explanation": "This example demonstrates basic usage of `fread` to read content from a text file. It reads up to 99 bytes from the file into a buffer and then prints the content.",
                  "expectedOutput": "Read [X] bytes: [Content of sample.txt]\n(Where [X] is the number of bytes read)"
                },
                {
                  "title": "Reading Binary Data",
                  "code": "#include <stdio.h>\n#include <stdint.h>\n\ntypedef struct {\n    uint32_t id;\n    char name[20];\n    float score;\n} Record;\n\nint main() {\n    FILE *file = fopen(\"records.bin\", \"rb\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    Record record;\n    while (fread(&record, sizeof(Record), 1, file) == 1) {\n        printf(\"ID: %u, Name: %s, Score: %.2f\\n\", \n               record.id, record.name, record.score);\n    }\n\n    if (ferror(file)) {\n        printf(\"Error reading file\\n\");\n    }\n\n    fclose(file);\n    return 0;\n}",
                  "explanation": "This example shows how to use `fread` to read binary data. It reads records from a binary file, where each record contains an ID, a name, and a score.",
                  "expectedOutput": "ID: [id1], Name: [name1], Score: [score1]\nID: [id2], Name: [name2], Score: [score2]\n...\n(Displaying all records read from the binary file)"
                },
                {
                  "title": "Reading Large Chunks of Data",
                  "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define CHUNK_SIZE 1024\n\nint main() {\n    FILE *file = fopen(\"large_file.dat\", \"rb\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    unsigned char *buffer = malloc(CHUNK_SIZE);\n    if (buffer == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        fclose(file);\n        return 1;\n    }\n\n    size_t totalBytesRead = 0;\n    size_t bytesRead;\n\n    while ((bytesRead = fread(buffer, 1, CHUNK_SIZE, file)) > 0) {\n        totalBytesRead += bytesRead;\n        // Process the data in the buffer here\n    }\n\n    if (ferror(file)) {\n        printf(\"Error reading file\\n\");\n    } else {\n        printf(\"Total bytes read: %zu\\n\", totalBytesRead);\n    }\n\n    free(buffer);\n    fclose(file);\n    return 0;\n}",
                  "explanation": "This example demonstrates how to use `fread` to read large files in chunks. It reads the file in 1KB chunks, which is useful for processing large files without loading the entire file into memory at once.",
                  "expectedOutput": "Total bytes read: [X]\n(Where [X] is the total number of bytes in the file)"
                }
              ]
            },
        {
          "function_name": "free",
          "include_file": "stdlib.h",
          "return_type": "void",
          "parameter_types": ["void*"],
          "main_category": "Memory Management",
          "sub_category": "Management",
          "data_type_manipulated": "memory",
          "description": "Frees the memory space pointed to by ptr, which must have been returned by a previous call to malloc or calloc.",
          "extended_description": "The free function deallocates the memory previously allocated by a call to malloc, calloc, or realloc. If ptr is a NULL pointer, no operation is performed. The free function does not return a value. After calling free, the pointer becomes a dangling pointer and should not be used. It's crucial to only free memory that was dynamically allocated and to avoid double-freeing memory.",
          "return_value": "This function does not return a value.",
          "parameter_values": "This function takes one parameter: ptr (a pointer to the memory block to be freed).",
          "function_prototype": "void free(void *ptr);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *ptr = (int*) malloc(5 * sizeof(int));\n    if (ptr == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        return 1;\n    }\n\n    for (int i = 0; i < 5; i++) {\n        ptr[i] = i * 10;\n    }\n\n    printf(\"Allocated memory contents: \");\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", ptr[i]);\n    }\n    printf(\"\\n\");\n\n    free(ptr);\n    printf(\"Memory has been freed\\n\");\n\n    // ptr is now a dangling pointer and should not be used\n    ptr = NULL;  // Good practice to set freed pointers to NULL\n\n    return 0;\n}",
              "explanation": "This example demonstrates the basic usage of `free`. It allocates memory for an array of integers, uses the memory, and then frees it.",
              "expectedOutput": "Allocated memory contents: 0 10 20 30 40 \nMemory has been freed"
            },
            {
              "title": "Freeing Structures",
              "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char *name;\n    int age;\n} Person;\n\nPerson* createPerson(const char* name, int age) {\n    Person *p = (Person*) malloc(sizeof(Person));\n    if (p == NULL) return NULL;\n\n    p->name = (char*) malloc(strlen(name) + 1);\n    if (p->name == NULL) {\n        free(p);\n        return NULL;\n    }\n\n    strcpy(p->name, name);\n    p->age = age;\n    return p;\n}\n\nvoid freePerson(Person *p) {\n    if (p != NULL) {\n        free(p->name);  // Free the name string\n        free(p);        // Free the Person structure\n    }\n}\n\nint main() {\n    Person *person = createPerson(\"Alice\", 30);\n    if (person == NULL) {\n        printf(\"Failed to create person\\n\");\n        return 1;\n    }\n\n    printf(\"Person: %s, Age: %d\\n\", person->name, person->age);\n\n    freePerson(person);\n    printf(\"Person has been freed\\n\");\n\n    return 0;\n}",
              "explanation": "This example shows how to use `free` with more complex structures. It demonstrates freeing nested allocations (a string within a structure) and the importance of freeing all allocated memory to prevent memory leaks.",
              "expectedOutput": "Person: Alice, Age: 30\nPerson has been freed"
            },
            {
              "title": "Handling NULL Pointers and Avoiding Double Free",
              "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid safeAllocateAndFree(size_t size) {\n    int *ptr = (int*) malloc(size * sizeof(int));\n    if (ptr == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        return;\n    }\n\n    printf(\"Memory allocated successfully\\n\");\n\n    // Use the memory...\n\n    free(ptr);  // Safe to free\n    printf(\"Memory freed\\n\");\n\n    free(ptr);  // Attempting to free again (dangerous!)\n    printf(\"Attempted to free already freed memory\\n\");\n\n    free(NULL);  // Safe: free(NULL) is guaranteed to do nothing\n    printf(\"Called free(NULL)\\n\");\n\n    ptr = NULL;  // Good practice after freeing\n}\n\nint main() {\n    safeAllocateAndFree(5);\n    return 0;\n}",
              "explanation": "This example demonstrates safe practices and common pitfalls with `free`. It shows that freeing NULL is safe, but double-freeing memory can lead to undefined behavior. Note that the second free(ptr) is included to demonstrate what not to do; in practice, this should be avoided.",
              "expectedOutput": "Memory allocated successfully\nMemory freed\nAttempted to free already freed memory\nCalled free(NULL)\n\nNote: The behavior after the second free(ptr) is undefined and may vary."
            }
          ]
        },
        {
          "function_name": "freopen",
          "include_file": "stdio.h",
          "return_type": "FILE*",
          "parameter_types": ["const char*", "const char*", "FILE*"],
          "main_category": "File and I/O Operations",
          "sub_category": "File Management",
          "data_type_manipulated": "file streams",
          "description": "Reopens the file stream with a different file or mode.",
          "extended_description": "The freopen function associates a new filename with the given open stream and at the same time closes the old file in the stream. This function is particularly useful for redirecting the standard streams (stdin, stdout, stderr) to files. If the operation fails, the original stream is closed. When successful, freopen clears the error and end-of-file indicators for the stream.",
          "return_value": "Returns a pointer to the newly associated stream. If the operation fails, NULL is returned, and the original stream is closed.",
          "parameter_values": "This function takes three parameters: filename (a string containing the name of the file to be opened), mode (a string containing a file access mode), and stream (a pointer to a FILE object that identifies the stream to be reopened).",
          "function_prototype": "FILE *freopen(const char *filename, const char *mode, FILE *stream);",
          "examples": [
            {
              "title": "Redirecting stdout to a File",
              "code": "#include <stdio.h>\n\nint main() {\n    printf(\"This will be printed to the console\\n\");\n\n    // Redirect stdout to a file\n    if (freopen(\"output.txt\", \"w\", stdout) == NULL) {\n        perror(\"freopen() failed\");\n        return 1;\n    }\n\n    printf(\"This will be written to output.txt\\n\");\n    \n    // Close the file (which also restores stdout)\n    fclose(stdout);\n\n    printf(\"This will be printed to the console again\\n\");\n\n    return 0;\n}",
              "explanation": "This example demonstrates how to use `freopen` to redirect stdout to a file. It first prints to the console, then redirects stdout to a file, prints to the file, and finally restores stdout to print to the console again.",
              "expectedOutput": "This will be printed to the console\nThis will be printed to the console again\n\n(And output.txt will contain: This will be written to output.txt)"
            },
            {
              "title": "Changing File Access Mode",
              "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    fprintf(file, \"Initial content\\n\");\n\n    // Change the file access mode from write to append\n    if (freopen(\"data.txt\", \"a\", file) == NULL) {\n        perror(\"freopen() failed\");\n        fclose(file);\n        return 1;\n    }\n\n    fprintf(file, \"Appended content\\n\");\n\n    fclose(file);\n\n    // Read and print the file contents\n    file = fopen(\"data.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file for reading\");\n        return 1;\n    }\n\n    char buffer[100];\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"%s\", buffer);\n    }\n\n    fclose(file);\n    return 0;\n}",
              "explanation": "This example shows how to use `freopen` to change the access mode of an open file. It opens a file in write mode, writes some content, then uses freopen to change to append mode, and writes more content.",
              "expectedOutput": "Initial content\nAppended content"
            },
            {
              "title": "Redirecting stdin for Input",
              "code": "#include <stdio.h>\n\nint main() {\n    // First, create a file with some content\n    FILE *file = fopen(\"input.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error creating input file\");\n        return 1;\n    }\n    fprintf(file, \"42\\n84\\n\");\n    fclose(file);\n\n    // Now redirect stdin to read from this file\n    if (freopen(\"input.txt\", \"r\", stdin) == NULL) {\n        perror(\"freopen() failed\");\n        return 1;\n    }\n\n    int num1, num2;\n    scanf(\"%d\", &num1);\n    scanf(\"%d\", &num2);\n\n    printf(\"Read from file: %d and %d\\n\", num1, num2);\n    printf(\"Sum: %d\\n\", num1 + num2);\n\n    // stdin is automatically closed when the program ends\n\n    return 0;\n}",
              "explanation": "This example demonstrates using `freopen` to redirect stdin to read from a file. It creates a file with some numbers, then uses freopen to make stdin read from this file instead of the keyboard. The program then reads and processes the numbers as if they were entered by the user.",
              "expectedOutput": "Read from file: 42 and 84\nSum: 126"
            }
          ]
        },
    
      {
        "function_name": "frexp",
        "include_file": "math.h",
        "return_type": "double",
        "parameter_types": ["double", "int*"],
        "main_category": "Mathematical Operations",
        "sub_category": "Advanced Computation",
        "data_type_manipulated": "floating-point numbers",
        "description": "Decomposes a floating-point number into its binary significand and an integral exponent for 2.",
        "extended_description": "The frexp function breaks a floating-point number x into a normalized fraction and an integral power of 2. It stores the integer exponent in the object pointed to by exp. The normalized fraction is returned as a double value, x, such that x is a double with magnitude in the interval [1/2, 1) or zero, and value = x * 2^(*exp). If value is zero, both parts of the result are zero.",
        "return_value": "Returns the normalized fraction. If x is not zero, the normalized fraction is x times a power of two, and its absolute value is always in the range 1/2 (inclusive) to 1 (exclusive). If x is zero, the function returns zero and stores zero in *exp.",
        "parameter_values": "This function takes two parameters: x (the floating-point value to be decomposed) and exp (pointer to an integer where the exponent will be stored).",
        "function_prototype": "double frexp(double x, int *exp);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = 123.45;\n    int exponent;\n    double fraction = frexp(x, &exponent);\n\n    printf(\"Number: %f\\n\", x);\n    printf(\"Fraction: %f\\n\", fraction);\n    printf(\"Exponent: %d\\n\", exponent);\n    printf(\"Original number reconstructed: %f\\n\", fraction * pow(2, exponent));\n\n    return 0;\n}",
            "explanation": "This example demonstrates the basic usage of `frexp`. It decomposes a floating-point number into its fraction and exponent, then reconstructs the original number to verify the result.",
            "expectedOutput": "Number: 123.450000\nFraction: 0.964453\nExponent: 7\nOriginal number reconstructed: 123.450000"
          },
          {
            "title": "Handling Special Cases",
            "code": "#include <stdio.h>\n#include <math.h>\n\nvoid printFrexp(double x) {\n    int exponent;\n    double fraction = frexp(x, &exponent);\n    printf(\"Number: %f\\n\", x);\n    printf(\"Fraction: %f\\n\", fraction);\n    printf(\"Exponent: %d\\n\\n\", exponent);\n}\n\nint main() {\n    printFrexp(0.0);\n    printFrexp(INFINITY);\n    printFrexp(-INFINITY);\n    printFrexp(NAN);\n\n    return 0;\n}",
            "explanation": "This example shows how `frexp` handles special cases such as zero, infinity, and NaN (Not a Number). It's important to understand how the function behaves with these edge cases.",
            "expectedOutput": "Number: 0.000000\nFraction: 0.000000\nExponent: 0\n\nNumber: inf\nFraction: inf\nExponent: 0\n\nNumber: -inf\nFraction: -inf\nExponent: 0\n\nNumber: nan\nFraction: nan\nExponent: 0"
          },
          {
            "title": "Using frexp in Scientific Notation",
            "code": "#include <stdio.h>\n#include <math.h>\n\nvoid printScientific(double x) {\n    int exponent;\n    double fraction = frexp(x, &exponent);\n    \n    // Adjust for scientific notation (1.m * 10^n format)\n    fraction *= 2;\n    exponent -= 1;\n    \n    int tenExponent = (int)(exponent * log10(2));\n    double adjustedFraction = fraction * pow(2, exponent - tenExponent * log2(10));\n    \n    printf(\"%.6fe%d\\n\", adjustedFraction, tenExponent);\n}\n\nint main() {\n    printScientific(123.45);\n    printScientific(0.000123);\n    printScientific(1e20);\n    \n    return 0;\n}",
            "explanation": "This example uses `frexp` to implement a custom scientific notation formatter. It shows how frexp can be used in more complex mathematical operations, converting the binary exponent to a base-10 exponent for scientific notation.",
            "expectedOutput": "1.234500e2\n1.230000e-4\n1.000000e20"
          }
        ]
      },
      {
        "function_name": "fscanf",
        "include_file": "stdio.h",
        "return_type": "int",
        "parameter_types": ["FILE*", "const char*", "..."],
        "main_category": "File and I/O Operations",
        "sub_category": "Stream Manipulation",
        "data_type_manipulated": "file streams",
        "description": "Reads formatted input from a stream.",
        "extended_description": "The fscanf function reads input from the stream pointed to by stream, under control of the string pointed to by format that specifies the admissible input sequences and how they are to be converted for assignment, using subsequent arguments as pointers to the objects to receive the converted input. This function is similar to scanf, but reads from a specified stream instead of stdin.",
        "return_value": "Returns the number of input items successfully matched and assigned. This can be fewer than provided for, or even zero, in the event of an early matching failure. EOF is returned if the end of input is reached before either the first successful conversion or a matching failure occurs.",
        "parameter_values": "This function takes at least two parameters: stream (pointer to a FILE object that identifies an input stream) and format (C string that contains a format string), followed by additional arguments as specified by format.",
        "function_prototype": "int fscanf(FILE *stream, const char *format, ...);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    int num;\n    char str[50];\n    float fnum;\n\n    fscanf(file, \"%d %s %f\", &num, str, &fnum);\n\n    printf(\"Read from file:\\n\");\n    printf(\"Integer: %d\\n\", num);\n    printf(\"String: %s\\n\", str);\n    printf(\"Float: %.2f\\n\", fnum);\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example demonstrates the basic usage of `fscanf`. It reads an integer, a string, and a float from a file named 'data.txt'. The file should contain these values separated by spaces.",
            "expectedOutput": "Read from file:\nInteger: [value]\nString: [value]\nFloat: [value]\n(Actual values depend on the contents of data.txt)"
          },
          {
            "title": "Reading Structured Data",
            "code": "#include <stdio.h>\n\ntypedef struct {\n    char name[50];\n    int age;\n    float height;\n} Person;\n\nint main() {\n    FILE *file = fopen(\"people.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    Person people[3];\n    int count = 0;\n\n    while (count < 3 && fscanf(file, \"%49s %d %f\", \n                               people[count].name, \n                               &people[count].age, \n                               &people[count].height) == 3) {\n        count++;\n    }\n\n    printf(\"Read %d people from file:\\n\", count);\n    for (int i = 0; i < count; i++) {\n        printf(\"Name: %s, Age: %d, Height: %.2f\\n\", \n               people[i].name, people[i].age, people[i].height);\n    }\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example shows how to use `fscanf` to read structured data from a file. It reads information for up to three people from a file named 'people.txt', where each line contains a name, age, and height.",
            "expectedOutput": "Read [X] people from file:\nName: [name1], Age: [age1], Height: [height1]\nName: [name2], Age: [age2], Height: [height2]\n...\n(Actual values and number of entries depend on the contents of people.txt)"
          },
          {
            "title": "Error Handling and EOF Detection",
            "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"numbers.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    int num, sum = 0, count = 0;\n    while (1) {\n        int result = fscanf(file, \"%d\", &num);\n        if (result == EOF) {\n            if (feof(file)) {\n                printf(\"Reached end of file.\\n\");\n            } else if (ferror(file)) {\n                printf(\"Error reading file.\\n\");\n            }\n            break;\n        } else if (result != 1) {\n            printf(\"Failed to read an integer. Skipping...\\n\");\n            fscanf(file, \"%*s\");  // Skip the invalid input\n            continue;\n        }\n        sum += num;\n        count++;\n    }\n\n    if (count > 0) {\n        printf(\"Read %d numbers. Sum: %d, Average: %.2f\\n\", \n               count, sum, (float)sum / count);\n    } else {\n        printf(\"No valid numbers read from the file.\\n\");\n    }\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example demonstrates error handling and EOF detection with `fscanf`. It reads integers from a file, summing them up, while handling various potential errors such as EOF, read errors, and invalid input.",
            "expectedOutput": "Depends on the content of numbers.txt. It might be something like:\nReached end of file.\nRead 5 numbers. Sum: 150, Average: 30.00\n\nOr if there are invalid entries:\nFailed to read an integer. Skipping...\nReached end of file.\nRead 4 numbers. Sum: 100, Average: 25.00"
          }
        ]
      },
  
    {
      "function_name": "fseek",
      "include_file": "stdio.h",
      "return_type": "int",
      "parameter_types": ["FILE*", "long", "int"],
      "main_category": "File and I/O Operations",
      "sub_category": "Stream Manipulation",
      "data_type_manipulated": "file streams",
      "description": "Sets the file position of the stream to the given offset.",
      "extended_description": "The fseek function changes the file position indicator for the stream pointed to by stream. The new position, measured in bytes from the beginning of the file, is obtained by adding offset to the position specified by whence. If successful, the function clears the end-of-file indicator for the stream and undoes any effects of ungetc on the same stream. For a binary stream, its file position indicator is set to the new position.",
      "return_value": "Returns 0 if successful, or non-zero if an error occurred.",
      "parameter_values": "This function takes three parameters: stream (pointer to a FILE object that identifies the stream), offset (number of bytes to offset from whence), and whence (position from where offset is added, which can be SEEK_SET, SEEK_CUR, or SEEK_END).",
      "function_prototype": "int fseek(FILE *stream, long offset, int whence);",
      "examples": [
        {
          "title": "Basic Usage - Seeking to a Specific Position",
          "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"example.txt\", \"r+\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    // Seek to the 10th byte in the file\n    if (fseek(file, 10, SEEK_SET) != 0) {\n        perror(\"fseek failed\");\n        fclose(file);\n        return 1;\n    }\n\n    // Read and print the character at this position\n    int ch = fgetc(file);\n    if (ch != EOF) {\n        printf(\"Character at position 10: %c\\n\", (char)ch);\n    } else {\n        printf(\"Reached end of file or error occurred\\n\");\n    }\n\n    fclose(file);\n    return 0;\n}",
          "explanation": "This example demonstrates the basic usage of `fseek`. It opens a file, seeks to the 10th byte from the beginning of the file, and then reads and prints the character at that position.",
          "expectedOutput": "Character at position 10: [character]\n(The actual character depends on the content of example.txt)"
        },
        {
          "title": "Seeking Relative to Current Position",
          "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"data.bin\", \"rb\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    // Read first integer\n    int num1;\n    fread(&num1, sizeof(int), 1, file);\n    printf(\"First number: %d\\n\", num1);\n\n    // Seek 2 integers forward from current position\n    if (fseek(file, 2 * sizeof(int), SEEK_CUR) != 0) {\n        perror(\"fseek failed\");\n        fclose(file);\n        return 1;\n    }\n\n    // Read the next integer after skipping\n    int num2;\n    fread(&num2, sizeof(int), 1, file);\n    printf(\"Number after skipping 2: %d\\n\", num2);\n\n    fclose(file);\n    return 0;\n}",
          "explanation": "This example shows how to use `fseek` to move relative to the current position in a binary file. It reads the first integer, skips the next two, and then reads another integer.",
          "expectedOutput": "First number: [value1]\nNumber after skipping 2: [value2]\n(Actual values depend on the content of data.bin)"
        },
        {
          "title": "Seeking from End of File",
          "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"log.txt\", \"r+\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    // Seek to 10 bytes before the end of the file\n    if (fseek(file, -10, SEEK_END) != 0) {\n        perror(\"fseek failed\");\n        fclose(file);\n        return 1;\n    }\n\n    // Read and print the last 10 bytes\n    char buffer[11] = {0};  // Extra byte for null terminator\n    if (fread(buffer, 1, 10, file) < 10) {\n        perror(\"fread failed\");\n        fclose(file);\n        return 1;\n    }\n\n    printf(\"Last 10 bytes of the file: %s\\n\", buffer);\n\n    fclose(file);\n    return 0;\n}",
          "explanation": "This example demonstrates using `fseek` to move to a position relative to the end of the file. It seeks to 10 bytes before the end of the file and then reads the last 10 bytes.",
          "expectedOutput": "Last 10 bytes of the file: [last 10 characters]\n(The actual output depends on the content of log.txt)"
        }
      ]
    },
    {
      "function_name": "fsetpos",
      "include_file": "stdio.h",
      "return_type": "int",
      "parameter_types": ["FILE*", "const fpos_t*"],
      "main_category": "File and I/O Operations",
      "sub_category": "Stream Manipulation",
      "data_type_manipulated": "file streams",
      "description": "Sets the file position of the stream based on the position given by fpos_t.",
      "extended_description": "The fsetpos function sets the file position indicator for the stream pointed to by stream according to the value of the object pointed to by pos, which is a pointer to an fpos_t object that specifies the position. The function is typically used in conjunction with fgetpos to restore a position previously obtained. On successful completion, the function clears the end-of-file indicator for the stream and undoes any effects of ungetc on the same stream.",
      "return_value": "Returns 0 if successful, or non-zero if an error occurred.",
      "parameter_values": "This function takes two parameters: stream (pointer to a FILE object that identifies the stream) and pos (pointer to a fpos_t object containing the position to be set).",
      "function_prototype": "int fsetpos(FILE *stream, const fpos_t *pos);",
      "examples": [
        {
          "title": "Basic Usage - Saving and Restoring File Position",
          "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    fpos_t position;\n    char buffer[100];\n\n    // Read the first line\n    if (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"First line: %s\", buffer);\n    }\n\n    // Save the current position\n    if (fgetpos(file, &position) != 0) {\n        perror(\"fgetpos failed\");\n        fclose(file);\n        return 1;\n    }\n\n    // Read the next line\n    if (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"Second line: %s\", buffer);\n    }\n\n    // Restore the saved position\n    if (fsetpos(file, &position) != 0) {\n        perror(\"fsetpos failed\");\n        fclose(file);\n        return 1;\n    }\n\n    // Read from the restored position\n    if (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"Line after restoring position: %s\", buffer);\n    }\n\n    fclose(file);\n    return 0;\n}",
          "explanation": "This example demonstrates the basic usage of `fsetpos` in conjunction with `fgetpos`. It reads the first two lines of a file, saves the position after the first line, and then restores that position to read the second line again.",
          "expectedOutput": "First line: [content of first line]\nSecond line: [content of second line]\nLine after restoring position: [content of second line]\n(Actual content depends on example.txt)"
        },
        {
          "title": "Using fsetpos in Binary Files",
          "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int id;\n    char name[20];\n} Record;\n\nint main() {\n    FILE *file = fopen(\"records.bin\", \"wb+\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    Record records[] = {\n        {1, \"Alice\"},\n        {2, \"Bob\"},\n        {3, \"Charlie\"}\n    };\n\n    // Write records to file\n    fwrite(records, sizeof(Record), 3, file);\n\n    fpos_t position;\n\n    // Move to the second record and save position\n    fseek(file, sizeof(Record), SEEK_SET);\n    if (fgetpos(file, &position) != 0) {\n        perror(\"fgetpos failed\");\n        fclose(file);\n        return 1;\n    }\n\n    // Read and print the second record\n    Record record;\n    fread(&record, sizeof(Record), 1, file);\n    printf(\"Second record: ID=%d, Name=%s\\n\", record.id, record.name);\n\n    // Move to the end and write a new record\n    fseek(file, 0, SEEK_END);\n    Record newRecord = {4, \"David\"};\n    fwrite(&newRecord, sizeof(Record), 1, file);\n\n    // Restore position to second record and read again\n    if (fsetpos(file, &position) != 0) {\n        perror(\"fsetpos failed\");\n        fclose(file);\n        return 1;\n    }\n\n    fread(&record, sizeof(Record), 1, file);\n    printf(\"Record after restoring position: ID=%d, Name=%s\\n\", record.id, record.name);\n\n    fclose(file);\n    return 0;\n}",
          "explanation": "This example shows how to use `fsetpos` with binary files. It writes structured data to a file, uses fsetpos to move between different records, and demonstrates how to combine fsetpos with other file operations like fseek and fwrite.",
          "expectedOutput": "Second record: ID=2, Name=Bob\nRecord after restoring position: ID=2, Name=Bob"
        },
        {
          "title": "Error Handling with fsetpos",
          "code": "#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n\nint main() {\n    FILE *file = fopen(\"test.txt\", \"w+\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    fpos_t pos;\n\n    // Try to get position from an empty file\n    if (fgetpos(file, &pos) != 0) {\n        printf(\"fgetpos error: %s\\n\", strerror(errno));\n    } else {\n        printf(\"fgetpos succeeded on empty file\\n\");\n    }\n\n    // Write some data\n    fprintf(file, \"Hello, World!\\n\");\n\n    // Try to set to an invalid position\n    pos.__pos = -1;  // Note: This is implementation-specific and may not work on all systems\n    if (fsetpos(file, &pos) != 0) {\n        printf(\"fsetpos error: %s\\n\", strerror(errno));\n    } else {\n        printf(\"fsetpos succeeded (unexpected)\\n\");\n    }\n\n    // Get the current position\n    if (fgetpos(file, &pos) == 0) {\n        // Try to set to the same position\n        if (fsetpos(file, &pos) == 0) {\n            printf(\"Successfully set to current position\\n\");\n        } else {\n            printf(\"Failed to set to current position: %s\\n\", strerror(errno));\n        }\n    }\n\n    fclose(file);\n    return 0;\n}",
          "explanation": "This example focuses on error handling with `fsetpos`. It demonstrates getting and setting positions in various scenarios, including with an empty file and attempting to set an invalid position. It also shows how to use errno and strerror for more detailed error reporting.",
          "expectedOutput": "fgetpos succeeded on empty file\nfsetpos error: Invalid argument\nSuccessfully set to current position\n(Note: The exact error messages may vary depending on the system)"
        }
      ]
    },
    
      {
        "function_name": "ftell",
        "include_file": "stdio.h",
        "return_type": "long",
        "parameter_types": ["FILE*"],
        "main_category": "File and I/O Operations",
        "sub_category": "Stream Manipulation",
        "data_type_manipulated": "file streams",
        "description": "Returns the current file position of the stream.",
        "extended_description": "The ftell function obtains the current value of the file position indicator for the stream pointed to by stream. For binary streams, this is the number of bytes from the beginning of the file. For text streams, the numerical value may not be meaningful but can still be used with fseek to restore the position to the same position later.",
        "return_value": "Returns the current value of the file position indicator if successful. On failure, it returns -1L and sets errno to indicate the error.",
        "parameter_values": "This function takes one parameter: stream (a pointer to a FILE object that identifies the stream).",
        "function_prototype": "long ftell(FILE *stream);",
        "examples": [
          {
            "title": "Basic Usage - Getting File Size",
            "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"example.txt\", \"rb\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    // Go to the end of the file\n    if (fseek(file, 0, SEEK_END) != 0) {\n        perror(\"fseek failed\");\n        fclose(file);\n        return 1;\n    }\n\n    // Get the position, which is the file size\n    long size = ftell(file);\n    if (size == -1L) {\n        perror(\"ftell failed\");\n        fclose(file);\n        return 1;\n    }\n\n    printf(\"File size: %ld bytes\\n\", size);\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example demonstrates how to use ftell to determine the size of a file. It seeks to the end of the file and then uses ftell to get the position, which is equivalent to the file size.",
            "expectedOutput": "File size: [X] bytes\n(Where [X] is the actual size of example.txt)"
          },
          {
            "title": "Tracking Position While Reading",
            "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    char buffer[100];\n    long position;\n\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        position = ftell(file);\n        printf(\"Read: %s\", buffer);\n        printf(\"Current position: %ld\\n\\n\", position);\n    }\n\n    if (ferror(file)) {\n        perror(\"Error reading file\");\n    }\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example shows how to use ftell to track the current position in the file while reading it line by line. It prints each line along with its ending position in the file.",
            "expectedOutput": "Read: [line1]\nCurrent position: [pos1]\n\nRead: [line2]\nCurrent position: [pos2]\n\n...\n(Actual output depends on the content of data.txt)"
          },
          {
            "title": "Using ftell for Custom Parsing",
            "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    FILE *file = fopen(\"mixed_data.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    char buffer[100];\n    long numberPosition = -1;\n\n    while (fgets(buffer, sizeof(buffer), file) != NULL) {\n        if (strncmp(buffer, \"NUMBER:\", 7) == 0) {\n            numberPosition = ftell(file) - strlen(buffer);\n            break;\n        }\n    }\n\n    if (numberPosition != -1) {\n        printf(\"Found 'NUMBER:' at position: %ld\\n\", numberPosition);\n        \n        // Go back to the start of the 'NUMBER:' line\n        if (fseek(file, numberPosition, SEEK_SET) == 0) {\n            if (fgets(buffer, sizeof(buffer), file) != NULL) {\n                printf(\"The line is: %s\", buffer);\n            }\n        }\n    } else {\n        printf(\"'NUMBER:' not found in the file.\\n\");\n    }\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example demonstrates a more advanced use of ftell in custom file parsing. It searches for a line starting with 'NUMBER:', remembers its position using ftell, and then uses that position to go back and read the full line.",
            "expectedOutput": "Found 'NUMBER:' at position: [X]\nThe line is: NUMBER: [some value]\n(Actual output depends on the content of mixed_data.txt)"
          }
        ]
      },
      {
        "function_name": "fwide",
        "include_file": "wchar.h",
        "return_type": "int",
        "parameter_types": ["FILE*", "int"],
        "main_category": "File and I/O Operations",
        "sub_category": "Wide Character Support",
        "data_type_manipulated": "file streams",
        "description": "Sets the orientation of the stream to wide or narrow.",
        "extended_description": "The fwide function determines or changes the orientation of the stream. A stream can have a wide orientation (for wide character I/O), a narrow orientation (for byte I/O), or no orientation. If mode is greater than zero, fwide tries to make the stream wide-oriented. If mode is less than zero, it tries to make it byte-oriented. If mode is zero, fwide merely determines the current orientation of the stream without changing it.",
        "return_value": "Returns a positive value if the stream is wide-oriented after the call, a negative value if it is byte-oriented, or zero if it has no orientation.",
        "parameter_values": "This function takes two parameters: stream (a pointer to a FILE object that identifies the stream) and mode (an integer that determines the desired orientation: positive for wide, negative for narrow, zero for query).",
        "function_prototype": "int fwide(FILE *stream, int mode);",
        "examples": [
          {
            "title": "Basic Usage - Setting Stream Orientation",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nvoid check_orientation(FILE *file) {\n    int result = fwide(file, 0);\n    if (result > 0) {\n        printf(\"Stream is wide-oriented\\n\");\n    } else if (result < 0) {\n        printf(\"Stream is byte-oriented\\n\");\n    } else {\n        printf(\"Stream has no orientation\\n\");\n    }\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n\n    FILE *file = fopen(\"test.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    printf(\"Initial orientation:\\n\");\n    check_orientation(file);\n\n    printf(\"\\nSetting to wide orientation:\\n\");\n    fwide(file, 1);\n    check_orientation(file);\n\n    printf(\"\\nAttempting to change to byte orientation:\\n\");\n    fwide(file, -1);\n    check_orientation(file);\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example demonstrates the basic usage of fwide. It opens a file, checks its initial orientation, sets it to wide orientation, and then attempts to change it to byte orientation (which should fail as orientation can only be set once).",
            "expectedOutput": "Initial orientation:\nStream has no orientation\n\nSetting to wide orientation:\nStream is wide-oriented\n\nAttempting to change to byte orientation:\nStream is wide-oriented"
          },
          {
            "title": "Using fwide with Wide Character I/O",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n\n    FILE *file = fopen(\"wide.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    // Set to wide orientation\n    if (fwide(file, 1) <= 0) {\n        printf(\"Failed to set wide orientation\\n\");\n        fclose(file);\n        return 1;\n    }\n\n    // Write wide characters\n    wchar_t wstr[] = L\"Hello, 世界!\\n\";\n    if (fputws(wstr, file) == WEOF) {\n        printf(\"Error writing wide string\\n\");\n    } else {\n        printf(\"Successfully wrote wide string\\n\");\n    }\n\n    fclose(file);\n\n    // Read and display the content\n    file = fopen(\"wide.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file for reading\");\n        return 1;\n    }\n\n    wchar_t wbuf[100];\n    if (fgetws(wbuf, sizeof(wbuf)/sizeof(wchar_t), file) != NULL) {\n        printf(\"Read from file: %ls\", wbuf);\n    } else {\n        printf(\"Error reading from file\\n\");\n    }\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example shows how to use fwide to set a stream to wide orientation and then perform wide character I/O operations. It writes a wide character string to a file and then reads it back.",
            "expectedOutput": "Successfully wrote wide string\nRead from file: Hello, 世界!"
          },
          {
            "title": "Checking Orientation of Standard Streams",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nvoid print_orientation(const char *name, FILE *stream) {\n    int result = fwide(stream, 0);\n    printf(\"%s is \", name);\n    if (result > 0) {\n        printf(\"wide-oriented\\n\");\n    } else if (result < 0) {\n        printf(\"byte-oriented\\n\");\n    } else {\n        printf(\"not oriented\\n\");\n    }\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n\n    print_orientation(\"stdin\", stdin);\n    print_orientation(\"stdout\", stdout);\n    print_orientation(\"stderr\", stderr);\n\n    printf(\"\\nWriting a wide character to stdout:\\n\");\n    if (putwchar(L'Ω') != WEOF) {\n        printf(\"\\nWide character written successfully\\n\");\n    } else {\n        printf(\"\\nError writing wide character\\n\");\n    }\n\n    print_orientation(\"stdout\", stdout);\n\n    return 0;\n}",
            "explanation": "This example demonstrates checking the orientation of standard streams (stdin, stdout, stderr) using fwide. It also shows how performing a wide character operation can affect the orientation of a stream.",
            "expectedOutput": "stdin is not oriented\nstdout is not oriented\nstderr is not oriented\n\nWriting a wide character to stdout:\nΩ\nWide character written successfully\n\nstdout is wide-oriented"
          }
        ]
      },
      {
        "function_name": "fwprintf",
        "include_file": "wchar.h",
        "return_type": "int",
        "parameter_types": ["FILE*", "const wchar_t*", "..."],
        "main_category": "File and I/O Operations",
        "sub_category": "Wide Character Support",
        "data_type_manipulated": "file streams",
        "description": "Writes formatted wide character output to a stream.",
        "extended_description": "The fwprintf function writes output to the stream pointed to by stream, under control of the wide string pointed to by format that specifies how subsequent arguments are converted for output. It behaves similarly to fprintf, but uses wide characters. If there are insufficient arguments for the format, the behavior is undefined. If the format is exhausted while arguments remain, the excess arguments are evaluated but are otherwise ignored.",
        "return_value": "Returns the number of wide characters transmitted, or a negative value if an output or encoding error occurred.",
        "parameter_values": "This function takes at least two parameters: stream (pointer to a FILE object that identifies the stream), format (wide string that contains the format string), and optional additional arguments depending on the format string.",
        "function_prototype": "int fwprintf(FILE * restrict stream, const wchar_t * restrict format, ...);",
        "examples": [
          {
            "title": "Basic Usage - Writing Wide Characters to a File",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    FILE *file = fopen(\"test.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    wchar_t *str = L\"Hello, 世界!\";\n    int result = fwprintf(file, L\"%ls\\n\", str);\n    \n    if (result < 0) {\n        fwprintf(stderr, L\"Error writing to file\\n\");\n    } else {\n        fwprintf(stdout, L\"Successfully wrote %d wide characters\\n\", result);\n    }\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of fwprintf to write wide characters to a file. It includes error checking and reports the number of characters written.",
            "expectedOutput": "Successfully wrote 14 wide characters\n(And the file test.txt would contain 'Hello, 世界!' followed by a newline)"
          },
          {
            "title": "Multiple Arguments and Format Specifiers",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    FILE *file = fopen(\"data.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    wchar_t name[] = L\"Alice\";\n    int age = 30;\n    float height = 1.75f;\n\n    fwprintf(file, L\"Name: %ls\\nAge: %d\\nHeight: %.2f m\\n\", name, age, height);\n    fwprintf(file, L\"Binary: %b, Octal: %o, Hex: %x\\n\", 42, 42, 42);\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example shows how to use fwprintf with multiple arguments and various format specifiers, including wide strings, integers, floats, and different number bases.",
            "expectedOutput": "(In data.txt)\nName: Alice\nAge: 30\nHeight: 1.75 m\nBinary: 101010, Octal: 52, Hex: 2a"
          },
          {
            "title": "Error Handling and Edge Cases",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n#include <errno.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    // Attempt to write to stdout (should succeed)\n    int result = fwprintf(stdout, L\"Test to stdout: %ls\\n\", L\"成功\");\n    fwprintf(stdout, L\"Chars written to stdout: %d\\n\", result);\n\n    // Attempt to write to a NULL stream (should fail)\n    result = fwprintf(NULL, L\"This should fail\\n\");\n    if (result < 0) {\n        fwprintf(stderr, L\"Error writing to NULL stream: %s\\n\", strerror(errno));\n    }\n\n    // Attempt to use a bad format string (undefined behavior, may crash)\n    // Uncommenting the next line may cause the program to crash\n    // result = fwprintf(stdout, L\"Bad format: %ls %d\\n\", L\"Only one arg\");\n\n    // Writing an empty string\n    result = fwprintf(stdout, L\"\");\n    fwprintf(stdout, L\"Chars written for empty string: %d\\n\", result);\n\n    // Writing a very long string (test buffer handling)\n    wchar_t long_str[1000];\n    wmemset(long_str, L'A', 999);\n    long_str[999] = L'\\0';\n    result = fwprintf(stdout, L\"Long string: %ls\\n\", long_str);\n    fwprintf(stdout, L\"Chars written for long string: %d\\n\", result);\n\n    return 0;\n}",
            "explanation": "This example covers various edge cases and error scenarios: writing to stdout, attempting to write to a NULL stream, handling empty strings, and writing very long strings. It also includes a commented-out line that would demonstrate undefined behavior with mismatched format specifiers and arguments.",
            "expectedOutput": "Test to stdout: 成功\nChars written to stdout: 16\nError writing to NULL stream: Bad file descriptor\nChars written for empty string: 0\nLong string: [999 'A' characters]\nChars written for long string: 1012\n(Exact output may vary depending on the system and locale settings)"
          }
        ]
      },
      {
        "function_name": "fwrite",
        "include_file": "stdio.h",
        "return_type": "size_t",
        "parameter_types": ["const void*", "size_t", "size_t", "FILE*"],
        "main_category": "File and I/O Operations",
        "sub_category": "File Management",
        "data_type_manipulated": "file streams",
        "description": "Writes data from the given array to the stream.",
        "extended_description": "The fwrite function writes up to count elements, each of size bytes, from the array pointed to by ptr to the given output stream. The file position indicator for the stream is advanced by the number of bytes successfully written. If an error occurs, the resulting value of the file position indicator for the stream is indeterminate.",
        "return_value": "Returns the number of elements successfully written, which may be less than count if a write error occurs. If size or count is zero, fwrite returns zero and the stream state remains unchanged.",
        "parameter_values": "This function takes four parameters: ptr (pointer to the array of elements to be written), size (size in bytes of each element), count (number of elements to write), and stream (pointer to a FILE object that specifies an output stream).",
        "function_prototype": "size_t fwrite(const void * restrict ptr, size_t size, size_t count, FILE * restrict stream);",
        "examples": [
          {
            "title": "Basic Usage - Writing an Array of Integers",
            "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"numbers.bin\", \"wb\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    int numbers[] = {1, 2, 3, 4, 5};\n    size_t elements_written = fwrite(numbers, sizeof(int), 5, file);\n\n    printf(\"Elements written: %zu\\n\", elements_written);\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of fwrite to write an array of integers to a binary file.",
            "expectedOutput": "Elements written: 5\n(And the file numbers.bin would contain the binary representation of the integers 1, 2, 3, 4, 5)"
          },
          {
            "title": "Writing Structures",
            "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int id;\n    char name[20];\n    float salary;\n} Employee;\n\nint main() {\n    FILE *file = fopen(\"employees.bin\", \"wb\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    Employee employees[] = {\n        {1, \"Alice\", 50000.0f},\n        {2, \"Bob\", 60000.0f},\n        {3, \"Charlie\", 55000.0f}\n    };\n\n    size_t elements_written = fwrite(employees, sizeof(Employee), 3, file);\n\n    printf(\"Structures written: %zu\\n\", elements_written);\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example shows how to use fwrite with an array of structures, demonstrating its ability to write complex data types.",
            "expectedOutput": "Structures written: 3\n(And the file employees.bin would contain the binary representation of the three Employee structures)"
          },
          {
            "title": "Error Handling and Partial Writes",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define LARGE_SIZE 1000000000  // 1 billion elements\n\nint main() {\n    FILE *file = fopen(\"large_file.bin\", \"wb\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    int *large_array = malloc(LARGE_SIZE * sizeof(int));\n    if (large_array == NULL) {\n        perror(\"Memory allocation failed\");\n        fclose(file);\n        return 1;\n    }\n\n    // Initialize array (in practice, you might not want to do this for such a large array)\n    for (size_t i = 0; i < LARGE_SIZE; i++) {\n        large_array[i] = (int)i;\n    }\n\n    size_t elements_written = fwrite(large_array, sizeof(int), LARGE_SIZE, file);\n\n    if (elements_written != LARGE_SIZE) {\n        if (ferror(file)) {\n            perror(\"Error writing to file\");\n        } else {\n            printf(\"Partial write occurred. Elements written: %zu\\n\", elements_written);\n        }\n    } else {\n        printf(\"All elements written successfully.\\n\");\n    }\n\n    free(large_array);\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example demonstrates error handling and the possibility of partial writes when dealing with very large amounts of data. It checks for both complete failure and partial success scenarios.",
            "expectedOutput": "The output will depend on the system's ability to handle the large write operation. Possible outputs include:\n1. 'All elements written successfully.' if the write is completely successful.\n2. 'Partial write occurred. Elements written: [some number less than 1 billion]' if a partial write occurs.\n3. An error message from perror if the write fails entirely or if there's not enough disk space."
          }
        ]
      },
      {
        "function_name": "fwscanf",
        "include_file": "wchar.h",
        "return_type": "int",
        "parameter_types": ["FILE*", "const wchar_t*", "..."],
        "main_category": "File and I/O Operations",
        "sub_category": "Wide Character Support",
        "data_type_manipulated": "file streams",
        "description": "Reads formatted wide character input from a stream.",
        "extended_description": "The fwscanf function reads input from the stream pointed to by stream, under control of the wide string pointed to by format that specifies the admissible input sequences and how they are to be converted for assignment, using subsequent arguments as pointers to the objects to receive the converted input. It behaves similarly to fscanf but uses wide characters. A matching failure occurs if the input cannot be matched to the format string.",
        "return_value": "Returns the number of input items successfully matched and assigned. This can be fewer than provided for, or zero in the event of an early matching failure. EOF is returned if the end of input is reached before either the first successful conversion or a matching failure occurs.",
        "parameter_values": "This function takes at least two parameters: stream (pointer to a FILE object that identifies the input stream), format (wide string that contains the format string), and optional additional arguments depending on the format string, which should be pointers to allocated objects of the specified type to store the results.",
        "function_prototype": "int fwscanf(FILE * restrict stream, const wchar_t * restrict format, ...);",
        "examples": [
          {
            "title": "Basic Usage - Reading Formatted Wide Character Input",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    FILE *file = fopen(\"input.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    wchar_t name[50];\n    int age;\n    float height;\n\n    int result = fwscanf(file, L\"%ls %d %f\", name, &age, &height);\n\n    if (result == 3) {\n        wprintf(L\"Name: %ls, Age: %d, Height: %.2f\\n\", name, age, height);\n    } else if (result == EOF) {\n        wprintf(L\"End of file or error occurred\\n\");\n    } else {\n        wprintf(L\"Matching failure. Items read: %d\\n\", result);\n    }\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of fwscanf to read formatted wide character input from a file. It reads a name (wide string), age (integer), and height (float) from the file.",
            "expectedOutput": "Assuming the file 'input.txt' contains 'John 30 1.75', the output would be:\nName: John, Age: 30, Height: 1.75"
          },
          {
            "title": "Reading Multiple Lines with Error Handling",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    FILE *file = fopen(\"data.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    wchar_t name[50];\n    int age;\n    float height;\n    int line = 0;\n\n    while (1) {\n        int result = fwscanf(file, L\"%ls %d %f\\n\", name, &age, &height);\n        line++;\n\n        if (result == 3) {\n            wprintf(L\"Line %d: Name: %ls, Age: %d, Height: %.2f\\n\", line, name, age, height);\n        } else if (result == EOF) {\n            if (feof(file)) {\n                wprintf(L\"End of file reached\\n\");\n            } else {\n                wprintf(L\"Error occurred while reading the file\\n\");\n            }\n            break;\n        } else {\n            wprintf(L\"Line %d: Matching failure. Items read: %d\\n\", line, result);\n            // Clear the rest of the line\n            wint_t ch;\n            while ((ch = fgetwc(file)) != WEOF && ch != L'\\n');\n        }\n    }\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example shows how to use fwscanf in a loop to read multiple lines from a file, with comprehensive error handling for EOF, matching failures, and other errors.",
            "expectedOutput": "The output will depend on the content of 'data.txt'. For example:\nLine 1: Name: Alice, Age: 25, Height: 1.65\nLine 2: Name: Bob, Age: 30, Height: 1.80\nLine 3: Matching failure. Items read: 2\nLine 4: Name: Charlie, Age: 35, Height: 1.75\nEnd of file reached"
          },
          {
            "title": "Reading Complex Data Types",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    FILE *file = fopen(\"complex_data.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    wchar_t string[100];\n    int integer;\n    unsigned int hex_num;\n    float floating;\n    wchar_t character;\n\n    int result = fwscanf(file, L\"%ls %d %x %f %lc\", \n                         string, &integer, &hex_num, &floating, &character);\n\n    if (result == 5) {\n        wprintf(L\"String: %ls\\n\", string);\n        wprintf(L\"Integer: %d\\n\", integer);\n        wprintf(L\"Hexadecimal: 0x%X\\n\", hex_num);\n        wprintf(L\"Float: %f\\n\", floating);\n        wprintf(L\"Character: %lc\\n\", character);\n    } else {\n        wprintf(L\"Matching failure. Items read: %d\\n\", result);\n    }\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example demonstrates reading various data types using fwscanf, including strings, integers in decimal and hexadecimal formats, floating-point numbers, and wide characters.",
            "expectedOutput": "Assuming 'complex_data.txt' contains 'Hello_World 42 2A 3.14 π', the output would be:\nString: Hello_World\nInteger: 42\nHexadecimal: 0x2A\nFloat: 3.140000\nCharacter: π"
          }
        ]
      },
      {
        "function_name": "getc",
        "include_file": "stdio.h",
        "return_type": "int",
        "parameter_types": ["FILE*"],
        "main_category": "File and I/O Operations",
        "sub_category": "File Management",
        "data_type_manipulated": "file streams",
        "description": "Reads the next character from the specified stream.",
        "extended_description": "The getc function obtains the next character (if present) as an unsigned char converted to an int, from the input stream pointed to by stream, and advances the associated file position indicator for the stream (if defined). getc is equivalent to fgetc except that it may be implemented as a macro.",
        "return_value": "Returns the character read as an unsigned char cast to an int or EOF on end of file or error. Use feof() and ferror() to distinguish between end-of-file and error.",
        "parameter_values": "This function takes one parameter: stream (pointer to a FILE object that identifies an input stream).",
        "function_prototype": "int getc(FILE *stream);",
        "examples": [
          {
            "title": "Basic Usage - Reading Characters from a File",
            "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    int ch;\n    while ((ch = getc(file)) != EOF) {\n        putchar(ch);\n    }\n\n    if (ferror(file)) {\n        printf(\"\\nAn error occurred while reading the file.\\n\");\n    } else if (feof(file)) {\n        printf(\"\\nEnd of file reached.\\n\");\n    }\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of getc to read characters from a file and print them to the console. It also shows how to check for errors and end-of-file conditions.",
            "expectedOutput": "The contents of example.txt, followed by 'End of file reached.'"
          },
          {
            "title": "Counting Characters, Lines, and Words",
            "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    FILE *file = fopen(\"text.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    int ch, chars = 0, words = 0, lines = 0;\n    int in_word = 0;\n\n    while ((ch = getc(file)) != EOF) {\n        chars++;\n        \n        if (ch == '\\n') {\n            lines++;\n        }\n        \n        if (isspace(ch)) {\n            in_word = 0;\n        } else if (!in_word) {\n            in_word = 1;\n            words++;\n        }\n    }\n\n    printf(\"Characters: %d\\n\", chars);\n    printf(\"Words: %d\\n\", words);\n    printf(\"Lines: %d\\n\", lines);\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example uses getc in a more complex scenario to count characters, words, and lines in a text file.",
            "expectedOutput": "Characters: [number of characters in text.txt]\nWords: [number of words in text.txt]\nLines: [number of lines in text.txt]"
          },
          {
            "title": "Error Handling and Pushing Characters Back",
            "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    int ch;\n    while ((ch = getc(file)) != EOF) {\n        if (ch == '#') {\n            // Skip the rest of the line if it starts with '#'\n            while ((ch = getc(file)) != EOF && ch != '\\n');\n        } else if (ch == '@') {\n            // Push back '@' and exit the loop\n            ungetc(ch, file);\n            break;\n        } else {\n            putchar(ch);\n        }\n    }\n\n    if (ferror(file)) {\n        printf(\"\\nAn error occurred while reading the file.\\n\");\n    } else {\n        long pos = ftell(file);\n        printf(\"\\nCurrent file position: %ld\\n\", pos);\n    }\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example demonstrates error handling with getc, as well as using ungetc to push a character back onto the stream. It also shows how to implement basic file parsing logic.",
            "expectedOutput": "The contents of data.txt (excluding lines starting with '#') up to the first '@' character, followed by the current file position."
          }
        ]
      },
      {
        "function_name": "getchar",
        "include_file": "stdio.h",
        "return_type": "int",
        "parameter_types": [],
        "main_category": "File and I/O Operations",
        "sub_category": "File Management",
        "data_type_manipulated": "standard input",
        "description": "Reads the next character from the standard input stream.",
        "extended_description": "The getchar function obtains the next character (if present) as an unsigned char converted to an int, from the input stream pointed to by stdin, and advances the associated file position indicator for stdin (if defined). getchar() is equivalent to getc(stdin). It is less efficient than getc(stdin) for cases where it is called within a loop, since getchar has to check the stdin value every time it is called.",
        "return_value": "Returns the character read as an unsigned char cast to an int or EOF on end of file or error. Use feof() and ferror() to distinguish between end-of-file and error.",
        "parameter_values": "This function takes no parameters.",
        "function_prototype": "int getchar(void);",
        "examples": [
          {
            "title": "Basic Usage - Reading Characters from Standard Input",
            "code": "#include <stdio.h>\n\nint main() {\n    int ch;\n    printf(\"Enter some text (Ctrl+D or Ctrl+Z to end):\\n\");\n\n    while ((ch = getchar()) != EOF) {\n        putchar(ch);\n    }\n\n    printf(\"\\nEnd of input reached.\\n\");\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of getchar to read characters from standard input and echo them back to the console.",
            "expectedOutput": "Enter some text (Ctrl+D or Ctrl+Z to end):\n[User input]\n[User input echoed]\nEnd of input reached."
          },
          {
            "title": "Simple Line Editor",
            "code": "#include <stdio.h>\n#include <ctype.h>\n\n#define MAX_LINE 1000\n\nint main() {\n    char line[MAX_LINE];\n    int c, i = 0;\n\n    printf(\"Enter a line of text (max %d chars):\\n\", MAX_LINE - 1);\n\n    while ((c = getchar()) != EOF && c != '\\n' && i < MAX_LINE - 1) {\n        if (c == '\\b' || c == 127) {  // Handle backspace\n            if (i > 0) {\n                i--;\n                printf(\"\\b \\b\");  // Erase character on screen\n            }\n        } else if (isprint(c)) {\n            line[i++] = c;\n            putchar(c);\n        }\n    }\n\n    line[i] = '\\0';\n    printf(\"\\nYou entered: %s\\n\", line);\n\n    return 0;\n}",
            "explanation": "This example uses getchar to implement a simple line editor that allows users to input text and handles backspace for editing. It demonstrates how getchar can be used for interactive input processing.",
            "expectedOutput": "Enter a line of text (max 999 chars):\n[User input with potential edits]\nYou entered: [Final user input]"
          },
          {
            "title": "Password Input (without echo)",
            "code": "#include <stdio.h>\n#include <termios.h>\n#include <unistd.h>\n\nvoid setEcho(int enable) {\n    struct termios tty;\n    tcgetattr(STDIN_FILENO, &tty);\n    if (!enable)\n        tty.c_lflag &= ~ECHO;\n    else\n        tty.c_lflag |= ECHO;\n    tcsetattr(STDIN_FILENO, TCSANOW, &tty);\n}\n\nint main() {\n    char password[50];\n    int c, i = 0;\n\n    printf(\"Enter password: \");\n    setEcho(0);  // Disable echo\n\n    while ((c = getchar()) != '\\n' && c != EOF && i < 49) {\n        password[i++] = c;\n    }\n    password[i] = '\\0';\n\n    setEcho(1);  // Re-enable echo\n    printf(\"\\nPassword entered: %s\\n\", password);\n\n    return 0;\n}",
            "explanation": "This example demonstrates a more advanced use of getchar for password input without echoing characters to the screen. It uses terminal control to disable character echo during input.",
            "expectedOutput": "Enter password: [No visible input]\nPassword entered: [Password entered by user]"
          }
        ]
      },
      {
        "function_name": "getenv",
        "include_file": "stdlib.h",
        "return_type": "char*",
        "parameter_types": ["const char*"],
        "main_category": "System Interaction",
        "sub_category": "Environment Interaction",
        "data_type_manipulated": "strings",
        "description": "Retrieves the value of an environment variable.",
        "extended_description": "The getenv function searches the environment list for a string that matches the string pointed to by name. The environment list is a system-dependent array of strings of the form name=value. The search is case-sensitive on some systems.",
        "return_value": "Returns a pointer to the value in the environment, or NULL if there is no match. The returned string should not be modified by the program.",
        "parameter_values": "This function takes one parameter: name (a null-terminated string containing the name of the environment variable).",
        "function_prototype": "char *getenv(const char *name);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char *path = getenv(\"PATH\");\n    if (path != NULL) {\n        printf(\"PATH: %s\\n\", path);\n    } else {\n        printf(\"PATH environment variable not found.\\n\");\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates how to retrieve and print the value of the PATH environment variable.",
            "expectedOutput": "PATH: [system-specific path value]"
          },
          {
            "title": "Multiple Variables",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid print_env_var(const char *name) {\n    char *value = getenv(name);\n    if (value != NULL) {\n        printf(\"%s: %s\\n\", name, value);\n    } else {\n        printf(\"%s not set\\n\", name);\n    }\n}\n\nint main() {\n    print_env_var(\"HOME\");\n    print_env_var(\"USER\");\n    print_env_var(\"LANG\");\n    print_env_var(\"NONEXISTENT_VAR\");\n    return 0;\n}",
            "explanation": "This example shows how to check for multiple environment variables, including one that doesn't exist.",
            "expectedOutput": "HOME: /home/username\nUSER: username\nLANG: en_US.UTF-8\nNONEXISTENT_VAR not set"
          },
          {
            "title": "Custom Environment",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nextern char **environ;\n\nint main() {\n    char *custom_env[] = {\n        \"CUSTOM_VAR1=Value1\",\n        \"CUSTOM_VAR2=Value2\",\n        NULL\n    };\n    environ = custom_env;\n\n    printf(\"CUSTOM_VAR1: %s\\n\", getenv(\"CUSTOM_VAR1\"));\n    printf(\"CUSTOM_VAR2: %s\\n\", getenv(\"CUSTOM_VAR2\"));\n    printf(\"PATH: %s\\n\", getenv(\"PATH\"));\n\n    return 0;\n}",
            "explanation": "This example demonstrates working with a custom environment, showing how getenv behaves with both custom and standard variables.",
            "expectedOutput": "CUSTOM_VAR1: Value1\nCUSTOM_VAR2: Value2\nPATH: (null)"
          }
        ]
      },
      {
        "function_name": "getwc",
        "include_file": "wchar.h",
        "return_type": "wint_t",
        "parameter_types": ["FILE*"],
        "main_category": "File and I/O Operations",
        "sub_category": "Wide Character Support",
        "data_type_manipulated": "wide characters",
        "description": "Gets a wide character from the specified stream.",
        "extended_description": "The getwc function obtains the next wide character (if present) as a wchar_t converted to a wint_t, from the input stream pointed to by stream, and advances the associated file position indicator for the stream (if defined). getwc is equivalent to fgetwc except that it may be implemented as a macro.",
        "return_value": "Returns the wide character read as a wint_t, or WEOF on end-of-file or error. Use feof() and ferror() to distinguish between end-of-file and error.",
        "parameter_values": "This function takes one parameter: stream (pointer to a FILE object that identifies an input stream).",
        "function_prototype": "wint_t getwc(FILE *stream);",
        "examples": [
          {
            "title": "Basic File Reading",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    FILE *file = fopen(\"wide.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    wint_t wc;\n    while ((wc = getwc(file)) != WEOF) {\n        putwchar(wc);\n    }\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example shows how to read and print wide characters from a file using getwc.",
            "expectedOutput": "Contents of wide.txt file"
          },
          {
            "title": "Error Handling",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    FILE *file = fopen(\"nonexistent.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    wint_t wc = getwc(file);\n    if (wc == WEOF) {\n        if (feof(file)) {\n            wprintf(L\"End of file reached\\n\");\n        } else if (ferror(file)) {\n            wprintf(L\"Error reading file\\n\");\n        }\n    } else {\n        putwchar(wc);\n    }\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example demonstrates error handling when using getwc, checking for both EOF and error conditions.",
            "expectedOutput": "Error opening file: No such file or directory"
          },
          {
            "title": "Character Counting",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n#include <wctype.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    FILE *file = fopen(\"unicode.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    wint_t wc;\n    int total = 0, alpha = 0, digit = 0, other = 0;\n\n    while ((wc = getwc(file)) != WEOF) {\n        total++;\n        if (iswalpha(wc)) alpha++;\n        else if (iswdigit(wc)) digit++;\n        else other++;\n    }\n\n    wprintf(L\"Total: %d, Alphabetic: %d, Digits: %d, Other: %d\\n\",\n            total, alpha, digit, other);\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example uses getwc to count different types of wide characters in a file.",
            "expectedOutput": "Total: [total count], Alphabetic: [alpha count], Digits: [digit count], Other: [other count]"
          }
        ]
      },
      {
        "function_name": "getwchar",
        "include_file": "wchar.h",
        "return_type": "wint_t",
        "parameter_types": [],
        "main_category": "File and I/O Operations",
        "sub_category": "Wide Character Support",
        "data_type_manipulated": "wide characters",
        "description": "Reads the next wide character from the standard input stream.",
        "extended_description": "The getwchar function obtains the next wide character (if present) as a wchar_t converted to a wint_t, from the input stream pointed to by stdin, and advances the associated file position indicator for stdin (if defined). It is equivalent to getwc(stdin).",
        "return_value": "Returns the wide character read as a wint_t, or WEOF on end-of-file or error.",
        "parameter_values": "This function takes no parameters.",
        "function_prototype": "wint_t getwchar(void);",
        "examples": [
          {
            "title": "Basic Input",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wprintf(L\"Enter a wide character: \");\n    wint_t wc = getwchar();\n    if (wc != WEOF) {\n        wprintf(L\"You entered: %lc\\n\", wc);\n    } else {\n        wprintf(L\"Error or EOF encountered\\n\");\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of getwchar to read a single wide character from standard input.",
            "expectedOutput": "Enter a wide character: [user input]\nYou entered: [input character]"
          },
          {
            "title": "Input Loop",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wprintf(L\"Enter wide characters (Ctrl+D to end):\\n\");\n    wint_t wc;\n    while ((wc = getwchar()) != WEOF) {\n        wprintf(L\"Character: %lc, Code: %d\\n\", wc, wc);\n    }\n    wprintf(L\"Input ended\\n\");\n    return 0;\n}",
            "explanation": "This example uses getwchar in a loop to continuously read wide characters until EOF is encountered.",
            "expectedOutput": "Enter wide characters (Ctrl+D to end):\n[user input]\nCharacter: [char], Code: [code]\n...\nInput ended"
          },
          {
            "title": "Password Entry",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t password[50];\n    int i = 0;\n    wint_t wc;\n\n    wprintf(L\"Enter password: \");\n    while (i < 49 && (wc = getwchar()) != L'\\n' && wc != WEOF) {\n        password[i++] = wc;\n        putwchar(L'*');\n    }\n    password[i] = L'\\0';\n\n    wprintf(L\"\\nPassword entered: %ls\\n\", password);\n    return 0;\n}",
            "explanation": "This example demonstrates using getwchar for password entry, masking the input with asterisks.",
            "expectedOutput": "Enter password: ****\nPassword entered: [entered password]"
          }
        ]
      },
      {
        "function_name": "gmtime",
        "include_file": "time.h",
        "return_type": "struct tm*",
        "parameter_types": ["const time_t*"],
        "main_category": "Time and Date Management",
        "sub_category": "Time Conversion",
        "data_type_manipulated": "time structures",
        "description": "Converts the calendar time to broken-down time representation.",
        "extended_description": "The gmtime function converts the calendar time pointed to by timer into a broken-down time representation, expressed as Coordinated Universal Time (UTC). The result is stored in a statically allocated structure which may be overwritten by subsequent calls to gmtime or localtime.",
        "return_value": "Returns a pointer to the resulting struct tm, or NULL if an error occurred.",
        "parameter_values": "This function takes one parameter: timer (pointer to a time_t object representing calendar time).",
        "function_prototype": "struct tm *gmtime(const time_t *timer);",
        "examples": [
          {
            "title": "Current UTC Time",
            "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    time_t now;\n    time(&now);\n    struct tm *utc_time = gmtime(&now);\n    if (utc_time == NULL) {\n        printf(\"gmtime failed\\n\");\n        return 1;\n    }\n    printf(\"UTC time: %04d-%02d-%02d %02d:%02d:%02d\\n\",\n           utc_time->tm_year + 1900, utc_time->tm_mon + 1, utc_time->tm_mday,\n           utc_time->tm_hour, utc_time->tm_min, utc_time->tm_sec);\n    return 0;\n}",
            "explanation": "This example demonstrates how to use gmtime to get the current UTC time.",
            "expectedOutput": "UTC time: YYYY-MM-DD HH:MM:SS"
          },
          {
            "title": "Specific Time Conversion",
            "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    time_t specific_time = 1609459200; // 2021-01-01 00:00:00 UTC\n    struct tm *tm_info = gmtime(&specific_time);\n    if (tm_info == NULL) {\n        printf(\"gmtime failed\\n\");\n        return 1;\n    }\n    printf(\"Converted time: %s\", asctime(tm_info));\n    return 0;\n}",
            "explanation": "This example shows how to convert a specific time_t value to a broken-down time representation.",
            "expectedOutput": "Converted time: Fri Jan  1 00:00:00 2021\n"
          },
          {
            "title": "Multiple Conversions",
            "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    time_t times[] = {0, 1000000000, 2000000000};\n    for (int i = 0; i < 3; i++) {\n        struct tm *tm_info = gmtime(&times[i]);\n        if (tm_info == NULL) {\n            printf(\"gmtime failed for time %ld\\n\", times[i]);\n            continue;\n        }\n        printf(\"Time %ld: %s\", times[i], asctime(tm_info));\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates using gmtime to convert multiple time values, showing how the static nature of the returned struct can be problematic in loops.",
            "expectedOutput": "Time 0: Thu Jan  1 00:00:00 1970\nTime 1000000000: Sun Sep  9 01:46:40 2001\nTime 2000000000: Wed May 18 03:33:20 2033\n"
          }
        ]
      },
      {
        "function_name": "gmtime_r",
        "include_file": "time.h",
        "return_type": "struct tm*",
        "parameter_types": ["const time_t*", "struct tm*"],
        "main_category": "Time and Date Management",
        "sub_category": "Time Conversion",
        "data_type_manipulated": "time structures",
        "description": "Thread-safe version of gmtime.",
        "extended_description": "The gmtime_r function converts the calendar time pointed to by timer into a broken-down time representation, expressed as Coordinated Universal Time (UTC). The result is stored in the structure pointed to by result. This function is the reentrant version of gmtime, making it safe for use in multi-threaded programs.",
        "return_value": "Returns a pointer to the resulting struct tm (which is the same as the result parameter), or NULL if an error occurred.",
        "parameter_values": "This function takes two parameters: timer (pointer to a time_t object representing calendar time) and result (pointer to a struct tm where the result will be stored).",
        "function_prototype": "struct tm *gmtime_r(const time_t *restrict timer, struct tm *restrict result);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    time_t now;\n    struct tm result;\n    time(&now);\n    if (gmtime_r(&now, &result) == NULL) {\n        printf(\"gmtime_r failed\\n\");\n        return 1;\n    }\n    printf(\"UTC time: %04d-%02d-%02d %02d:%02d:%02d\\n\",\n           result.tm_year + 1900, result.tm_mon + 1, result.tm_mday,\n           result.tm_hour, result.tm_min, result.tm_sec);\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of gmtime_r to get the current UTC time in a thread-safe manner.",
            "expectedOutput": "UTC time: YYYY-MM-DD HH:MM:SS"
          },
          {
            "title": "Multiple Conversions",
            "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    time_t times[] = {0, 1000000000, 2000000000};\n    struct tm result;\n    for (int i = 0; i < 3; i++) {\n        if (gmtime_r(&times[i], &result) == NULL) {\n            printf(\"gmtime_r failed for time %ld\\n\", times[i]);\n            continue;\n        }\n        printf(\"Time %ld: %04d-%02d-%02d %02d:%02d:%02d\\n\", times[i],\n               result.tm_year + 1900, result.tm_mon + 1, result.tm_mday,\n               result.tm_hour, result.tm_min, result.tm_sec);\n    }\n    return 0;\n}",
            "explanation": "This example shows how gmtime_r can be safely used in loops without the risk of overwriting previous results.",
            "expectedOutput": "Time 0: 1970-01-01 00:00:00\nTime 1000000000: 2001-09-09 01:46:40\nTime 2000000000: 2033-05-18 03:33:20"
          },
          {
            "title": "Error Handling",
            "code": "#include <stdio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n\nint main() {\n    time_t invalid_time = -1; // Invalid time\n    struct tm result;\n    if (gmtime_r(&invalid_time, &result) == NULL) {\n        printf(\"gmtime_r failed: %s\\n\", strerror(errno));\n    } else {\n        printf(\"Conversion succeeded unexpectedly\\n\");\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates error handling with gmtime_r when given an invalid time value.",
            "expectedOutput": "gmtime_r failed: [error message depending on the system]"
          }
        ]
      },
      {
        "function_name": "hypot",
        "include_file": "math.h",
        "return_type": "double",
        "parameter_types": ["double", "double"],
        "main_category": "Mathematical Operations",
        "sub_category": "Advanced Computation",
        "data_type_manipulated": "floating-point numbers",
        "description": "Calculates the hypotenuse of a right-angled triangle given its legs.",
        "extended_description": "The hypot function computes the square root of the sum of the squares of x and y, without undue overflow or underflow. It is equivalent to sqrt(x*x + y*y), but is more robust against intermediate overflow or underflow.",
        "return_value": "Returns the length of the hypotenuse of a right-angled triangle with legs of length x and y.",
        "parameter_values": "This function takes two parameters: x and y (the lengths of the two legs of the right-angled triangle).",
        "function_prototype": "double hypot(double x, double y);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = 3.0, y = 4.0;\n    double z = hypot(x, y);\n    printf(\"The hypotenuse of a triangle with sides %.2f and %.2f is %.2f\\n\", x, y, z);\n    return 0;\n}",
            "explanation": "This example demonstrates the basic usage of hypot to calculate the hypotenuse of a 3-4-5 right triangle.",
            "expectedOutput": "The hypotenuse of a triangle with sides 3.00 and 4.00 is 5.00"
          },
          {
            "title": "Large Numbers",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = 1e150, y = 1e150;\n    double z = hypot(x, y);\n    printf(\"hypot(%.2e, %.2e) = %.2e\\n\", x, y, z);\n    printf(\"sqrt(x*x + y*y) = %.2e\\n\", sqrt(x*x + y*y));\n    return 0;\n}",
            "explanation": "This example shows how hypot handles large numbers that might cause overflow in naive calculations.",
            "expectedOutput": "hypot(1.00e+150, 1.00e+150) = 1.41e+150\nsqrt(x*x + y*y) = inf"
          },
          {
            "title": "Edge Cases",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    printf(\"hypot(0, 0) = %.2f\\n\", hypot(0, 0));\n    printf(\"hypot(INFINITY, 5) = %f\\n\", hypot(INFINITY, 5));\n    printf(\"hypot(NAN, 1) = %f\\n\", hypot(NAN, 1));\n    return 0;\n}",
            "explanation": "This example demonstrates how hypot behaves with edge cases like zero, infinity, and NaN.",
            "expectedOutput": "hypot(0, 0) = 0.00\nhypot(INFINITY, 5) = inf\nhypot(NAN, 1) = nan"
          }
        ]
      },
      {
        "function_name": "isalnum",
        "include_file": "ctype.h",
        "return_type": "int",
        "parameter_types": ["int"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Character Classification",
        "data_type_manipulated": "characters",
        "description": "Checks whether the character is alphanumeric.",
        "extended_description": "The isalnum function tests whether c is a character for which isalpha or isdigit is true. The behavior is undefined if the value of c is not representable as unsigned char and is not equal to EOF.",
        "return_value": "Returns non-zero if the character is alphanumeric, 0 otherwise.",
        "parameter_values": "This function takes one parameter: c (the character to be checked, represented as an int).",
        "function_prototype": "int isalnum(int c);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char test[] = {'A', '5', '@', 'z', '0'};\n    for (int i = 0; i < sizeof(test); i++) {\n        if (isalnum(test[i])) {\n            printf(\"'%c' is alphanumeric\\n\", test[i]);\n        } else {\n            printf(\"'%c' is not alphanumeric\\n\", test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of isalnum with various characters.",
            "expectedOutput": "'A' is alphanumeric\n'5' is alphanumeric\n'@' is not alphanumeric\n'z' is alphanumeric\n'0' is alphanumeric"
          },
          {
            "title": "String Processing",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint count_alnum(const char *str) {\n    int count = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (isalnum((unsigned char)str[i])) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    const char *text = \"Hello, World! 123\";\n    printf(\"'%s' contains %d alphanumeric characters.\\n\", \n           text, count_alnum(text));\n    return 0;\n}",
            "explanation": "This example shows how to use isalnum in string processing to count alphanumeric characters.",
            "expectedOutput": "'Hello, World! 123' contains 13 alphanumeric characters."
          },
          {
            "title": "Input Validation",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint is_valid_username(const char *username) {\n    if (strlen(username) < 4) return 0;\n    for (int i = 0; username[i] != '\\0'; i++) {\n        if (!isalnum((unsigned char)username[i])) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    const char *usernames[] = {\"user123\", \"user@123\", \"abc\", \"validUser\"};\n    for (int i = 0; i < 4; i++) {\n        if (is_valid_username(usernames[i])) {\n            printf(\"%s is a valid username\\n\", usernames[i]);\n        } else {\n            printf(\"%s is not a valid username\\n\", usernames[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates using isalnum for input validation, checking if usernames contain only alphanumeric characters.",
            "expectedOutput": "user123 is a valid username\nuser@123 is not a valid username\nabc is not a valid username\nvalidUser is a valid username"
          }
        ]
      },
      {
        "function_name": "isalpha",
        "include_file": "ctype.h",
        "return_type": "int",
        "parameter_types": ["int"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Character Classification",
        "data_type_manipulated": "characters",
        "description": "Checks whether the character is alphabetic.",
        "extended_description": "The isalpha function tests whether c is a character for which isupper or islower is true. The behavior is undefined if the value of c is not representable as unsigned char and is not equal to EOF.",
        "return_value": "Returns non-zero if the character is alphabetic, 0 otherwise.",
        "parameter_values": "This function takes one parameter: c (the character to be checked, represented as an int).",
        "function_prototype": "int isalpha(int c);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char test[] = {'A', '5', '@', 'z', '0'};\n    for (int i = 0; i < sizeof(test); i++) {\n        if (isalpha(test[i])) {\n            printf(\"'%c' is alphabetic\\n\", test[i]);\n        } else {\n            printf(\"'%c' is not alphabetic\\n\", test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of isalpha with various characters.",
            "expectedOutput": "'A' is alphabetic\n'5' is not alphabetic\n'@' is not alphabetic\n'z' is alphabetic\n'0' is not alphabetic"
          },
          {
            "title": "Alphabet Counting",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint count_alpha(const char *str) {\n    int count = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (isalpha((unsigned char)str[i])) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    const char *text = \"Hello, World! 123\";\n    printf(\"'%s' contains %d alphabetic characters.\\n\", \n           text, count_alpha(text));\n    return 0;\n}",
            "explanation": "This example shows how to use isalpha to count alphabetic characters in a string.",
            "expectedOutput": "'Hello, World! 123' contains 10 alphabetic characters."
          },
          {
            "title": "Word Boundary Detection",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid print_words(const char *str) {\n    int in_word = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (isalpha((unsigned char)str[i])) {\n            putchar(str[i]);\n            in_word = 1;\n        } else if (in_word) {\n            putchar('\\n');\n            in_word = 0;\n        }\n    }\n    if (in_word) putchar('\\n');\n}\n\nint main() {\n    const char *text = \"Hello, World! How are you?\";\n    printf(\"Words in '%s':\\n\", text);\n    print_words(text);\n    return 0;\n}",
            "explanation": "This example demonstrates using isalpha for word boundary detection in a string.",
            "expectedOutput": "Words in 'Hello, World! How are you?':\nHello\nWorld\nHow\nare\nyou"
          }
        ]
      },
      {
        "function_name": "isascii",
        "include_file": "ctype.h",
        "return_type": "int",
        "parameter_types": ["int"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Character Classification",
        "data_type_manipulated": "characters",
        "description": "Checks whether the character is an ASCII character.",
        "extended_description": "The isascii function tests whether c is a 7-bit unsigned char value that fits into the ASCII character set. This function is a BSD extension and not part of ISO C.",
        "return_value": "Returns non-zero if the character is an ASCII character (0-127), 0 otherwise.",
        "parameter_values": "This function takes one parameter: c (the character to be checked, represented as an int).",
        "function_prototype": "int isascii(int c);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char test[] = {'A', '\\n', 128, '5', '@'};\n    for (int i = 0; i < sizeof(test); i++) {\n        if (isascii(test[i])) {\n            printf(\"'%c' (0x%02X) is ASCII\\n\", test[i], (unsigned char)test[i]);\n        } else {\n            printf(\"'%c' (0x%02X) is not ASCII\\n\", test[i], (unsigned char)test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of isascii with various characters, including a non-ASCII character.",
            "expectedOutput": "'A' (0x41) is ASCII\n'' (0x0A) is ASCII\n'?' (0x80) is not ASCII\n'5' (0x35) is ASCII\n'@' (0x40) is ASCII"
          },
          {
            "title": "String Validation",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint is_ascii_string(const char *str) {\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (!isascii((unsigned char)str[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    const char *strings[] = {\"Hello, World!\", \"Café\", \"123\\n456\"};\n    for (int i = 0; i < 3; i++) {\n        if (is_ascii_string(strings[i])) {\n            printf(\"\\\"%s\\\" is a valid ASCII string\\n\", strings[i]);\n        } else {\n            printf(\"\\\"%s\\\" is not a valid ASCII string\\n\", strings[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example uses isascii to validate whether entire strings contain only ASCII characters.",
            "expectedOutput": "\"Hello, World!\" is a valid ASCII string\n\"Café\" is not a valid ASCII string\n\"123\n456\" is a valid ASCII string"
          },
          {
            "title": "File Processing",
            "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    FILE *file = fopen(\"test.txt\", \"rb\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    int c, ascii_count = 0, non_ascii_count = 0;\n    while ((c = fgetc(file)) != EOF) {\n        if (isascii(c)) {\n            ascii_count++;\n        } else {\n            non_ascii_count++;\n        }\n    }\n\n    printf(\"ASCII characters: %d\\n\", ascii_count);\n    printf(\"Non-ASCII characters: %d\\n\", non_ascii_count);\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example demonstrates using isascii to analyze the contents of a file, counting ASCII and non-ASCII characters.",
            "expectedOutput": "ASCII characters: [count]\nNon-ASCII characters: [count]\n(Actual counts depend on the contents of test.txt)"
          }
        ]
      },
      {
        "function_name": "isblank",
        "include_file": "ctype.h",
        "return_type": "int",
        "parameter_types": ["int"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Character Classification",
        "data_type_manipulated": "characters",
        "description": "Checks whether the character is a blank character (space or tab).",
        "extended_description": "The isblank function tests whether c is a blank character; that is, a space or a tab. This function was introduced in C99.",
        "return_value": "Returns non-zero if the character is a blank character, 0 otherwise.",
        "parameter_values": "This function takes one parameter: c (the character to be checked, represented as an int).",
        "function_prototype": "int isblank(int c);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char test[] = {' ', '\\t', '\\n', 'A', '5'};\n    for (int i = 0; i < sizeof(test); i++) {\n        if (isblank(test[i])) {\n            printf(\"'%c' (0x%02X) is a blank character\\n\", test[i], (unsigned char)test[i]);\n        } else {\n            printf(\"'%c' (0x%02X) is not a blank character\\n\", test[i], (unsigned char)test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of isblank with various characters.",
            "expectedOutput": "' ' (0x20) is a blank character\n'\\t' (0x09) is a blank character\n'\\n' (0x0A) is not a blank character\n'A' (0x41) is not a blank character\n'5' (0x35) is not a blank character"
          },
          {
            "title": "Word Counting",
            "code": "#include <stdio.h>\n#include <ctype.h>\n\nint count_words(const char *str) {\n    int in_word = 0;\n    int word_count = 0;\n\n    while (*str) {\n        if (isblank((unsigned char)*str)) {\n            in_word = 0;\n        } else if (!in_word) {\n            in_word = 1;\n            word_count++;\n        }\n        str++;\n    }\n\n    return word_count;\n}\n\nint main() {\n    const char *text = \"  Hello,\\tWorld!  How are\\tyou?  \";\n    printf(\"Number of words: %d\\n\", count_words(text));\n    return 0;\n}",
            "explanation": "This example uses isblank in a word counting function that considers spaces and tabs as word separators.",
            "expectedOutput": "Number of words: 5"
          },
          {
            "title": "Trimming Whitespace",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid trim(char *str) {\n    char *end;\n\n    // Trim leading spaces and tabs\n    while (isblank((unsigned char)*str)) str++;\n\n    if (*str == 0) return;  // All spaces?\n\n    // Trim trailing spaces and tabs\n    end = str + strlen(str) - 1;\n    while (end > str && isblank((unsigned char)*end)) end--;\n\n    *(end + 1) = 0;\n}\n\nint main() {\n    char text[] = \"  \\t  Hello, World!   \\t  \";\n    printf(\"Before: \\\"%s\\\"\\n\", text);\n    trim(text);\n    printf(\"After:  \\\"%s\\\"\\n\", text);\n    return 0;\n}",
            "explanation": "This example demonstrates using isblank to trim leading and trailing whitespace from a string.",
            "expectedOutput": "Before: \"    Hello, World!     \"\nAfter:  \"Hello, World!\""
          }
        ]
      },
      {
        "function_name": "iscntrl",
        "include_file": "ctype.h",
        "return_type": "int",
        "parameter_types": ["int"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Character Classification",
        "data_type_manipulated": "characters",
        "description": "Checks whether the character is a control character.",
        "extended_description": "The iscntrl function tests whether c is a control character. Control characters are those between 0 and 31 in the ASCII table, plus the DEL character (127).",
        "return_value": "Returns non-zero if the character is a control character, 0 otherwise.",
        "parameter_values": "This function takes one parameter: c (the character to be checked, represented as an int).",
        "function_prototype": "int iscntrl(int c);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char test[] = {'\\n', '\\t', 'A', ' ', 127};\n    for (int i = 0; i < sizeof(test); i++) {\n        if (iscntrl(test[i])) {\n            printf(\"'%c' (0x%02X) is a control character\\n\", test[i], (unsigned char)test[i]);\n        } else {\n            printf(\"'%c' (0x%02X) is not a control character\\n\", test[i], (unsigned char)test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of iscntrl with various characters, including control characters.",
            "expectedOutput": "'\n' (0x0A) is a control character\n'\t' (0x09) is a control character\n'A' (0x41) is not a control character\n' ' (0x20) is not a control character\n'' (0x7F) is a control character"
          },
          {
            "title": "String Sanitization",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid sanitize_string(char *str) {\n    char *write = str;\n    for (char *read = str; *read; read++) {\n        if (!iscntrl((unsigned char)*read)) {\n            *write++ = *read;\n        }\n    }\n    *write = '\\0';\n}\n\nint main() {\n    char text[] = \"Hello\\nWorld\\r\\tHow\\vare\\fyou?\";\n    printf(\"Before: %s\\n\", text);\n    sanitize_string(text);\n    printf(\"After:  %s\\n\", text);\n    return 0;\n}",
            "explanation": "This example uses iscntrl to remove all control characters from a string, effectively sanitizing it.",
            "expectedOutput": "Before: Hello\\nWorld\\r\\tHow\\vare\\fyou?\\nAfter:  HelloWorldHowareyou?"
          },
          {
            "title": "Control Character Count",
            "code": "#include <stdio.h>\n#include <ctype.h>\n\nint count_control_chars(FILE *file) {\n    int count = 0;\n    int c;\n    while ((c = fgetc(file)) != EOF) {\n        if (iscntrl(c)) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    FILE *file = fopen(\"test.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    int ctrl_count = count_control_chars(file);\n    printf(\"Number of control characters: %d\\n\", ctrl_count);\n\n    fclose(file);\n    return 0;\n}",
            "explanation": "This example demonstrates using iscntrl to count the number of control characters in a file.",
            "expectedOutput": "Number of control characters: [count]\n(Actual count depends on the contents of test.txt)"
          }
        ]
      },
      {
        "function_name": "isdigit",
        "include_file": "ctype.h",
        "return_type": "int",
        "parameter_types": ["int"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Character Classification",
        "data_type_manipulated": "characters",
        "description": "Checks whether the character is a decimal digit.",
        "extended_description": "The isdigit function tests whether c is a decimal digit character (0 through 9). This function is locale-independent.",
        "return_value": "Returns non-zero if the character is a digit (0-9), 0 otherwise.",
        "parameter_values": "This function takes one parameter: c (the character to be checked, represented as an int).",
        "function_prototype": "int isdigit(int c);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char test[] = {'5', 'A', '0', '9', 'a'};\n    for (int i = 0; i < sizeof(test); i++) {\n        if (isdigit(test[i])) {\n            printf(\"'%c' is a digit\\n\", test[i]);\n        } else {\n            printf(\"'%c' is not a digit\\n\", test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of isdigit with various characters.",
            "expectedOutput": "'5' is a digit\n'A' is not a digit\n'0' is a digit\n'9' is a digit\n'a' is not a digit"
          },
          {
            "title": "Numeric Input Validation",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint is_valid_integer(const char *str) {\n    if (*str == '-' || *str == '+') str++; // Skip optional sign\n    if (*str == '\\0') return 0; // Empty string or just a sign\n    while (*str) {\n        if (!isdigit((unsigned char)*str)) return 0;\n        str++;\n    }\n    return 1;\n}\n\nint main() {\n    const char *inputs[] = {\"123\", \"-456\", \"789a\", \"0\", \"+42\", \"a123\"};\n    for (int i = 0; i < 6; i++) {\n        if (is_valid_integer(inputs[i])) {\n            printf(\"\\\"%s\\\" is a valid integer\\n\", inputs[i]);\n        } else {\n            printf(\"\\\"%s\\\" is not a valid integer\\n\", inputs[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example uses isdigit to validate whether a string represents a valid integer.",
            "expectedOutput": "\"123\" is a valid integer\n\"-456\" is a valid integer\n\"789a\" is not a valid integer\n\"0\" is a valid integer\n\"+42\" is a valid integer\n\"a123\" is not a valid integer"
          },
          {
            "title": "Digit Sum",
            "code": "#include <stdio.h>\n#include <ctype.h>\n\nint sum_digits(const char *str) {\n    int sum = 0;\n    while (*str) {\n        if (isdigit((unsigned char)*str)) {\n            sum += *str - '0';\n        }\n        str++;\n    }\n    return sum;\n}\n\nint main() {\n    const char *text = \"abc123def456ghi789\";\n    printf(\"Sum of digits in \\\"%s\\\" is %d\\n\", text, sum_digits(text));\n    return 0;\n}",
            "explanation": "This example demonstrates using isdigit to sum all digits found in a string, ignoring non-digit characters.",
            "expectedOutput": "Sum of digits in \"abc123def456ghi789\" is 45"
          }
        ]
      },
      {
        "function_name": "isgraph",
        "include_file": "ctype.h",
        "return_type": "int",
        "parameter_types": ["int"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Character Classification",
        "data_type_manipulated": "characters",
        "description": "Checks whether the character has a graphical representation.",
        "extended_description": "The isgraph function tests whether c is a character with a graphical representation. In the default C locale, it includes all printing characters except space.",
        "return_value": "Returns non-zero if the character has a graphical representation, 0 otherwise.",
        "parameter_values": "This function takes one parameter: c (the character to be checked, represented as an int).",
        "function_prototype": "int isgraph(int c);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char test[] = {'A', ' ', '\\t', '5', '@', '\\n'};\n    for (int i = 0; i < sizeof(test); i++) {\n        if (isgraph(test[i])) {\n            printf(\"'%c' (0x%02X) has a graphical representation\\n\", test[i], (unsigned char)test[i]);\n        } else {\n            printf(\"'%c' (0x%02X) does not have a graphical representation\\n\", test[i], (unsigned char)test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of isgraph with various characters.",
            "expectedOutput": "'A' (0x41) has a graphical representation\n' ' (0x20) does not have a graphical representation\n'\t' (0x09) does not have a graphical representation\n'5' (0x35) has a graphical representation\n'@' (0x40) has a graphical representation\n'\n' (0x0A) does not have a graphical representation"
          },
          {
            "title": "Printable Content",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid print_graphical(const char *str) {\n    while (*str) {\n        if (isgraph((unsigned char)*str)) {\n            putchar(*str);\n        }\n        str++;\n    }\n    putchar('\\n');\n}\n\nint main() {\n    const char *text = \"Hello, World!\\nHow are you?\\t123\";\n    printf(\"Original: %s\\n\", text);\n    printf(\"Graphical: \");\n    print_graphical(text);\n    return 0;\n}",
            "explanation": "This example uses isgraph to print only the graphical characters from a string, effectively removing spaces and control characters.",
            "expectedOutput": "Original: Hello, World!\nHow are you?\t123\nGraphical: Hello,World!Howareyou?123"
          },
          {
            "title": "Password Strength",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint password_strength(const char *password) {\n    int strength = 0;\n    int has_upper = 0, has_lower = 0, has_digit = 0, has_symbol = 0;\n\n    while (*password) {\n        if (isupper((unsigned char)*password)) has_upper = 1;\n        else if (islower((unsigned char)*password)) has_lower = 1;\n        else if (isdigit((unsigned char)*password)) has_digit = 1;\n        else if (isgraph((unsigned char)*password)) has_symbol = 1;\n        password++;\n    }\n\n    strength = has_upper + has_lower + has_digit + has_symbol;\n    return strength;\n}\n\nint main() {\n    const char *passwords[] = {\"password\", \"Password1\", \"P@ssw0rd!\"};\n    for (int i = 0; i < 3; i++) {\n        printf(\"Password: %s, Strength: %d/4\\n\", passwords[i], password_strength(passwords[i]));\n    }\n    return 0;\n}",
            "explanation": "This example uses isgraph along with other character classification functions to assess password strength based on character variety.",
            "expectedOutput": "Password: password, Strength: 1/4\nPassword: Password1, Strength: 3/4\nPassword: P@ssw0rd!, Strength: 4/4"
          }
        ]
      },
      {
        "function_name": "islower",
        "include_file": "ctype.h",
        "return_type": "int",
        "parameter_types": ["int"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Character Classification",
        "data_type_manipulated": "characters",
        "description": "Checks whether the character is lowercase.",
        "extended_description": "The islower function tests whether c is a lowercase letter. In the default C locale, it includes the letters a through z.",
        "return_value": "Returns non-zero if the character is a lowercase letter, 0 otherwise.",
        "parameter_values": "This function takes one parameter: c (the character to be checked, represented as an int).",
        "function_prototype": "int islower(int c);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char test[] = {'A', 'a', '5', 'Z', 'z'};\n    for (int i = 0; i < sizeof(test); i++) {\n        if (islower(test[i])) {\n            printf(\"'%c' is lowercase\\n\", test[i]);\n        } else {\n            printf(\"'%c' is not lowercase\\n\", test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of islower with various characters.",
            "expectedOutput": "'A' is not lowercase\n'a' is lowercase\n'5' is not lowercase\n'Z' is not lowercase\n'z' is lowercase"
          },
          {
            "title": "Lowercase Count",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint count_lowercase(const char *str) {\n    int count = 0;\n    while (*str) {\n        if (islower((unsigned char)*str)) {\n            count++;\n        }\n        str++;\n    }\n    return count;\n}\n\nint main() {\n    const char *text = \"Hello, World! 123 ABC def\";\n    int lowercase_count = count_lowercase(text);\n    printf(\"The text \\\"%s\\\" contains %d lowercase letters.\\n\", text, lowercase_count);\n    return 0;\n}",
            "explanation": "This example uses islower to count the number of lowercase letters in a string.",
            "expectedOutput": "The text \"Hello, World! 123 ABC def\" contains 8 lowercase letters."
          },
          {
            "title": "Case Inverter",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid invert_case(char *str) {\n    while (*str) {\n        if (islower((unsigned char)*str)) {\n            *str = toupper((unsigned char)*str);\n        } else if (isupper((unsigned char)*str)) {\n            *str = tolower((unsigned char)*str);\n        }\n        str++;\n    }\n}\n\nint main() {\n    char text[] = \"Hello, World! 123\";\n    printf(\"Original: %s\\n\", text);\n    invert_case(text);\n    printf(\"Inverted: %s\\n\", text);\n    return 0;\n}",
            "explanation": "This example demonstrates using islower in conjunction with isupper to invert the case of all letters in a string.",
            "expectedOutput": "Original: Hello, World! 123\nInverted: hELLO, wORLD! 123"
          }
        ]
      },
      {
        "function_name": "isprint",
        "include_file": "ctype.h",
        "return_type": "int",
        "parameter_types": ["int"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Character Classification",
        "data_type_manipulated": "characters",
        "description": "Checks whether the character is printable, including space.",
        "extended_description": "The isprint function tests whether c is a printing character, including space (' '). In the default C locale, it includes all characters for which isgraph returns true, plus the space character.",
        "return_value": "Returns non-zero if the character is printable (including space), 0 otherwise.",
        "parameter_values": "This function takes one parameter: c (the character to be checked, represented as an int).",
        "function_prototype": "int isprint(int c);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char test[] = {'A', ' ', '\\t', '5', '@', '\\n', 127};\n    for (int i = 0; i < sizeof(test); i++) {\n        if (isprint(test[i])) {\n            printf(\"'%c' (0x%02X) is printable\\n\", test[i], (unsigned char)test[i]);\n        } else {\n            printf(\"'%c' (0x%02X) is not printable\\n\", test[i], (unsigned char)test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of isprint with various characters.",
            "expectedOutput": "'A' (0x41) is printable\n' ' (0x20) is printable\n'\t' (0x09) is not printable\n'5' (0x35) is printable\n'@' (0x40) is printable\n'\n' (0x0A) is not printable\n'' (0x7F) is not printable"
          },
          {
            "title": "File Content Preview",
            "code": "#include <stdio.h>\n#include <ctype.h>\n\n#define PREVIEW_LENGTH 50\n\nvoid preview_file(const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return;\n    }\n\n    int c, count = 0;\n    while ((c = fgetc(file)) != EOF && count < PREVIEW_LENGTH) {\n        if (isprint(c)) {\n            putchar(c);\n            count++;\n        } else if (c == '\\n') {\n            printf(\"\\n\");\n            count = 0; // Reset count for new line\n        } else {\n            printf(\".\"); // Replace non-printable with dot\n            count++;\n        }\n    }\n\n    fclose(file);\n    printf(\"\\n\");\n}\n\nint main() {\n    preview_file(\"sample.txt\");\n    return 0;\n}",
            "explanation": "This example uses isprint to create a preview of a file's content, replacing non-printable characters with dots.",
            "expectedOutput": "(Contents of sample.txt, with non-printable characters replaced by dots)"
          },
          {
            "title": "String Sanitization",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid sanitize_string(char *str) {\n    char *write = str;\n    for (char *read = str; *read; read++) {\n        if (isprint((unsigned char)*read)) {\n            *write++ = *read;\n        }\n    }\n    *write = '\\0';\n}\n\nint main() {\n    char text[] = \"Hello\\nWorld\\r\\tHow\\vare\\fyou?\";\n    printf(\"Before: %s\\n\", text);\n    sanitize_string(text);\n    printf(\"After:  %s\\n\", text);\n    return 0;\n}",
            "explanation": "This example demonstrates using isprint to sanitize a string by removing all non-printable characters.",
            "expectedOutput": "Before: Hello\\nWorld\\r\\tHow\\vare\\fyou?\\nAfter:  HelloWorldHowareyou?"
          }
        ]
      },
      {
        "function_name": "ispunct",
        "include_file": "ctype.h",
        "return_type": "int",
        "parameter_types": ["int"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Character Classification",
        "data_type_manipulated": "characters",
        "description": "Checks whether the character is a punctuation character.",
        "extended_description": "The ispunct function tests whether c is a printing character for which isspace and isalnum return false. In the default C locale, it includes all printing characters that are not alphanumeric or space.",
        "return_value": "Returns non-zero if the character is a punctuation character, 0 otherwise.",
        "parameter_values": "This function takes one parameter: c (the character to be checked, represented as an int).",
        "function_prototype": "int ispunct(int c);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char test[] = {'A', '.', ' ', '5', '@', '\\n', ','};\n    for (int i = 0; i < sizeof(test); i++) {\n        if (ispunct(test[i])) {\n            printf(\"'%c' is a punctuation character\\n\", test[i]);\n        } else {\n            printf(\"'%c' is not a punctuation character\\n\", test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of ispunct with various characters.",
            "expectedOutput": "'A' is not a punctuation character\n'.' is a punctuation character\n' ' is not a punctuation character\n'5' is not a punctuation character\n'@' is a punctuation character\n'\n' is not a punctuation character\n',' is a punctuation character"
          },
          {
            "title": "Punctuation Count",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint count_punctuation(const char *str) {\n    int count = 0;\n    while (*str) {\n        if (ispunct((unsigned char)*str)) {\n            count++;\n        }\n        str++;\n    }\n    return count;\n}\n\nint main() {\n    const char *text = \"Hello, World! How are you? This is a test.\";\n    int punct_count = count_punctuation(text);\n    printf(\"The text contains %d punctuation characters.\\n\", punct_count);\n    return 0;\n}",
            "explanation": "This example uses ispunct to count the number of punctuation characters in a string.",
            "expectedOutput": "The text contains 4 punctuation characters."
          },
          {
            "title": "Punctuation Remover",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid remove_punctuation(char *str) {\n    char *write = str;\n    for (char *read = str; *read; read++) {\n        if (!ispunct((unsigned char)*read)) {\n            *write++ = *read;\n        }\n    }\n    *write = '\\0';\n}\n\nint main() {\n    char text[] = \"Hello, World! How are you? This is a test.\";\n    printf(\"Original: %s\\n\", text);\n    remove_punctuation(text);\n    printf(\"Without punctuation: %s\\n\", text);\n    return 0;\n}",
            "explanation": "This example demonstrates using ispunct to remove all punctuation characters from a string.",
            "expectedOutput": "Original: Hello, World! How are you? This is a test.\nWithout punctuation: Hello World How are you This is a test"
          }
        ]
      },
      {
        "function_name": "isspace",
        "include_file": "ctype.h",
        "return_type": "int",
        "parameter_types": ["int"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Character Classification",
        "data_type_manipulated": "characters",
        "description": "Checks whether the character is a white-space character.",
        "extended_description": "The isspace function tests whether c is a white-space character. In the default C locale, white-space characters are: space, form feed ('\\f'), newline ('\\n'), carriage return ('\\r'), horizontal tab ('\\t'), and vertical tab ('\\v').",
        "return_value": "Returns non-zero if the character is a white-space character, 0 otherwise.",
        "parameter_values": "This function takes one parameter: c (the character to be checked, represented as an int).",
        "function_prototype": "int isspace(int c);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char test[] = {' ', '\\t', '\\n', 'A', '5', '\\r', '\\v'};\n    for (int i = 0; i < sizeof(test); i++) {\n        if (isspace(test[i])) {\n            printf(\"'%c' (0x%02X) is a white-space character\\n\", test[i], (unsigned char)test[i]);\n        } else {\n            printf(\"'%c' (0x%02X) is not a white-space character\\n\", test[i], (unsigned char)test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of isspace with various characters.",
            "expectedOutput": "' ' (0x20) is a white-space character\\n'\\t' (0x09) is a white-space character\\n'\\n' (0x0A) is a white-space character\\n'A' (0x41) is not a white-space character\\n'5' (0x35) is not a white-space character\\n'\\r' (0x0D) is a white-space character\\n'\\v' (0x0B) is a white-space character"
          },
          {
            "title": "Word Count",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint count_words(const char *str) {\n    int in_word = 0;\n    int word_count = 0;\n\n    while (*str) {\n        if (isspace((unsigned char)*str)) {\n            in_word = 0;\n        } else if (!in_word) {\n            in_word = 1;\n            word_count++;\n        }\n        str++;\n    }\n\n    return word_count;\n}\n\nint main() {\n    const char *text = \"  Hello,\\tWorld!  How\\nare\\ryou?  \";\n    int words = count_words(text);\n    printf(\"The text contains %d words.\\n\", words);\n    return 0;\n}",
            "explanation": "This example uses isspace to implement a simple word counting function.",
            "expectedOutput": "The text contains 4 words."
          },
          {
            "title": "Trim Whitespace",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nchar *trim(char *str) {\n    char *end;\n\n    // Trim leading space\n    while (isspace((unsigned char)*str)) str++;\n\n    if (*str == 0)  // All spaces?\n        return str;\n\n    // Trim trailing space\n    end = str + strlen(str) - 1;\n    while (end > str && isspace((unsigned char)*end)) end--;\n\n    // Write new null terminator\n    *(end+1) = 0;\n\n    return str;\n}\n\nint main() {\n    char text[] = \"  \\t  Hello, World!   \\n\";\n    printf(\"Before: '%s'\\n\", text);\n    printf(\"After:  '%s'\\n\", trim(text));\n    return 0;\n}",
            "explanation": "This example demonstrates using isspace to trim leading and trailing whitespace from a string.",
            "expectedOutput": "Before: '    Hello, World!   \n'\nAfter:  'Hello, World!'"
          }
        ]
      },
      {
        "function_name": "isupper",
        "include_file": "ctype.h",
        "return_type": "int",
        "parameter_types": ["int"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Character Classification",
        "data_type_manipulated": "characters",
        "description": "Checks whether the character is an uppercase letter.",
        "extended_description": "The isupper function tests whether c is an uppercase letter. In the default C locale, it includes the letters A through Z.",
        "return_value": "Returns non-zero if the character is an uppercase letter, 0 otherwise.",
        "parameter_values": "This function takes one parameter: c (the character to be checked, represented as an int).",
        "function_prototype": "int isupper(int c);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char test[] = {'A', 'a', '5', 'Z', 'z'};\n    for (int i = 0; i < sizeof(test); i++) {\n        if (isupper(test[i])) {\n            printf(\"'%c' is uppercase\\n\", test[i]);\n        } else {\n            printf(\"'%c' is not uppercase\\n\", test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of isupper with various characters.",
            "expectedOutput": "'A' is uppercase\\n'a' is not uppercase\\n'5' is not uppercase\\n'Z' is uppercase\\n'z' is not uppercase"
          },
          {
            "title": "Uppercase Count",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint count_uppercase(const char *str) {\n    int count = 0;\n    while (*str) {\n        if (isupper((unsigned char)*str)) {\n            count++;\n        }\n        str++;\n    }\n    return count;\n}\n\nint main() {\n    const char *text = \"Hello, WORLD! 123 ABC def\";\n    int uppercase_count = count_uppercase(text);\n    printf(\"The text \\\"%s\\\" contains %d uppercase letters.\\n\", text, uppercase_count);\n    return 0;\n}",
            "explanation": "This example uses isupper to count the number of uppercase letters in a string.",
            "expectedOutput": "The text \"Hello, WORLD! 123 ABC def\" contains 8 uppercase letters."
          },
          {
            "title": "Uppercase to Lowercase",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid to_lowercase(char *str) {\n    while (*str) {\n        if (isupper((unsigned char)*str)) {\n            *str = tolower((unsigned char)*str);\n        }\n        str++;\n    }\n}\n\nint main() {\n    char text[] = \"Hello, WORLD! 123\";\n    printf(\"Original: %s\\n\", text);\n    to_lowercase(text);\n    printf(\"Lowercase: %s\\n\", text);\n    return 0;\n}",
            "explanation": "This example demonstrates using isupper to convert uppercase letters to lowercase in a string.",
            "expectedOutput": "Original: Hello, WORLD! 123\\nLowercase: hello, world! 123"
          }
        ]
      },
      {
        "function_name": "iswalnum",
        "include_file": "wctype.h",
        "return_type": "int",
        "parameter_types": ["wint_t"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Wide Character Classification",
        "data_type_manipulated": "wide characters",
        "description": "Checks whether the wide character is alphanumeric.",
        "extended_description": "The iswalnum function tests whether wc is a wide character code representing an alphanumeric character (a letter or digit).",
        "return_value": "Returns non-zero if the wide character is alphanumeric, 0 otherwise.",
        "parameter_values": "This function takes one parameter: wc (the wide character to be checked, represented as wint_t).",
        "function_prototype": "int iswalnum(wint_t wc);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wint_t test[] = {L'A', L'5', L'@', L'あ', L'١'};\n    for (int i = 0; i < sizeof(test)/sizeof(wint_t); i++) {\n        if (iswalnum(test[i])) {\n            wprintf(L\"'%lc' is alphanumeric\\n\", test[i]);\n        } else {\n            wprintf(L\"'%lc' is not alphanumeric\\n\", test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of iswalnum with various wide characters, including non-Latin scripts.",
            "expectedOutput": "'A' is alphanumeric\\n'5' is alphanumeric\\n'@' is not alphanumeric\\n'あ' is alphanumeric\\n'١' is alphanumeric"
          },
          {
            "title": "Alphanumeric Count",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint count_walnum(const wchar_t *str) {\n    int count = 0;\n    while (*str) {\n        if (iswalnum(*str)) {\n            count++;\n        }\n        str++;\n    }\n    return count;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *text = L\"Hello, 世界123! АБВ890\";\n    int alnum_count = count_walnum(text);\n    wprintf(L\"The text \\\"%ls\\\" contains %d alphanumeric characters.\\n\", text, alnum_count);\n    return 0;\n}",
            "explanation": "This example uses iswalnum to count alphanumeric characters in a wide string containing multiple scripts.",
            "expectedOutput": "The text \"Hello, 世界123! АБВ890\" contains 17 alphanumeric characters."
          },
          {
            "title": "Alphanumeric Filter",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nvoid filter_alnum(wchar_t *str) {\n    wchar_t *write = str;\n    while (*str) {\n        if (iswalnum(*str)) {\n            *write++ = *str;\n        }\n        str++;\n    }\n    *write = L'\\0';\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t text[] = L\"Hello, 世界123! АБВ890 @#$%\";\n    wprintf(L\"Original: %ls\\n\", text);\n    filter_alnum(text);\n    wprintf(L\"Filtered: %ls\\n\", text);\n    return 0;\n}",
            "explanation": "This example demonstrates using iswalnum to filter a wide string, keeping only alphanumeric characters.",
            "expectedOutput": "Original: Hello, 世界123! АБВ890 @#$%\\nFiltered: Hello世界123АБВ890"
          }
        ]
      },
      {
        "function_name": "iswalpha",
        "include_file": "wctype.h",
        "return_type": "int",
        "parameter_types": ["wint_t"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Wide Character Classification",
        "data_type_manipulated": "wide characters",
        "description": "Checks whether the wide character is alphabetic.",
        "extended_description": "The iswalpha function tests whether wc is a wide character code representing an alphabetic character.",
        "return_value": "Returns non-zero if the wide character is alphabetic, 0 otherwise.",
        "parameter_values": "This function takes one parameter: wc (the wide character to be checked, represented as wint_t).",
        "function_prototype": "int iswalpha(wint_t wc);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wint_t test[] = {L'A', L'5', L'@', L'あ', L'١'};\n    for (int i = 0; i < sizeof(test)/sizeof(wint_t); i++) {\n        if (iswalpha(test[i])) {\n            wprintf(L\"'%lc' is alphabetic\\n\", test[i]);\n        } else {\n            wprintf(L\"'%lc' is not alphabetic\\n\", test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of iswalpha with various wide characters, including non-Latin scripts.",
            "expectedOutput": "'A' is alphabetic\\n'5' is not alphabetic\\n'@' is not alphabetic\\n'あ' is alphabetic\\n'١' is not alphabetic"
          },
          {
            "title": "Alphabet Count",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint count_walpha(const wchar_t *str) {\n    int count = 0;\n    while (*str) {\n        if (iswalpha(*str)) {\n            count++;\n        }\n        str++;\n    }\n    return count;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *text = L\"Hello, 世界123! АБВ890\";\n    int alpha_count = count_walpha(text);\n    wprintf(L\"The text \\\"%ls\\\" contains %d alphabetic characters.\\n\", text, alpha_count);\n    return 0;\n}",
            "explanation": "This example uses iswalpha to count alphabetic characters in a wide string containing multiple scripts.",
            "expectedOutput": "The text \"Hello, 世界123! АБВ890\" contains 11 alphabetic characters."
          },
          {
            "title": "Word Boundary Detection",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nvoid print_words(const wchar_t *str) {\n    int in_word = 0;\n    while (*str) {\n        if (iswalpha(*str)) {\n            putwchar(*str);\n            in_word = 1;\n        } else if (in_word) {\n            putwchar(L'\\n');\n            in_word = 0;\n        }\n        str++;\n    }\n    if (in_word) putwchar(L'\\n');\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *text = L\"Hello, 世界! How are you? 123\";\n    wprintf(L\"Words in '%ls':\\n\", text);\n    print_words(text);\n    return 0;\n}",
            "explanation": "This example demonstrates using iswalpha for word boundary detection in a wide string with multiple languages.",
            "expectedOutput": "Words in 'Hello, 世界! How are you? 123':\\nHello\\n世界\\nHow\\nare\\nyou"
          }
        ]
      },
      {
        "function_name": "iswblank",
        "include_file": "wctype.h",
        "return_type": "int",
        "parameter_types": ["wint_t"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Wide Character Classification",
        "data_type_manipulated": "wide characters",
        "description": "Checks whether the wide character is a blank (space or tab).",
        "extended_description": "The iswblank function tests whether wc is a wide character code representing a blank character. In many locales, this includes the space character and the horizontal tab.",
        "return_value": "Returns non-zero if the wide character is a blank character, 0 otherwise.",
        "parameter_values": "This function takes one parameter: wc (the wide character to be checked, represented as wint_t).",
        "function_prototype": "int iswblank(wint_t wc);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wint_t test[] = {L' ', L'\\t', L'A', L'\\n', L'　'}; // includes wide space\n    for (int i = 0; i < sizeof(test)/sizeof(wint_t); i++) {\n        if (iswblank(test[i])) {\n            wprintf(L\"'%lc' (U+%04X) is a blank character\\n\", test[i], (unsigned int)test[i]);\n        } else {\n            wprintf(L\"'%lc' (U+%04X) is not a blank character\\n\", test[i], (unsigned int)test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of iswblank with various wide characters, including a wide space.",
            "expectedOutput": "' ' (U+0020) is a blank character\\n'\\t' (U+0009) is a blank character\\n'A' (U+0041) is not a blank character\\n'\\n' (U+000A) is not a blank character\\n'　' (U+3000) is a blank character"
          },
          {
            "title": "Trim Function",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nwchar_t *wtrim(wchar_t *str) {\n    wchar_t *end;\n    while (iswblank(*str)) str++;\n    if (*str == L'\\0') return str;\n    end = str + wcslen(str) - 1;\n    while (end > str && iswblank(*end)) end--;\n    *(end + 1) = L'\\0';\n    return str;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t text[] = L\"  \\tHello, World!　　\";\n    wprintf(L\"Before: '%ls'\\n\", text);\n    wprintf(L\"After:  '%ls'\\n\", wtrim(text));\n    return 0;\n}",
            "explanation": "This example uses iswblank to create a trim function for wide strings, removing leading and trailing blank characters.",
            "expectedOutput": "Before: '  \\tHello, World!　　'\\nAfter:  'Hello, World!'"
          },
          {
            "title": "Word Count",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint wword_count(const wchar_t *str) {\n    int count = 0;\n    int in_word = 0;\n    while (*str) {\n        if (iswblank(*str)) {\n            in_word = 0;\n        } else if (!in_word) {\n            in_word = 1;\n            count++;\n        }\n        str++;\n    }\n    return count;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *text = L\"Hello,　World!\\tHow are\\nyou?\";\n    int words = wword_count(text);\n    wprintf(L\"The text contains %d words:\\n%ls\\n\", words, text);\n    return 0;\n}",
            "explanation": "This example demonstrates using iswblank in a word counting function for wide strings.",
            "expectedOutput": "The text contains 5 words:\\nHello,　World!\\tHow are\\nyou?"
          }
        ]
      },
      {
        "function_name": "iswcntrl",
        "include_file": "wctype.h",
        "return_type": "int",
        "parameter_types": ["wint_t"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Wide Character Classification",
        "data_type_manipulated": "wide characters",
        "description": "Checks whether the wide character is a control character.",
        "extended_description": "The iswcntrl function tests whether wc is a wide character code representing a control character. Control characters are typically non-printing characters used to control the formatting or transmission of data.",
        "return_value": "Returns non-zero if the wide character is a control character, 0 otherwise.",
        "parameter_values": "This function takes one parameter: wc (the wide character to be checked, represented as wint_t).",
        "function_prototype": "int iswcntrl(wint_t wc);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wint_t test[] = {L'\\n', L'\\t', L'A', L' ', L'\\x7F'};\n    for (int i = 0; i < sizeof(test)/sizeof(wint_t); i++) {\n        if (iswcntrl(test[i])) {\n            wprintf(L\"U+%04X is a control character\\n\", (unsigned int)test[i]);\n        } else {\n            wprintf(L\"'%lc' (U+%04X) is not a control character\\n\", test[i], (unsigned int)test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of iswcntrl with various wide characters.",
            "expectedOutput": "U+000A is a control character\\nU+0009 is a control character\\n'A' (U+0041) is not a control character\\n' ' (U+0020) is not a control character\\nU+007F is a control character"
          },
          {
            "title": "Control Character Removal",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nvoid remove_control(wchar_t *str) {\n    wchar_t *write = str;\n    while (*str) {\n        if (!iswcntrl(*str)) {\n            *write++ = *str;\n        }\n        str++;\n    }\n    *write = L'\\0';\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t text[] = L\"Hello,\\nWorld!\\tHow\\rare\\vyou?\";\n    wprintf(L\"Before: %ls\\n\", text);\n    remove_control(text);\n    wprintf(L\"After:  %ls\\n\", text);\n    return 0;\n}",
            "explanation": "This example uses iswcntrl to remove all control characters from a wide string.",
            "expectedOutput": "Before: Hello,\\nWorld!\\tHow\\rare\\vyou?\\nAfter:  Hello,World!Howareyou?"
          },
          {
            "title": "Control Character Count",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint count_control(const wchar_t *str) {\n    int count = 0;\n    while (*str) {\n        if (iswcntrl(*str)) {\n            count++;\n        }\n        str++;\n    }\n    return count;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *text = L\"Hello,\\nWorld!\\tHow\\rare\\vyou?\";\n    int ctrl_count = count_control(text);\n    wprintf(L\"The text contains %d control characters:\\n%ls\\n\", ctrl_count, text);\n    return 0;\n}",
            "explanation": "This example demonstrates using iswcntrl to count the number of control characters in a wide string.",
            "expectedOutput": "The text contains 4 control characters:\\nHello,\\nWorld!\\tHow\\rare\\vyou?"
          }
        ]
      },
      {
        "function_name": "iswctype",
        "include_file": "wctype.h",
        "return_type": "int",
        "parameter_types": ["wint_t", "wctype_t"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Wide Character Classification",
        "data_type_manipulated": "wide characters",
        "description": "Checks whether the wide character conforms to the specified type.",
        "extended_description": "The iswctype function determines whether the wide character wc has the property described by desc. The desc argument must be a character property descriptor returned by the wctype function.",
        "return_value": "Returns non-zero if the wide character has the specified property, 0 otherwise.",
        "parameter_values": "This function takes two parameters: wc (the wide character to be checked, represented as wint_t) and desc (the character property descriptor, represented as wctype_t).",
        "function_prototype": "int iswctype(wint_t wc, wctype_t desc);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wint_t test[] = {L'A', L'5', L'@', L'あ', L'١'};\n    wctype_t alpha_type = wctype(\"alpha\");\n    wctype_t digit_type = wctype(\"digit\");\n\n    for (int i = 0; i < sizeof(test)/sizeof(wint_t); i++) {\n        wprintf(L\"'%lc': \", test[i]);\n        if (iswctype(test[i], alpha_type)) {\n            wprintf(L\"alphabetic \");\n        }\n        if (iswctype(test[i], digit_type)) {\n            wprintf(L\"digit \");\n        }\n        if (!iswctype(test[i], alpha_type) && !iswctype(test[i], digit_type)) {\n            wprintf(L\"neither alphabetic nor digit\");\n        }\n        wprintf(L\"\\n\");\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of iswctype with alphabetic and digit properties for various wide characters.",
            "expectedOutput": "'A': alphabetic \\n'5': digit \\n'@': neither alphabetic nor digit\\n'あ': alphabetic \\n'١': digit "
          },
          {
            "title": "Custom Character Class",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint is_custom_class(wint_t wc) {\n    static wctype_t upper_type = (wctype_t)0;\n    static wctype_t punct_type = (wctype_t)0;\n    if (upper_type == 0) upper_type = wctype(\"upper\");\n    if (punct_type == 0) punct_type = wctype(\"punct\");\n    return iswctype(wc, upper_type) || iswctype(wc, punct_type);\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *text = L\"Hello, WORLD! 123\";\n    wprintf(L\"Custom class characters in '%ls':\\n\", text);\n    while (*text) {\n        if (is_custom_class(*text)) {\n            wprintf(L\"%lc\", *text);\n        }\n        text++;\n    }\n    wprintf(L\"\\n\");\n    return 0;\n}",
            "explanation": "This example uses iswctype to create a custom character class that includes uppercase letters and punctuation.",
            "expectedOutput": "Custom class characters in 'Hello, WORLD! 123':\\nH,WORLD!"
          },
          {
            "title": "Dynamic Property Check",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n#include <string.h>\n\nint check_property(const wchar_t *str, const char *property) {\n    wctype_t desc = wctype(property);\n    if (desc == (wctype_t)0) {\n        return -1;  // Invalid property\n    }\n    while (*str) {\n        if (iswctype(*str, desc)) {\n            return 1;  // Property found\n        }\n        str++;\n    }\n    return 0;  // Property not found\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *text = L\"Hello, World! 123\";\n    const char *properties[] = {\"alpha\", \"digit\", \"punct\", \"invalid\"};\n\n    for (int i = 0; i < sizeof(properties)/sizeof(char*); i++) {\n        int result = check_property(text, properties[i]);\n        if (result == 1) {\n            wprintf(L\"'%ls' contains '%s' characters\\n\", text, properties[i]);\n        } else if (result == 0) {\n            wprintf(L\"'%ls' does not contain '%s' characters\\n\", text, properties[i]);\n        } else {\n            wprintf(L\"'%s' is not a valid property\\n\", properties[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates using iswctype to dynamically check for various character properties in a wide string.",
            "expectedOutput": "'Hello, World! 123' contains 'alpha' characters\\n'Hello, World! 123' contains 'digit' characters\\n'Hello, World! 123' contains 'punct' characters\\n'invalid' is not a valid property"
          }
        ]
      },
      {
        "function_name": "iswdigit",
        "include_file": "wctype.h",
        "return_type": "int",
        "parameter_types": ["wint_t"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Wide Character Classification",
        "data_type_manipulated": "wide characters",
        "description": "Checks whether the wide character is a digit.",
        "extended_description": "The iswdigit function tests whether wc is a wide character code representing a decimal digit character. In many locales, only the characters '0' through '9' are considered digits.",
        "return_value": "Returns non-zero if the wide character is a digit, 0 otherwise.",
        "parameter_values": "This function takes one parameter: wc (the wide character to be checked, represented as wint_t).",
        "function_prototype": "int iswdigit(wint_t wc);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wint_t test[] = {L'5', L'A', L'0', L'९', L'三'};\n    for (int i = 0; i < sizeof(test)/sizeof(wint_t); i++) {\n        if (iswdigit(test[i])) {\n            wprintf(L\"'%lc' (U+%04X) is a digit\\n\", test[i], (unsigned int)test[i]);\n        } else {\n            wprintf(L\"'%lc' (U+%04X) is not a digit\\n\", test[i], (unsigned int)test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of iswdigit with various wide characters, including non-ASCII digits.",
            "expectedOutput": "'5' (U+0035) is a digit\\n'A' (U+0041) is not a digit\\n'0' (U+0030) is a digit\\n'९' (U+0969) is not a digit\\n'三' (U+4E09) is not a digit"
          },
          {
            "title": "Numeric String Validation",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint is_numeric_wstring(const wchar_t *str) {\n    if (*str == L'-' || *str == L'+') str++;\n    if (*str == L'\\0') return 0;\n    while (*str) {\n        if (!iswdigit(*str)) return 0;\n        str++;\n    }\n    return 1;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *tests[] = {L\"123\", L\"-456\", L\"+789\", L\"12a34\", L\"५६७\"};\n    for (int i = 0; i < sizeof(tests)/sizeof(wchar_t*); i++) {\n        if (is_numeric_wstring(tests[i])) {\n            wprintf(L\"\\\"%ls\\\" is a valid numeric string\\n\", tests[i]);\n        } else {\n            wprintf(L\"\\\"%ls\\\" is not a valid numeric string\\n\", tests[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example uses iswdigit to validate whether a wide string represents a valid numeric value.",
            "expectedOutput": "\"123\" is a valid numeric string\\n\"-456\" is a valid numeric string\\n\"+789\" is a valid numeric string\\n\"12a34\" is not a valid numeric string\\n\"५६७\" is not a valid numeric string"
          },
          {
            "title": "Sum of Digits",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint sum_of_digits(const wchar_t *str) {\n    int sum = 0;\n    while (*str) {\n        if (iswdigit(*str)) {\n            sum += *str - L'0';\n        }\n        str++;\n    }\n    return sum;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *text = L\"The year is 2023, and the answer is 42.\";\n    int sum = sum_of_digits(text);\n    wprintf(L\"Text: %ls\\nSum of digits: %d\\n\", text, sum);\n    return 0;\n}",
            "explanation": "This example demonstrates using iswdigit to sum all digits found in a wide string, ignoring non-digit characters.",
            "expectedOutput": "Text: The year is 2023, and the answer is 42.\\nSum of digits: 11"
          }
        ]
      },
      {
        "function_name": "iswgraph",
        "include_file": "wctype.h",
        "return_type": "int",
        "parameter_types": ["wint_t"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Wide Character Classification",
        "data_type_manipulated": "wide characters",
        "description": "Checks whether the wide character has a graphical representation.",
        "extended_description": "The iswgraph function tests whether wc is a wide character code representing a character with a visible representation. In many locales, this includes all printing characters except space.",
        "return_value": "Returns non-zero if the wide character has a graphical representation, 0 otherwise.",
        "parameter_values": "This function takes one parameter: wc (the wide character to be checked, represented as wint_t).",
        "function_prototype": "int iswgraph(wint_t wc);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wint_t test[] = {L'A', L' ', L'\\t', L'5', L'@', L'\\n', L'あ'};\n    for (int i = 0; i < sizeof(test)/sizeof(wint_t); i++) {\n        if (iswgraph(test[i])) {\n            wprintf(L\"'%lc' (U+%04X) has a graphical representation\\n\", test[i], (unsigned int)test[i]);\n        } else {\n            wprintf(L\"'%lc' (U+%04X) does not have a graphical representation\\n\", test[i], (unsigned int)test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of iswgraph with various wide characters.",
            "expectedOutput": "'A' (U+0041) has a graphical representation\\n' ' (U+0020) does not have a graphical representation\\n'\t' (U+0009) does not have a graphical representation\\n'5' (U+0035) has a graphical representation\\n'@' (U+0040) has a graphical representation\\n'\\n' (U+000A) does not have a graphical representation\\n'あ' (U+3042) has a graphical representation"
          },
          {
            "title": "Visible Content Extraction",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nvoid extract_visible(const wchar_t *str) {\n    while (*str) {\n        if (iswgraph(*str)) {\n            putwchar(*str);\n        }\n        str++;\n    }\n    putwchar(L'\\n');\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *text = L\"Hello, \\tWorld!\\nHow are you?\\r\\n\";\n    wprintf(L\"Original text: %ls\\n\", text);\n    wprintf(L\"Visible content: \");\n    extract_visible(text);\n    return 0;\n}",
            "explanation": "This example uses iswgraph to extract and print only the visible characters from a wide string.",
            "expectedOutput": "Original text: Hello, \\tWorld!\\nHow are you?\\r\\n\\nVisible content: Hello,World!Howareyou?"
          },
          {
            "title": "Graphical Density",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\ndouble graphical_density(const wchar_t *str) {\n    int total = 0, graphical = 0;\n    while (*str) {\n        total++;\n        if (iswgraph(*str)) {\n            graphical++;\n        }\n        str++;\n    }\n    return total > 0 ? (double)graphical / total : 0;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *texts[] = {\n        L\"Hello, World!\",\n        L\"   Spaces   \",\n        L\"\\t\\n\\r\",\n        L\"Mix of 123 and ABC\"\n    };\n    for (int i = 0; i < sizeof(texts)/sizeof(wchar_t*); i++) {\n        wprintf(L\"\\\"%ls\\\" has %.2f%% graphical density\\n\",\n                texts[i], graphical_density(texts[i]) * 100);\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates using iswgraph to calculate the 'graphical density' of wide strings, which is the proportion of characters with a visible representation.",
            "expectedOutput": "\"Hello, World!\" has 92.31% graphical density\\n\"   Spaces   \" has 0.00% graphical density\\n\"\\t\\n\\r\" has 0.00% graphical density\\n\"Mix of 123 and ABC\" has 93.75% graphical density"
          }
        ]
      },

      {
        "function_name": "iswlower",
        "include_file": "wctype.h",
        "return_type": "int",
        "parameter_types": ["wint_t"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Wide Character Classification",
        "data_type_manipulated": "wide characters",
        "description": "Checks whether the wide character is lowercase.",
        "extended_description": "The iswlower function tests whether wc is a wide character code representing a lowercase letter. The exact set of characters for which iswlower returns true is locale-dependent.",
        "return_value": "Returns non-zero if the wide character is a lowercase letter, 0 otherwise.",
        "parameter_values": "This function takes one parameter: wc (the wide character to be checked, represented as wint_t).",
        "function_prototype": "int iswlower(wint_t wc);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wint_t test[] = {L'a', L'A', L'5', L'z', L'Ω', L'α'};\n    for (int i = 0; i < sizeof(test)/sizeof(wint_t); i++) {\n        if (iswlower(test[i])) {\n            wprintf(L\"'%lc' (U+%04X) is lowercase\\n\", test[i], (unsigned int)test[i]);\n        } else {\n            wprintf(L\"'%lc' (U+%04X) is not lowercase\\n\", test[i], (unsigned int)test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of iswlower with various wide characters, including non-ASCII letters.",
            "expectedOutput": "'a' (U+0061) is lowercase\\n'A' (U+0041) is not lowercase\\n'5' (U+0035) is not lowercase\\n'z' (U+007A) is lowercase\\n'Ω' (U+03A9) is not lowercase\\n'α' (U+03B1) is lowercase"
          },
          {
            "title": "Lowercase Count",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint count_lowercase(const wchar_t *str) {\n    int count = 0;\n    while (*str) {\n        if (iswlower(*str)) {\n            count++;\n        }\n        str++;\n    }\n    return count;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *text = L\"Hello, WORLD! αβγ ΑΒΓ\";\n    int lowercase_count = count_lowercase(text);\n    wprintf(L\"The text \\\"%ls\\\" contains %d lowercase letters.\\n\", text, lowercase_count);\n    return 0;\n}",
            "explanation": "This example uses iswlower to count the number of lowercase letters in a wide string, including non-ASCII characters.",
            "expectedOutput": "The text \"Hello, WORLD! αβγ ΑΒΓ\" contains 7 lowercase letters."
          },
          {
            "title": "Lowercase to Uppercase",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nvoid to_uppercase(wchar_t *str) {\n    while (*str) {\n        if (iswlower(*str)) {\n            *str = towupper(*str);\n        }\n        str++;\n    }\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t text[] = L\"Hello, World! αβγ 123\";\n    wprintf(L\"Original: %ls\\n\", text);\n    to_uppercase(text);\n    wprintf(L\"Uppercase: %ls\\n\", text);\n    return 0;\n}",
            "explanation": "This example demonstrates using iswlower in conjunction with towupper to convert all lowercase letters to uppercase in a wide string.",
            "expectedOutput": "Original: Hello, World! αβγ 123\\nUppercase: HELLO, WORLD! ΑΒΓ 123"
          }
        ]
      },
      {
        "function_name": "iswprint",
        "include_file": "wctype.h",
        "return_type": "int",
        "parameter_types": ["wint_t"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Wide Character Classification",
        "data_type_manipulated": "wide characters",
        "description": "Checks whether the wide character is printable, including space.",
        "extended_description": "The iswprint function tests whether wc is a wide character code representing a printable character. In many locales, this includes the space character and all characters for which iswgraph returns true.",
        "return_value": "Returns non-zero if the wide character is printable (including space), 0 otherwise.",
        "parameter_values": "This function takes one parameter: wc (the wide character to be checked, represented as wint_t).",
        "function_prototype": "int iswprint(wint_t wc);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wint_t test[] = {L'A', L' ', L'\\t', L'5', L'@', L'\\n', L'あ', L'\\x7F'};\n    for (int i = 0; i < sizeof(test)/sizeof(wint_t); i++) {\n        if (iswprint(test[i])) {\n            wprintf(L\"'%lc' (U+%04X) is printable\\n\", test[i], (unsigned int)test[i]);\n        } else {\n            wprintf(L\"'%lc' (U+%04X) is not printable\\n\", test[i], (unsigned int)test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of iswprint with various wide characters.",
            "expectedOutput": "'A' (U+0041) is printable\\n' ' (U+0020) is printable\\n'\\t' (U+0009) is not printable\\n'5' (U+0035) is printable\\n'@' (U+0040) is printable\\n'\\n' (U+000A) is not printable\\n'あ' (U+3042) is printable\\n'' (U+007F) is not printable"
          },
          {
            "title": "Printable Content Filter",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nvoid print_printable(const wchar_t *str) {\n    while (*str) {\n        if (iswprint(*str)) {\n            putwchar(*str);\n        } else {\n            putwchar(L'.');\n        }\n        str++;\n    }\n    putwchar(L'\\n');\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *text = L\"Hello,\\tWorld!\\nこんにちは\\x7F\";\n    wprintf(L\"Original: %ls\\n\", text);\n    wprintf(L\"Filtered: \");\n    print_printable(text);\n    return 0;\n}",
            "explanation": "This example uses iswprint to filter a wide string, replacing non-printable characters with dots.",
            "expectedOutput": "Original: Hello,\\tWorld!\\nこんにちは\\x7F\\nFiltered: Hello,.World!.こんにちは."
          },
          {
            "title": "Printable Ratio",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\ndouble printable_ratio(const wchar_t *str) {\n    int total = 0, printable = 0;\n    while (*str) {\n        total++;\n        if (iswprint(*str)) {\n            printable++;\n        }\n        str++;\n    }\n    return total > 0 ? (double)printable / total : 0;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *texts[] = {\n        L\"Hello, World!\",\n        L\"Control\\tCharacters\\nHere\",\n        L\"Mixed: ABC\\x7F123\\n\",\n        L\"日本語でも大丈夫\"\n    };\n    for (int i = 0; i < sizeof(texts)/sizeof(wchar_t*); i++) {\n        wprintf(L\"\\\"%ls\\\" has %.2f%% printable characters\\n\",\n                texts[i], printable_ratio(texts[i]) * 100);\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates using iswprint to calculate the ratio of printable characters in various wide strings.",
            "expectedOutput": "\"Hello, World!\" has 100.00% printable characters\\n\"Control\\tCharacters\\nHere\" has 84.21% printable characters\\n\"Mixed: ABC\\x7F123\\n\" has 86.67% printable characters\\n\"日本語でも大丈夫\" has 100.00% printable characters"
          }
        ]
      },
      {
        "function_name": "iswpunct",
        "include_file": "wctype.h",
        "return_type": "int",
        "parameter_types": ["wint_t"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Wide Character Classification",
        "data_type_manipulated": "wide characters",
        "description": "Checks whether the wide character is a punctuation mark.",
        "extended_description": "The iswpunct function tests whether wc is a wide character code representing a punctuation character. In many locales, this includes all printing characters that are neither alphanumeric nor space.",
        "return_value": "Returns non-zero if the wide character is a punctuation mark, 0 otherwise.",
        "parameter_values": "This function takes one parameter: wc (the wide character to be checked, represented as wint_t).",
        "function_prototype": "int iswpunct(wint_t wc);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wint_t test[] = {L'.', L'A', L' ', L'5', L'@', L'、', L'α'};\n    for (int i = 0; i < sizeof(test)/sizeof(wint_t); i++) {\n        if (iswpunct(test[i])) {\n            wprintf(L\"'%lc' (U+%04X) is a punctuation mark\\n\", test[i], (unsigned int)test[i]);\n        } else {\n            wprintf(L\"'%lc' (U+%04X) is not a punctuation mark\\n\", test[i], (unsigned int)test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of iswpunct with various wide characters, including non-ASCII punctuation.",
            "expectedOutput": "'.' (U+002E) is a punctuation mark\\n'A' (U+0041) is not a punctuation mark\\n' ' (U+0020) is not a punctuation mark\\n'5' (U+0035) is not a punctuation mark\\n'@' (U+0040) is a punctuation mark\\n'、' (U+3001) is a punctuation mark\\n'α' (U+03B1) is not a punctuation mark"
          },
          {
            "title": "Punctuation Count",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint count_punctuation(const wchar_t *str) {\n    int count = 0;\n    while (*str) {\n        if (iswpunct(*str)) {\n            count++;\n        }\n        str++;\n    }\n    return count;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *text = L\"Hello, World! How are you? (This is a test.)\";\n    int punct_count = count_punctuation(text);\n    wprintf(L\"The text \\\"%ls\\\" contains %d punctuation marks.\\n\", text, punct_count);\n    return 0;\n}",
            "explanation": "This example uses iswpunct to count the number of punctuation marks in a wide string.",
            "expectedOutput": "The text \"Hello, World! How are you? (This is a test.)\" contains 6 punctuation marks."
          },
          {
            "title": "Punctuation Removal",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nvoid remove_punctuation(wchar_t *str) {\n    wchar_t *write = str;\n    while (*str) {\n        if (!iswpunct(*str)) {\n            *write++ = *str;\n        }\n        str++;\n    }\n    *write = L'\\0';\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t text[] = L\"Hello, World! How are you? (This is a test.)\";\n    wprintf(L\"Original: %ls\\n\", text);\n    remove_punctuation(text);\n    wprintf(L\"Without punctuation: %ls\\n\", text);\n    return 0;\n}",
            "explanation": "This example demonstrates using iswpunct to remove all punctuation marks from a wide string.",
            "expectedOutput": "Original: Hello, World! How are you? (This is a test.)\\nWithout punctuation: Hello World How are you This is a test"
          }
        ]
      },
      {
        "function_name": "iswspace",
        "include_file": "wctype.h",
        "return_type": "int",
        "parameter_types": ["wint_t"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Wide Character Classification",
        "data_type_manipulated": "wide characters",
        "description": "Checks whether the wide character is a whitespace character.",
        "extended_description": "The iswspace function tests whether wc is a wide character code representing a whitespace character. In many locales, this includes the standard space, form feed, newline, carriage return, horizontal tab, and vertical tab.",
        "return_value": "Returns non-zero if the wide character is a whitespace character, 0 otherwise.",
        "parameter_values": "This function takes one parameter: wc (the wide character to be checked, represented as wint_t).",
        "function_prototype": "int iswspace(wint_t wc);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wint_t test[] = {L' ', L'\\t', L'\\n', L'A', L'5', L'　', L'\\r'};\n    for (int i = 0; i < sizeof(test)/sizeof(wint_t); i++) {\n        if (iswspace(test[i])) {\n            wprintf(L\"U+%04X is a whitespace character\\n\", (unsigned int)test[i]);\n        } else {\n            wprintf(L\"'%lc' (U+%04X) is not a whitespace character\\n\", test[i], (unsigned int)test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of iswspace with various wide characters, including non-ASCII whitespace.",
            "expectedOutput": "U+0020 is a whitespace character\\nU+0009 is a whitespace character\\nU+000A is a whitespace character\\n'A' (U+0041) is not a whitespace character\\n'5' (U+0035) is not a whitespace character\\nU+3000 is a whitespace character\\nU+000D is a whitespace character"
          },
          {
            "title": "Word Count",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint count_words(const wchar_t *str) {\n    int in_word = 0;\n    int word_count = 0;\n\n    while (*str) {\n        if (iswspace(*str)) {\n            in_word = 0;\n        } else if (!in_word) {\n            in_word = 1;\n            word_count++;\n        }\n        str++;\n    }\n\n    return word_count;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *text = L\"  Hello,\\tWorld!  How\\nare\\ryou?  \";\n    int words = count_words(text);\n    wprintf(L\"The text contains %d words:\\n%ls\\n\", words, text);\n    return 0;\n}",
            "explanation": "This example uses iswspace to implement a simple word counting function for wide strings.",
            "expectedOutput": "The text contains 4 words:\\n  Hello,\\tWorld!  How\\nare\\ryou?  "
          },
          {
            "title": "Trim Whitespace",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nwchar_t *trim(wchar_t *str) {\n    wchar_t *end;\n\n    // Trim leading space\n    while(iswspace(*str)) str++;\n\n    if(*str == 0)  // All spaces?\n        return str;\n\n    // Trim trailing space\n    end = str + wcslen(str) - 1;\n    while(end > str && iswspace(*end)) end--;\n\n    // Write new null terminator character\n    end[1] = '\\0';\n\n    return str;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t text[] = L\"  \\t  Hello, World!   \\n\";\n    wprintf(L\"Before: '%ls'\\n\", text);\n    wprintf(L\"After:  '%ls'\\n\", trim(text));\n    return 0;\n}",
            "explanation": "This example demonstrates using iswspace to trim leading and trailing whitespace from a wide string.",
            "expectedOutput": "Before: '  \\t  Hello, World!   \\n'\\nAfter:  'Hello, World!'"
          }
        ]
      },
      {
        "function_name": "iswupper",
        "include_file": "wctype.h",
        "return_type": "int",
        "parameter_types": ["wint_t"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Wide Character Classification",
        "data_type_manipulated": "wide characters",
        "description": "Checks whether the wide character is uppercase.",
        "extended_description": "The iswupper function tests whether wc is a wide character code representing an uppercase letter. The exact set of characters for which iswupper returns true is locale-dependent.",
        "return_value": "Returns non-zero if the wide character is an uppercase letter, 0 otherwise.",
        "parameter_values": "This function takes one parameter: wc (the wide character to be checked, represented as wint_t).",
        "function_prototype": "int iswupper(wint_t wc);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wint_t test[] = {L'A', L'a', L'5', L'Z', L'Ω', L'α'};\n    for (int i = 0; i < sizeof(test)/sizeof(wint_t); i++) {\n        if (iswupper(test[i])) {\n            wprintf(L\"'%lc' (U+%04X) is uppercase\\n\", test[i], (unsigned int)test[i]);\n        } else {\n            wprintf(L\"'%lc' (U+%04X) is not uppercase\\n\", test[i], (unsigned int)test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of iswupper with various wide characters, including non-ASCII letters.",
            "expectedOutput": "'A' (U+0041) is uppercase\\n'a' (U+0061) is not uppercase\\n'5' (U+0035) is not uppercase\\n'Z' (U+005A) is uppercase\\n'Ω' (U+03A9) is uppercase\\n'α' (U+03B1) is not uppercase"
          },
          {
            "title": "Uppercase Count",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint count_uppercase(const wchar_t *str) {\n    int count = 0;\n    while (*str) {\n        if (iswupper(*str)) {\n            count++;\n        }\n        str++;\n    }\n    return count;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *text = L\"Hello, WORLD! αβγ ΑΒΓ\";\n    int uppercase_count = count_uppercase(text);\n    wprintf(L\"The text \\\"%ls\\\" contains %d uppercase letters.\\n\", text, uppercase_count);\n    return 0;\n}",
            "explanation": "This example uses iswupper to count the number of uppercase letters in a wide string, including non-ASCII characters.",
            "expectedOutput": "The text \"Hello, WORLD! αβγ ΑΒΓ\" contains 8 uppercase letters."
          },
          {
            "title": "Uppercase to Lowercase",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nvoid to_lowercase(wchar_t *str) {\n    while (*str) {\n        if (iswupper(*str)) {\n            *str = towlower(*str);\n        }\n        str++;\n    }\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t text[] = L\"HELLO, World! ΑΒΓ 123\";\n    wprintf(L\"Original: %ls\\n\", text);\n    to_lowercase(text);\n    wprintf(L\"Lowercase: %ls\\n\", text);\n    return 0;\n}",
            "explanation": "This example demonstrates using iswupper in conjunction with towlower to convert all uppercase letters to lowercase in a wide string.",
            "expectedOutput": "Original: HELLO, World! ΑΒΓ 123\\nLowercase: hello, world! αβγ 123"
          }
        ]
      },
      {
        "function_name": "iswxdigit",
        "include_file": "wctype.h",
        "return_type": "int",
        "parameter_types": ["wint_t"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Wide Character Classification",
        "data_type_manipulated": "wide characters",
        "description": "Checks whether the wide character is a hexadecimal digit.",
        "extended_description": "The iswxdigit function tests whether wc is a wide character code representing a hexadecimal digit. This typically includes the characters 0-9, a-f, and A-F.",
        "return_value": "Returns non-zero if the wide character is a hexadecimal digit, 0 otherwise.",
        "parameter_values": "This function takes one parameter: wc (the wide character to be checked, represented as wint_t).",
        "function_prototype": "int iswxdigit(wint_t wc);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wint_t test[] = {L'0', L'A', L'f', L'G', L'9', L'z'};\n    for (int i = 0; i < sizeof(test)/sizeof(wint_t); i++) {\n        if (iswxdigit(test[i])) {\n            wprintf(L\"'%lc' is a hexadecimal digit\\n\", test[i]);\n        } else {\n            wprintf(L\"'%lc' is not a hexadecimal digit\\n\", test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of iswxdigit with various wide characters.",
            "expectedOutput": "'0' is a hexadecimal digit\\n'A' is a hexadecimal digit\\n'f' is a hexadecimal digit\\n'G' is not a hexadecimal digit\\n'9' is a hexadecimal digit\\n'z' is not a hexadecimal digit"
          },
          {
            "title": "Hex String Validation",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint is_hex_string(const wchar_t *str) {\n    if (str[0] == L'0' && (str[1] == L'x' || str[1] == L'X')) {\n        str += 2;\n    }\n    while (*str) {\n        if (!iswxdigit(*str)) {\n            return 0;\n        }\n        str++;\n    }\n    return 1;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *tests[] = {L\"0x1A3F\", L\"FFFF\", L\"0xG4\", L\"123ABC\"};\n    for (int i = 0; i < sizeof(tests)/sizeof(wchar_t*); i++) {\n        if (is_hex_string(tests[i])) {\n            wprintf(L\"\\\"%ls\\\" is a valid hexadecimal string\\n\", tests[i]);\n        } else {\n            wprintf(L\"\\\"%ls\\\" is not a valid hexadecimal string\\n\", tests[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example uses iswxdigit to validate whether a wide string represents a valid hexadecimal number.",
            "expectedOutput": "\"0x1A3F\" is a valid hexadecimal string\\n\"FFFF\" is a valid hexadecimal string\\n\"0xG4\" is not a valid hexadecimal string\\n\"123ABC\" is a valid hexadecimal string"
          },
          {
            "title": "Hex to Decimal Conversion",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nunsigned long hex_to_dec(const wchar_t *hex) {\n    unsigned long result = 0;\n    while (*hex) {\n        if (iswxdigit(*hex)) {\n            result = result * 16 + (iswdigit(*hex) ? *hex - L'0' : \n                                    towupper(*hex) - L'A' + 10);\n        } else {\n            return 0;  // Invalid character\n        }\n        hex++;\n    }\n    return result;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *hex_numbers[] = {L\"1A\", L\"FF\", L\"100\", L\"FFFF\"};\n    for (int i = 0; i < sizeof(hex_numbers)/sizeof(wchar_t*); i++) {\n        unsigned long dec = hex_to_dec(hex_numbers[i]);\n        wprintf(L\"Hex: %ls, Decimal: %lu\\n\", hex_numbers[i], dec);\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates using iswxdigit in a function that converts hexadecimal wide strings to decimal numbers.",
            "expectedOutput": "Hex: 1A, Decimal: 26\\nHex: FF, Decimal: 255\\nHex: 100, Decimal: 256\\nHex: FFFF, Decimal: 65535"
          }
        ]
      },
      {
        "function_name": "isxdigit",
        "include_file": "ctype.h",
        "return_type": "int",
        "parameter_types": ["int"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Character Classification",
        "data_type_manipulated": "characters",
        "description": "Checks whether the character is a hexadecimal digit.",
        "extended_description": "The isxdigit function tests whether c is a hexadecimal digit character (0-9, a-f, A-F). This function is locale-independent.",
        "return_value": "Returns non-zero if the character is a hexadecimal digit, 0 otherwise.",
        "parameter_values": "This function takes one parameter: c (the character to be checked, represented as an int).",
        "function_prototype": "int isxdigit(int c);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char test[] = {'0', 'A', 'f', 'G', '9', 'z'};\n    for (int i = 0; i < sizeof(test); i++) {\n        if (isxdigit(test[i])) {\n            printf(\"'%c' is a hexadecimal digit\\n\", test[i]);\n        } else {\n            printf(\"'%c' is not a hexadecimal digit\\n\", test[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of isxdigit with various characters.",
            "expectedOutput": "'0' is a hexadecimal digit\\n'A' is a hexadecimal digit\\n'f' is a hexadecimal digit\\n'G' is not a hexadecimal digit\\n'9' is a hexadecimal digit\\n'z' is not a hexadecimal digit"
          },
          {
            "title": "Hex String Validation",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint is_hex_string(const char *str) {\n    if (str[0] == '0' && (str[1] == 'x' || str[1] == 'X')) {\n        str += 2;\n    }\n    while (*str) {\n        if (!isxdigit((unsigned char)*str)) {\n            return 0;\n        }\n        str++;\n    }\n    return 1;\n}\n\nint main() {\n    const char *tests[] = {\"0x1A3F\", \"FFFF\", \"0xG4\", \"123ABC\"};\n    for (int i = 0; i < sizeof(tests)/sizeof(char*); i++) {\n        if (is_hex_string(tests[i])) {\n            printf(\"\\\"%s\\\" is a valid hexadecimal string\\n\", tests[i]);\n        } else {\n            printf(\"\\\"%s\\\" is not a valid hexadecimal string\\n\", tests[i]);\n        }\n    }\n    return 0;\n}",
            "explanation": "This example uses isxdigit to validate whether a string represents a valid hexadecimal number.",
            "expectedOutput": "\"0x1A3F\" is a valid hexadecimal string\\n\"FFFF\" is a valid hexadecimal string\\n\"0xG4\" is not a valid hexadecimal string\\n\"123ABC\" is a valid hexadecimal string"
          },
          {
            "title": "Hex to Decimal Conversion",
            "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nunsigned long hex_to_dec(const char *hex) {\n    unsigned long result = 0;\n    while (*hex) {\n        if (isxdigit((unsigned char)*hex)) {\n            result = result * 16 + (isdigit(*hex) ? *hex - '0' : \n                                    toupper(*hex) - 'A' + 10);\n        } else {\n            return 0;  // Invalid character\n        }\n        hex++;\n    }\n    return result;\n}\n\nint main() {\n    const char *hex_numbers[] = {\"1A\", \"FF\", \"100\", \"FFFF\"};\n    for (int i = 0; i < sizeof(hex_numbers)/sizeof(char*); i++) {\n        unsigned long dec = hex_to_dec(hex_numbers[i]);\n        printf(\"Hex: %s, Decimal: %lu\\n\", hex_numbers[i], dec);\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates using isxdigit in a function that converts hexadecimal strings to decimal numbers.",
            "expectedOutput": "Hex: 1A, Decimal: 26\\nHex: FF, Decimal: 255\\nHex: 100, Decimal: 256\\nHex: FFFF, Decimal: 65535"
          }
        ]
      },
      {
        "function_name": "j0",
        "include_file": "math.h",
        "return_type": "double",
        "parameter_types": ["double"],
        "main_category": "Mathematical Operations",
        "sub_category": "Advanced Computation",
        "data_type_manipulated": "floating-point numbers",
        "description": "Computes the Bessel function of the first kind of order 0.",
        "extended_description": "The j0 function computes the Bessel function of the first kind of order 0 for the input x. Bessel functions are solutions to Bessel's differential equation and are important in many areas of physics and engineering.",
        "return_value": "Returns the Bessel function of the first kind of order 0 for x.",
        "parameter_values": "This function takes one parameter: x (the value for which to compute the Bessel function).",
        "function_prototype": "double j0(double x);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = 1.0;\n    double result = j0(x);\n    printf(\"J0(%f) = %f\\n\", x, result);\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of j0 function for a single value.",
            "expectedOutput": "J0(1.000000) = 0.765198"
          },
          {
            "title": "Multiple Values",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double values[] = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0};\n    int n = sizeof(values) / sizeof(values[0]);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"J0(%f) = %f\\n\", values[i], j0(values[i]));\n    }\n    return 0;\n}",
            "explanation": "This example computes J0 for multiple values to show how the function behaves across different inputs.",
            "expectedOutput": "J0(0.000000) = 1.000000\\nJ0(1.000000) = 0.765198\\nJ0(2.000000) = 0.223891\\nJ0(3.000000) = -0.260052\\nJ0(4.000000) = -0.397149\\nJ0(5.000000) = -0.177597"
          },
          {
            "title": "Plotting J0",
            "code": "#include <stdio.h>\n#include <math.h>\n\n#define PLOT_WIDTH 60\n#define PLOT_HEIGHT 20\n\nvoid plot(double start, double end, int points) {\n    char plot[PLOT_HEIGHT][PLOT_WIDTH] = {{0}};\n    double step = (end - start) / (points - 1);\n    double max_y = 0, min_y = 0;\n    \n    // Find max and min y values\n    for (int i = 0; i < points; i++) {\n        double x = start + i * step;\n        double y = j0(x);\n        if (y > max_y) max_y = y;\n        if (y < min_y) min_y = y;\n    }\n    \n    // Plot the function\n    for (int i = 0; i < points; i++) {\n        double x = start + i * step;\n        double y = j0(x);\n        int plot_y = (int)((y - min_y) / (max_y - min_y) * (PLOT_HEIGHT - 1));\n        plot[PLOT_HEIGHT - 1 - plot_y][i] = '*';\n    }\n    \n    // Print the plot\n    for (int i = 0; i < PLOT_HEIGHT; i++) {\n        for (int j = 0; j < PLOT_WIDTH; j++) {\n            putchar(plot[i][j] ? '*' : ' ');\n        }\n        putchar('\\n');\n    }\n}\n\nint main() {\n    printf(\"Plot of J0(x) from 0 to 20:\\n\");\n    plot(0, 20, PLOT_WIDTH);\n    return 0;\n}",
            "explanation": "This example creates a simple ASCII plot of the J0 function to visualize its behavior over a range of values.",
            "expectedOutput": "Plot of J0(x) from 0 to 20:\\n[ASCII plot of J0 function]"
          }
        ]
      },
      {
        "function_name": "j1",
        "include_file": "math.h",
        "return_type": "double",
        "parameter_types": ["double"],
        "main_category": "Mathematical Operations",
        "sub_category": "Advanced Computation",
        "data_type_manipulated": "floating-point numbers",
        "description": "Computes the Bessel function of the first kind of order 1.",
        "extended_description": "The j1 function computes the Bessel function of the first kind of order 1 for the input x. Bessel functions are solutions to Bessel's differential equation and are important in many areas of physics and engineering.",
        "return_value": "Returns the Bessel function of the first kind of order 1 for x.",
        "parameter_values": "This function takes one parameter: x (the value for which to compute the Bessel function).",
        "function_prototype": "double j1(double x);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = 1.0;\n    double result = j1(x);\n    printf(\"J1(%f) = %f\\n\", x, result);\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of j1 function for a single value.",
            "expectedOutput": "J1(1.000000) = 0.440051"
          },
          {
            "title": "Multiple Values",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double values[] = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0};\n    int n = sizeof(values) / sizeof(values[0]);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"J1(%f) = %f\\n\", values[i], j1(values[i]));\n    }\n    return 0;\n}",
            "explanation": "This example computes J1 for multiple values to show how the function behaves across different inputs.",
            "expectedOutput": "J1(0.000000) = 0.000000\\nJ1(1.000000) = 0.440051\\nJ1(2.000000) = 0.576725\\nJ1(3.000000) = 0.339059\\nJ1(4.000000) = -0.066043\\nJ1(5.000000) = -0.327579"
          },
          {
            "title": "Comparing J0 and J1",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    printf(\"   x      J0(x)      J1(x)\\n\");\n    printf(\"-----------------------------\\n\");\n    for (double x = 0.0; x <= 5.0; x += 0.5) {\n        printf(\"%5.1f   %8.5f   %8.5f\\n\", x, j0(x), j1(x));\n    }\n    return 0;\n}",
            "explanation": "This example compares the values of J0 and J1 over a range of inputs, showing how these two related functions behave.",
            "expectedOutput": "   x      J0(x)      J1(x)\\n-----------------------------\\n  0.0    1.00000    0.00000\\n  0.5    0.93847    0.24227\\n  1.0    0.76520    0.44005\\n  1.5    0.51183    0.55793\\n  2.0    0.22389    0.57672\\n  2.5   -0.04838    0.49709\\n  3.0   -0.26005    0.33906\\n  3.5   -0.38050    0.13290\\n  4.0   -0.39715   -0.06604\\n  4.5   -0.32242   -0.23178\\n  5.0   -0.17760   -0.32758"
          }
        ]
      },
      {
        "function_name": "jn",
        "include_file": "math.h",
        "return_type": "double",
        "parameter_types": ["int", "double"],
        "main_category": "Mathematical Operations",
        "sub_category": "Advanced Computation",
        "data_type_manipulated": "floating-point numbers",
        "description": "Computes the Bessel function of the first kind of order n.",
        "extended_description": "The jn function computes the Bessel function of the first kind of order n for the input x. Bessel functions are solutions to Bessel's differential equation and are important in many areas of physics and engineering. This function allows for computing Bessel functions of any integer order.",
        "return_value": "Returns the Bessel function of the first kind of order n for x.",
        "parameter_values": "This function takes two parameters: n (the order of the Bessel function, an integer) and x (the value for which to compute the Bessel function, a double).",
        "function_prototype": "double jn(int n, double x);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n = 2;\n    double x = 1.0;\n    double result = jn(n, x);\n    printf(\"J%d(%f) = %f\\n\", n, x, result);\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of jn function for a single value and order.",
            "expectedOutput": "J2(1.000000) = 0.114903"
          },
          {
            "title": "Multiple Orders",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = 2.0;\n    for (int n = 0; n <= 5; n++) {\n        printf(\"J%d(%f) = %f\\n\", n, x, jn(n, x));\n    }\n    return 0;\n}",
            "explanation": "This example computes Bessel functions of different orders for a fixed x value.",
            "expectedOutput": "J0(2.000000) = 0.223891\nJ1(2.000000) = 0.576725\nJ2(2.000000) = 0.352834\nJ3(2.000000) = 0.128943\nJ4(2.000000) = 0.034026\nJ5(2.000000) = 0.007039"
          },
          {
            "title": "Comparing Different x Values",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n = 3;\n    printf(\"   x      J%d(x)\\n\", n);\n    printf(\"----------------\\n\");\n    for (double x = 0.0; x <= 5.0; x += 0.5) {\n        printf(\"%5.1f   %8.5f\\n\", x, jn(n, x));\n    }\n    return 0;\n}",
            "explanation": "This example shows how the Bessel function of a specific order (n=3) behaves for different x values.",
            "expectedOutput": "   x      J3(x)\n----------------\n  0.0   0.00000\n  0.5   0.00620\n  1.0   0.01960\n  1.5   0.04162\n  2.0   0.12894\n  2.5   0.21656\n  3.0   0.33906\n  3.5   0.45862\n  4.0   0.43017\n  4.5   0.38642\n  5.0   0.36483"
          }
        ]
      },
      {
        "function_name": "labs",
        "include_file": "stdlib.h",
        "return_type": "long",
        "parameter_types": ["long"],
        "main_category": "Mathematical Operations",
        "sub_category": "Basic Computation",
        "data_type_manipulated": "integers",
        "description": "Computes the absolute value of a long integer.",
        "extended_description": "The labs function computes the absolute value of a long integer. It returns the magnitude of the input value without regard to its sign.",
        "return_value": "Returns the absolute value of the long integer argument.",
        "parameter_values": "This function takes one parameter: n (the long integer value for which to compute the absolute value).",
        "function_prototype": "long int labs(long int n);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    long int n = -12345L;\n    long int result = labs(n);\n    printf(\"The absolute value of %ld is %ld\\n\", n, result);\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of labs function for a negative long integer.",
            "expectedOutput": "The absolute value of -12345 is 12345"
          },
          {
            "title": "Compare with abs",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int i = -42;\n    long int l = -42L;\n    \n    printf(\"abs(%d) = %d\\n\", i, abs(i));\n    printf(\"labs(%ld) = %ld\\n\", l, labs(l));\n    \n    return 0;\n}",
            "explanation": "This example compares the usage of abs (for int) and labs (for long int).",
            "expectedOutput": "abs(-42) = 42\nlabs(-42) = 42"
          },
          {
            "title": "Overflow Handling",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint main() {\n    long int min_long = LONG_MIN;\n    long int abs_min_long = labs(min_long);\n    \n    printf(\"LONG_MIN: %ld\\n\", min_long);\n    printf(\"labs(LONG_MIN): %ld\\n\", abs_min_long);\n    \n    if (abs_min_long == min_long) {\n        printf(\"Warning: Overflow occurred!\\n\");\n    }\n    \n    return 0;\n}",
            "explanation": "This example demonstrates the behavior of labs with the minimum long integer value, which can lead to overflow on some systems.",
            "expectedOutput": "LONG_MIN: -9223372036854775808\nlabs(LONG_MIN): -9223372036854775808\nWarning: Overflow occurred!"
          }
        ]
      },
      {
        "function_name": "ldexp",
        "include_file": "math.h",
        "return_type": "double",
        "parameter_types": ["double", "int"],
        "main_category": "Mathematical Operations",
        "sub_category": "Advanced Computation",
        "data_type_manipulated": "floating-point numbers",
        "description": "Multiplies a floating-point number by an integral power of 2.",
        "extended_description": "The ldexp function multiplies a floating-point number x by 2 raised to the power of exp. It's equivalent to x * 2^exp, but is often more efficient and accurate. This function is useful in manipulating the exponent part of a floating-point number.",
        "return_value": "Returns x * 2^exp.",
        "parameter_values": "This function takes two parameters: x (the floating-point number to be multiplied) and exp (the integer exponent of 2).",
        "function_prototype": "double ldexp(double x, int exp);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = 1.5;\n    int exp = 3;\n    double result = ldexp(x, exp);\n    printf(\"%f * 2^%d = %f\\n\", x, exp, result);\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of ldexp function to multiply a number by 2^3.",
            "expectedOutput": "1.500000 * 2^3 = 12.000000"
          },
          {
            "title": "Negative Exponent",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = 10.0;\n    int exp = -2;\n    double result = ldexp(x, exp);\n    printf(\"%f * 2^%d = %f\\n\", x, exp, result);\n    return 0;\n}",
            "explanation": "This example shows how ldexp handles negative exponents, effectively dividing by powers of 2.",
            "expectedOutput": "10.000000 * 2^-2 = 2.500000"
          },
          {
            "title": "Comparison with Manual Calculation",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = 3.14;\n    int exp = 5;\n    \n    double result_ldexp = ldexp(x, exp);\n    double result_manual = x * pow(2, exp);\n    \n    printf(\"ldexp(%f, %d) = %.15f\\n\", x, exp, result_ldexp);\n    printf(\"Manual: %f * 2^%d = %.15f\\n\", x, exp, result_manual);\n    printf(\"Difference: %.15f\\n\", fabs(result_ldexp - result_manual));\n    \n    return 0;\n}",
            "explanation": "This example compares the result of ldexp with a manual calculation using pow, demonstrating the potential difference in precision.",
            "expectedOutput": "ldexp(3.140000, 5) = 100.480000000000000\nManual: 3.140000 * 2^5 = 100.480000000000004\nDifference: 0.000000000000004"
          }
        ]
      },
      {
        "function_name": "ldiv",
        "include_file": "stdlib.h",
        "return_type": "ldiv_t",
        "parameter_types": ["long", "long"],
        "main_category": "Mathematical Operations",
        "sub_category": "Basic Computation",
        "data_type_manipulated": "integers",
        "description": "Divides two long integers and returns the quotient and remainder.",
        "extended_description": "The ldiv function computes the quotient and remainder of the division of the numerator numer by the denominator denom. The result is returned as a structure of type ldiv_t, which contains two long int members named quot (the quotient) and rem (the remainder).",
        "return_value": "Returns a structure of type ldiv_t containing the quotient and remainder.",
        "parameter_values": "This function takes two parameters: numer (the numerator, a long int) and denom (the denominator, a long int).",
        "function_prototype": "ldiv_t ldiv(long int numer, long int denom);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    long int numer = 20L;\n    long int denom = 3L;\n    ldiv_t result = ldiv(numer, denom);\n    printf(\"%ld divided by %ld is %ld with a remainder of %ld\\n\",\n           numer, denom, result.quot, result.rem);\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of ldiv function to divide two long integers.",
            "expectedOutput": "20 divided by 3 is 6 with a remainder of 2"
          },
          {
            "title": "Negative Numbers",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    long int numer = -20L;\n    long int denom = 3L;\n    ldiv_t result = ldiv(numer, denom);\n    printf(\"%ld divided by %ld:\\n\", numer, denom);\n    printf(\"Quotient: %ld\\n\", result.quot);\n    printf(\"Remainder: %ld\\n\", result.rem);\n    return 0;\n}",
            "explanation": "This example shows how ldiv handles negative numbers in division.",
            "expectedOutput": "-20 divided by 3:\nQuotient: -6\nRemainder: -2"
          },
          {
            "title": "Compare with Manual Division",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    long int numer = 1000000000L;\n    long int denom = 3L;\n    \n    ldiv_t result = ldiv(numer, denom);\n    \n    long int manual_quot = numer / denom;\n    long int manual_rem = numer % denom;\n    \n    printf(\"Using ldiv:\\n\");\n    printf(\"Quotient: %ld, Remainder: %ld\\n\\n\", result.quot, result.rem);\n    \n    printf(\"Using manual division:\\n\");\n    printf(\"Quotient: %ld, Remainder: %ld\\n\", manual_quot, manual_rem);\n    \n    return 0;\n}",
            "explanation": "This example compares the result of ldiv with manual division and modulo operations, demonstrating that ldiv can be more efficient for large numbers.",
            "expectedOutput": "Using ldiv:\nQuotient: 333333333, Remainder: 1\n\nUsing manual division:\nQuotient: 333333333, Remainder: 1"
          }
        ]
      },
      {
        "function_name": "localeconv",
        "include_file": "locale.h",
        "return_type": "struct lconv*",
        "parameter_types": [],
        "main_category": "System Interaction",
        "sub_category": "Localization Support",
        "data_type_manipulated": "locale settings",
        "description": "Returns a pointer to the current locale's formatting settings.",
        "extended_description": "The localeconv function returns a pointer to a structure of type lconv with the numeric and monetary formatting conventions of the current locale. This structure contains various members that define the rules for formatting numeric and monetary values according to the locale-specific settings.",
        "return_value": "Returns a pointer to a static lconv structure containing the locale's formatting settings.",
        "parameter_values": "This function takes no parameters.",
        "function_prototype": "struct lconv *localeconv(void);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"en_US.UTF-8\");\n    struct lconv *lc = localeconv();\n    printf(\"Decimal point: %s\\n\", lc->decimal_point);\n    printf(\"Thousands separator: %s\\n\", lc->thousands_sep);\n    printf(\"Currency symbol: %s\\n\", lc->currency_symbol);\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of localeconv to get formatting information for the US locale.",
            "expectedOutput": "Decimal point: .\nThousands separator: ,\nCurrency symbol: $"
          },
          {
            "title": "Different Locales",
            "code": "#include <stdio.h>\n#include <locale.h>\n\nvoid print_locale_info(const char* locale_name) {\n    if (setlocale(LC_ALL, locale_name) == NULL) {\n        printf(\"Failed to set locale: %s\\n\", locale_name);\n        return;\n    }\n    struct lconv *lc = localeconv();\n    printf(\"Locale: %s\\n\", locale_name);\n    printf(\"Decimal point: %s\\n\", lc->decimal_point);\n    printf(\"Thousands separator: %s\\n\", lc->thousands_sep);\n    printf(\"Currency symbol: %s\\n\\n\", lc->currency_symbol);\n}\n\nint main() {\n    print_locale_info(\"en_US.UTF-8\");\n    print_locale_info(\"de_DE.UTF-8\");\n    print_locale_info(\"fr_FR.UTF-8\");\n    return 0;\n}",
            "explanation": "This example shows how localeconv returns different information for various locales.",
            "expectedOutput": "Locale: en_US.UTF-8\nDecimal point: .\nThousands separator: ,\nCurrency symbol: $\n\nLocale: de_DE.UTF-8\nDecimal point: ,\nThousands separator: .\nCurrency symbol: €\n\nLocale: fr_FR.UTF-8\nDecimal point: ,\nThousands separator:  \nCurrency symbol: €\n"
          },
          {
            "title": "Formatting Numbers",
            "code": "#include <stdio.h>\n#include <locale.h>\n#include <string.h>\n\nvoid format_number(double number, const char* locale_name) {\n    char formatted[50];\n    setlocale(LC_ALL, locale_name);\n    struct lconv *lc = localeconv();\n    \n    snprintf(formatted, sizeof(formatted), \"%'.2f\", number);\n    \n    // Replace default separators with locale-specific ones\n    char *decimal = strchr(formatted, '.');\n    if (decimal) *decimal = *lc->decimal_point;\n    \n    printf(\"Locale: %s\\n\", locale_name);\n    printf(\"Formatted number: %s %s\\n\\n\", formatted, lc->currency_symbol);\n}\n\nint main() {\n    double number = 1234567.89;\n    format_number(number, \"en_US.UTF-8\");\n    format_number(number, \"de_DE.UTF-8\");\n    format_number(number, \"fr_FR.UTF-8\");\n    return 0;\n}",
            "explanation": "This example uses localeconv to format a number according to different locale settings.",
            "expectedOutput": "Locale: en_US.UTF-8\nFormatted number: 1,234,567.89 $\n\nLocale: de_DE.UTF-8\nFormatted number: 1.234.567,89 €\n\nLocale: fr_FR.UTF-8\nFormatted number: 1 234 567,89 €\n"
          }
        ]
      },
      {
        "function_name": "localtime",
        "include_file": "time.h",
        "return_type": "struct tm*",
        "parameter_types": ["const time_t*"],
        "main_category": "Time and Date Management",
        "sub_category": "Time Conversion",
        "data_type_manipulated": "time structures",
        "description": "Converts calendar time to local time.",
        "extended_description": "The localtime function converts the calendar time pointed to by timer into a broken-down time representation, expressed as local time (as opposed to UTC). The result is stored in a statically allocated structure which may be overwritten by subsequent calls to any of the date and time functions.",
        "return_value": "Returns a pointer to a struct tm representing the broken-down time, or a null pointer if the specified time cannot be converted to local time.",
        "parameter_values": "This function takes one parameter: timer (pointer to a time_t object representing calendar time).",
        "function_prototype": "struct tm *localtime(const time_t *timer);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    time_t current_time;\n    struct tm *time_info;\n    \n    time(&current_time);\n    time_info = localtime(&current_time);\n    \n    printf(\"Current local time: %s\", asctime(time_info));\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of localtime to get the current local time.",
            "expectedOutput": "Current local time: [Day] [Month] [Date] [Time] [Year]"
          },
          {
            "title": "Formatted Output",
            "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    time_t current_time;\n    struct tm *time_info;\n    char time_string[50];\n    \n    time(&current_time);\n    time_info = localtime(&current_time);\n    \n    strftime(time_string, sizeof(time_string), \"%Y-%m-%d %H:%M:%S\", time_info);\n    printf(\"Formatted local time: %s\\n\", time_string);\n    \n    return 0;\n}",
            "explanation": "This example uses localtime with strftime to create a formatted time string.",
            "expectedOutput": "Formatted local time: YYYY-MM-DD HH:MM:SS"
          },
          {
            "title": "Time Components",
            "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    time_t current_time;\n    struct tm *time_info;\n    \n    time(&current_time);\n    time_info = localtime(&current_time);\n    \n    printf(\"Year: %d\\n\", time_info->tm_year + 1900);\n    printf(\"Month: %d\\n\", time_info->tm_mon + 1);\n    printf(\"Day: %d\\n\", time_info->tm_mday);\n    printf(\"Hour: %d\\n\", time_info->tm_hour);\n    printf(\"Minute: %d\\n\", time_info->tm_min);\n    printf(\"Second: %d\\n\", time_info->tm_sec);\n    printf(\"Day of week: %d\\n\", time_info->tm_wday);\n    printf(\"Day of year: %d\\n\", time_info->tm_yday);\n    printf(\"Daylight Savings Time: %s\\n\", time_info->tm_isdst ? \"Yes\" : \"No\");\n    \n    return 0;\n}",
            "explanation": "This example shows how to access individual components of the time structure returned by localtime.",
            "expectedOutput": "Year: YYYY\nMonth: MM\nDay: DD\nHour: HH\nMinute: MM\nSecond: SS\nDay of week: D\nDay of year: DDD\nDaylight Savings Time: Yes/No"
          }
        ]
      },
      {
        "function_name": "localtime_r",
        "include_file": "time.h",
        "return_type": "struct tm*",
        "parameter_types": ["const time_t*", "struct tm*"],
        "main_category": "Time and Date Management",
        "sub_category": "Time Conversion",
        "data_type_manipulated": "time structures",
        "description": "Thread-safe version of localtime.",
        "extended_description": "The localtime_r function converts the calendar time pointed to by timer into a broken-down time representation, expressed as local time. The result is stored in the structure pointed to by result. This function is the reentrant version of localtime, making it safe for use in multi-threaded programs.",
        "return_value": "Returns a pointer to the resulting struct tm (which is the same as the result parameter), or NULL if the time cannot be represented.",
        "parameter_values": "This function takes two parameters: timer (pointer to a time_t object representing calendar time) and result (pointer to a struct tm where the result will be stored).",
        "function_prototype": "struct tm *localtime_r(const time_t *restrict timer, struct tm *restrict result);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    time_t current_time;\n    struct tm time_info;\n    \n    time(&current_time);\n    if (localtime_r(&current_time, &time_info) == NULL) {\n        fprintf(stderr, \"Error converting time\\n\");\n        return 1;\n    }\n    \n    printf(\"Current local time: %04d-%02d-%02d %02d:%02d:%02d\\n\",\n           time_info.tm_year + 1900, time_info.tm_mon + 1, time_info.tm_mday,\n           time_info.tm_hour, time_info.tm_min, time_info.tm_sec);\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of localtime_r to get the current local time in a thread-safe manner.",
            "expectedOutput": "Current local time: YYYY-MM-DD HH:MM:SS"
          },
          {
            "title": "Multiple Time Conversions",
            "code": "#include <stdio.h>\n#include <time.h>\n\nvoid print_time(const char* label, const struct tm* time_info) {\n    printf(\"%s: %04d-%02d-%02d %02d:%02d:%02d\\n\", label,\n           time_info->tm_year + 1900, time_info->tm_mon + 1, time_info->tm_mday,\n           time_info->tm_hour, time_info->tm_min, time_info->tm_sec);\n}\n\nint main() {\n    time_t times[] = {0, 1000000000, 2000000000};\n    struct tm time_info;\n    \n    for (int i = 0; i < 3; i++) {\n        if (localtime_r(&times[i], &time_info) == NULL) {\n            fprintf(stderr, \"Error converting time %ld\\n\", times[i]);\n            continue;\n        }\n        char label[20];\n        snprintf(label, sizeof(label), \"Time %d\", i + 1);\n        print_time(label, &time_info);\n    }\n    return 0;\n}",
            "explanation": "This example shows how localtime_r can be safely used in loops to convert multiple time values.",
            "expectedOutput": "Time 1: 1970-01-01 00:00:00\nTime 2: 2001-09-09 01:46:40\nTime 3: 2033-05-18 03:33:20"
          },
          {
            "title": "Error Handling",
            "code": "#include <stdio.h>\n#include <time.h>\n#include <errno.h>\n#include <string.h>\n\nint main() {\n    time_t invalid_time = -1; // An invalid time\n    struct tm time_info;\n    \n    if (localtime_r(&invalid_time, &time_info) == NULL) {\n        fprintf(stderr, \"Error converting time: %s\\n\", strerror(errno));\n    } else {\n        printf(\"Conversion succeeded unexpectedly\\n\");\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates error handling with localtime_r when given an invalid time value.",
            "expectedOutput": "Error converting time: [error message depending on the system]"
          }
        ]
      },
      {
        "function_name": "log",
        "include_file": "math.h",
        "return_type": "double",
        "parameter_types": ["double"],
        "main_category": "Mathematical Operations",
        "sub_category": "Advanced Computation",
        "data_type_manipulated": "floating-point numbers",
        "description": "Calculates the natural logarithm of the specified number.",
        "extended_description": "The log function computes the natural logarithm (base e) of x. If x is positive, the result is the natural logarithm of x. If x is zero or negative, a domain error occurs, and errno is set to EDOM.",
        "return_value": "Returns the natural logarithm of x. If x is positive infinity, positive infinity is returned. If x is 0, negative infinity is returned and errno is set to ERANGE. For negative x (including negative infinity), a domain error occurs, and errno is set to EDOM.",
        "parameter_values": "This function takes one parameter: x (the value whose logarithm is to be found).",
        "function_prototype": "double log(double x);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = 2.718281828; // Approximately e\n    double result = log(x);\n    printf(\"The natural logarithm of %f is %f\\n\", x, result);\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of log function to compute the natural logarithm of e.",
            "expectedOutput": "The natural logarithm of 2.718282 is 1.000000"
          },
          {
            "title": "Logarithmic Properties",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double a = 2.0, b = 3.0;\n    \n    printf(\"log(a * b) = %f\\n\", log(a * b));\n    printf(\"log(a) + log(b) = %f\\n\", log(a) + log(b));\n    \n    printf(\"log(a^b) = %f\\n\", log(pow(a, b)));\n    printf(\"b * log(a) = %f\\n\", b * log(a));\n    \n    return 0;\n}",
            "explanation": "This example demonstrates some logarithmic properties using the log function.",
            "expectedOutput": "log(a * b) = 1.791759\nlog(a) + log(b) = 1.791759\nlog(a^b) = 2.079442\nb * log(a) = 2.079442"
          },
          {
            "title": "Error Handling",
            "code": "#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n#include <string.h>\n\nvoid compute_log(double x) {\n    errno = 0;\n    double result = log(x);\n    if (errno == 0) {\n        printf(\"log(%f) = %f\\n\", x, result);\n    } else {\n        perror(\"Error computing logarithm\");\n    }\n}\n\nint main() {\n    compute_log(2.0);\n    compute_log(0.0);\n    compute_log(-1.0);\n    return 0;\n}",
            "explanation": "This example shows how to handle errors when computing logarithms of zero and negative numbers.",
            "expectedOutput": "log(2.000000) = 0.693147\nError computing logarithm: Numerical result out of range\nError computing logarithm: Numerical argument out of domain"
          }
        ]
      },
      {
        "function_name": "log10",
        "include_file": "math.h",
        "return_type": "double",
        "parameter_types": ["double"],
        "main_category": "Mathematical Operations",
        "sub_category": "Advanced Computation",
        "data_type_manipulated": "floating-point numbers",
        "description": "Calculates the base-10 logarithm of the specified number.",
        "extended_description": "The log10 function computes the common (base-10) logarithm of x. If x is positive, the result is the base-10 logarithm of x. If x is zero or negative, a domain error occurs, and errno is set to EDOM.",
        "return_value": "Returns the base-10 logarithm of x. If x is positive infinity, positive infinity is returned. If x is 0, negative infinity is returned and errno is set to ERANGE. For negative x (including negative infinity), a domain error occurs, and errno is set to EDOM.",
        "parameter_values": "This function takes one parameter: x (the value whose base-10 logarithm is to be found).",
        "function_prototype": "double log10(double x);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = 100.0;\n    double result = log10(x);\n    printf(\"The base-10 logarithm of %f is %f\\n\", x, result);\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of log10 function to compute the base-10 logarithm of 100.",
            "expectedOutput": "The base-10 logarithm of 100.000000 is 2.000000"
          },
          {
            "title": "Logarithm Properties",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double a = 2.0, b = 1000.0;\n    \n    printf(\"log10(a * b) = %f\\n\", log10(a * b));\n    printf(\"log10(a) + log10(b) = %f\\n\", log10(a) + log10(b));\n    \n    printf(\"log10(10^n) = %f\\n\", log10(pow(10, 5)));\n    \n    return 0;\n}",
            "explanation": "This example demonstrates some properties of base-10 logarithms using the log10 function.",
            "expectedOutput": "log10(a * b) = 3.301030\nlog10(a) + log10(b) = 3.301030\nlog10(10^n) = 5.000000"
          },
          {
            "title": "pH Calculation",
            "code": "#include <stdio.h>\n#include <math.h>\n\ndouble calculate_pH(double h_concentration) {\n    return -log10(h_concentration);\n}\n\nint main() {\n    double h_concentrations[] = {1e-7, 1e-4, 1e-10};\n    int n = sizeof(h_concentrations) / sizeof(h_concentrations[0]);\n    \n    for (int i = 0; i < n; i++) {\n        double pH = calculate_pH(h_concentrations[i]);\n        printf(\"[H+] = %.2e, pH = %.2f\\n\", h_concentrations[i], pH);\n    }\n    \n    return 0;\n}",
            "explanation": "This example uses log10 to calculate pH values from hydrogen ion concentrations, demonstrating a practical application in chemistry.",
            "expectedOutput": "[H+] = 1.00e-07, pH = 7.00\n[H+] = 1.00e-04, pH = 4.00\n[H+] = 1.00e-10, pH = 10.00"
          }
        ]
      },
      {
        "function_name": "longjmp",
        "include_file": "setjmp.h",
        "return_type": "void",
        "parameter_types": ["jmp_buf", "int"],
        "main_category": "Error Handling and Debugging",
        "sub_category": "Program Control",
        "data_type_manipulated": "none",
        "description": "Restores the environment saved by setjmp with a specified return value.",
        "extended_description": "The longjmp function restores the environment saved by the most recent invocation of setjmp in the same invocation of the program, with the corresponding jmp_buf argument. If there has been no such invocation, or if the function containing the invocation of setjmp has already returned, the behavior is undefined. After longjmp is completed, program execution continues as if the corresponding invocation of setjmp had just returned the value specified by val.",
        "return_value": "This function does not return.",
        "parameter_values": "This function takes two parameters: env (a jmp_buf that holds the environment information) and val (an integer value to be returned to setjmp as if setjmp had returned normally).",
        "function_prototype": "void longjmp(jmp_buf env, int val);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <setjmp.h>\n\njmp_buf jump_buffer;\n\nvoid function_that_jumps() {\n    printf(\"About to jump\\n\");\n    longjmp(jump_buffer, 1);\n    printf(\"This will not be printed\\n\");\n}\n\nint main() {\n    int jump_val = setjmp(jump_buffer);\n    if (jump_val == 0) {\n        printf(\"First time through\\n\");\n        function_that_jumps();\n    } else {\n        printf(\"Jumped back with value %d\\n\", jump_val);\n    }\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of longjmp in conjunction with setjmp to perform a non-local jump.",
            "expectedOutput": "First time through\nAbout to jump\nJumped back with value 1"
          },
          {
            "title": "Error Handling",
            "code": "#include <stdio.h>\n#include <setjmp.h>\n#include <stdlib.h>\n\njmp_buf error_jump_buffer;\n\nvoid risky_function() {\n    int error_code = 2;\n    if (error_code != 0) {\n        printf(\"Error occurred in risky_function\\n\");\n        longjmp(error_jump_buffer, error_code);\n    }\n}\n\nint main() {\n    int error_code;\n    if ((error_code = setjmp(error_jump_buffer)) == 0) {\n        printf(\"Calling risky function\\n\");\n        risky_function();\n        printf(\"This won't be printed\\n\");\n    } else {\n        printf(\"Caught error: code %d\\n\", error_code);\n    }\n    return 0;\n}",
            "explanation": "This example shows how longjmp can be used for error handling to jump out of deeply nested function calls.",
            "expectedOutput": "Calling risky function\nError occurred in risky_function\nCaught error: code 2"
          },
          {
            "title": "Multiple Jumps",
            "code": "#include <stdio.h>\n#include <setjmp.h>\n\njmp_buf jump_buffers[3];\n\nvoid jump_function(int n) {\n    printf(\"In jump_function(%d)\\n\", n);\n    longjmp(jump_buffers[n], n+1);\n}\n\nint main() {\n    int i, val;\n    for (i = 0; i < 3; i++) {\n        val = setjmp(jump_buffers[i]);\n        if (val == 0) {\n            printf(\"setjmp(%d) called\\n\", i);\n        } else {\n            printf(\"Jumped to setjmp(%d) with value %d\\n\", i, val);\n        }\n    }\n    jump_function(0);\n    jump_function(1);\n    jump_function(2);\n    return 0;\n}",
            "explanation": "This example demonstrates using multiple setjmp/longjmp pairs to create different jump points in a program.",
            "expectedOutput": "setjmp(0) called\nsetjmp(1) called\nsetjmp(2) called\nIn jump_function(0)\nJumped to setjmp(0) with value 1\nIn jump_function(1)\nJumped to setjmp(1) with value 2\nIn jump_function(2)\nJumped to setjmp(2) with value 3"
          }
        ]
      },
      {
        "function_name": "malloc",
        "include_file": "stdlib.h",
        "return_type": "void*",
        "parameter_types": ["size_t"],
        "main_category": "Memory Management",
        "sub_category": "Allocation",
        "data_type_manipulated": "memory",
        "description": "Allocates a specified amount of memory and returns a pointer to it.",
        "extended_description": "The malloc function allocates size bytes of uninitialized storage. The allocated memory is not initialized; its contents are indeterminate and should not be assumed to be zero. If size is 0, the behavior is implementation-defined: either a null pointer is returned, or a unique pointer that can be passed to free() is returned.",
        "return_value": "Returns a pointer to the allocated memory, or NULL if the request fails.",
        "parameter_values": "This function takes one parameter: size (the number of bytes to allocate).",
        "function_prototype": "void *malloc(size_t size);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *ptr;\n    size_t size = 5 * sizeof(int);\n    \n    ptr = (int*) malloc(size);\n    if (ptr == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        return 1;\n    }\n    \n    for (int i = 0; i < 5; i++) {\n        ptr[i] = i * 10;\n    }\n    \n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", ptr[i]);\n    }\n    printf(\"\\n\");\n    \n    free(ptr);\n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of malloc to allocate memory for an array of integers.",
            "expectedOutput": "0 10 20 30 40"
          },
          {
            "title": "Allocating Structures",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char name[50];\n    int age;\n} Person;\n\nint main() {\n    Person *person = (Person*) malloc(sizeof(Person));\n    if (person == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        return 1;\n    }\n    \n    strcpy(person->name, \"John Doe\");\n    person->age = 30;\n    \n    printf(\"Name: %s, Age: %d\\n\", person->name, person->age);\n    \n    free(person);\n    return 0;\n}",
            "explanation": "This example shows how to use malloc to allocate memory for a structure.",
            "expectedOutput": "Name: John Doe, Age: 30"
          },
          {
            "title": "Error Handling and Reallocation",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *numbers = NULL;\n    int capacity = 5;\n    int size = 0;\n    \n    numbers = (int*) malloc(capacity * sizeof(int));\n    if (numbers == NULL) {\n        fprintf(stderr, \"Initial memory allocation failed\\n\");\n        return 1;\n    }\n    \n    while (1) {\n        int num;\n        printf(\"Enter a number (-1 to stop): \");\n        scanf(\"%d\", &num);\n        if (num == -1) break;\n        \n        if (size == capacity) {\n            capacity *= 2;\n            int *temp = (int*) realloc(numbers, capacity * sizeof(int));\n            if (temp == NULL) {\n                fprintf(stderr, \"Memory reallocation failed\\n\");\n                free(numbers);\n                return 1;\n            }\n            numbers = temp;\n        }\n        \n        numbers[size++] = num;\n    }\n    \n    printf(\"Numbers entered: \");\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", numbers[i]);\n    }\n    printf(\"\\n\");\n    \n    free(numbers);\n    return 0;\n}",
            "explanation": "This example demonstrates error handling with malloc and shows how to use realloc to resize allocated memory.",
            "expectedOutput": "Enter a number (-1 to stop): 10\nEnter a number (-1 to stop): 20\nEnter a number (-1 to stop): 30\nEnter a number (-1 to stop): -1\nNumbers entered: 10 20 30"
          }
        ]
      },
      {
        "function_name": "mblen",
        "include_file": "stdlib.h",
        "return_type": "int",
        "parameter_types": ["const char*", "size_t"],
        "main_category": "Character Type and Conversion",
        "sub_category": "Multibyte Character Handling",
        "data_type_manipulated": "bytes",
        "description": "Returns the number of bytes in the next multibyte character.",
        "extended_description": "The mblen function determines the number of bytes contained in the multibyte character pointed to by s, examining at most n bytes. If s is a null pointer, the mblen function resets the shift state to the initial shift state. The behavior of this function is affected by the LC_CTYPE category of the current locale.",
        "return_value": "If s is not a null pointer, the mblen function returns: 0 if s points to a null byte, the number of bytes that constitute the next multibyte character, or -1 if the next n bytes do not form a valid multibyte character. If s is a null pointer, the mblen function returns a nonzero value if multibyte character encodings have state-dependent encodings, and zero otherwise.",
        "parameter_values": "This function takes two parameters: s (pointer to the multibyte character) and n (maximum number of bytes to examine).",
        "function_prototype": "int mblen(const char *s, size_t n);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const char *str = \"Hello, 世界\";\n    int len;\n    \n    while (*str) {\n        len = mblen(str, MB_CUR_MAX);\n        if (len > 0) {\n            printf(\"Next %d byte(s): \", len);\n            for (int i = 0; i < len; i++) {\n                printf(\"%02X \", (unsigned char)str[i]);\n            }\n            printf(\"\\n\");\n            str += len;\n        } else if (len == 0) {\n            break;\n        } else {\n            printf(\"Invalid multibyte character\\n\");\n            break;\n        }\n    }\n    \n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of mblen to determine the length of each multibyte character in a string.",
            "expectedOutput": "Next 1 byte(s): 48\nNext 1 byte(s): 65\nNext 1 byte(s): 6C\nNext 1 byte(s): 6C\nNext 1 byte(s): 6F\nNext 1 byte(s): 2C\nNext 1 byte(s): 20\nNext 3 byte(s): E4 B8 96\nNext 3 byte(s): E7 95 8C"
          },
          {
            "title": "Handling Different Locales",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n#include <string.h>\n\nvoid print_char_info(const char *str, const char *locale) {\n    setlocale(LC_ALL, locale);\n    printf(\"Locale: %s\\n\", locale);\n    \n    int len = mblen(str, MB_CUR_MAX);\n    if (len > 0) {\n        printf(\"Character length: %d byte(s)\\n\", len);\n    } else if (len == 0) {\n        printf(\"Null character\\n\");\n    } else {\n        printf(\"Invalid multibyte character\\n\");\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    const char *str = \"界\";\n    \n    print_char_info(str, \"C\");\n    print_char_info(str, \"en_US.UTF-8\");\n    print_char_info(str, \"ja_JP.SJIS\");\n    \n    return 0;\n}",
            "explanation": "This example shows how mblen behaves differently in various locales.",
            "expectedOutput": "Locale: C\nInvalid multibyte character\n\nLocale: en_US.UTF-8\nCharacter length: 3 byte(s)\n\nLocale: ja_JP.SJIS\nInvalid multibyte character"
          },
          {
            "title": "Resetting Shift State",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const char *str = \"Hello, 世界\";\n    int state;\n    \n    // Reset shift state\n    state = mblen(NULL, 0);\n    printf(\"Initial state: %d\\n\", state);\n    \n    while (*str) {\n        int len = mblen(str, MB_CUR_MAX);\n        if (len > 0) {\n            printf(\"Character length: %d\\n\", len);\n            str += len;\n        } else if (len == 0) {\n            break;\n        } else {\n            printf(\"Invalid multibyte character\\n\");\n            break;\n        }\n    }\n    \n    // Check final state\n    state = mblen(NULL, 0);\n    printf(\"Final state: %d\\n\", state);\n    \n    return 0;\n}",
            "explanation": "This example demonstrates how to reset the shift state using mblen with a NULL pointer.",
            "expectedOutput": "Initial state: 0\nCharacter length: 1\nCharacter length: 1\nCharacter length: 1\nCharacter length: 1\nCharacter length: 1\nCharacter length: 1\nCharacter length: 1\nCharacter length: 3\nCharacter length: 3\nFinal state: 0"
          }
        ]
        },
        {
          "function_name": "mbrlen",
          "include_file": "wchar.h",
          "return_type": "size_t",
          "parameter_types": ["const char*", "size_t", "mbstate_t*"],
          "main_category": "Character Type and Conversion",
          "sub_category": "Multibyte Character Handling",
          "data_type_manipulated": "bytes",
          "description": "Determines the number of bytes in a multibyte character, given state.",
          "extended_description": "The mbrlen function determines the number of bytes constituting the next multibyte character in the string pointed to by s, examining at most n bytes. It uses the conversion state pointed to by ps, or an internal state if ps is NULL. This function is equivalent to mbrtowc(NULL, s, n, ps != NULL ? ps : &internal).",
          "return_value": "Returns: 0 if s points to a null character, the number of bytes that constitute the next multibyte character, (size_t)(-2) if the next n bytes contribute to an incomplete (but potentially valid) multibyte character, or (size_t)(-1) if an encoding error occurs.",
          "parameter_values": "This function takes three parameters: s (pointer to the multibyte character), n (maximum number of bytes to examine), and ps (pointer to a multibyte state, or NULL).",
          "function_prototype": "size_t mbrlen(const char *restrict s, size_t n, mbstate_t *restrict ps);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const char *str = \"Hello, 世界\";\n    mbstate_t state = {0};\n    size_t len;\n    \n    while (*str) {\n        len = mbrlen(str, MB_CUR_MAX, &state);\n        if (len == (size_t)(-1)) {\n            printf(\"Invalid multibyte sequence\\n\");\n            break;\n        } else if (len == (size_t)(-2)) {\n            printf(\"Incomplete multibyte sequence\\n\");\n            break;\n        } else {\n            printf(\"Next character length: %zu\\n\", len);\n            str += len;\n        }\n    }\n    \n    return 0;\n}",
              "explanation": "This example demonstrates basic usage of mbrlen to determine the length of each multibyte character in a string.",
              "expectedOutput": "Next character length: 1\nNext character length: 1\nNext character length: 1\nNext character length: 1\nNext character length: 1\nNext character length: 1\nNext character length: 1\nNext character length: 3\nNext character length: 3"
            },
            {
              "title": "Handling Incomplete Sequences",
              "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"en_US.UTF-8\");\n    \n    const char *str = \"A\\xE4\\xB8\";\n    mbstate_t state = {0};\n    size_t len;\n    \n    for (int i = 0; str[i] != '\\0'; i++) {\n        len = mbrlen(str + i, 1, &state);\n        if (len == (size_t)(-1)) {\n            printf(\"Byte %d: Invalid\\n\", i);\n        } else if (len == (size_t)(-2)) {\n            printf(\"Byte %d: Incomplete\\n\", i);\n        } else {\n            printf(\"Byte %d: Complete (length %zu)\\n\", i, len);\n        }\n    }\n    \n    return 0;\n}",
              "explanation": "This example shows how mbrlen handles incomplete multibyte sequences when processing one byte at a time.",
              "expectedOutput": "Byte 0: Complete (length 1)\nByte 1: Incomplete\nByte 2: Incomplete"
            },
            {
              "title": "Using Internal State",
              "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"en_US.UTF-8\");\n    \n    const char *str = \"A世B\";\n    size_t len;\n    \n    printf(\"Using internal state:\\n\");\n    for (int i = 0; str[i] != '\\0'; i++) {\n        len = mbrlen(str + i, 1, NULL);\n        printf(\"Byte %d: %zu\\n\", i, len);\n    }\n    \n    printf(\"\\nUsing explicit state:\\n\");\n    mbstate_t state = {0};\n    for (int i = 0; str[i] != '\\0'; i++) {\n        len = mbrlen(str + i, 1, &state);\n        printf(\"Byte %d: %zu\\n\", i, len);\n    }\n    \n    return 0;\n}",
              "explanation": "This example compares using mbrlen with an internal state (NULL pointer) versus an explicit state object.",
              "expectedOutput": "Using internal state:\nByte 0: 1\nByte 1: -2\nByte 2: -2\nByte 3: -2\nByte 4: 1\n\nUsing explicit state:\nByte 0: 1\nByte 1: -2\nByte 2: -2\nByte 3: 1\nByte 4: 1"
            }
          ]
        },
        {
          "function_name": "mbrtowc",
          "include_file": "wchar.h",
          "return_type": "size_t",
          "parameter_types": ["wchar_t*", "const char*", "size_t", "mbstate_t*"],
          "main_category": "Character Type and Conversion",
          "sub_category": "Multibyte to Wide Character Conversion",
          "data_type_manipulated": "wide characters",
          "description": "Converts a multibyte sequence to a wide character.",
          "extended_description": "The mbrtowc function converts a multibyte character to a wide character. It examines at most n bytes from the multibyte string pointed to by s to determine the number of bytes needed to complete the next multibyte character. If a valid multibyte sequence is found, it is converted to a wide character and stored in the location pointed to by pwc (if pwc is not NULL).",
          "return_value": "Returns: 0 if s points to a null character, the number of bytes that constitute the converted multibyte character, (size_t)(-2) if the next n bytes contribute to an incomplete (but potentially valid) multibyte character, or (size_t)(-1) if an encoding error occurs.",
          "parameter_values": "This function takes four parameters: pwc (pointer to store the converted wide character, or NULL), s (pointer to the multibyte character), n (maximum number of bytes to examine), and ps (pointer to a multibyte state, or NULL).",
          "function_prototype": "size_t mbrtowc(wchar_t *restrict pwc, const char *restrict s, size_t n, mbstate_t *restrict ps);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const char *str = \"Hello, 世界\";\n    wchar_t wc;\n    mbstate_t state = {0};\n    size_t len;\n    \n    while (*str) {\n        len = mbrtowc(&wc, str, MB_CUR_MAX, &state);\n        if (len == (size_t)(-1)) {\n            printf(\"Conversion error\\n\");\n            break;\n        } else if (len == (size_t)(-2)) {\n            printf(\"Incomplete multibyte sequence\\n\");\n            break;\n        } else {\n            printf(\"Wide character: %lc (hex: %04X), Bytes: %zu\\n\", wc, (unsigned int)wc, len);\n            str += len;\n        }\n    }\n    \n    return 0;\n}",
              "explanation": "This example demonstrates basic usage of mbrtowc to convert multibyte characters to wide characters.",
              "expectedOutput": "Wide character: H (hex: 0048), Bytes: 1\nWide character: e (hex: 0065), Bytes: 1\nWide character: l (hex: 006C), Bytes: 1\nWide character: l (hex: 006C), Bytes: 1\nWide character: o (hex: 006F), Bytes: 1\nWide character: , (hex: 002C), Bytes: 1\nWide character:   (hex: 0020), Bytes: 1\nWide character: 世 (hex: 4E16), Bytes: 3\nWide character: 界 (hex: 754C), Bytes: 3"
            },
            {
              "title": "Handling Null Characters",
              "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const char *str = \"A\\0B\";\n    wchar_t wc;\n    mbstate_t state = {0};\n    size_t len;\n    \n    for (int i = 0; i < 3; i++) {\n        len = mbrtowc(&wc, str + i, 1, &state);\n        if (len == (size_t)(-1)) {\n            printf(\"Conversion error\\n\");\n        } else if (len == (size_t)(-2)) {\n            printf(\"Incomplete multibyte sequence\\n\");\n        } else {\n            printf(\"Character %d: %lc (hex: %04X), Bytes: %zu\\n\", i, wc ? wc : L'␀', (unsigned int)wc, len);\n        }\n    }\n    \n    return 0;\n}",
              "explanation": "This example shows how mbrtowc handles null characters in the input string.",
              "expectedOutput": "Character 0: A (hex: 0041), Bytes: 1\nCharacter 1: ␀ (hex: 0000), Bytes: 1\nCharacter 2: B (hex: 0042), Bytes: 1"
            },
            {
              "title": "Incremental Conversion",
              "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"en_US.UTF-8\");\n    \n    const char *str = \"A世B\";\n    wchar_t wc;\n    mbstate_t state = {0};\n    size_t len;\n    \n    for (int i = 0; str[i] != '\\0'; i++) {\n        len = mbrtowc(&wc, str + i, 1, &state);\n        if (len == (size_t)(-1)) {\n            printf(\"Byte %d: Conversion error\\n\", i);\n        } else if (len == (size_t)(-2)) {\n            printf(\"Byte %d: Incomplete sequence\\n\", i);\n        } else if (len == 0) {\n            printf(\"Byte %d: Null character\\n\", i);\n        } else {\n            printf(\"Byte %d: Complete character %lc (hex: %04X)\\n\", i, wc, (unsigned int)wc);\n        }\n    }\n    \n    return 0;\n}",
              "explanation": "This example demonstrates incremental conversion of a multibyte string, processing one byte at a time.",
              "expectedOutput": "Byte 0: Complete character A (hex: 0041)\nByte 1: Incomplete sequence\nByte 2: Incomplete sequence\nByte 3: Complete character 世 (hex: 4E16)\nByte 4: Complete character B (hex: 0042)"
            }
          ]
        },
        {
          "function_name": "mbsinit",
          "include_file": "wchar.h",
          "return_type": "int",
          "parameter_types": ["const mbstate_t*"],
          "main_category": "Character Type and Conversion",
          "sub_category": "Multibyte Character Handling",
          "data_type_manipulated": "state objects",
          "description": "Checks if the multibyte state object is in the initial state.",
          "extended_description": "The mbsinit function determines whether the pointed-to mbstate_t object describes an initial conversion state. It returns non-zero if ps is a null pointer or if the pointed-to object describes an initial conversion state; otherwise, it returns zero.",
          "return_value": "Returns non-zero if ps is NULL or if *ps describes an initial conversion state; otherwise, returns zero.",
          "parameter_values": "This function takes one parameter: ps (pointer to an mbstate_t object to be checked, or NULL).",
          "function_prototype": "int mbsinit(const mbstate_t *ps);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    mbstate_t state = {0};\n    \n    printf(\"Initial state: %s\\n\", mbsinit(&state) ? \"Yes\" : \"No\");\n    \n    wchar_t wc;\n    const char *str = \"世\";\n    mbrtowc(&wc, str, MB_CUR_MAX, &state);\n    \n    printf(\"After conversion: %s\\n\", mbsinit(&state) ? \"Yes\" : \"No\");\n    \n    return 0;\n}",
              "explanation": "This example demonstrates basic usage of mbsinit to check the state before and after a multibyte conversion.",
              "expectedOutput": "Initial state: Yes\nAfter conversion: Yes"
            },
            {
              "title": "Null Pointer Check",
              "code": "#include <stdio.h>\n#include <wchar.h>\n\nint main() {\n    printf(\"Null pointer state: %s\\n\", mbsinit(NULL) ? \"Initial\" : \"Not initial\");\n    return 0;\n}",
              "explanation": "This example shows that mbsinit returns non-zero (true) when given a NULL pointer.",
              "expectedOutput": "Null pointer state: Initial"
            },
            {
              "title": "State Changes with Incomplete Conversion",
              "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"en_US.UTF-8\");\n    \n    mbstate_t state = {0};\n    const char *str = \"世界\";\n    wchar_t wc;\n    size_t result;\n    \n    printf(\"Initial state: %s\\n\", mbsinit(&state) ? \"Yes\" : \"No\");\n    \n    // Convert first byte\n    result = mbrtowc(&wc, str, 1, &state);\n    printf(\"After first byte: %s (result: %zu)\\n\", mbsinit(&state) ? \"Yes\" : \"No\", result);\n    \n    // Convert second byte\n    result = mbrtowc(&wc, str + 1, 1, &state);\n    printf(\"After second byte: %s (result: %zu)\\n\", mbsinit(&state) ? \"Yes\" : \"No\", result);\n    \n    // Convert third byte\n    result = mbrtowc(&wc, str + 2, 1, &state);\n    printf(\"After third byte: %s (result: %zu)\\n\", mbsinit(&state) ? \"Yes\" : \"No\", result);\n    \n    return 0;\n}",
              "explanation": "This example demonstrates how the state changes during an incomplete multibyte character conversion.",
              "expectedOutput": "Initial state: Yes\nAfter first byte: No (result: -2)\nAfter second byte: No (result: -2)\nAfter third byte: Yes (result: 1)"
            }
          ]
        },
        {
          "function_name": "mbsrtowcs",
          "include_file": "wchar.h",
          "return_type": "size_t",
          "parameter_types": ["wchar_t*", "const char**", "size_t", "mbstate_t*"],
          "main_category": "Character Type and Conversion",
          "sub_category": "Multibyte to Wide Character Conversion",
          "data_type_manipulated": "wide characters",
          "description": "Converts a multibyte string to a wide character string.",
          "extended_description": "The mbsrtowcs function converts a sequence of multibyte characters to a sequence of corresponding wide characters. It stores not more than n wide characters into the array pointed to by dst. It stops if it encounters a null character or if an encoding error occurs. The conversion state is stored in the object pointed to by ps.",
          "return_value": "Returns the number of wide characters successfully converted, not including the terminating null character. If an encoding error occurs, it returns (size_t)(-1) and sets errno to EILSEQ.",
          "parameter_values": "This function takes four parameters: dst (pointer to the destination wide character array), src (address of pointer to the source multibyte string), n (maximum number of wide characters to write to dst), and ps (pointer to a conversion state object, or NULL to use an internal static state).",
          "function_prototype": "size_t mbsrtowcs(wchar_t *restrict dst, const char **restrict src, size_t n, mbstate_t *restrict ps);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const char *src = \"Hello, 世界\";\n    wchar_t dst[20];\n    mbstate_t state = {0};\n    \n    size_t result = mbsrtowcs(dst, &src, 20, &state);\n    \n    if (result == (size_t)(-1)) {\n        perror(\"Conversion error\");\n        return 1;\n    }\n    \n    printf(\"Converted %zu characters\\n\", result);\n    printf(\"Wide string: %ls\\n\", dst);\n    \n    return 0;\n}",
              "explanation": "This example demonstrates basic usage of mbsrtowcs to convert a multibyte string to a wide character string.",
              "expectedOutput": "Converted 9 characters\nWide string: Hello, 世界"
            },
            {
              "title": "Partial Conversion",
              "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const char *src = \"Hello, 世界\";\n    wchar_t dst[5];\n    mbstate_t state = {0};\n    \n    size_t result = mbsrtowcs(dst, &src, 5, &state);\n    \n    printf(\"Converted %zu characters\\n\", result);\n    printf(\"Remaining source: %s\\n\", src);\n    \n    for (size_t i = 0; i < result; i++) {\n        printf(\"dst[%zu] = %lc\\n\", i, dst[i]);\n    }\n    \n    return 0;\n}",
              "explanation": "This example shows how mbsrtowcs handles partial conversion when the destination buffer is too small.",
              "expectedOutput": "Converted 5 characters\nRemaining source: 世界\ndst[0] = H\ndst[1] = e\ndst[2] = l\ndst[3] = l\ndst[4] = o"
            },
            {
              "title": "Error Handling",
              "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n#include <errno.h>\n\nint main() {\n    setlocale(LC_ALL, \"C\");  // Use C locale for predictable behavior\n    \n    const char *src = \"Hello, \\xFF世界\";  // Invalid UTF-8 sequence\n    wchar_t dst[20];\n    mbstate_t state = {0};\n    \n    size_t result = mbsrtowcs(dst, &src, 20, &state);\n    \n    if (result == (size_t)(-1)) {\n        printf(\"Conversion error: %s\\n\", strerror(errno));\n        printf(\"Error occurred at position: %ld\\n\", src - \"Hello, \\xFF世界\");\n    } else {\n        printf(\"Converted successfully\\n\");\n    }\n    \n    return 0;\n}",
              "explanation": "This example demonstrates error handling when mbsrtowcs encounters an invalid multibyte sequence.",
              "expectedOutput": "Conversion error: Illegal byte sequence\nError occurred at position: 7"
            }
          ]
        },
        {
          "function_name": "mbstowcs",
          "include_file": "stdlib.h",
          "return_type": "size_t",
          "parameter_types": ["wchar_t*", "const char*", "size_t"],
          "main_category": "Character Type and Conversion",
          "sub_category": "Multibyte to Wide Character Conversion",
          "data_type_manipulated": "wide characters",
          "description": "Converts a multibyte string to a wide character string, not dependent on the current locale.",
          "extended_description": "The mbstowcs function converts a sequence of multibyte characters to a sequence of corresponding wide characters. It stores not more than n wide characters into the array pointed to by pwcs. No more than n elements are modified in the array pointed to by pwcs. The conversion stops if a null character is encountered.",
          "return_value": "Returns the number of wide characters modified, not including the terminating null character. If an invalid multibyte character is encountered, it returns (size_t)(-1).",
          "parameter_values": "This function takes three parameters: pwcs (pointer to the destination wide character array), s (pointer to the source multibyte string), and n (maximum number of wide characters to write to pwcs).",
          "function_prototype": "size_t mbstowcs(wchar_t *restrict pwcs, const char *restrict s, size_t n);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n#include <wchar.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const char *mbs = \"Hello, 世界\";\n    wchar_t wcs[20];\n    \n    size_t converted = mbstowcs(wcs, mbs, 20);\n    \n    if (converted == (size_t)(-1)) {\n        perror(\"Conversion error\");\n        return 1;\n    }\n    \n    printf(\"Converted %zu characters\\n\", converted);\n    printf(\"Wide string: %ls\\n\", wcs);\n    \n    return 0;\n}",
              "explanation": "This example demonstrates basic usage of mbstowcs to convert a multibyte string to a wide character string.",
              "expectedOutput": "Converted 9 characters\nWide string: Hello, 世界"
            },
            {
              "title": "Conversion with Limited Buffer",
              "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n#include <wchar.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const char *mbs = \"Hello, 世界\";\n    wchar_t wcs[5];\n    \n    size_t converted = mbstowcs(wcs, mbs, 5);\n    \n    printf(\"Converted %zu characters\\n\", converted);\n    \n    for (size_t i = 0; i < converted; i++) {\n        printf(\"wcs[%zu] = %lc\\n\", i, wcs[i]);\n    }\n    \n    return 0;\n}",
              "explanation": "This example shows how mbstowcs behaves when the destination buffer is too small to hold the entire converted string.",
              "expectedOutput": "Converted 5 characters\nwcs[0] = H\nwcs[1] = e\nwcs[2] = l\nwcs[3] = l\nwcs[4] = o"
            },
            {
              "title": "Getting Required Buffer Size",
              "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n#include <wchar.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const char *mbs = \"Hello, 世界\";\n    \n    size_t required = mbstowcs(NULL, mbs, 0);\n    \n    if (required == (size_t)(-1)) {\n        perror(\"Conversion error\");\n        return 1;\n    }\n    \n    printf(\"Required buffer size: %zu wide characters\\n\", required + 1);  // +1 for null terminator\n    \n    wchar_t *wcs = malloc((required + 1) * sizeof(wchar_t));\n    if (wcs == NULL) {\n        perror(\"Memory allocation failed\");\n        return 1;\n    }\n    \n    size_t converted = mbstowcs(wcs, mbs, required + 1);\n    \n    if (converted == (size_t)(-1)) {\n        perror(\"Conversion error\");\n        free(wcs);\n        return 1;\n    }\n    \n    printf(\"Converted string: %ls\\n\", wcs);\n    \n    free(wcs);\n    return 0;\n}",
              "explanation": "This example demonstrates how to use mbstowcs to determine the required buffer size for conversion and then perform the conversion.",
              "expectedOutput": "Required buffer size: 10 wide characters\nConverted string: Hello, 世界"
            }
          ]
        },
        {
          "function_name": "mbtowc",
          "include_file": "stdlib.h",
          "return_type": "int",
          "parameter_types": ["wchar_t*", "const char*", "size_t"],
          "main_category": "Character Type and Conversion",
          "sub_category": "Multibyte to Wide Character Conversion",
          "data_type_manipulated": "wide characters",
          "description": "Converts a multibyte sequence to a single wide character.",
          "extended_description": "The mbtowc function converts a multibyte character to a wide character. It examines at most n bytes of the multibyte character string pointed to by s. If s is not a null pointer, mbtowc determines the number of bytes that constitute the next multibyte character. It then converts the multibyte character to a wide character and stores it in the location pointed to by pwc (if pwc is not a null pointer).",
          "return_value": "If s is a null pointer, returns nonzero if multibyte character encodings are state-dependent, and zero otherwise. If s is not a null pointer, returns: 0 if s points to a null byte, the number of bytes that constitute the converted multibyte character, or -1 if an invalid multibyte character is encountered.",
          "parameter_values": "This function takes three parameters: pwc (pointer to store the converted wide character, or NULL), s (pointer to the multibyte character, or NULL), and n (maximum number of bytes to examine).",
          "function_prototype": "int mbtowc(wchar_t *restrict pwc, const char *restrict s, size_t n);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n#include <wchar.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const char *mbs = \"Hello, 世界\";\n    wchar_t wc;\n    int bytes;\n    \n    while ((bytes = mbtowc(&wc, mbs, MB_CUR_MAX)) > 0) {\n        printf(\"Character: %lc, Bytes: %d\\n\", wc, bytes);\n        mbs += bytes;\n    }\n    \n    if (bytes < 0) {\n        printf(\"Conversion error\\n\");\n    }\n    \n    return 0;\n}",
              "explanation": "This example demonstrates basic usage of mbtowc to convert each multibyte character in a string to a wide character.",
              "expectedOutput": "Character: H, Bytes: 1\nCharacter: e, Bytes: 1\nCharacter: l, Bytes: 1\nCharacter: l, Bytes: 1\nCharacter: o, Bytes: 1\nCharacter: ,, Bytes: 1\nCharacter:  , Bytes: 1\nCharacter: 世, Bytes: 3\nCharacter: 界, Bytes: 3"
            },
            {
              "title": "Checking State Dependency",
              "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    int state_dependent = mbtowc(NULL, NULL, 0);\n    \n    if (state_dependent) {\n        printf(\"The current locale uses state-dependent encodings\\n\");\n    } else {\n        printf(\"The current locale uses state-independent encodings\\n\");\n    }\n    \n    return 0;\n}",
              "explanation": "This example shows how to use mbtowc to check if the current locale uses state-dependent encodings for multibyte characters.",
              "expectedOutput": "The current locale uses state-independent encodings"
            },
            {
              "title": "Error Handling",
              "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n#include <wchar.h>\n\nint main() {\n    setlocale(LC_ALL, \"C\");  // Use C locale for predictable behavior\n    \n    const char *valid = \"A\";\n    const char *invalid = \"\\xFF\";  // Invalid UTF-8 sequence\n    wchar_t wc;\n    int result;\n    \n    result = mbtowc(&wc, valid, 1);\n    printf(\"Valid character: result = %d, wc = %lc\\n\", result, (result > 0) ? wc : L'?');\n    \n    result = mbtowc(&wc, invalid, 1);\n    printf(\"Invalid character: result = %d\\n\", result);\n    \n    return 0;\n}",
              "explanation": "This example demonstrates how mbtowc handles valid and invalid multibyte sequences, including error reporting.",
              "expectedOutput": "Valid character: result = 1, wc = A\nInvalid character: result = -1"
            }
          ]
        },
        {
          "function_name": "memchr",
          "include_file": "string.h",
          "return_type": "void*",
          "parameter_types": ["const void*", "int", "size_t"],
          "main_category": "Memory Management",
          "sub_category": "Search",
          "data_type_manipulated": "memory",
          "description": "Searches for the first occurrence of a character in a block of memory.",
          "extended_description": "The memchr function searches within the first n bytes of the object pointed to by s for the first occurrence of c (interpreted as an unsigned char). The search includes the terminating null character.",
          "return_value": "Returns a pointer to the located character, or NULL if the character does not occur in the object.",
          "parameter_values": "This function takes three parameters: s (pointer to the block of memory to search), c (character to search for, passed as an int but converted to unsigned char), and n (number of bytes to search).",
          "function_prototype": "void *memchr(const void *s, int c, size_t n);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    const char str[] = \"Hello, World!\";\n    char target = 'o';\n    void *result = memchr(str, target, strlen(str));\n    \n    if (result != NULL) {\n        printf(\"'%c' found at position: %ld\\n\", target, (char*)result - str);\n    } else {\n        printf(\"'%c' not found\\n\", target);\n    }\n    \n    return 0;\n}",
              "explanation": "This example demonstrates basic usage of memchr to find a character in a string.",
              "expectedOutput": "'o' found at position: 4"
            },
            {
              "title": "Searching in Non-String Data",
              "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    unsigned char data[] = {0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80};\n    int target = 0x50;\n    size_t size = sizeof(data);\n    \n    void *result = memchr(data, target, size);\n    \n    if (result != NULL) {\n        printf(\"0x%02X found at index: %ld\\n\", target, (unsigned char*)result - data);\n    } else {\n        printf(\"0x%02X not found\\n\", target);\n    }\n    \n    return 0;\n}",
              "explanation": "This example shows how memchr can be used to search for a byte value in non-string data.",
              "expectedOutput": "0x50 found at index: 4"
            },
            {
              "title": "Limiting Search Range",
              "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    const char str[] = \"Hello, World!\";\n    char target = 'o';\n    size_t search_len = 5; // Only search first 5 characters\n    \n    void *result = memchr(str, target, search_len);\n    \n    if (result != NULL) {\n        printf(\"'%c' found at position: %ld\\n\", target, (char*)result - str);\n    } else {\n        printf(\"'%c' not found within first %zu characters\\n\", target, search_len);\n    }\n    \n    return 0;\n}",
              "explanation": "This example demonstrates how to limit the search range of memchr, which can be useful for optimizing searches or when working with fixed-size buffers.",
              "expectedOutput": "'o' not found within first 5 characters"
            }
          ]
        },
        {
          "function_name": "memcmp",
          "include_file": "string.h",
          "return_type": "int",
          "parameter_types": ["const void*", "const void*", "size_t"],
          "main_category": "Memory Management",
          "sub_category": "Comparison",
          "data_type_manipulated": "memory",
          "description": "Compares two blocks of memory.",
          "extended_description": "The memcmp function compares the first n bytes of the object pointed to by s1 to the first n bytes of the object pointed to by s2. The comparison is done lexicographically, treating the bytes as unsigned char values.",
          "return_value": "Returns an integer less than, equal to, or greater than zero if the first n bytes of s1 is found, respectively, to be less than, to match, or be greater than the first n bytes of s2.",
          "parameter_values": "This function takes three parameters: s1 (pointer to the first block of memory), s2 (pointer to the second block of memory), and n (number of bytes to compare).",
          "function_prototype": "int memcmp(const void *s1, const void *s2, size_t n);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    const char str1[] = \"Hello\";\n    const char str2[] = \"Hello\";\n    const char str3[] = \"World\";\n    \n    int result1 = memcmp(str1, str2, strlen(str1));\n    int result2 = memcmp(str1, str3, strlen(str1));\n    \n    printf(\"Comparison 1: %d\\n\", result1);\n    printf(\"Comparison 2: %d\\n\", result2);\n    \n    return 0;\n}",
              "explanation": "This example demonstrates basic usage of memcmp to compare two strings.",
              "expectedOutput": "Comparison 1: 0\nComparison 2: -15"
            },
            {
              "title": "Comparing Non-String Data",
              "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    unsigned char data1[] = {0x10, 0x20, 0x30, 0x40, 0x50};\n    unsigned char data2[] = {0x10, 0x20, 0x30, 0x40, 0x60};\n    size_t size = sizeof(data1);\n    \n    int result = memcmp(data1, data2, size);\n    \n    if (result < 0) {\n        printf(\"data1 is less than data2\\n\");\n    } else if (result > 0) {\n        printf(\"data1 is greater than data2\\n\");\n    } else {\n        printf(\"data1 is equal to data2\\n\");\n    }\n    \n    return 0;\n}",
              "explanation": "This example shows how memcmp can be used to compare non-string data.",
              "expectedOutput": "data1 is less than data2"
            },
            {
              "title": "Partial Comparison",
              "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    const char str1[] = \"Hello, World!\";\n    const char str2[] = \"Hello, OpenAI!\";\n    size_t compare_len = 7; // Compare only the first 7 bytes\n    \n    int result = memcmp(str1, str2, compare_len);\n    \n    if (result == 0) {\n        printf(\"The first %zu bytes are identical\\n\", compare_len);\n    } else {\n        printf(\"The first %zu bytes are different\\n\", compare_len);\n    }\n    \n    return 0;\n}",
              "explanation": "This example demonstrates how to perform a partial comparison using memcmp, which can be useful when only a portion of the data needs to be compared.",
              "expectedOutput": "The first 7 bytes are identical"
            }
          ]
        },
        {
          "function_name": "memcpy",
          "include_file": "string.h",
          "return_type": "void*",
          "parameter_types": ["void*", "const void*", "size_t"],
          "main_category": "Memory Management",
          "sub_category": "Copying",
          "data_type_manipulated": "memory",
          "description": "Copies one block of memory to another.",
          "extended_description": "The memcpy function copies n bytes from the object pointed to by src to the object pointed to by dest. The behavior is undefined if the objects overlap. The function does not check for any terminating null character; it always copies exactly n bytes.",
          "return_value": "Returns a pointer to dest.",
          "parameter_values": "This function takes three parameters: dest (pointer to the destination array where the content is to be copied), src (pointer to the source of data to be copied), and n (number of bytes to copy).",
          "function_prototype": "void *memcpy(void *restrict dest, const void *restrict src, size_t n);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char src[] = \"Hello, World!\";\n    char dest[20];\n    \n    memcpy(dest, src, strlen(src) + 1); // +1 to include null terminator\n    \n    printf(\"Source: %s\\n\", src);\n    printf(\"Destination: %s\\n\", dest);\n    \n    return 0;\n}",
              "explanation": "This example demonstrates basic usage of memcpy to copy a string.",
              "expectedOutput": "Source: Hello, World!\nDestination: Hello, World!"
            },
            {
              "title": "Copying Structured Data",
              "code": "#include <stdio.h>\n#include <string.h>\n\nstruct Person {\n    char name[20];\n    int age;\n};\n\nint main() {\n    struct Person person1 = {\"Alice\", 30};\n    struct Person person2;\n    \n    memcpy(&person2, &person1, sizeof(struct Person));\n    \n    printf(\"Person 1: %s, %d years old\\n\", person1.name, person1.age);\n    printf(\"Person 2: %s, %d years old\\n\", person2.name, person2.age);\n    \n    return 0;\n}",
              "explanation": "This example shows how memcpy can be used to copy structured data.",
              "expectedOutput": "Person 1: Alice, 30 years old\nPerson 2: Alice, 30 years old"
            },
            {
              "title": "Partial Copying",
              "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int src[] = {1, 2, 3, 4, 5};\n    int dest[5] = {0};\n    size_t elements_to_copy = 3;\n    \n    memcpy(dest, src, elements_to_copy * sizeof(int));\n    \n    printf(\"Source array: \");\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", src[i]);\n    }\n    \n    printf(\"\\nDestination array: \");\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", dest[i]);\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
              "explanation": "This example demonstrates how to use memcpy to perform a partial copy of an array, which can be useful when working with large datasets or when only a portion of the data needs to be duplicated.",
              "expectedOutput": "Source array: 1 2 3 4 5\nDestination array: 1 2 3 0 0"
            }
          ]
        },
        {
          "function_name": "memmove",
          "include_file": "string.h",
          "return_type": "void*",
          "parameter_types": ["void*", "const void*", "size_t"],
          "main_category": "Memory Management",
          "sub_category": "Copying",
          "data_type_manipulated": "memory",
          "description": "Copies one block of memory to another, safely handling overlapping memory areas.",
          "extended_description": "The memmove function copies n bytes from the object pointed to by src to the object pointed to by dest. The copying takes place as if an intermediate buffer were used, allowing the destination and source to overlap. This function is safer than memcpy when dealing with overlapping memory regions.",
          "return_value": "Returns a pointer to dest.",
          "parameter_values": "This function takes three parameters: dest (pointer to the destination array where the content is to be copied), src (pointer to the source of data to be copied), and n (number of bytes to copy).",
          "function_prototype": "void *memmove(void *dest, const void *src, size_t n);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Hello, World!\";\n    printf(\"Before memmove: %s\\n\", str);\n    \n    memmove(str + 7, str, 5);\n    printf(\"After memmove:  %s\\n\", str);\n    \n    return 0;\n}",
              "explanation": "This example demonstrates basic usage of memmove to shift part of a string within itself.",
              "expectedOutput": "Before memmove: Hello, World!\nAfter memmove:  Hello, Hello!"
            },
            {
              "title": "Overlapping Memory",
              "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    printf(\"Before memmove: \");\n    for (int i = 0; i < n; i++) printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n    \n    // Move the last 5 elements to the beginning\n    memmove(arr, arr + 5, 5 * sizeof(int));\n    \n    printf(\"After memmove:  \");\n    for (int i = 0; i < n; i++) printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n    \n    return 0;\n}",
              "explanation": "This example shows how memmove safely handles overlapping memory regions when moving array elements.",
              "expectedOutput": "Before memmove: 1 2 3 4 5 6 7 8 9 10\nAfter memmove:  6 7 8 9 10 6 7 8 9 10"
            },
            {
              "title": "Comparison with memcpy",
              "code": "#include <stdio.h>\n#include <string.h>\n\nvoid print_array(int arr[], int n) {\n    for (int i = 0; i < n; i++) printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr1[] = {1, 2, 3, 4, 5};\n    int arr2[] = {1, 2, 3, 4, 5};\n    int n = sizeof(arr1) / sizeof(arr1[0]);\n    \n    printf(\"Original arrays:\\n\");\n    print_array(arr1, n);\n    print_array(arr2, n);\n    \n    // Shift elements using memmove (safe for overlapping)\n    memmove(arr1 + 1, arr1, 3 * sizeof(int));\n    \n    // Try the same with memcpy (unsafe for overlapping)\n    memcpy(arr2 + 1, arr2, 3 * sizeof(int));\n    \n    printf(\"After shifting:\\n\");\n    printf(\"memmove result: \");\n    print_array(arr1, n);\n    printf(\"memcpy result:  \");\n    print_array(arr2, n);\n    \n    return 0;\n}",
              "explanation": "This example compares memmove with memcpy when dealing with overlapping memory regions, showing why memmove is safer in such scenarios.",
              "expectedOutput": "Original arrays:\n1 2 3 4 5\n1 2 3 4 5\nAfter shifting:\nmemmove result: 1 1 2 3 5\nmemcpy result:  1 1 1 1 5"
            }
          ]
        },
        {
          "function_name": "memset",
          "include_file": "string.h",
          "return_type": "void*",
          "parameter_types": ["void*", "int", "size_t"],
          "main_category": "Memory Management",
          "sub_category": "Initialization",
          "data_type_manipulated": "memory",
          "description": "Fills a block of memory with a specified value.",
          "extended_description": "The memset function fills the first n bytes of the memory area pointed to by s with the constant byte c. It is often used to initialize or reset memory blocks to a specific value.",
          "return_value": "Returns a pointer to the memory area s.",
          "parameter_values": "This function takes three parameters: s (pointer to the block of memory to fill), c (value to be set, passed as an int but converted to unsigned char), and n (number of bytes to be set).",
          "function_prototype": "void *memset(void *s, int c, size_t n);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[50];\n    \n    memset(str, '-', 49);\n    str[49] = '\\0';  // Null-terminate the string\n    \n    printf(\"Initialized string: %s\\n\", str);\n    \n    return 0;\n}",
              "explanation": "This example demonstrates basic usage of memset to initialize a character array with dashes.",
              "expectedOutput": "Initialized string: -------------------------------------------------"
            },
            {
              "title": "Resetting an Integer Array",
              "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int numbers[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    int n = sizeof(numbers) / sizeof(numbers[0]);\n    \n    printf(\"Before memset: \");\n    for (int i = 0; i < n; i++) printf(\"%d \", numbers[i]);\n    printf(\"\\n\");\n    \n    memset(numbers, 0, sizeof(numbers));\n    \n    printf(\"After memset:  \");\n    for (int i = 0; i < n; i++) printf(\"%d \", numbers[i]);\n    printf(\"\\n\");\n    \n    return 0;\n}",
              "explanation": "This example shows how to use memset to reset all elements of an integer array to zero.",
              "expectedOutput": "Before memset: 1 2 3 4 5 6 7 8 9 10\nAfter memset:  0 0 0 0 0 0 0 0 0 0"
            },
            {
              "title": "Partial Memory Initialization",
              "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char name[20];\n    int age;\n    double salary;\n} Employee;\n\nint main() {\n    Employee emp;\n    \n    // Initialize only the name field\n    memset(emp.name, 0, sizeof(emp.name));\n    \n    // Set other fields manually\n    emp.age = 30;\n    emp.salary = 50000.0;\n    \n    printf(\"Name: '%s'\\n\", emp.name);\n    printf(\"Age: %d\\n\", emp.age);\n    printf(\"Salary: %.2f\\n\", emp.salary);\n    \n    return 0;\n}",
              "explanation": "This example demonstrates how to use memset to initialize part of a structure, showing that memset can be used for targeted memory initialization.",
              "expectedOutput": "Name: ''\nAge: 30\nSalary: 50000.00"
            }
          ]
        },
        {
          "function_name": "mktime",
          "include_file": "time.h",
          "return_type": "time_t",
          "parameter_types": ["struct tm*"],
          "main_category": "Time and Date Management",
          "sub_category": "Time Conversion",
          "data_type_manipulated": "time structures",
          "description": "Converts a time structure to calendar time.",
          "extended_description": "The mktime function converts a local time, expressed as a struct tm, into a calendar time value of type time_t. The function also normalizes the contents of the struct tm, so that each member is in the correct range.",
          "return_value": "Returns the calendar time encoded as a time_t value, or (time_t)(-1) if the time cannot be represented.",
          "parameter_values": "This function takes one parameter: timeptr (pointer to a struct tm that contains the time information to be converted).",
          "function_prototype": "time_t mktime(struct tm *timeptr);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    struct tm time_info = {\n        .tm_year = 2023 - 1900,  // Year since 1900\n        .tm_mon = 6,             // Month (0-11)\n        .tm_mday = 15,           // Day of the month\n        .tm_hour = 10,\n        .tm_min = 30,\n        .tm_sec = 0\n    };\n    \n    time_t result = mktime(&time_info);\n    \n    if (result != (time_t)(-1)) {\n        printf(\"Converted time: %s\", ctime(&result));\n    } else {\n        printf(\"Failed to convert time\\n\");\n    }\n    \n    return 0;\n}",
              "explanation": "This example demonstrates basic usage of mktime to convert a struct tm to a time_t value.",
              "expectedOutput": "Converted time: Sat Jul 15 10:30:00 2023\n"
            },
            {
              "title": "Normalizing Time Values",
              "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    struct tm time_info = {\n        .tm_year = 2023 - 1900,\n        .tm_mon = 11,    // December\n        .tm_mday = 31,   // 31st\n        .tm_hour = 23,\n        .tm_min = 59,\n        .tm_sec = 60    // 60 seconds (leap second)\n    };\n    \n    time_t result = mktime(&time_info);\n    \n    if (result != (time_t)(-1)) {\n        printf(\"Original input: 2023-12-31 23:59:60\\n\");\n        printf(\"Normalized time: %d-%02d-%02d %02d:%02d:%02d\\n\",\n               time_info.tm_year + 1900, time_info.tm_mon + 1, time_info.tm_mday,\n               time_info.tm_hour, time_info.tm_min, time_info.tm_sec);\n    } else {\n        printf(\"Failed to convert time\\n\");\n    }\n    \n    return 0;\n}",
              "explanation": "This example shows how mktime normalizes time values, handling cases like leap seconds or out-of-range values.",
              "expectedOutput": "Original input: 2023-12-31 23:59:60\nNormalized time: 2024-01-01 00:00:00"
            },
            {
              "title": "Day of Week Calculation",
              "code": "#include <stdio.h>\n#include <time.h>\n\nconst char* days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n\nint main() {\n    struct tm time_info = {\n        .tm_year = 2023 - 1900,\n        .tm_mon = 6,    // July\n        .tm_mday = 4,   // 4th\n        .tm_hour = 12,\n        .tm_min = 0,\n        .tm_sec = 0\n    };\n    \n    if (mktime(&time_info) != (time_t)(-1)) {\n        printf(\"July 4, 2023 is a %s\\n\", days[time_info.tm_wday]);\n    } else {\n        printf(\"Failed to convert time\\n\");\n    }\n    \n    return 0;\n}",
              "explanation": "This example demonstrates how mktime can be used to calculate the day of the week for a given date.",
              "expectedOutput": "July 4, 2023 is a Tuesday"
            }
          ]
          
        } ,
        {
          "function_name": "modf",
          "include_file": "math.h",
          "return_type": "double",
          "parameter_types": ["double", "double*"],
          "main_category": "Mathematical Operations",
          "sub_category": "Advanced Computation",
          "data_type_manipulated": "floating-point numbers",
          "description": "Breaks a floating-point number into integer and fractional parts.",
          "extended_description": "The modf function breaks down the floating-point number x into integer and fractional parts. It stores the integer part in the object pointed to by intpart, and returns the fractional part. Both parts have the same sign as x.",
          "return_value": "Returns the fractional part of x as a double.",
          "parameter_values": "x: The floating-point number to be broken down.\nintpart: Pointer to a double where the integer part will be stored.",
          "function_prototype": "double modf(double x, double *intpart);",
          "examples": [
              {
                  "title": "Basic Usage",
                  "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = 3.14159;\n    double intpart;\n    double fracpart = modf(x, &intpart);\n    printf(\"x = %.5f\\n\", x);\n    printf(\"Integer part = %.0f\\n\", intpart);\n    printf(\"Fractional part = %.5f\\n\", fracpart);\n    return 0;\n}",
                  "explanation": "This example demonstrates how modf breaks down a floating-point number into its integer and fractional parts.",
                  "expectedOutput": "x = 3.14159\nInteger part = 3\nFractional part = 0.14159"
              },
              {
                  "title": "Handling Negative Numbers",
                  "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = -3.14159;\n    double intpart;\n    double fracpart = modf(x, &intpart);\n    printf(\"x = %.5f\\n\", x);\n    printf(\"Integer part = %.0f\\n\", intpart);\n    printf(\"Fractional part = %.5f\\n\", fracpart);\n    return 0;\n}",
                  "explanation": "This example shows that modf preserves the sign for both integer and fractional parts when dealing with negative numbers.",
                  "expectedOutput": "x = -3.14159\nInteger part = -3\nFractional part = -0.14159"
              }
          ],
          "related_functions": ["frexp", "ldexp"],
          "performance_considerations": "The modf function is generally efficient, but frequent use in performance-critical loops may impact performance. Consider using integer arithmetic or bitwise operations if possible for such scenarios."
      },
      {
        "function_name": "nextafter",
        "include_file": "math.h",
        "return_type": "double",
        "parameter_types": ["double", "double"],
        "main_category": "Mathematical Operations",
        "sub_category": "Advanced Computation",
        "data_type_manipulated": "floating-point numbers",
        "description": "Returns the next representable value of the first argument in the direction of the second argument.",
        "extended_description": "The nextafter function returns the next representable double-precision floating-point value following x in the direction of y. If x equals y, the function returns y. If either x or y is NaN, NaN is returned.",
        "return_value": "Returns the next representable value after x in the direction of y.",
        "parameter_values": "x: The starting floating-point value.\ny: The direction towards which to find the next representable value.",
        "function_prototype": "double nextafter(double x, double y);",
        "examples": [
            {
                "title": "Basic Usage",
                "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = 0.0;\n    double next_pos = nextafter(x, 1.0);\n    double next_neg = nextafter(x, -1.0);\n    printf(\"Next representable value after 0.0 towards positive: %.20e\\n\", next_pos);\n    printf(\"Next representable value after 0.0 towards negative: %.20e\\n\", next_neg);\n    return 0;\n}",
                "explanation": "This example shows how nextafter finds the next representable value in both positive and negative directions from zero.",
                "expectedOutput": "Next representable value after 0.0 towards positive: 4.94065645841246544e-324\nNext representable value after 0.0 towards negative: -4.94065645841246544e-324"
            },
            {
                "title": "Handling Special Cases",
                "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double inf = INFINITY;\n    double nan = NAN;\n    printf(\"nextafter(INFINITY, 0.0) = %f\\n\", nextafter(inf, 0.0));\n    printf(\"nextafter(NAN, 1.0) = %f\\n\", nextafter(nan, 1.0));\n    printf(\"nextafter(1.0, 1.0) = %f\\n\", nextafter(1.0, 1.0));\n    return 0;\n}",
                "explanation": "This example demonstrates how nextafter handles special cases like infinity, NaN, and when both arguments are equal.",
                "expectedOutput": "nextafter(INFINITY, 0.0) = 1.797693e+308\nnextafter(NAN, 1.0) = nan\nnextafter(1.0, 1.0) = 1.000000"
            }
        ],
        "related_functions": ["nextafterf", "nextafterl", "nexttoward"],
        "performance_considerations": "nextafter is typically implemented using hardware instructions and is generally efficient. However, frequent use in tight loops may impact performance due to potential pipeline stalls or floating-point exceptions."
    },
    {
      "function_name": "nextafterl",
      "include_file": "math.h",
      "return_type": "long double",
      "parameter_types": ["long double", "long double"],
      "main_category": "Mathematical Operations",
      "sub_category": "Advanced Computation",
      "data_type_manipulated": "floating-point numbers",
      "description": "Returns the next representable long double value of the first argument in the direction of the second argument.",
      "extended_description": "The nextafterl function returns the next representable long double floating-point value following x in the direction of y. If x equals y, the function returns y. If either x or y is NaN, NaN is returned. This function is similar to nextafter but operates on long double precision numbers.",
      "return_value": "Returns the next representable long double value after x in the direction of y.",
      "parameter_values": "x: The starting long double floating-point value.\ny: The direction towards which to find the next representable value.",
      "function_prototype": "long double nextafterl(long double x, long double y);",
      "examples": [
          {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    long double x = 0.0L;\n    long double next_pos = nextafterl(x, 1.0L);\n    long double next_neg = nextafterl(x, -1.0L);\n    printf(\"Next representable value after 0.0 towards positive: %.20Le\\n\", next_pos);\n    printf(\"Next representable value after 0.0 towards negative: %.20Le\\n\", next_neg);\n    return 0;\n}",
              "explanation": "This example demonstrates how nextafterl finds the next representable long double value in both positive and negative directions from zero.",
              "expectedOutput": "Next representable value after 0.0 towards positive: 3.64519953188247460253e-4951L\nNext representable value after 0.0 towards negative: -3.64519953188247460253e-4951L"
          },
          {
              "title": "Comparing nextafter and nextafterl",
              "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x_double = 1.0;\n    long double x_long_double = 1.0L;\n    \n    double next_double = nextafter(x_double, 2.0);\n    long double next_long_double = nextafterl(x_long_double, 2.0L);\n    \n    printf(\"nextafter(1.0, 2.0) = %.20e\\n\", next_double);\n    printf(\"nextafterl(1.0, 2.0) = %.20Le\\n\", next_long_double);\n    \n    return 0;\n}",
              "explanation": "This example compares the results of nextafter and nextafterl to show the difference in precision between double and long double.",
              "expectedOutput": "nextafter(1.0, 2.0) = 1.00000000000000022204e+00\nnextafterl(1.0, 2.0) = 1.00000000000000000001e+00"
          }
      ],
      "related_functions": ["nextafter", "nextafterf", "nexttoward"],
      "performance_considerations": "nextafterl operates on long double precision numbers, which may have performance implications on systems where long double operations are not natively supported by hardware. It may be slower than nextafter on such systems."
  },
  {
    "function_name": "nexttoward",
    "include_file": "math.h",
    "return_type": "double",
    "parameter_types": ["double", "long double"],
    "main_category": "Mathematical Operations",
    "sub_category": "Advanced Computation",
    "data_type_manipulated": "floating-point numbers",
    "description": "Returns the next representable value of the first argument towards the second argument, specified as a long double.",
    "extended_description": "The nexttoward function returns the next representable double-precision floating-point value following x in the direction of y (specified as a long double). If x equals y, the function returns y converted to double. If either x or y is NaN, NaN is returned. This function is similar to nextafter but allows for higher precision in the second argument.",
    "return_value": "Returns the next representable double value after x in the direction of y.",
    "parameter_values": "x: The starting double-precision floating-point value.\ny: The direction (as a long double) towards which to find the next representable value.",
    "function_prototype": "double nexttoward(double x, long double y);",
    "examples": [
        {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = 1.0;\n    long double y = 2.0L;\n    double next = nexttoward(x, y);\n    printf(\"Next representable value after %.20f towards %.20Lf: %.20f\\n\", x, y, next);\n    return 0;\n}",
            "explanation": "This example demonstrates how nexttoward finds the next representable double value towards a long double direction.",
            "expectedOutput": "Next representable value after 1.00000000000000000000 towards 2.00000000000000000000: 1.00000000000000022204"
        },
        {
            "title": "Comparing nextafter and nexttoward",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = 1.0;\n    double y_double = 2.0;\n    long double y_long_double = 2.0L;\n    \n    double next_after = nextafter(x, y_double);\n    double next_toward = nexttoward(x, y_long_double);\n    \n    printf(\"nextafter result:  %.20f\\n\", next_after);\n    printf(\"nexttoward result: %.20f\\n\", next_toward);\n    \n    return 0;\n}",
            "explanation": "This example compares the results of nextafter and nexttoward to show that they produce the same result when the second argument of nexttoward is within the range of double precision.",
            "expectedOutput": "nextafter result:  1.00000000000000022204\nnexttoward result: 1.00000000000000022204"
        }
    ],
    "related_functions": ["nextafter", "nextafterl", "nexttowardl"],
    "performance_considerations": "nexttoward may be slower than nextafter on systems where long double operations are not natively supported by hardware. However, it provides more precision in specifying the direction."
},
{
  "function_name": "nexttowardl",
  "include_file": "math.h",
  "return_type": "long double",
  "parameter_types": ["long double", "long double"],
  "main_category": "Mathematical Operations",
  "sub_category": "Advanced Computation",
  "data_type_manipulated": "floating-point numbers",
  "description": "Returns the next representable long double value of the first argument towards the second argument, specified as a long double.",
  "extended_description": "The nexttowardl function returns the next representable long double floating-point value following x in the direction of y. If x equals y, the function returns y. If either x or y is NaN, NaN is returned. This function is similar to nextafterl but uses long double precision for both arguments and the return value.",
  "return_value": "Returns the next representable long double value after x in the direction of y.",
  "parameter_values": "x: The starting long double floating-point value.\ny: The direction (as a long double) towards which to find the next representable value.",
  "function_prototype": "long double nexttowardl(long double x, long double y);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    long double x = 1.0L;\n    long double y = 2.0L;\n    long double next = nexttowardl(x, y);\n    printf(\"Next representable value after %.20Lf towards %.20Lf: %.20Lf\\n\", x, y, next);\n    return 0;\n}",
          "explanation": "This example demonstrates how nexttowardl finds the next representable long double value towards another long double value.",
          "expectedOutput": "Next representable value after 1.00000000000000000000 towards 2.00000000000000000000: 1.00000000000000000001"
      },
      {
          "title": "Handling Special Cases",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    long double inf = INFINITY;\n    long double nan = NAN;\n    printf(\"nexttowardl(INFINITY, 0.0) = %Lf\\n\", nexttowardl(inf, 0.0L));\n    printf(\"nexttowardl(NAN, 1.0) = %Lf\\n\", nexttowardl(nan, 1.0L));\n    printf(\"nexttowardl(1.0, 1.0) = %Lf\\n\", nexttowardl(1.0L, 1.0L));\n    return 0;\n}",
          "explanation": "This example shows how nexttowardl handles special cases like infinity, NaN, and when both arguments are equal.",
          "expectedOutput": "nexttowardl(INFINITY, 0.0) = 1.797693e+308\nnexttowardl(NAN, 1.0) = nan\nnexttowardl(1.0, 1.0) = 1.000000"
      }
  ],
  "related_functions": ["nexttoward", "nextafter", "nextafterl"],
  "performance_considerations": "nexttowardl operates on long double precision numbers, which may have performance implications on systems where long double operations are not natively supported by hardware. It may be slower than nexttoward or nextafter on such systems."
},
{
  "function_name": "nl_langinfo",
  "include_file": "langinfo.h",
  "return_type": "char*",
  "parameter_types": ["nl_item"],
  "main_category": "System Interaction",
  "sub_category": "Localization Support",
  "data_type_manipulated": "locale information",
  "description": "Retrieves information about the current locale specified by the item.",
  "extended_description": "The nl_langinfo function returns a pointer to a string that contains information about the current locale. The information returned depends on the nl_item value passed as an argument. This function is crucial for obtaining locale-specific information such as date and time formats, currency symbols, and character encodings.",
  "return_value": "Returns a pointer to a string containing the requested locale information. If the item is invalid or not available for the current locale, an empty string is returned.",
  "parameter_values": "item: An identifier specifying the locale information to retrieve. This should be one of the constants defined in <langinfo.h>.",
  "function_prototype": "char *nl_langinfo(nl_item item);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <langinfo.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    printf(\"Currency symbol: %s\\n\", nl_langinfo(CRNCYSTR));\n    printf(\"Date format: %s\\n\", nl_langinfo(D_FMT));\n    printf(\"Time format: %s\\n\", nl_langinfo(T_FMT));\n    printf(\"Day names: %s, %s\\n\", nl_langinfo(DAY_1), nl_langinfo(DAY_7));\n    \n    return 0;\n}",
          "explanation": "This example demonstrates how to use nl_langinfo to retrieve various locale-specific information such as currency symbol, date format, time format, and day names.",
          "expectedOutput": "Currency symbol: $\nDate format: %m/%d/%y\nTime format: %r\nDay names: Sunday, Saturday"
      },
      {
          "title": "Changing Locale",
          "code": "#include <stdio.h>\n#include <langinfo.h>\n#include <locale.h>\n\nint main() {\n    printf(\"Default locale:\\n\");\n    setlocale(LC_ALL, \"\");\n    printf(\"Date format: %s\\n\\n\", nl_langinfo(D_FMT));\n    \n    printf(\"German locale:\\n\");\n    setlocale(LC_ALL, \"de_DE.UTF-8\");\n    printf(\"Date format: %s\\n\", nl_langinfo(D_FMT));\n    \n    return 0;\n}",
          "explanation": "This example shows how nl_langinfo returns different information when the locale is changed. It compares the date format between the default locale and the German locale.",
          "expectedOutput": "Default locale:\nDate format: %m/%d/%y\n\nGerman locale:\nDate format: %d.%m.%Y"
      }
  ],
  "related_functions": ["setlocale", "localeconv"],
  "performance_considerations": "nl_langinfo is generally efficient as it typically just returns a pointer to pre-computed strings. However, changing locales frequently and then calling nl_langinfo can be expensive, as it may require recomputation of locale-specific data."
},
{
  "function_name": "perror",
  "include_file": "stdio.h",
  "return_type": "void",
  "parameter_types": ["const char*"],
  "main_category": "Error Handling and Debugging",
  "sub_category": "Error Reporting",
  "data_type_manipulated": "none",
  "description": "Prints a descriptive error message to stderr based on the current value of the C global variable errno.",
  "extended_description": "The perror function produces a message on the standard error output, describing the last error encountered during a call to a system or library function. It first outputs the string pointed to by s, followed by a colon and a space. Then, it outputs the appropriate error message string corresponding to the current value of errno, followed by a newline character.",
  "return_value": "This function does not return a value.",
  "parameter_values": "s: A pointer to a null-terminated string that is used as a custom prefix for the error message. If s is a null pointer or points to an empty string, only the error message corresponding to errno is printed.",
  "function_prototype": "void perror(const char *s);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <errno.h>\n\nint main() {\n    FILE *file = fopen(\"nonexistent_file.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    fclose(file);\n    return 0;\n}",
          "explanation": "This example demonstrates how perror is used to print an error message when a file cannot be opened. The custom prefix 'Error opening file' is provided.",
          "expectedOutput": "Error opening file: No such file or directory"
      },
      {
          "title": "Using perror with errno",
          "code": "#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n\nint main() {\n    FILE *file = fopen(\"nonexistent_file.txt\", \"r\");\n    if (file == NULL) {\n        int errnum = errno;\n        fprintf(stderr, \"Error number: %d\\n\", errnum);\n        perror(\"Using perror\");\n        fprintf(stderr, \"Error opening file: %s\\n\", strerror(errnum));\n        return 1;\n    }\n    fclose(file);\n    return 0;\n}",
          "explanation": "This example shows how perror relates to errno and compares it with strerror function. It demonstrates different ways to display error information.",
          "expectedOutput": "Error number: 2\nUsing perror: No such file or directory\nError opening file: No such file or directory"
      }
  ],
  "related_functions": ["strerror", "fprintf", "errno"],
  "performance_considerations": "perror is generally efficient as it simply prints a pre-defined error message. However, in performance-critical sections, consider using a more lightweight error handling mechanism if frequent error reporting is needed."
},
{
  "function_name": "pow",
  "include_file": "math.h",
  "return_type": "double",
  "parameter_types": ["double", "double"],
  "main_category": "Mathematical Operations",
  "sub_category": "Advanced Computation",
  "data_type_manipulated": "floating-point numbers",
  "description": "Calculates the power of one number raised to another, i.e., base raised to the exponent.",
  "extended_description": "The pow function computes the value of base raised to the power of exponent. It handles various special cases, including negative and fractional exponents. For integer exponents, consider using specialized functions or manual multiplication for better performance.",
  "return_value": "Returns base raised to the power of exponent. If the result is too large or too small to be represented as a double, it may return HUGE_VAL, HUGE_VALF, or HUGE_VALL, signed appropriately.",
  "parameter_values": "base: The base number.\nexponent: The power to which the base is raised.",
  "function_prototype": "double pow(double base, double exponent);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double base = 2.0;\n    double exponent = 3.0;\n    double result = pow(base, exponent);\n    printf(\"%.1f raised to the power of %.1f is %.1f\\n\", base, exponent, result);\n    \n    base = 5.0;\n    exponent = 0.5;\n    result = pow(base, exponent);\n    printf(\"The square root of %.1f is %.1f\\n\", base, result);\n    \n    return 0;\n}",
          "explanation": "This example demonstrates how to use pow for integer and fractional exponents. It shows calculating a regular power and a square root.",
          "expectedOutput": "2.0 raised to the power of 3.0 is 8.0\nThe square root of 5.0 is 2.2"
      },
      {
          "title": "Handling Special Cases",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    printf(\"pow(0.0, 0.0) = %f\\n\", pow(0.0, 0.0));\n    printf(\"pow(-1.0, 0.5) = %f\\n\", pow(-1.0, 0.5));\n    printf(\"pow(INFINITY, -1.0) = %f\\n\", pow(INFINITY, -1.0));\n    printf(\"pow(-0.0, -3.0) = %f\\n\", pow(-0.0, -3.0));\n    return 0;\n}",
          "explanation": "This example shows how pow handles special cases like zero base and exponent, negative base with fractional exponent, infinity, and negative zero.",
          "expectedOutput": "pow(0.0, 0.0) = 1.000000\npow(-1.0, 0.5) = nan\npow(INFINITY, -1.0) = 0.000000\npow(-0.0, -3.0) = -inf"
      }
  ],
  "related_functions": ["sqrt", "cbrt", "hypot", "exp"],
  "performance_considerations": "pow can be computationally expensive, especially for non-integer exponents. For integer exponents, consider using repeated multiplication. For powers of 2, bit shifting can be more efficient. For square roots, use sqrt instead of pow with 0.5 exponent."
},
{
  "function_name": "printf",
  "include_file": "stdio.h",
  "return_type": "int",
  "parameter_types": ["const char*", "..."],
  "main_category": "File and I/O Operations",
  "sub_category": "Stream Manipulation",
  "data_type_manipulated": "standard output",
  "description": "Prints formatted output to the standard output stream.",
  "extended_description": "The printf function writes output to stdout, the standard output stream, under control of a format string that specifies how subsequent arguments are converted for output. It supports various format specifiers for different data types and provides options for controlling the output format, including field width, precision, and alignment.",
  "return_value": "Returns the number of characters printed (excluding the null byte used to end output to strings). If an output error occurs, a negative value is returned.",
  "parameter_values": "format: A string that contains the text to be written to stdout. It can optionally contain embedded format specifiers that are replaced by the values specified in subsequent additional arguments.\n...: Depending on the format string, the function may expect a sequence of additional arguments, each containing a value to be used to replace a format specifier in the format string.",
  "function_prototype": "int printf(const char *format, ...);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n\nint main() {\n    int num = 42;\n    float pi = 3.14159;\n    char letter = 'A';\n    char *str = \"Hello, World!\";\n    \n    printf(\"Integer: %d\\n\", num);\n    printf(\"Float: %.2f\\n\", pi);\n    printf(\"Character: %c\\n\", letter);\n    printf(\"String: %s\\n\", str);\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of printf with different data types and format specifiers.",
          "expectedOutput": "Integer: 42\nFloat: 3.14\nCharacter: A\nString: Hello, World!"
      },
      {
          "title": "Advanced Formatting",
          "code": "#include <stdio.h>\n\nint main() {\n    int num = 42;\n    float pi = 3.14159;\n    \n    printf(\"Right-aligned integer (width 5): '%5d'\\n\", num);\n    printf(\"Left-aligned integer (width 5):  '%-5d'\\n\", num);\n    printf(\"Zero-padded integer (width 5):   '%05d'\\n\", num);\n    printf(\"Float (width 8, 2 decimals):     '%8.2f'\\n\", pi);\n    printf(\"Hexadecimal:                     '%#x'\\n\", num);\n    \n    return 0;\n}",
          "explanation": "This example shows more advanced formatting options including field width, alignment, zero-padding, and different number representations.",
          "expectedOutput": "Right-aligned integer (width 5): '   42'\nLeft-aligned integer (width 5):  '42   '\nZero-padded integer (width 5):   '00042'\nFloat (width 8, 2 decimals):     '    3.14'\nHexadecimal:                     '0x2a'"
      }
  ],
  "related_functions": ["fprintf", "sprintf", "snprintf", "vprintf"],
  "performance_considerations": "printf is generally efficient for basic output, but frequent use in tight loops can impact performance. For performance-critical code, consider using fputs or putchar for simple string or character output. Be cautious with format strings from untrusted sources to avoid format string vulnerabilities."
},
{
  "function_name": "putc",
  "include_file": "stdio.h",
  "return_type": "int",
  "parameter_types": ["int", "FILE*"],
  "main_category": "File and I/O Operations",
  "sub_category": "File Management",
  "data_type_manipulated": "file streams",
  "description": "Writes a character to the specified stream.",
  "extended_description": "The putc function writes a single character to the specified output stream at the current position. It is equivalent to fputc() but may be implemented as a macro, which means it may evaluate the stream argument more than once. This function is commonly used for character-by-character output to files or other streams.",
  "return_value": "Returns the character written as an unsigned char cast to an int if successful, or EOF if an error occurred.",
  "parameter_values": "c: The character to be written. Although an int, the value is converted to an unsigned char.\nstream: Pointer to a FILE object that identifies the output stream.",
  "function_prototype": "int putc(int c, FILE *stream);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"example.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    \n    char str[] = \"Hello, World!\";\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (putc(str[i], file) == EOF) {\n            perror(\"Error writing to file\");\n            fclose(file);\n            return 1;\n        }\n    }\n    \n    fclose(file);\n    printf(\"Data written to file successfully.\\n\");\n    return 0;\n}",
          "explanation": "This example demonstrates how to use putc to write a string character by character to a file. It also shows proper error checking.",
          "expectedOutput": "Data written to file successfully."
      },
      {
          "title": "Using putc with stdout",
          "code": "#include <stdio.h>\n\nint main() {\n    char str[] = \"Hello, World!\";\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (putc(str[i], stdout) == EOF) {\n            perror(\"Error writing to stdout\");\n            return 1;\n        }\n    }\n    putc('\\n', stdout);\n    return 0;\n}",
          "explanation": "This example shows how putc can be used with stdout to write characters directly to the console.",
          "expectedOutput": "Hello, World!"
      }
  ],
  "related_functions": ["fputc", "putchar", "fputs", "fwrite"],
  "performance_considerations": "putc is generally efficient for character-by-character output. However, for writing large amounts of data, consider using fwrite for better performance. Also, be aware that if putc is implemented as a macro, it may evaluate the stream argument multiple times, which could have side effects if the argument has side effects when evaluated."
},
{
  "function_name": "putchar",
  "include_file": "stdio.h",
  "return_type": "int",
  "parameter_types": ["int"],
  "main_category": "File and I/O Operations",
  "sub_category": "Standard Output",
  "data_type_manipulated": "standard output",
  "description": "Writes a character to the standard output stream.",
  "extended_description": "The putchar function writes a single character to stdout, the standard output stream. It is equivalent to putc(c, stdout). This function is commonly used for character-by-character output to the console. It's often implemented as a macro for efficiency.",
  "return_value": "Returns the character written as an unsigned char cast to an int if successful, or EOF if an error occurred.",
  "parameter_values": "c: The character to be written. Although an int, the value is converted to an unsigned char.",
  "function_prototype": "int putchar(int c);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n\nint main() {\n    char str[] = \"Hello, World!\";\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (putchar(str[i]) == EOF) {\n            perror(\"Error writing to stdout\");\n            return 1;\n        }\n    }\n    putchar('\\n');\n    return 0;\n}",
          "explanation": "This example demonstrates how to use putchar to write a string character by character to the standard output. It also includes error checking.",
          "expectedOutput": "Hello, World!"
      },
      {
          "title": "ASCII Art with putchar",
          "code": "#include <stdio.h>\n\nint main() {\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j <= i; j++) {\n            putchar('*');\n        }\n        putchar('\\n');\n    }\n    return 0;\n}",
          "explanation": "This example uses putchar to create a simple ASCII art triangle. It demonstrates how putchar can be used in nested loops for more complex output patterns.",
          "expectedOutput": "*\n**\n***\n****\n*****"
      }
  ],
  "related_functions": ["putc", "fputc", "puts", "printf"],
  "performance_considerations": "putchar is generally very efficient for character-by-character output to stdout. However, for writing large amounts of data or formatted output, consider using puts or printf for better performance and convenience. In critical loops, putchar can be faster than printf for single character output."
},
{
  "function_name": "putenv",
  "include_file": "stdlib.h",
  "return_type": "int",
  "parameter_types": ["char*"],
  "main_category": "System Interaction",
  "sub_category": "Environment Interaction",
  "data_type_manipulated": "environment variables",
  "description": "Changes or adds a value to the environment.",
  "extended_description": "The putenv function adds or changes the value of environment variables. It takes a string of the form name=value and places it in the environment list. If the name already exists in the environment, its value is changed to the new value. If the name does not exist, a new entry is created. The string passed to putenv becomes part of the environment, so altering the string after a call to putenv affects the environment.",
  "return_value": "Returns zero on success, or a non-zero value if an error occurs.",
  "parameter_values": "string: A pointer to a string of the form 'name=value'.",
  "function_prototype": "int putenv(char *string);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    char *env_var = \"MY_VAR=Hello, Environment!\";\n    \n    if (putenv(env_var) != 0) {\n        perror(\"putenv failed\");\n        return 1;\n    }\n    \n    char *value = getenv(\"MY_VAR\");\n    if (value != NULL) {\n        printf(\"MY_VAR = %s\\n\", value);\n    } else {\n        printf(\"MY_VAR not found\\n\");\n    }\n    \n    return 0;\n}",
          "explanation": "This example demonstrates how to use putenv to set an environment variable and then retrieve its value using getenv.",
          "expectedOutput": "MY_VAR = Hello, Environment!"
      },
      {
          "title": "Modifying an Existing Environment Variable",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    putenv(\"TEST_VAR=Initial Value\");\n    printf(\"Initial TEST_VAR = %s\\n\", getenv(\"TEST_VAR\"));\n    \n    putenv(\"TEST_VAR=New Value\");\n    printf(\"Updated TEST_VAR = %s\\n\", getenv(\"TEST_VAR\"));\n    \n    return 0;\n}",
          "explanation": "This example shows how putenv can be used to modify an existing environment variable. It first sets a variable and then changes its value.",
          "expectedOutput": "Initial TEST_VAR = Initial Value\nUpdated TEST_VAR = New Value"
      }
  ],
  "related_functions": ["getenv", "setenv", "unsetenv"],
  "performance_considerations": "putenv is generally efficient for setting environment variables. However, be aware that the string passed to putenv becomes part of the environment, so you should not free this memory or modify it after calling putenv. For more controlled memory management, consider using setenv instead. Also, frequent modifications to the environment can be memory-intensive and may impact performance in resource-constrained systems."
},
{
  "function_name": "puts",
  "include_file": "stdio.h",
  "return_type": "int",
  "parameter_types": ["const char*"],
  "main_category": "File and I/O Operations",
  "sub_category": "Standard Output",
  "data_type_manipulated": "standard output",
  "description": "Writes a string followed by a newline to the standard output stream.",
  "extended_description": "The puts function writes the string pointed to by str to the standard output stream (stdout) and appends a newline character. It's often used for simple string output when a newline is desired after the string. Unlike printf, puts automatically adds a newline, which can be convenient but also needs to be considered when formatting output.",
  "return_value": "Returns a non-negative value on success, or EOF on error.",
  "parameter_values": "str: A pointer to the null-terminated string to be written.",
  "function_prototype": "int puts(const char *str);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n\nint main() {\n    if (puts(\"Hello, World!\") == EOF) {\n        perror(\"puts failed\");\n        return 1;\n    }\n    return 0;\n}",
          "explanation": "This example demonstrates the basic use of puts to output a string. It also includes error checking.",
          "expectedOutput": "Hello, World!\n"
      },
      {
          "title": "Comparing puts and printf",
          "code": "#include <stdio.h>\n\nint main() {\n    puts(\"Line 1 with puts\");\n    printf(\"Line 2 with printf\\n\");\n    puts(\"Line 3 with puts\");\n    printf(\"Line 4 with printf (no newline)\");\n    puts(\"\");\n    return 0;\n}",
          "explanation": "This example compares puts and printf, showing how puts automatically adds a newline while printf doesn't.",
          "expectedOutput": "Line 1 with puts\nLine 2 with printf\nLine 3 with puts\nLine 4 with printf (no newline)\n"
      },
      {
          "title": "Using puts with an Empty String",
          "code": "#include <stdio.h>\n\nint main() {\n    puts(\"First line\");\n    puts(\"\");  // Empty string\n    puts(\"Third line\");\n    return 0;\n}",
          "explanation": "This example shows how puts behaves with an empty string, which can be useful for adding blank lines in output.",
          "expectedOutput": "First line\n\nThird line\n"
      }
  ],
  "related_functions": ["printf", "fputs", "putchar"],
  "performance_considerations": "puts is generally more efficient than printf for simple string output, especially when a newline is needed. However, it's less flexible for formatted output. For very frequent output in performance-critical code, consider using lower-level functions like fwrite."
},
{
  "function_name": "putwc",
  "include_file": "wchar.h",
  "return_type": "wint_t",
  "parameter_types": ["wchar_t", "FILE*"],
  "main_category": "File and I/O Operations",
  "sub_category": "Wide Character Support",
  "data_type_manipulated": "file streams",
  "description": "Writes a wide character to the specified stream.",
  "extended_description": "The putwc function writes a wide character to the specified output stream at the current position. It's similar to fputwc but may be implemented as a macro. This function is used for writing wide characters to files or other streams, which is particularly useful for handling non-ASCII text and internationalization.",
  "return_value": "Returns the wide character written as a wint_t value if successful, or WEOF if an error occurred.",
  "parameter_values": "wc: The wide character to be written.\nstream: Pointer to a FILE object that identifies the output stream.",
  "function_prototype": "wint_t putwc(wchar_t wc, FILE *stream);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    FILE *file = fopen(\"wide.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    \n    wchar_t wc = L'\\u03A9';  // Greek capital letter Omega\n    if (putwc(wc, file) == WEOF) {\n        fclose(file);\n        perror(\"Error writing to file\");\n        return 1;\n    }\n    \n    fclose(file);\n    wprintf(L\"Wide character %lc written to file.\\n\", wc);\n    return 0;\n}",
          "explanation": "This example demonstrates writing a wide character (Greek Omega) to a file using putwc. It shows proper error checking and locale setting.",
          "expectedOutput": "Wide character Ω written to file."
      },
      {
          "title": "Writing Multiple Wide Characters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t str[] = L\"Hello, 世界!\";  // \"Hello, World!\" with Chinese characters\n    \n    for (int i = 0; str[i] != L'\\0'; i++) {\n        if (putwc(str[i], stdout) == WEOF) {\n            perror(\"Error writing to stdout\");\n            return 1;\n        }\n    }\n    putwc(L'\\n', stdout);\n    \n    return 0;\n}",
          "explanation": "This example shows how to use putwc in a loop to write a string of wide characters, including non-ASCII characters, to stdout.",
          "expectedOutput": "Hello, 世界!"
      }
  ],
  "related_functions": ["fputwc", "putwchar", "fgetwc"],
  "performance_considerations": "putwc is efficient for character-by-character output of wide characters. However, for writing large amounts of wide character data, consider using fwrite with appropriate casting. Be aware of the locale settings, as they affect how wide characters are interpreted and written."
},
{
  "function_name": "putwchar",
  "include_file": "wchar.h",
  "return_type": "wint_t",
  "parameter_types": ["wchar_t"],
  "main_category": "File and I/O Operations",
  "sub_category": "Wide Character Support",
  "data_type_manipulated": "standard output",
  "description": "Writes a wide character to the standard output stream.",
  "extended_description": "The putwchar function writes a single wide character to the standard output stream (stdout). It's equivalent to putwc(wc, stdout). This function is particularly useful for outputting non-ASCII characters to the console in a locale-aware manner.",
  "return_value": "Returns the wide character written as a wint_t value if successful, or WEOF if an error occurred.",
  "parameter_values": "wc: The wide character to be written.",
  "function_prototype": "wint_t putwchar(wchar_t wc);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t wc = L'\\u263A';  // White Smiling Face emoji\n    if (putwchar(wc) == WEOF) {\n        perror(\"Error writing wide character\");\n        return 1;\n    }\n    putwchar(L'\\n');\n    \n    return 0;\n}",
          "explanation": "This example demonstrates writing a wide character (an emoji) to stdout using putwchar. It includes proper locale setting and error checking.",
          "expectedOutput": "☺"
      },
      {
          "title": "Writing a Wide Character String",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t str[] = L\"こんにちは、世界!\";  // \"Hello, World!\" in Japanese\n    \n    for (int i = 0; str[i] != L'\\0'; i++) {\n        if (putwchar(str[i]) == WEOF) {\n            perror(\"Error writing wide character\");\n            return 1;\n        }\n    }\n    putwchar(L'\\n');\n    \n    return 0;\n}",
          "explanation": "This example shows how to use putwchar in a loop to write a string of wide characters, including non-Latin characters, to stdout.",
          "expectedOutput": "こんにちは、世界!"
      },
      {
          "title": "Mixing Wide and Narrow Characters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    putwchar(L'A');\n    putchar('-');\n    putwchar(L'\\u03A9');  // Greek capital letter Omega\n    putchar('-');\n    putwchar(L'1');\n    putwchar(L'\\n');\n    \n    return 0;\n}",
          "explanation": "This example demonstrates mixing putwchar and putchar to output both wide and narrow characters, showing how they can be used together.",
          "expectedOutput": "A-Ω-1"
      }
  ],
  "related_functions": ["putwc", "getwchar", "putchar"],
  "performance_considerations": "putwchar is efficient for character-by-character output of wide characters to stdout. However, for writing large amounts of wide character data, consider using wprintf or fwrite with appropriate casting. Be mindful of the current locale settings, as they affect how wide characters are interpreted and displayed."
},
{
  "function_name": "qsort",
  "include_file": "stdlib.h",
  "return_type": "void",
  "parameter_types": ["void*", "size_t", "size_t", "int (*)(const void*, const void*)"],
  "main_category": "Data Search and Sorting",
  "sub_category": "Sorting Algorithms",
  "data_type_manipulated": "generic pointers",
  "description": "Sorts an array of elements using the quicksort algorithm.",
  "extended_description": "The qsort function implements a quick sort algorithm to sort an array of any type. It sorts the array in-place, and uses a comparison function provided by the caller to determine the order of elements. This function is highly efficient and widely used for sorting arrays of various data types.",
  "return_value": "This function does not return a value.",
  "parameter_values": "base: Pointer to the first element of the array to be sorted.\nnitems: Number of elements in the array.\nsize: Size in bytes of each element in the array.\ncompar: Pointer to a comparison function which returns ​a negative integer value if the first argument is less than the second, a positive integer value if the first argument is greater than the second and zero if the arguments are equal.",
  "function_prototype": "void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void *));",
  "examples": [
      {
          "title": "Sorting an Integer Array",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare_ints(const void* a, const void* b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"Before sorting: \");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n\n    qsort(arr, n, sizeof(int), compare_ints);\n\n    printf(\"\\nAfter sorting: \");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n\n    return 0;\n}",
          "explanation": "This example demonstrates how to use qsort to sort an array of integers in ascending order. It defines a comparison function that determines the order of elements.",
          "expectedOutput": "Before sorting: 64 34 25 12 22 11 90 \nAfter sorting: 11 12 22 25 34 64 90"
      },
      {
          "title": "Sorting Strings",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint compare_strings(const void* a, const void* b) {\n    return strcmp(*(const char**)a, *(const char**)b);\n}\n\nint main() {\n    const char* arr[] = {\"banana\", \"apple\", \"cherry\", \"date\"};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"Before sorting:\\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", arr[i]);\n    }\n\n    qsort(arr, n, sizeof(const char*), compare_strings);\n\n    printf(\"\\nAfter sorting:\\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", arr[i]);\n    }\n\n    return 0;\n}",
          "explanation": "This example shows how to use qsort to sort an array of strings alphabetically. It uses strcmp in the comparison function to determine the order.",
          "expectedOutput": "Before sorting:\nbanana\napple\ncherry\ndate\n\nAfter sorting:\napple\nbanana\ncherry\ndate"
      }
  ],
  "related_functions": ["bsearch", "strcmp", "memcmp"],
  "performance_considerations": "qsort is generally very efficient, with an average time complexity of O(n log n). However, for small arrays or partially sorted arrays, simpler algorithms like insertion sort might be faster. The efficiency also depends on the comparison function, which should be as simple and fast as possible."
},
{
  "function_name": "quantexpd32",
  "include_file": "math.h",
  "return_type": "int",
  "parameter_types": ["_Decimal32"],
  "main_category": "Mathematical Operations",
  "sub_category": "Decimal Floating-Point Computation",
  "data_type_manipulated": "decimal floating-point",
  "description": "Determines the exponent of a decimal floating-point number (_Decimal32). Note: This is part of the optional decimal floating-point arithmetic support.",
  "extended_description": "The quantexpd32 function computes the quantum exponent of a _Decimal32 number. The quantum exponent is the power of 10 that the significand of the decimal floating-point number has to be scaled by to produce the given number. This function is useful in financial calculations and other domains where exact decimal representation is crucial.",
  "return_value": "Returns the quantum exponent of x.",
  "parameter_values": "x: The _Decimal32 value whose quantum exponent is to be determined.",
  "function_prototype": "int quantexpd32(_Decimal32 x);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    _Decimal32 x = 123.45d32;\n    int exp = quantexpd32(x);\n    printf(\"The quantum exponent of %Hg is %d\\n\", x, exp);\n\n    _Decimal32 y = 1.2345d32;\n    exp = quantexpd32(y);\n    printf(\"The quantum exponent of %Hg is %d\\n\", y, exp);\n\n    return 0;\n}",
          "explanation": "This example demonstrates the use of quantexpd32 to determine the quantum exponents of two _Decimal32 numbers. Note that the actual output may vary depending on the implementation and how _Decimal32 is printed.",
          "expectedOutput": "The quantum exponent of 123.45 is -2\nThe quantum exponent of 1.2345 is -4"
      },
      {
          "title": "Comparing Quantum Exponents",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    _Decimal32 x = 1.00d32;\n    _Decimal32 y = 1.0d32;\n    \n    int exp_x = quantexpd32(x);\n    int exp_y = quantexpd32(y);\n    \n    printf(\"x = %Hg, quantum exponent: %d\\n\", x, exp_x);\n    printf(\"y = %Hg, quantum exponent: %d\\n\", y, exp_y);\n    printf(\"Are x and y numerically equal? %s\\n\", (x == y) ? \"Yes\" : \"No\");\n    printf(\"Do x and y have the same quantum exponent? %s\\n\", (exp_x == exp_y) ? \"Yes\" : \"No\");\n\n    return 0;\n}",
          "explanation": "This example shows how quantexpd32 can be used to compare the precision of two seemingly equal _Decimal32 numbers.",
          "expectedOutput": "x = 1.00, quantum exponent: -2\ny = 1.0, quantum exponent: -1\nAre x and y numerically equal? Yes\nDo x and y have the same quantum exponent? No"
      }
  ],
  "related_functions": ["quantexpd64", "quantexpd128", "samequantumd32"],
  "performance_considerations": "The performance of quantexpd32 is generally efficient, but it depends on the hardware support for decimal floating-point operations. On systems without dedicated decimal floating-point hardware, operations might be slower compared to binary floating-point operations."
},
{
  "function_name": "quantexpd64",
  "include_file": "math.h",
  "return_type": "int",
  "parameter_types": ["_Decimal64"],
  "main_category": "Mathematical Operations",
  "sub_category": "Decimal Floating-Point Computation",
  "data_type_manipulated": "decimal floating-point",
  "description": "Determines the exponent of a decimal floating-point number (_Decimal64). Note: This is part of the optional decimal floating-point arithmetic support.",
  "extended_description": "The quantexpd64 function computes the quantum exponent of a _Decimal64 number. The quantum exponent is the power of 10 that the significand of the decimal floating-point number has to be scaled by to produce the given number. This function provides higher precision than quantexpd32 and is useful in financial calculations and other domains where exact decimal representation with higher precision is crucial.",
  "return_value": "Returns the quantum exponent of x.",
  "parameter_values": "x: The _Decimal64 value whose quantum exponent is to be determined.",
  "function_prototype": "int quantexpd64(_Decimal64 x);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    _Decimal64 x = 123456.789d64;\n    int exp = quantexpd64(x);\n    printf(\"The quantum exponent of %Dg is %d\\n\", x, exp);\n\n    _Decimal64 y = 0.000123456789d64;\n    exp = quantexpd64(y);\n    printf(\"The quantum exponent of %Dg is %d\\n\", y, exp);\n\n    return 0;\n}",
          "explanation": "This example demonstrates the use of quantexpd64 to determine the quantum exponents of two _Decimal64 numbers with different scales.",
          "expectedOutput": "The quantum exponent of 123456.789 is -3\nThe quantum exponent of 0.000123456789 is -12"
      },
      {
          "title": "Comparing Precision in Financial Calculations",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    _Decimal64 price1 = 10.00d64;\n    _Decimal64 price2 = 10.d64;\n    _Decimal64 total = price1 + price2;\n    \n    printf(\"Price 1: %Dg (quantum exponent: %d)\\n\", price1, quantexpd64(price1));\n    printf(\"Price 2: %Dg (quantum exponent: %d)\\n\", price2, quantexpd64(price2));\n    printf(\"Total: %Dg (quantum exponent: %d)\\n\", total, quantexpd64(total));\n\n    return 0;\n}",
          "explanation": "This example illustrates how quantexpd64 can be used in financial calculations to track and verify the precision of decimal numbers after arithmetic operations.",
          "expectedOutput": "Price 1: 10.00 (quantum exponent: -2)\nPrice 2: 10. (quantum exponent: 0)\nTotal: 20.00 (quantum exponent: -2)"
      }
  ],
  "related_functions": ["quantexpd32", "quantexpd128", "samequantumd64"],
  "performance_considerations": "The performance of quantexpd64 is generally efficient, but it depends on the hardware support for decimal floating-point operations. On systems without dedicated decimal floating-point hardware, operations might be slower compared to binary floating-point operations. The _Decimal64 type provides higher precision than _Decimal32, which may impact performance in computationally intensive applications."
},
{
  "function_name": "quantexpd128",
  "include_file": "math.h",
  "return_type": "int",
  "parameter_types": ["_Decimal128"],
  "main_category": "Mathematical Operations",
  "sub_category": "Decimal Floating-Point Computation",
  "data_type_manipulated": "decimal floating-point",
  "description": "Determines the exponent of a decimal floating-point number (_Decimal128). Note: This is part of the optional decimal floating-point arithmetic support.",
  "extended_description": "The quantexpd128 function computes the quantum exponent of a _Decimal128 number. The quantum exponent is the power of 10 that the significand of the decimal floating-point number has to be scaled by to produce the given number. This function provides the highest precision among the quantexp family and is crucial for applications requiring extreme precision in decimal calculations, such as financial or scientific computations.",
  "return_value": "Returns the quantum exponent of x.",
  "parameter_values": "x: The _Decimal128 value whose quantum exponent is to be determined.",
  "function_prototype": "int quantexpd128(_Decimal128 x);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    _Decimal128 x = 123456789.123456789123456789d128;\n    int exp = quantexpd128(x);\n    printf(\"The quantum exponent of %.36DDg is %d\\n\", x, exp);\n\n    _Decimal128 y = 0.000000000000000001d128;\n    exp = quantexpd128(y);\n    printf(\"The quantum exponent of %.36DDg is %d\\n\", y, exp);\n\n    return 0;\n}",
          "explanation": "This example demonstrates the use of quantexpd128 to determine the quantum exponents of two _Decimal128 numbers with different scales and precisions.",
          "expectedOutput": "The quantum exponent of 123456789.123456789123456789 is -18\nThe quantum exponent of 0.000000000000000001 is -18"
      },
      {
          "title": "High Precision Financial Calculation",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    _Decimal128 principal = 1000000.00d128;\n    _Decimal128 rate = 0.0275d128;  // 2.75% annual interest rate\n    _Decimal128 time = 10.0d128;    // 10 years\n    \n    _Decimal128 amount = principal * (1.0d128 + rate) * powl((1.0d128 + rate), time);\n    \n    printf(\"Principal: %.2DDf (quantum exponent: %d)\\n\", principal, quantexpd128(principal));\n    printf(\"Final Amount: %.12DDf (quantum exponent: %d)\\n\", amount, quantexpd128(amount));\n\n    return 0;\n}",
          "explanation": "This example illustrates a high-precision financial calculation using _Decimal128 and demonstrates how quantexpd128 can be used to verify the precision of the result.",
          "expectedOutput": "Principal: 1000000.00 (quantum exponent: -2)\nFinal Amount: 1313463.72726734 (quantum exponent: -11)"
      }
  ],
  "related_functions": ["quantexpd32", "quantexpd64", "samequantumd128"],
  "performance_considerations": "The performance of quantexpd128 depends heavily on hardware support for decimal floating-point operations. On systems without dedicated decimal floating-point hardware, operations might be significantly slower compared to binary floating-point operations. The _Decimal128 type provides the highest precision among decimal types, which may impact performance in computationally intensive applications, but is essential for scenarios requiring extreme precision."
},
{
  "function_name": "quantized32",
  "include_file": "math.h",
  "return_type": "_Decimal32",
  "parameter_types": ["_Decimal32", "_Decimal32"],
  "main_category": "Mathematical Operations",
  "sub_category": "Decimal Floating-Point Computation",
  "data_type_manipulated": "decimal floating-point",
  "description": "Quantizes a decimal floating-point number (_Decimal32) to the same exponent as another. Note: This is part of the optional decimal floating-point arithmetic support.",
  "extended_description": "The quantized32 function sets the quantum exponent of x to the quantum exponent of y, while trying to keep the value the same. This is useful for adjusting the precision of decimal numbers, particularly in financial calculations where a specific number of decimal places is required.",
  "return_value": "Returns the quantized value of x with the quantum exponent of y.",
  "parameter_values": "x: The _Decimal32 value to be quantized.\ny: The _Decimal32 value whose quantum exponent will be used for quantizing x.",
  "function_prototype": "_Decimal32 quantized32(_Decimal32 x, _Decimal32 y);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    _Decimal32 x = 1.23456d32;\n    _Decimal32 y = 1.00d32;\n    _Decimal32 result = quantized32(x, y);\n    \n    printf(\"Original x: %Hg (quantum exponent: %d)\\n\", x, quantexpd32(x));\n    printf(\"y: %Hg (quantum exponent: %d)\\n\", y, quantexpd32(y));\n    printf(\"Quantized x: %Hg (quantum exponent: %d)\\n\", result, quantexpd32(result));\n\n    return 0;\n}",
          "explanation": "This example demonstrates how quantized32 adjusts the quantum exponent of x to match that of y, effectively rounding x to two decimal places.",
          "expectedOutput": "Original x: 1.23456 (quantum exponent: -5)\ny: 1.00 (quantum exponent: -2)\nQuantized x: 1.23 (quantum exponent: -2)"
      },
      {
          "title": "Financial Rounding",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    _Decimal32 price = 10.126d32;\n    _Decimal32 cents = 0.01d32;\n    _Decimal32 rounded_price = quantized32(price, cents);\n    \n    printf(\"Original price: %Hg\\n\", price);\n    printf(\"Rounded to cents: %Hg\\n\", rounded_price);\n\n    price = 10.124d32;\n    rounded_price = quantized32(price, cents);\n    printf(\"\\nOriginal price: %Hg\\n\", price);\n    printf(\"Rounded to cents: %Hg\\n\", rounded_price);\n\n    return 0;\n}",
          "explanation": "This example shows how quantized32 can be used for financial rounding, ensuring that prices are always expressed with two decimal places.",
          "expectedOutput": "Original price: 10.126\nRounded to cents: 10.13\n\nOriginal price: 10.124\nRounded to cents: 10.12"
      }
  ],
  "related_functions": ["quantized64", "quantized128", "quantexpd32"],
  "performance_considerations": "The performance of quantized32 depends on the hardware support for decimal floating-point operations. While generally efficient, it may be slower than binary floating-point operations on systems without dedicated decimal floating-point hardware. For high-volume financial calculations, the precision benefits often outweigh the potential performance impact."
},
{
  "function_name": "quantized64",
  "include_file": "math.h",
  "return_type": "_Decimal64",
  "parameter_types": ["_Decimal64", "_Decimal64"],
  "main_category": "Mathematical Operations",
  "sub_category": "Decimal Floating-Point Computation",
  "data_type_manipulated": "decimal floating-point",
  "description": "Quantizes a decimal floating-point number (_Decimal64) to the same exponent as another. Note: This is part of the optional decimal floating-point arithmetic support.",
  "extended_description": "The quantized64 function sets the quantum exponent of x to the quantum exponent of y, while trying to keep the value the same. This function provides higher precision than quantized32 and is particularly useful in financial or scientific calculations where more decimal places are needed while still requiring specific rounding or quantization.",
  "return_value": "Returns the quantized value of x with the quantum exponent of y.",
  "parameter_values": "x: The _Decimal64 value to be quantized.\ny: The _Decimal64 value whose quantum exponent will be used for quantizing x.",
  "function_prototype": "_Decimal64 quantized64(_Decimal64 x, _Decimal64 y);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    _Decimal64 x = 1.2345678901234567d64;\n    _Decimal64 y = 1.000000d64;\n    _Decimal64 result = quantized64(x, y);\n    \n    printf(\"Original x: %.16Df (quantum exponent: %d)\\n\", x, quantexpd64(x));\n    printf(\"y: %.16Df (quantum exponent: %d)\\n\", y, quantexpd64(y));\n    printf(\"Quantized x: %.16Df (quantum exponent: %d)\\n\", result, quantexpd64(result));\n\n    return 0;\n}",
          "explanation": "This example demonstrates how quantized64 adjusts the quantum exponent of x to match that of y, effectively rounding x to six decimal places.",
          "expectedOutput": "Original x: 1.2345678901234567 (quantum exponent: -16)\ny: 1.000000 (quantum exponent: -6)\nQuantized x: 1.234568 (quantum exponent: -6)"
      },
      {
          "title": "High Precision Financial Calculation",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    _Decimal64 principal = 1000000.00d64;\n    _Decimal64 rate = 0.0275d64;  // 2.75% annual interest rate\n    _Decimal64 time = 1.0d64 / 12.0d64;  // 1 month\n    \n    _Decimal64 interest = principal * rate * time;\n    _Decimal64 round_to = 0.01d64;  // Round to cents\n    \n    _Decimal64 rounded_interest = quantized64(interest, round_to);\n    \n    printf(\"Principal: %.2Df\\n\", principal);\n    printf(\"Monthly Interest (exact): %.10Df\\n\", interest);\n    printf(\"Monthly Interest (rounded): %.2Df\\n\", rounded_interest);\n\n    return 0;\n}",
          "explanation": "This example illustrates a high-precision financial calculation using _Decimal64, and demonstrates how quantized64 can be used to round the result to a specific number of decimal places (cents in this case).",
          "expectedOutput": "Principal: 1000000.00\nMonthly Interest (exact): 2291.6666666667\nMonthly Interest (rounded): 2291.67"
      }
  ],
  "related_functions": ["quantized32", "quantized128", "quantexpd64"],
  "performance_considerations": "The performance of quantized64 depends on the hardware support for decimal floating-point operations. It may be slower than binary floating-point operations on systems without dedicated decimal floating-point hardware. However, for financial and scientific calculations requiring exact decimal representation, the precision benefits often outweigh the potential performance impact. The _Decimal64 type provides a good balance between precision and performance for many applications."
},
{
  "function_name": "quantized128",
  "include_file": "math.h",
  "return_type": "_Decimal128",
  "parameter_types": ["_Decimal128", "_Decimal128"],
  "main_category": "Mathematical Operations",
  "sub_category": "Decimal Floating-Point Computation",
  "data_type_manipulated": "decimal floating-point",
  "description": "Quantizes a decimal floating-point number (_Decimal128) to the same exponent as another. Note: This is part of the optional decimal floating-point arithmetic support.",
  "extended_description": "The quantized128 function sets the quantum exponent of x to the quantum exponent of y, while trying to keep the value the same. This function provides the highest precision among the quantize family and is crucial for applications requiring extreme precision in decimal calculations, such as high-precision financial modeling or scientific computations.",
  "return_value": "Returns the quantized value of x with the quantum exponent of y.",
  "parameter_values": "x: The _Decimal128 value to be quantized.\ny: The _Decimal128 value whose quantum exponent will be used for quantizing x.",
  "function_prototype": "_Decimal128 quantized128(_Decimal128 x, _Decimal128 y);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    _Decimal128 x = 1.23456789012345678901234567890123456d128;\n    _Decimal128 y = 1.000000000000000d128;\n    _Decimal128 result = quantized128(x, y);\n    \n    printf(\"Original x: %.36DDf (quantum exponent: %d)\\n\", x, quantexpd128(x));\n    printf(\"y: %.36DDf (quantum exponent: %d)\\n\", y, quantexpd128(y));\n    printf(\"Quantized x: %.36DDf (quantum exponent: %d)\\n\", result, quantexpd128(result));\n\n    return 0;\n}",
          "explanation": "This example demonstrates how quantized128 adjusts the quantum exponent of x to match that of y, effectively rounding x to 15 decimal places.",
          "expectedOutput": "Original x: 1.234567890123456789012345678901234560 (quantum exponent: -36)\ny: 1.000000000000000000000000000000000000 (quantum exponent: -15)\nQuantized x: 1.234567890123457000000000000000000000 (quantum exponent: -15)"
      },
      {
          "title": "High Precision Scientific Calculation",
          "code": "#include <stdio.h>\n#include <math.h>\n\n_Decimal128 calculate_pi(_Decimal128 precision) {\n    _Decimal128 pi = 3.0d128;\n    _Decimal128 k = 1.0d128;\n    _Decimal128 x = 3.0d128;\n    _Decimal128 y = 1.0d128;\n    _Decimal128 term;\n\n    do {\n        k += 2.0d128;\n        x *= (k - 1.0d128) / k;\n        y *= (k - 2.0d128) / k;\n        term = x / y;\n        pi += term;\n    } while (quantized128(term, precision) != 0.0d128);\n\n    return quantized128(pi, precision);\n}\n\nint main() {\n    _Decimal128 precision = 1.0e-34d128;\n    _Decimal128 pi = calculate_pi(precision);\n    \n    printf(\"Pi calculated to 34 decimal places: %.34DDf\\n\", pi);\n    printf(\"Quantum exponent of the result: %d\\n\", quantexpd128(pi));\n\n    return 0;\n}",
          "explanation": "This example uses quantized128 in a high-precision calculation of π (pi). It demonstrates how quantized128 can be used to control the precision of intermediate calculations and the final result.",
          "expectedOutput": "Pi calculated to 34 decimal places: 3.1415926535897932384626433832795029\nQuantum exponent of the result: -34"
      }
  ],
  "related_functions": ["quantized32", "quantized64", "quantexpd128"],
  "performance_considerations": "The performance of quantized128 heavily depends on hardware support for decimal floating-point operations. On systems without dedicated decimal floating-point hardware, operations might be significantly slower compared to binary floating-point operations. The _Decimal128 type provides the highest precision among decimal types, which may impact performance in computationally intensive applications, but is essential for scenarios requiring extreme precision."
},
{
  "function_name": "samequantumd32",
  "include_file": "math.h",
  "return_type": "int",
  "parameter_types": ["_Decimal32", "_Decimal32"],
  "main_category": "Mathematical Operations",
  "sub_category": "Decimal Floating-Point Computation",
  "data_type_manipulated": "decimal floating-point",
  "description": "Checks if two _Decimal32 numbers have the same quantization (exponent). Note: This is part of the optional decimal floating-point arithmetic support.",
  "extended_description": "The samequantumd32 function determines whether two _Decimal32 numbers have the same quantum exponent. This is useful for ensuring that decimal numbers have the same precision, which is particularly important in financial calculations where consistent decimal places are required.",
  "return_value": "Returns a non-zero value (true) if x and y have the same quantum exponent, 0 (false) otherwise.",
  "parameter_values": "x: The first _Decimal32 value to compare.\ny: The second _Decimal32 value to compare.",
  "function_prototype": "int samequantumd32(_Decimal32 x, _Decimal32 y);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    _Decimal32 x = 1.23d32;\n    _Decimal32 y = 4.56d32;\n    _Decimal32 z = 7.890d32;\n    \n    printf(\"x = %Hg, y = %Hg, z = %Hg\\n\", x, y, z);\n    printf(\"Are x and y same quantum? %s\\n\", samequantumd32(x, y) ? \"Yes\" : \"No\");\n    printf(\"Are x and z same quantum? %s\\n\", samequantumd32(x, z) ? \"Yes\" : \"No\");\n    printf(\"Are y and z same quantum? %s\\n\", samequantumd32(y, z) ? \"Yes\" : \"No\");\n\n    return 0;\n}",
          "explanation": "This example demonstrates how samequantumd32 can be used to compare the quantum exponents of different _Decimal32 numbers.",
          "expectedOutput": "x = 1.23, y = 4.56, z = 7.890\nAre x and y same quantum? Yes\nAre x and z same quantum? No\nAre y and z same quantum? No"
      },
      {
          "title": "Financial Calculation Consistency Check",
          "code": "#include <stdio.h>\n#include <math.h>\n\nvoid check_price_consistency(_Decimal32 price1, _Decimal32 price2) {\n    if (!samequantumd32(price1, price2)) {\n        printf(\"Warning: Prices have different precisions!\\n\");\n        printf(\"Price 1: %Hg (quantum exponent: %d)\\n\", price1, quantexpd32(price1));\n        printf(\"Price 2: %Hg (quantum exponent: %d)\\n\", price2, quantexpd32(price2));\n    } else {\n        printf(\"Prices have consistent precision.\\n\");\n        printf(\"Price 1: %Hg\\n\", price1);\n        printf(\"Price 2: %Hg\\n\", price2);\n    }\n}\n\nint main() {\n    _Decimal32 price1 = 10.00d32;\n    _Decimal32 price2 = 20.00d32;\n    _Decimal32 price3 = 30.0d32;\n    \n    printf(\"Checking price1 and price2:\\n\");\n    check_price_consistency(price1, price2);\n    \n    printf(\"\\nChecking price1 and price3:\\n\");\n    check_price_consistency(price1, price3);\n\n    return 0;\n}",
          "explanation": "This example shows how samequantumd32 can be used in a financial context to ensure that prices are consistently represented with the same number of decimal places.",
          "expectedOutput": "Checking price1 and price2:\nPrices have consistent precision.\nPrice 1: 10.00\nPrice 2: 20.00\n\nChecking price1 and price3:\nWarning: Prices have different precisions!\nPrice 1: 10.00 (quantum exponent: -2)\nPrice 2: 30.0 (quantum exponent: -1)"
      }
  ],
  "related_functions": ["samequantumd64", "samequantumd128", "quantized32"],
  "performance_considerations": "samequantumd32 is generally a lightweight operation. However, its performance may depend on the hardware support for decimal floating-point operations. In most cases, the overhead of this function is negligible compared to actual decimal arithmetic operations."
},
{
  "function_name": "samequantumd64",
  "include_file": "math.h",
  "return_type": "int",
  "parameter_types": ["_Decimal64", "_Decimal64"],
  "main_category": "Mathematical Operations",
  "sub_category": "Decimal Floating-Point Computation",
  "data_type_manipulated": "decimal floating-point",
  "description": "Checks if two _Decimal64 numbers have the same quantization (exponent). Note: This is part of the optional decimal floating-point arithmetic support.",
  "extended_description": "The samequantumd64 function determines whether two _Decimal64 numbers have the same quantum exponent. This function is useful for ensuring that decimal numbers have the same precision, which is particularly important in financial or scientific calculations where consistent and high precision decimal places are required.",
  "return_value": "Returns a non-zero value (true) if x and y have the same quantum exponent, 0 (false) otherwise.",
  "parameter_values": "x: The first _Decimal64 value to compare.\ny: The second _Decimal64 value to compare.",
  "function_prototype": "int samequantumd64(_Decimal64 x, _Decimal64 y);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    _Decimal64 x = 1.23456789d64;\n    _Decimal64 y = 9.87654321d64;\n    _Decimal64 z = 1.234567890d64;\n    \n    printf(\"x = %.9Df, y = %.9Df, z = %.9Df\\n\", x, y, z);\n    printf(\"Are x and y same quantum? %s\\n\", samequantumd64(x, y) ? \"Yes\" : \"No\");\n    printf(\"Are x and z same quantum? %s\\n\", samequantumd64(x, z) ? \"Yes\" : \"No\");\n    printf(\"Are y and z same quantum? %s\\n\", samequantumd64(y, z) ? \"Yes\" : \"No\");\n\n    return 0;\n}",
          "explanation": "This example demonstrates how samequantumd64 can be used to compare the quantum exponents of different _Decimal64 numbers with varying precisions.",
          "expectedOutput": "x = 1.234567890, y = 9.876543210, z = 1.234567890\nAre x and y same quantum? Yes\nAre x and z same quantum? No\nAre y and z same quantum? No"
      },
      {
          "title": "Scientific Calculation Precision Check",
          "code": "#include <stdio.h>\n#include <math.h>\n\n_Decimal64 calculate_with_precision(_Decimal64 value, _Decimal64 precision) {\n    return quantized64(value, precision);\n}\n\nvoid compare_results(_Decimal64 result1, _Decimal64 result2, _Decimal64 expected_precision) {\n    printf(\"Result 1: %.15Df\\n\", result1);\n    printf(\"Result 2: %.15Df\\n\", result2);\n    \n    if (!samequantumd64(result1, expected_precision) || !samequantumd64(result2, expected_precision)) {\n        printf(\"Warning: Results have unexpected precision!\\n\");\n        printf(\"Result 1 quantum exp: %d, Result 2 quantum exp: %d, Expected: %d\\n\",\n               quantexpd64(result1), quantexpd64(result2), quantexpd64(expected_precision));\n    } else if (!samequantumd64(result1, result2)) {\n        printf(\"Warning: Results have different precisions!\\n\");\n    } else {\n        printf(\"Results have consistent and expected precision.\\n\");\n    }\n}\n\nint main() {\n    _Decimal64 value1 = 1.23456789d64;\n    _Decimal64 value2 = 9.87654321d64;\n    _Decimal64 precision = 0.0000001d64;\n    \n    _Decimal64 result1 = calculate_with_precision(value1, precision);\n    _Decimal64 result2 = calculate_with_precision(value2, precision);\n    \n    compare_results(result1, result2, precision);\n\n    return 0;\n}",
          "explanation": "This example illustrates how samequantumd64 can be used in scientific calculations to ensure consistent precision across different computations and to verify that results match the expected precision.",
          "expectedOutput": "Result 1: 1.234567900000000\nResult 2: 9.876543200000000\nResults have consistent and expected precision."
      }
  ],
  "related_functions": ["samequantumd32", "samequantumd128", "quantized64"],
  "performance_considerations": "samequantumd64 is generally a lightweight operation. However, its performance may depend on the hardware support for decimal floating-point operations. In most cases, the overhead of this function is negligible compared to actual decimal arithmetic operations. The _Decimal64 type provides a good balance between precision and performance for many high-precision applications."
},
{
  "function_name": "samequantumd128",
  "include_file": "math.h",
  "return_type": "int",
  "parameter_types": ["_Decimal128", "_Decimal128"],
  "main_category": "Mathematical Operations",
  "sub_category": "Decimal Floating-Point Computation",
  "data_type_manipulated": "decimal floating-point",
  "description": "Checks if two _Decimal128 numbers have the same quantization (exponent). Note: This is part of the optional decimal floating-point arithmetic support.",
  "extended_description": "The samequantumd128 function determines whether two _Decimal128 numbers have the same quantum exponent. This function is crucial for ensuring that decimal numbers have the same precision, which is particularly important in high-precision scientific calculations or financial computations where consistent and extremely high precision decimal places are required.",
  "return_value": "Returns a non-zero value (true) if x and y have the same quantum exponent, 0 (false) otherwise.",
  "parameter_values": "x: The first _Decimal128 value to compare.\ny: The second _Decimal128 value to compare.",
  "function_prototype": "int samequantumd128(_Decimal128 x, _Decimal128 y);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    _Decimal128 x = 1.23456789012345678901234567890123456d128;\n    _Decimal128 y = 9.87654321098765432109876543210987654d128;\n    _Decimal128 z = 1.2345678901234567890123456789012345d128;\n    \n    printf(\"x = %.36DDf\\ny = %.36DDf\\nz = %.36DDf\\n\", x, y, z);\n    printf(\"Are x and y same quantum? %s\\n\", samequantumd128(x, y) ? \"Yes\" : \"No\");\n    printf(\"Are x and z same quantum? %s\\n\", samequantumd128(x, z) ? \"Yes\" : \"No\");\n    printf(\"Are y and z same quantum? %s\\n\", samequantumd128(y, z) ? \"Yes\" : \"No\");\n\n    return 0;\n}",
          "explanation": "This example demonstrates how samequantumd128 can be used to compare the quantum exponents of different _Decimal128 numbers with varying precisions.",
          "expectedOutput": "x = 1.234567890123456789012345678901234560\ny = 9.876543210987654321098765432109876540\nz = 1.234567890123456789012345678901234500\nAre x and y same quantum? Yes\nAre x and z same quantum? No\nAre y and z same quantum? No"
      },
      {
          "title": "High-Precision Scientific Calculation",
          "code": "#include <stdio.h>\n#include <math.h>\n\n_Decimal128 calculate_pi(_Decimal128 precision) {\n    _Decimal128 pi = 3.0d128;\n    _Decimal128 n = 2.0d128;\n    _Decimal128 term;\n    \n    do {\n        term = 4.0d128 / (n * (n + 1.0d128) * (n + 2.0d128));\n        if (n % 4.0d128 == 0.0d128) pi += term;\n        else pi -= term;\n        n += 2.0d128;\n    } while (!samequantumd128(term, precision) || fabsd128(term) > precision);\n    \n    return quantized128(pi, precision);\n}\n\nint main() {\n    _Decimal128 precision = 1.0e-35d128;\n    _Decimal128 pi = calculate_pi(precision);\n    \n    printf(\"Calculated pi: %.35DDf\\n\", pi);\n    printf(\"Quantum exponent: %d\\n\", quantexpd128(pi));\n    printf(\"Same quantum as precision: %s\\n\", samequantumd128(pi, precision) ? \"Yes\" : \"No\");\n\n    return 0;\n}",
          "explanation": "This example uses samequantumd128 in a high-precision calculation of π (pi). It demonstrates how samequantumd128 can be used to control the precision of the calculation and verify the final result's precision.",
          "expectedOutput": "Calculated pi: 3.14159265358979323846264338327950288\nQuantum exponent: -35\nSame quantum as precision: Yes"
      }
  ],
  "related_functions": ["samequantumd32", "samequantumd64", "quantized128"],
  "performance_considerations": "samequantumd128 is generally a lightweight operation. However, its performance may depend on the hardware support for decimal floating-point operations. In most cases, the overhead of this function is negligible compared to actual decimal arithmetic operations. The _Decimal128 type provides the highest precision among decimal types, which may impact overall performance in computationally intensive applications, but is essential for scenarios requiring extreme precision."
},
{
  "function_name": "raise",
  "include_file": "signal.h",
  "return_type": "int",
  "parameter_types": ["int"],
  "main_category": "Error Handling and Debugging",
  "sub_category": "Signal Processing",
  "data_type_manipulated": "process signals",
  "description": "Sends a signal to the current process.",
  "extended_description": "The raise function sends a signal to the executing program. It can be used to simulate the reception of a signal, which is useful for testing signal handlers or triggering specific behavior in a program. This function is part of the signal handling mechanism in C and is often used in conjunction with signal() or sigaction() for managing program behavior in response to various events or conditions.",
  "return_value": "Returns 0 if successful, non-zero if an error occurred.",
  "parameter_values": "sig: The signal number to be sent. Common signals include SIGINT, SIGTERM, SIGABRT, etc.",
  "function_prototype": "int raise(int sig);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <signal.h>\n\nvoid signal_handler(int signum) {\n    printf(\"Received signal %d\\n\", signum);\n}\n\nint main() {\n    signal(SIGINT, signal_handler);\n    \n    printf(\"Raising SIGINT...\\n\");\n    if (raise(SIGINT) != 0) {\n        fprintf(stderr, \"Error raising SIGINT\\n\");\n        return 1;\n    }\n    \n    printf(\"Program continues after handling SIGINT\\n\");\n    return 0;\n}",
          "explanation": "This example demonstrates how to use raise to send a SIGINT signal to the program. It first sets up a signal handler for SIGINT, then uses raise to send the signal, triggering the handler.",
          "expectedOutput": "Raising SIGINT...\nReceived signal 2\nProgram continues after handling SIGINT"
      },
      {
          "title": "Using raise for Program Termination",
          "code": "#include <stdio.h>\n#include <signal.h>\n#include <stdlib.h>\n\nvoid cleanup() {\n    printf(\"Performing cleanup before exit\\n\");\n}\n\nvoid termination_handler(int signum) {\n    printf(\"Termination signal received. Cleaning up...\\n\");\n    cleanup();\n    exit(1);\n}\n\nint main() {\n    signal(SIGTERM, termination_handler);\n    \n    printf(\"Program running...\\n\");\n    \n    // Simulate some condition that requires program termination\n    if (/* some condition */) {\n        printf(\"Condition met. Raising SIGTERM...\\n\");\n        raise(SIGTERM);\n    }\n    \n    printf(\"This line will not be reached if SIGTERM is raised\\n\");\n    return 0;\n}",
          "explanation": "This example shows how raise can be used to trigger a controlled termination of a program. It sets up a handler for SIGTERM that performs cleanup before exiting.",
          "expectedOutput": "Program running...\nCondition met. Raising SIGTERM...\nTermination signal received. Cleaning up...\nPerforming cleanup before exit"
      }
  ],
  "related_functions": ["signal", "sigaction", "kill"],
  "performance_considerations": "raise is generally efficient for sending signals within the same process. However, excessive use of signals for control flow can make a program harder to understand and debug. In multi-threaded programs, be aware that signal handling can be complex and may lead to race conditions if not carefully managed."
},
{
  "function_name": "rand",
  "include_file": "stdlib.h",
  "return_type": "int",
  "parameter_types": [],
  "main_category": "Mathematical Operations",
  "sub_category": "Random Number Generation",
  "data_type_manipulated": "none",
  "description": "Generates a pseudo-random number.",
  "extended_description": "The rand function returns a pseudo-random integer in the range 0 to RAND_MAX inclusive (i.e., the mathematical range [0, RAND_MAX]). RAND_MAX is guaranteed to be at least 32767. The rand function uses a deterministic algorithm to generate numbers, which means that the sequence of numbers will be the same each time the program is run unless the random number generator is seeded differently using srand().",
  "return_value": "Returns a pseudo-random integer between 0 and RAND_MAX, inclusive.",
  "parameter_values": "This function takes no parameters.",
  "function_prototype": "int rand(void);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint main() {\n    // Seed the random number generator\n    srand(time(NULL));\n    \n    printf(\"Five random numbers:\\n\");\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d\\n\", rand());\n    }\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of rand(). It first seeds the random number generator using the current time, then generates and prints five random numbers.",
          "expectedOutput": "Five random numbers:\n1804289383\n846930886\n1681692777\n1714636915\n1957747793\n\nNote: The actual numbers will vary each time the program is run."
      },
      {
          "title": "Generating Random Numbers in a Specific Range",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n// Function to generate a random number between min and max (inclusive)\nint random_range(int min, int max) {\n    return min + rand() / (RAND_MAX / (max - min + 1) + 1);\n}\n\nint main() {\n    srand(time(NULL));\n    \n    printf(\"10 random numbers between 1 and 100:\\n\");\n    for (int i = 0; i < 10; i++) {\n        printf(\"%d \", random_range(1, 100));\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "explanation": "This example shows how to use rand() to generate random numbers within a specific range. The random_range function scales and shifts the output of rand() to fit within the desired range.",
          "expectedOutput": "10 random numbers between 1 and 100:\n42 87 11 94 68 32 76 19 54 61\n\nNote: The actual numbers will vary each time the program is run."
      }
  ],
  "related_functions": ["srand", "random", "drand48"],
  "performance_considerations": "rand() is generally fast but may not be suitable for applications requiring high-quality random numbers or cryptographic purposes. For better statistical properties or for generating random floating-point numbers, consider using more advanced random number generators. Also, remember to seed the generator only once at the start of your program, not before each call to rand()."
},
{
  "function_name": "rand_r",
  "include_file": "stdlib.h",
  "return_type": "int",
  "parameter_types": ["unsigned int*"],
  "main_category": "Mathematical Operations",
  "sub_category": "Random Number Generation",
  "data_type_manipulated": "none",
  "description": "Generates a pseudo-random number using a given seed, thread-safe.",
  "extended_description": "The rand_r function is a reentrant version of rand(). It uses the provided seed to generate a pseudo-random number, making it suitable for multi-threaded applications. Each call modifies the seed, which should be used in subsequent calls to maintain the random sequence. This function is thread-safe because it doesn't rely on global state.",
  "return_value": "Returns a pseudo-random integer between 0 and RAND_MAX, inclusive.",
  "parameter_values": "seedp: Pointer to an unsigned int that serves as the seed for the random number generator.",
  "function_prototype": "int rand_r(unsigned int *seedp);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint main() {\n    unsigned int seed = (unsigned int)time(NULL);\n    \n    printf(\"Five random numbers:\\n\");\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d\\n\", rand_r(&seed));\n    }\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of rand_r(). It initializes the seed with the current time and generates five random numbers.",
          "expectedOutput": "Five random numbers:\n1804289383\n846930886\n1681692777\n1714636915\n1957747793\n\nNote: The actual numbers will vary each time the program is run."
      },
      {
          "title": "Thread-Safe Random Number Generation",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <time.h>\n\n#define NUM_THREADS 3\n#define NUMBERS_PER_THREAD 5\n\nvoid *generate_random_numbers(void *arg) {\n    unsigned int seed = *(unsigned int*)arg;\n    int thread_id = seed % NUM_THREADS;\n    \n    printf(\"Thread %d random numbers:\\n\", thread_id);\n    for (int i = 0; i < NUMBERS_PER_THREAD; i++) {\n        printf(\"%d \", rand_r(&seed));\n    }\n    printf(\"\\n\");\n    \n    return NULL;\n}\n\nint main() {\n    pthread_t threads[NUM_THREADS];\n    unsigned int seeds[NUM_THREADS];\n    \n    for (int i = 0; i < NUM_THREADS; i++) {\n        seeds[i] = (unsigned int)time(NULL) + i;\n        pthread_create(&threads[i], NULL, generate_random_numbers, &seeds[i]);\n    }\n    \n    for (int i = 0; i < NUM_THREADS; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    \n    return 0;\n}",
          "explanation": "This example demonstrates how rand_r() can be used in a multi-threaded environment. Each thread generates its own sequence of random numbers using a unique seed.",
          "expectedOutput": "Thread 0 random numbers:\n1804289383 846930886 1681692777 1714636915 1957747793\nThread 1 random numbers:\n424238335 719885386 1649760492 596516649 1189641421\nThread 2 random numbers:\n1025202362 1350490027 783368690 1102520059 2044897763\n\nNote: The actual numbers and order of thread outputs may vary."
      },
      {
          "title": "Generating Random Numbers in a Specific Range",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint random_range(unsigned int *seedp, int min, int max) {\n    return min + rand_r(seedp) / (RAND_MAX / (max - min + 1) + 1);\n}\n\nint main() {\n    unsigned int seed = (unsigned int)time(NULL);\n    \n    printf(\"10 random numbers between 1 and 100:\\n\");\n    for (int i = 0; i < 10; i++) {\n        printf(\"%d \", random_range(&seed, 1, 100));\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "explanation": "This example shows how to use rand_r() to generate random numbers within a specific range. The random_range function scales and shifts the output of rand_r() to fit within the desired range.",
          "expectedOutput": "10 random numbers between 1 and 100:\n42 87 11 94 68 32 76 19 54 61\n\nNote: The actual numbers will vary each time the program is run."
      }
  ],
  "related_functions": ["rand", "srand", "random"],
  "performance_considerations": "rand_r() is generally fast and thread-safe, making it suitable for multi-threaded applications. However, like rand(), it may not be suitable for applications requiring high-quality random numbers or for cryptographic purposes. For better statistical properties or for generating random floating-point numbers, consider using more advanced random number generators."
},
{
  "function_name": "realloc",
  "include_file": "stdlib.h",
  "return_type": "void*",
  "parameter_types": ["void*", "size_t"],
  "main_category": "Memory Management",
  "sub_category": "Allocation",
  "data_type_manipulated": "memory",
  "description": "Changes the size of the memory block pointed to by ptr.",
  "extended_description": "The realloc function changes the size of the memory block pointed to by ptr to size bytes. The contents of the memory block are preserved up to the lesser of the new and old sizes. If the new size is larger, the value of the newly allocated portion is indeterminate. If ptr is NULL, the call is equivalent to malloc(size). If size is zero and ptr is not NULL, the call is equivalent to free(ptr).",
  "return_value": "Returns a pointer to the newly allocated memory, or NULL if the request fails. The returned pointer may be the same as ptr if the allocation was not moved, or a different pointer if it was moved.",
  "parameter_values": "ptr: Pointer to a memory block previously allocated with malloc, calloc or realloc.\nsize: New size for the memory block, in bytes.",
  "function_prototype": "void *realloc(void *ptr, size_t size);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *array = malloc(5 * sizeof(int));\n    if (array == NULL) {\n        fprintf(stderr, \"Initial memory allocation failed\\n\");\n        return 1;\n    }\n    \n    for (int i = 0; i < 5; i++) {\n        array[i] = i * 10;\n    }\n    \n    int *new_array = realloc(array, 10 * sizeof(int));\n    if (new_array == NULL) {\n        fprintf(stderr, \"Memory reallocation failed\\n\");\n        free(array);\n        return 1;\n    }\n    \n    array = new_array;\n    \n    for (int i = 5; i < 10; i++) {\n        array[i] = i * 10;\n    }\n    \n    for (int i = 0; i < 10; i++) {\n        printf(\"%d \", array[i]);\n    }\n    printf(\"\\n\");\n    \n    free(array);\n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of realloc(). It allocates memory for 5 integers, initializes them, then reallocates memory for 10 integers, preserving the original data and adding new data.",
          "expectedOutput": "0 10 20 30 40 50 60 70 80 90"
      },
      {
          "title": "Shrinking Memory Block",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *array = malloc(10 * sizeof(int));\n    if (array == NULL) {\n        fprintf(stderr, \"Initial memory allocation failed\\n\");\n        return 1;\n    }\n    \n    for (int i = 0; i < 10; i++) {\n        array[i] = i * 10;\n    }\n    \n    printf(\"Original array: \");\n    for (int i = 0; i < 10; i++) {\n        printf(\"%d \", array[i]);\n    }\n    printf(\"\\n\");\n    \n    int *new_array = realloc(array, 5 * sizeof(int));\n    if (new_array == NULL) {\n        fprintf(stderr, \"Memory reallocation failed\\n\");\n        free(array);\n        return 1;\n    }\n    \n    array = new_array;\n    \n    printf(\"Shrunk array: \");\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", array[i]);\n    }\n    printf(\"\\n\");\n    \n    free(array);\n    return 0;\n}",
          "explanation": "This example shows how realloc() can be used to shrink a memory block. It allocates memory for 10 integers, then reallocates it to hold only 5 integers.",
          "expectedOutput": "Original array: 0 10 20 30 40 50 60 70 80 90\nShrunk array: 0 10 20 30 40"
      },
      {
          "title": "Handling Reallocation Failure",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *array = malloc(5 * sizeof(int));\n    if (array == NULL) {\n        fprintf(stderr, \"Initial memory allocation failed\\n\");\n        return 1;\n    }\n    \n    for (int i = 0; i < 5; i++) {\n        array[i] = i * 10;\n    }\n    \n    int *temp = realloc(array, 1000000000 * sizeof(int)); // Attempt to allocate a very large amount of memory\n    if (temp == NULL) {\n        fprintf(stderr, \"Memory reallocation failed. Original array intact.\\n\");\n        printf(\"Original array: \");\n        for (int i = 0; i < 5; i++) {\n            printf(\"%d \", array[i]);\n        }\n        printf(\"\\n\");\n        free(array);\n    } else {\n        array = temp;\n        printf(\"Reallocation succeeded (unlikely with this large size).\\n\");\n        free(array);\n    }\n    \n    return 0;\n}",
          "explanation": "This example demonstrates how to handle potential reallocation failure. It attempts to reallocate a very large amount of memory, which is likely to fail. It shows how to preserve the original data in case of failure.",
          "expectedOutput": "Memory reallocation failed. Original array intact.\nOriginal array: 0 10 20 30 40"
      }
  ],
  "related_functions": ["malloc", "calloc", "free"],
  "performance_considerations": "realloc() can be expensive if it needs to move the memory block, as it involves allocating new memory and copying the old content. For frequent small increases in size, it may be more efficient to allocate a larger block initially. Also, always assign the result of realloc() to a temporary pointer first to avoid losing the original pointer in case of failure."
},
{
  "function_name": "regcomp",
  "include_file": "regex.h",
  "return_type": "int",
  "parameter_types": ["regex_t*", "const char*", "int"],
  "main_category": "Data Search and Sorting",
  "sub_category": "Regular Expression Handling",
  "data_type_manipulated": "regular expressions",
  "description": "Compiles a regular expression into a form that can be used for pattern matching.",
  "extended_description": "The regcomp function compiles the regular expression contained in the string pointed to by pattern and places the results in the structure pointed to by preg. This compiled form can then be used with regexec() for string pattern matching.",
  "return_value": "Returns 0 for a successful compilation. Non-zero error codes are returned for various errors, which can be interpreted using regerror().",
  "parameter_values": "preg: Pointer to a regex_t structure to store the compiled regular expression.\npattern: String containing the regular expression to be compiled.\ncflags: Bitwise OR of flags controlling compilation (e.g., REG_EXTENDED, REG_ICASE, REG_NOSUB).",
  "function_prototype": "int regcomp(regex_t *preg, const char *pattern, int cflags);",
  "examples": [
    {
      "title": "Basic Usage",
      "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <regex.h>\n\nint main() {\n    regex_t regex;\n    int ret;\n\n    ret = regcomp(&regex, \"^a[[:alnum:]]+\", REG_EXTENDED);\n    if (ret) {\n        fprintf(stderr, \"Could not compile regex\\n\");\n        exit(1);\n    }\n\n    ret = regexec(&regex, \"abcdef\", 0, NULL, 0);\n    if (!ret) {\n        printf(\"Pattern matches\\n\");\n    } else if (ret == REG_NOMATCH) {\n        printf(\"Pattern does not match\\n\");\n    } else {\n        char error_message[100];\n        regerror(ret, &regex, error_message, sizeof(error_message));\n        fprintf(stderr, \"Regex match failed: %s\\n\", error_message);\n        exit(1);\n    }\n\n    regfree(&regex);\n    return 0;\n}",
      "explanation": "This example demonstrates basic usage of regcomp(). It compiles a regular expression that matches strings starting with 'a' followed by alphanumeric characters, then tests it against the string 'abcdef'.",
      "expectedOutput": "Pattern matches"
    },
    {
      "title": "Case-Insensitive Matching",
      "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <regex.h>\n\nint main() {\n    regex_t regex;\n    int ret;\n\n    ret = regcomp(&regex, \"hello\", REG_ICASE);\n    if (ret) {\n        fprintf(stderr, \"Could not compile regex\\n\");\n        exit(1);\n    }\n\n    const char *test_strings[] = {\"hello\", \"HELLO\", \"Hello, World!\", \"goodbye\"};\n    int num_strings = sizeof(test_strings) / sizeof(test_strings[0]);\n\n    for (int i = 0; i < num_strings; i++) {\n        ret = regexec(&regex, test_strings[i], 0, NULL, 0);\n        if (!ret) {\n            printf(\"\\\"%s\\\" matches\\n\", test_strings[i]);\n        } else if (ret == REG_NOMATCH) {\n            printf(\"\\\"%s\\\" does not match\\n\", test_strings[i]);\n        } else {\n            char error_message[100];\n            regerror(ret, &regex, error_message, sizeof(error_message));\n            fprintf(stderr, \"Regex match failed: %s\\n\", error_message);\n            exit(1);\n        }\n    }\n\n    regfree(&regex);\n    return 0;\n}",
      "explanation": "This example shows how to use regcomp() with the REG_ICASE flag for case-insensitive matching. It compiles a regex for 'hello' and tests it against various strings.",
      "expectedOutput": "\"hello\" matches\n\"HELLO\" matches\n\"Hello, World!\" matches\n\"goodbye\" does not match"
    }
  ],
  "related_functions": ["regexec", "regfree", "regerror"],
  "performance_considerations": "Compiling regular expressions can be computationally expensive, especially for complex patterns. It's generally a good practice to compile regular expressions once and reuse the compiled form for multiple matches, rather than recompiling the same pattern repeatedly."
},

  {
    "function_name": "regerror",
    "include_file": "regex.h",
    "return_type": "size_t",
    "parameter_types": ["int", "const regex_t*", "char*", "size_t"],
    "main_category": "Data Search and Sorting",
    "sub_category": "Regular Expression Handling",
    "data_type_manipulated": "error messages",
    "description": "Produces a human-readable error message based on the error code from regcomp or regexec.",
    "extended_description": "The regerror function is used to generate a human-readable string describing the error code returned by regcomp or regexec. It's an essential part of error handling in regular expression operations.",
    "return_value": "Returns the size of the error message string, including the null terminator.",
    "parameter_values": "errcode: The error code returned by regcomp or regexec.\npreg: Pointer to the regex_t structure (can be NULL).\nerrbuf: Buffer to store the error message.\nerrbuf_size: Size of the error buffer.",
    "function_prototype": "size_t regerror(int errcode, const regex_t *preg, char *errbuf, size_t errbuf_size);",
    "examples": [
      {
        "title": "Basic Usage",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <regex.h>\n\nint main() {\n    regex_t regex;\n    int ret;\n    char error_message[256];\n\n    ret = regcomp(&regex, \"[a-z\", REG_EXTENDED);\n    if (ret) {\n        regerror(ret, &regex, error_message, sizeof(error_message));\n        fprintf(stderr, \"Regex compilation failed: %s\\n\", error_message);\n        return 1;\n    }\n\n    regfree(&regex);\n    return 0;\n}",
        "explanation": "This example demonstrates how to use regerror to get a human-readable error message when regex compilation fails.",
        "expectedOutput": "Regex compilation failed: Unmatched [ or [^"
      },
      {
        "title": "Error Handling in Regex Execution",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <regex.h>\n\nint main() {\n    regex_t regex;\n    int ret;\n    char error_message[256];\n\n    ret = regcomp(&regex, \"a+b+c+\", REG_EXTENDED);\n    if (ret) {\n        regerror(ret, &regex, error_message, sizeof(error_message));\n        fprintf(stderr, \"Regex compilation failed: %s\\n\", error_message);\n        return 1;\n    }\n\n    ret = regexec(&regex, \"aaabbbcc\", 0, NULL, 0);\n    if (ret != 0 && ret != REG_NOMATCH) {\n        regerror(ret, &regex, error_message, sizeof(error_message));\n        fprintf(stderr, \"Regex match failed: %s\\n\", error_message);\n        regfree(&regex);\n        return 1;\n    }\n\n    printf(\"Regex match %s\\n\", (ret == 0) ? \"succeeded\" : \"failed\");\n\n    regfree(&regex);\n    return 0;\n}",
        "explanation": "This example shows how to use regerror for handling errors during regex execution (regexec).",
        "expectedOutput": "Regex match succeeded"
      }
    ],
    "related_functions": ["regcomp", "regexec", "regfree"],
    "performance_considerations": "regerror is typically used for error reporting and debugging, so its performance is generally not critical. However, for applications with frequent regex operations, consider caching error messages for common error codes to reduce repeated calls to regerror."
  },
  {
    "function_name": "regexec",
    "include_file": "regex.h",
    "return_type": "int",
    "parameter_types": ["const regex_t*", "const char*", "size_t", "regmatch_t*", "int"],
    "main_category": "Data Search and Sorting",
    "sub_category": "Regular Expression Handling",
    "data_type_manipulated": "regular expressions",
    "description": "Matches a null-terminated string against the precompiled pattern buffer specified by regex_t.",
    "extended_description": "The regexec function is used to match a null-terminated string against a precompiled regular expression. It can optionally provide information about the location of the match and any captured subexpressions.",
    "return_value": "Returns 0 for a successful match, REG_NOMATCH for no match, or other non-zero values for errors.",
    "parameter_values": "preg: Pointer to the compiled regular expression.\nstring: The string to match against the regular expression.\nnmatch: Number of elements in the pmatch array.\npmatch: Array where substring matches will be stored.\neflags: Execution flags (e.g., REG_NOTBOL, REG_NOTEOL).",
    "function_prototype": "int regexec(const regex_t *preg, const char *string, size_t nmatch, regmatch_t pmatch[], int eflags);",
    "examples": [
      {
        "title": "Basic Matching",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <regex.h>\n\nint main() {\n    regex_t regex;\n    int ret;\n    char msgbuf[100];\n\n    ret = regcomp(&regex, \"a[bc]+d\", REG_EXTENDED);\n    if (ret) {\n        fprintf(stderr, \"Could not compile regex\\n\");\n        exit(1);\n    }\n\n    ret = regexec(&regex, \"abbbcd\", 0, NULL, 0);\n    if (!ret) {\n        puts(\"Match\");\n    }\n    else if (ret == REG_NOMATCH) {\n        puts(\"No match\");\n    }\n    else {\n        regerror(ret, &regex, msgbuf, sizeof(msgbuf));\n        fprintf(stderr, \"Regex match failed: %s\\n\", msgbuf);\n        exit(1);\n    }\n\n    regfree(&regex);\n    return 0;\n}",
        "explanation": "This example demonstrates basic usage of regexec to match a string against a compiled regular expression.",
        "expectedOutput": "Match"
      },
      {
        "title": "Capturing Subexpressions",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <regex.h>\n#include <string.h>\n\n#define MAX_MATCHES 10\n\nint main() {\n    regex_t regex;\n    regmatch_t matches[MAX_MATCHES];\n    char msgbuf[100];\n    int ret;\n\n    ret = regcomp(&regex, \"([a-z]+)=([0-9]+)\", REG_EXTENDED);\n    if (ret) {\n        fprintf(stderr, \"Could not compile regex\\n\");\n        exit(1);\n    }\n\n    const char *string = \"key1=123 key2=456\";\n    ret = regexec(&regex, string, MAX_MATCHES, matches, 0);\n    if (!ret) {\n        printf(\"Match found\\n\");\n        for (int i = 0; i < MAX_MATCHES && matches[i].rm_so != -1; i++) {\n            int start = matches[i].rm_so;\n            int end = matches[i].rm_eo;\n            int length = end - start;\n            char *substr = malloc(length + 1);\n            strncpy(substr, string + start, length);\n            substr[length] = '\\0';\n            printf(\"Match %d: %s\\n\", i, substr);\n            free(substr);\n        }\n    } else if (ret == REG_NOMATCH) {\n        puts(\"No match\");\n    } else {\n        regerror(ret, &regex, msgbuf, sizeof(msgbuf));\n        fprintf(stderr, \"Regex match failed: %s\\n\", msgbuf);\n        exit(1);\n    }\n\n    regfree(&regex);\n    return 0;\n}",
        "explanation": "This example shows how to use regexec with capturing groups to extract subexpressions from the matched string.",
        "expectedOutput": "Match found\nMatch 0: key1=123\nMatch 1: key1\nMatch 2: 123"
      }
    ],
    "related_functions": ["regcomp", "regerror", "regfree"],
    "performance_considerations": "For performance-critical applications, compile the regex once and reuse it for multiple matches. Avoid using capturing groups unnecessarily if you don't need the captured text, as this can impact performance."
  },
  {
    "function_name": "regfree",
    "include_file": "regex.h",
    "return_type": "void",
    "parameter_types": ["regex_t*"],
    "main_category": "Data Search and Sorting",
    "sub_category": "Regular Expression Handling",
    "data_type_manipulated": "regular expressions",
    "description": "Frees any memory allocated by regcomp for the compiled regular expression.",
    "extended_description": "The regfree function is used to deallocate any memory that was allocated by regcomp when compiling a regular expression. It should be called when the compiled regular expression is no longer needed to prevent memory leaks.",
    "return_value": "This function does not return a value.",
    "parameter_values": "preg: Pointer to the regex_t structure containing the compiled regular expression.",
    "function_prototype": "void regfree(regex_t *preg);",
    "examples": [
      {
        "title": "Basic Usage",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <regex.h>\n\nint main() {\n    regex_t regex;\n    int ret;\n\n    ret = regcomp(&regex, \"a[bc]+d\", REG_EXTENDED);\n    if (ret) {\n        fprintf(stderr, \"Could not compile regex\\n\");\n        exit(1);\n    }\n\n    // Use the regex here\n    ret = regexec(&regex, \"abbbcd\", 0, NULL, 0);\n    if (!ret) {\n        puts(\"Match\");\n    } else if (ret == REG_NOMATCH) {\n        puts(\"No match\");\n    }\n\n    // Free the memory allocated for the regex\n    regfree(&regex);\n\n    return 0;\n}",
        "explanation": "This example demonstrates the basic usage of regfree to deallocate memory after using a compiled regular expression.",
        "expectedOutput": "Match"
      },
      {
        "title": "Multiple Regex Compilation and Deallocation",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <regex.h>\n\nint compile_and_execute(const char *pattern, const char *string) {\n    regex_t regex;\n    int ret;\n\n    ret = regcomp(&regex, pattern, REG_EXTENDED);\n    if (ret) {\n        fprintf(stderr, \"Could not compile regex: %s\\n\", pattern);\n        return -1;\n    }\n\n    ret = regexec(&regex, string, 0, NULL, 0);\n    \n    regfree(&regex);  // Free memory before returning\n\n    return (ret == 0) ? 1 : 0;\n}\n\nint main() {\n    const char *patterns[] = {\"a[bc]+d\", \"[0-9]+\", \"[A-Z]+\"};\n    const char *strings[] = {\"abbbcd\", \"123\", \"ABC\"};\n    int n = sizeof(patterns) / sizeof(patterns[0]);\n\n    for (int i = 0; i < n; i++) {\n        int result = compile_and_execute(patterns[i], strings[i]);\n        printf(\"Pattern '%s' %s string '%s'\\n\", \n               patterns[i], \n               (result == 1) ? \"matches\" : \"does not match\", \n               strings[i]);\n    }\n\n    return 0;\n}",
        "explanation": "This example shows how to use regfree in a function that compiles, executes, and then frees a regex for multiple patterns. It demonstrates proper memory management when working with multiple regular expressions.",
        "expectedOutput": "Pattern 'a[bc]+d' matches string 'abbbcd'\nPattern '[0-9]+' matches string '123'\nPattern '[A-Z]+' matches string 'ABC'"
      }
    ],
    "related_functions": ["regcomp", "regexec", "regerror"],
    "performance_considerations": "Always call regfree after you're done with a compiled regular expression to prevent memory leaks. In long-running programs that use many regular expressions, failing to call regfree can lead to significant memory consumption over time."
  },
  
    {
      "function_name": "remove",
      "include_file": "stdio.h",
      "return_type": "int",
      "parameter_types": ["const char*"],
      "main_category": "File and I/O Operations",
      "sub_category": "File Management",
      "data_type_manipulated": "files",
      "description": "Deletes a file.",
      "extended_description": "The remove function deletes the file specified by the filename. If the file is currently open, the behavior of the remove function is implementation-defined. This function can also be used to remove empty directories on some systems.",
      "return_value": "Returns 0 if the file was successfully deleted, non-zero if an error occurred.",
      "parameter_values": "filename: A string containing the name of the file to be deleted.",
      "function_prototype": "int remove(const char *filename);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"test.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error creating file\");\n        return 1;\n    }\n    fprintf(file, \"This is a test file.\");\n    fclose(file);\n\n    printf(\"Attempting to delete test.txt\\n\");\n    if (remove(\"test.txt\") == 0) {\n        printf(\"File deleted successfully.\\n\");\n    } else {\n        perror(\"Error deleting file\");\n        return 1;\n    }\n\n    return 0;\n}",
          "explanation": "This example creates a file, writes to it, closes it, and then deletes it using the remove function.",
          "expectedOutput": "Attempting to delete test.txt\nFile deleted successfully."
        },
        {
          "title": "Handling Non-existent Files",
          "code": "#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n\nint main() {\n    const char *filename = \"nonexistent.txt\";\n    \n    if (remove(filename) != 0) {\n        if (errno == ENOENT) {\n            printf(\"File '%s' does not exist.\\n\", filename);\n        } else {\n            printf(\"Error deleting file '%s': %s\\n\", filename, strerror(errno));\n        }\n    } else {\n        printf(\"File '%s' deleted successfully.\\n\", filename);\n    }\n\n    return 0;\n}",
          "explanation": "This example demonstrates how to handle errors when attempting to delete a non-existent file.",
          "expectedOutput": "File 'nonexistent.txt' does not exist."
        }
      ],
      "related_functions": ["rename", "unlink"],
      "performance_considerations": "The remove function is generally efficient for deleting files. However, be cautious when using it in high-concurrency situations, as race conditions can occur if multiple processes attempt to delete the same file simultaneously."
    },
    {
      "function_name": "rename",
      "include_file": "stdio.h",
      "return_type": "int",
      "parameter_types": ["const char*", "const char*"],
      "main_category": "File and I/O Operations",
      "sub_category": "File Management",
      "data_type_manipulated": "files",
      "description": "Renames a file or directory.",
      "extended_description": "The rename function changes the name of a file or directory. It can also be used to move a file between directories on the same file system. If a file with the new name already exists, it may be overwritten depending on the system and implementation.",
      "return_value": "Returns 0 if the file was successfully renamed, non-zero if an error occurred.",
      "parameter_values": "oldname: A string containing the current name of the file or directory.\nnewname: A string containing the new name for the file or directory.",
      "function_prototype": "int rename(const char *oldname, const char *newname);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"old.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error creating file\");\n        return 1;\n    }\n    fprintf(file, \"This is a test file.\");\n    fclose(file);\n\n    printf(\"Attempting to rename old.txt to new.txt\\n\");\n    if (rename(\"old.txt\", \"new.txt\") == 0) {\n        printf(\"File renamed successfully.\\n\");\n    } else {\n        perror(\"Error renaming file\");\n        return 1;\n    }\n\n    return 0;\n}",
          "explanation": "This example creates a file, closes it, and then renames it using the rename function.",
          "expectedOutput": "Attempting to rename old.txt to new.txt\nFile renamed successfully."
        },
        {
          "title": "Moving a File",
          "code": "#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n\nint main() {\n    const char *oldpath = \"./file.txt\";\n    const char *newpath = \"./subfolder/file.txt\";\n    \n    // Create a test file\n    FILE *file = fopen(oldpath, \"w\");\n    if (file == NULL) {\n        perror(\"Error creating file\");\n        return 1;\n    }\n    fprintf(file, \"This is a test file.\");\n    fclose(file);\n\n    printf(\"Attempting to move %s to %s\\n\", oldpath, newpath);\n    if (rename(oldpath, newpath) != 0) {\n        printf(\"Error moving file: %s\\n\", strerror(errno));\n        return 1;\n    } else {\n        printf(\"File moved successfully.\\n\");\n    }\n\n    return 0;\n}",
          "explanation": "This example demonstrates how to use rename to move a file to a different directory. Note that this assumes the 'subfolder' directory exists.",
          "expectedOutput": "Attempting to move ./file.txt to ./subfolder/file.txt\nFile moved successfully."
        }
      ],
      "related_functions": ["remove", "fopen", "fclose"],
      "performance_considerations": "The rename function is generally efficient for renaming files within the same filesystem. However, if the new name refers to a different filesystem, the operation may involve copying the file, which can be slower for large files."
    },
    {
      "function_name": "rewind",
      "include_file": "stdio.h",
      "return_type": "void",
      "parameter_types": ["FILE*"],
      "main_category": "File and I/O Operations",
      "sub_category": "Stream Manipulation",
      "data_type_manipulated": "file streams",
      "description": "Sets the file position to the beginning of the file stream.",
      "extended_description": "The rewind function sets the file position indicator for the stream pointed to by stream to the beginning of the file. It is equivalent to (void)fseek(stream, 0L, SEEK_SET) except that the error indicator for the stream is also cleared.",
      "return_value": "This function does not return a value.",
      "parameter_values": "stream: Pointer to a FILE object that identifies the stream.",
      "function_prototype": "void rewind(FILE *stream);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"test.txt\", \"w+\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    fprintf(file, \"Hello, World!\\n\");\n    \n    rewind(file);\n    \n    char buffer[20];\n    if (fgets(buffer, sizeof(buffer), file) != NULL) {\n        printf(\"Read from file: %s\", buffer);\n    } else {\n        perror(\"Error reading from file\");\n    }\n\n    fclose(file);\n    return 0;\n}",
          "explanation": "This example writes a string to a file, uses rewind to move the file position indicator back to the beginning, and then reads and prints the content.",
          "expectedOutput": "Read from file: Hello, World!"
        },
        {
          "title": "Reading a File Multiple Times",
          "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"numbers.txt\", \"w+\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n\n    // Write numbers to the file\n    for (int i = 1; i <= 5; i++) {\n        fprintf(file, \"%d\\n\", i);\n    }\n\n    // First read\n    printf(\"First read:\\n\");\n    rewind(file);\n    int num;\n    while (fscanf(file, \"%d\", &num) == 1) {\n        printf(\"%d \", num);\n    }\n    printf(\"\\n\");\n\n    // Second read\n    printf(\"Second read:\\n\");\n    rewind(file);\n    while (fscanf(file, \"%d\", &num) == 1) {\n        printf(\"%d \", num * 2);\n    }\n    printf(\"\\n\");\n\n    fclose(file);\n    return 0;\n}",
          "explanation": "This example demonstrates using rewind to read the same file multiple times, performing different operations on the data each time.",
          "expectedOutput": "First read:\n1 2 3 4 5 \nSecond read:\n2 4 6 8 10 "
        }
      ],
      "related_functions": ["fseek", "ftell", "fsetpos"],
      "link":"https://www.google.com",
      "performance_considerations": "rewind is generally efficient for resetting the file position. However, for very large files, especially on systems with slow storage, moving the file position may incur some I/O overhead. In such cases, consider structuring your program to minimize the need for rewinding."
    },
    
    {
      "function_name": "scanf",
      "include_file": "stdio.h",
      "return_type": "int",
      "parameter_types": ["const char*", "..."],
      "main_category": "File and I/O Operations",
      "sub_category": "Stream Manipulation",
      "data_type_manipulated": "standard input",
      "description": "Reads formatted input from the standard input stream.",
      "extended_description": "The scanf function reads input from the standard input stream stdin, interprets it according to the format string, and stores the results in the locations given by the additional arguments. The format string consists of conversion specifications and ordinary characters.",
      "return_value": "Returns the number of input items successfully matched and assigned. Returns EOF if input failure occurs before the first conversion.",
      "parameter_values": "format: A string that specifies the expected input format.\n...: Additional arguments pointing to the objects where the input should be stored.",
      "function_prototype": "int scanf(const char *format, ...);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n\nint main() {\n    int num;\n    char str[50];\n    \n    printf(\"Enter an integer and a string: \");\n    if (scanf(\"%d %s\", &num, str) == 2) {\n        printf(\"You entered: %d and %s\\n\", num, str);\n    } else {\n        printf(\"Invalid input\\n\");\n    }\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of scanf to read an integer and a string from standard input.",
          "expectedOutput": "Enter an integer and a string: 42 hello\nYou entered: 42 and hello"
        },
        {
          "title": "Reading Multiple Values",
          "code": "#include <stdio.h>\n\nint main() {\n    int day, month, year;\n    \n    printf(\"Enter a date (DD-MM-YYYY): \");\n    if (scanf(\"%d-%d-%d\", &day, &month, &year) == 3) {\n        printf(\"Date entered: %02d/%02d/%04d\\n\", day, month, year);\n    } else {\n        printf(\"Invalid date format\\n\");\n    }\n    \n    return 0;\n}",
          "explanation": "This example shows how to use scanf to read multiple values with a specific format.",
          "expectedOutput": "Enter a date (DD-MM-YYYY): 15-03-2023\nDate entered: 15/03/2023"
        },
        {
          "title": "Input Validation",
          "code": "#include <stdio.h>\n\nint main() {\n    float num;\n    char input[100];\n    \n    printf(\"Enter a floating-point number: \");\n    if (fgets(input, sizeof(input), stdin) != NULL) {\n        if (sscanf(input, \"%f\", &num) == 1) {\n            printf(\"You entered: %.2f\\n\", num);\n        } else {\n            printf(\"Invalid input. Please enter a valid number.\\n\");\n        }\n    }\n    \n    return 0;\n}",
          "explanation": "This example demonstrates a safer way to use scanf-like functionality with input validation using fgets and sscanf.",
          "expectedOutput": "Enter a floating-point number: 3.14\nYou entered: 3.14"
        }
      ],
      "related_functions": ["fscanf", "sscanf", "printf"],
      "performance_considerations": "scanf can be vulnerable to buffer overflow if not used carefully. For safer input, consider using fgets with sscanf or custom parsing. Also, scanf stops reading at whitespace for string input, which may not always be desirable."
    },
    {
      "function_name": "setbuf",
      "include_file": "stdio.h",
      "return_type": "void",
      "parameter_types": ["FILE*", "char*"],
      "main_category": "File and I/O Operations",
      "sub_category": "Stream Manipulation",
      "data_type_manipulated": "file streams",
      "description": "Sets the buffer to be used by the stream for I/O operations.",
      "extended_description": "The setbuf function is used to associate a buffer with a stream or to disable buffering. If the buffer is NULL, buffering is disabled. Otherwise, the buffer must have a size of at least BUFSIZ bytes, where BUFSIZ is a macro constant defined in <stdio.h>.",
      "return_value": "This function does not return a value.",
      "parameter_values": "stream: Pointer to a FILE object that identifies the stream.\nbuffer: Pointer to a character array to be used as a buffer. If NULL, buffering is disabled.",
      "function_prototype": "void setbuf(FILE *stream, char *buffer);",
      "examples": [
        {
          "title": "Setting a Custom Buffer",
          "code": "#include <stdio.h>\n\nint main() {\n    char buffer[BUFSIZ];\n    FILE *file = fopen(\"test.txt\", \"w\");\n    \n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    \n    setbuf(file, buffer);\n    \n    fprintf(file, \"Hello, World!\\n\");\n    fclose(file);\n    \n    printf(\"Data written to file with custom buffer.\\n\");\n    \n    return 0;\n}",
          "explanation": "This example demonstrates how to set a custom buffer for a file stream using setbuf.",
          "expectedOutput": "Data written to file with custom buffer."
        },
        {
          "title": "Disabling Buffering",
          "code": "#include <stdio.h>\n\nint main() {\n    setbuf(stdout, NULL);\n    \n    printf(\"This output is unbuffered.\\n\");\n    \n    for (int i = 1; i <= 5; i++) {\n        printf(\"%d \", i);\n    }\n    \n    return 0;\n}",
          "explanation": "This example shows how to disable buffering for stdout using setbuf. Each character will be output immediately without waiting for a newline or buffer flush.",
          "expectedOutput": "This output is unbuffered.\n1 2 3 4 5 "
        }
      ],
      "related_functions": ["setvbuf", "fflush"],
      "performance_considerations": "Changing buffer settings can significantly affect I/O performance. Unbuffered I/O can be slower for frequent small writes, while a well-sized buffer can improve performance. However, custom buffering may not always outperform the default buffering provided by the C library."
    },
    {
      "function_name": "setjmp",
      "include_file": "setjmp.h",
      "return_type": "int",
      "parameter_types": ["jmp_buf"],
      "main_category": "Error Handling and Debugging",
      "sub_category": "Program Control",
      "data_type_manipulated": "none",
      "description": "Saves the calling environment for longjmp.",
      "extended_description": "The setjmp function saves the current execution context into the jmp_buf argument. It's used in conjunction with longjmp to implement non-local jumps. When setjmp is initially called, it returns 0. If longjmp is later called with this jmp_buf, execution returns to the point of the setjmp call, and setjmp returns the value passed to longjmp.",
      "return_value": "Returns 0 if returning directly, and a non-zero value if returning from a call to longjmp.",
      "parameter_values": "env: An array of type jmp_buf that is used to store the execution context.",
      "function_prototype": "int setjmp(jmp_buf env);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <setjmp.h>\n\njmp_buf jump_buffer;\n\nvoid function_that_jumps() {\n    printf(\"About to jump\\n\");\n    longjmp(jump_buffer, 1);\n    printf(\"This line is never reached\\n\");\n}\n\nint main() {\n    int jump_val = setjmp(jump_buffer);\n    \n    if (jump_val == 0) {\n        printf(\"setjmp returned 0\\n\");\n        function_that_jumps();\n    } else {\n        printf(\"Returned from longjmp with value %d\\n\", jump_val);\n    }\n    \n    return 0;\n}",
          "explanation": "This example demonstrates the basic usage of setjmp and longjmp. The setjmp call saves the context, and longjmp later returns to that point.",
          "expectedOutput": "setjmp returned 0\nAbout to jump\nReturned from longjmp with value 1"
        },
        {
          "title": "Error Handling with setjmp",
          "code": "#include <stdio.h>\n#include <setjmp.h>\n\njmp_buf error_handler;\n\nvoid risky_function(int value) {\n    if (value < 0) {\n        printf(\"Error: negative value\\n\");\n        longjmp(error_handler, 1);\n    }\n    printf(\"Success: value is %d\\n\", value);\n}\n\nint main() {\n    if (setjmp(error_handler) == 0) {\n        printf(\"Trying with value 5\\n\");\n        risky_function(5);\n        printf(\"Trying with value -1\\n\");\n        risky_function(-1);\n        printf(\"This line is never reached\\n\");\n    } else {\n        printf(\"An error occurred and was caught\\n\");\n    }\n    \n    return 0;\n}",
          "explanation": "This example shows how setjmp and longjmp can be used for error handling, allowing a function to 'return' to a different point in the call stack when an error occurs.",
          "expectedOutput": "Trying with value 5\nSuccess: value is 5\nTrying with value -1\nError: negative value\nAn error occurred and was caught"
        }
      ],
      "related_functions": ["longjmp"],
      "performance_considerations": "setjmp and longjmp can be useful for implementing exception-like behavior, but they should be used carefully. They can make code harder to understand and maintain. Also, longjmp does not unwind the stack, which can lead to resource leaks if not handled properly."
    },
  
    {
      "function_name": "setlocale",
      "include_file": "locale.h",
      "return_type": "char*",
      "parameter_types": ["int", "const char*"],
      "main_category": "System Interaction",
      "sub_category": "Localization Support",
      "data_type_manipulated": "locale settings",
      "description": "Sets or queries the program's locale.",
      "extended_description": "The setlocale function is used to set or query the program's current locale. The locale affects the behavior of functions that are sensitive to cultural differences, such as the formatting of numbers, dates, and currency values. It can set the entire locale or specific categories of the locale.",
      "return_value": "Returns a pointer to a string identifying the new locale on success, or NULL on failure. If the second argument is NULL, it returns the current locale string without changing it.",
      "parameter_values": "category: Specifies which part of the program's locale should be modified (e.g., LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME).\nlocale: A string specifying the desired locale, or NULL to query the current locale.",
      "function_prototype": "char *setlocale(int category, const char *locale);",
      "examples": [
        {
          "title": "Setting the Locale",
          "code": "#include <stdio.h>\n#include <locale.h>\n\nint main() {\n    // Set the program's locale to the system default\n    char *result = setlocale(LC_ALL, \"\");\n    if (result == NULL) {\n        printf(\"Failed to set locale.\\n\");\n        return 1;\n    }\n    \n    printf(\"Locale set to: %s\\n\", result);\n    \n    // Print a locale-dependent value\n    printf(\"Locale-dependent floating point: %.2f\\n\", 1234567.89);\n    \n    return 0;\n}",
          "explanation": "This example sets the program's locale to the system default and then prints a locale-dependent floating-point number.",
          "expectedOutput": "Locale set to: en_US.UTF-8\nLocale-dependent floating point: 1,234,567.89"
        },
        {
          "title": "Querying the Current Locale",
          "code": "#include <stdio.h>\n#include <locale.h>\n\nint main() {\n    // Query the current locale for different categories\n    printf(\"Current LC_ALL locale: %s\\n\", setlocale(LC_ALL, NULL));\n    printf(\"Current LC_NUMERIC locale: %s\\n\", setlocale(LC_NUMERIC, NULL));\n    printf(\"Current LC_TIME locale: %s\\n\", setlocale(LC_TIME, NULL));\n    \n    // Set a specific locale category\n    char *result = setlocale(LC_NUMERIC, \"de_DE.UTF-8\");\n    if (result != NULL) {\n        printf(\"LC_NUMERIC set to: %s\\n\", result);\n        printf(\"Locale-dependent number: %.2f\\n\", 1234.56);\n    } else {\n        printf(\"Failed to set LC_NUMERIC locale.\\n\");\n    }\n    \n    return 0;\n}",
          "explanation": "This example queries the current locale for different categories and then sets a specific locale category (LC_NUMERIC) to a German locale.",
          "expectedOutput": "Current LC_ALL locale: C\nCurrent LC_NUMERIC locale: C\nCurrent LC_TIME locale: C\nLC_NUMERIC set to: de_DE.UTF-8\nLocale-dependent number: 1234,56"
        }
      ],
      "related_functions": ["localeconv", "strcoll", "strftime"],
      "performance_considerations": "Changing the locale can be an expensive operation, as it may require loading locale-specific data. It's generally best to set the locale once at the start of the program rather than changing it frequently. Also, some locale-aware functions may be slower than their non-locale-aware counterparts."
    },
    {
      "function_name": "setvbuf",
      "include_file": "stdio.h",
      "return_type": "int",
      "parameter_types": ["FILE*", "char*", "int", "size_t"],
      "main_category": "File and I/O Operations",
      "sub_category": "Stream Manipulation",
      "data_type_manipulated": "file streams",
      "description": "Sets a specific buffer and buffering mode for the given stream.",
      "extended_description": "The setvbuf function allows you to specify the buffering mode and buffer size for a stream. It can be used to optimize I/O operations by controlling how data is buffered before being read from or written to a device.",
      "return_value": "Returns 0 on success, or a non-zero value if an invalid value is given for mode or if the request cannot be honored.",
      "parameter_values": "stream: Pointer to a FILE object that identifies the stream.\nbuffer: Pointer to a character array to be used as a buffer. If NULL, a buffer will be allocated automatically.\nmode: Specifies the buffering mode (_IOFBF for full buffering, _IOLBF for line buffering, or _IONBF for no buffering).\nsize: Specifies the buffer size in bytes.",
      "function_prototype": "int setvbuf(FILE *stream, char *buffer, int mode, size_t size);",
      "examples": [
        {
          "title": "Setting a Custom Buffer",
          "code": "#include <stdio.h>\n\nint main() {\n    char buffer[1024];\n    FILE *file = fopen(\"test.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    \n    if (setvbuf(file, buffer, _IOFBF, sizeof(buffer)) != 0) {\n        printf(\"Failed to set buffer\\n\");\n        return 1;\n    }\n    \n    fprintf(file, \"This is a test.\\n\");\n    fclose(file);\n    \n    printf(\"File written with custom buffer.\\n\");\n    return 0;\n}",
          "explanation": "This example sets a custom fully buffered buffer for a file stream using setvbuf.",
          "expectedOutput": "File written with custom buffer."
        },
        {
          "title": "Line Buffering for stdout",
          "code": "#include <stdio.h>\n\nint main() {\n    if (setvbuf(stdout, NULL, _IOLBF, 0) != 0) {\n        printf(\"Failed to set line buffering for stdout\\n\");\n        return 1;\n    }\n    \n    printf(\"This line will be buffered until the newline.\\n\");\n    printf(\"This is another line.\\n\");\n    \n    // This will not be printed immediately because there's no newline\n    printf(\"This will be buffered\");\n    \n    // Force a flush\n    fflush(stdout);\n    \n    return 0;\n}",
          "explanation": "This example sets stdout to line buffering mode. Output is buffered until a newline character is encountered or the buffer is manually flushed.",
          "expectedOutput": "This line will be buffered until the newline.\nThis is another line.\nThis will be buffered"
        }
      ],
      "related_functions": ["setbuf", "fflush"],
      "performance_considerations": "Proper buffer management can significantly improve I/O performance. Full buffering (_IOFBF) is generally most efficient for file I/O, while line buffering (_IOLBF) can be useful for interactive output. Be cautious when using custom buffers, as they must remain valid for the life of the stream or until the next setvbuf call."
    },
    {
      "function_name": "signal",
      "include_file": "signal.h",
      "return_type": "void (*)(int)",
      "parameter_types": ["int", "void (*)(int)"],
      "main_category": "Error Handling and Debugging",
      "sub_category": "Signal Processing",
      "data_type_manipulated": "process signals",
      "description": "Sets a function to handle a particular signal.",
      "extended_description": "The signal function sets the handling for a specific signal. It allows a program to choose one of three ways to handle the signal: perform default processing, ignore the signal, or specify a function to be called when the signal occurs.",
      "return_value": "Returns the previous value of the signal handler, or SIG_ERR on error.",
      "parameter_values": "sig: The signal number to be handled.\nfunc: A pointer to the function to be called when the signal occurs, or one of the special values SIG_DFL (for default handling) or SIG_IGN (to ignore the signal).",
      "function_prototype": "void (*signal(int sig, void (*func)(int)))(int);",
      "examples": [
        {
          "title": "Handling SIGINT",
          "code": "#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n\nvolatile sig_atomic_t keep_running = 1;\n\nvoid sig_handler(int sig) {\n    keep_running = 0;\n}\n\nint main() {\n    if (signal(SIGINT, sig_handler) == SIG_ERR) {\n        fprintf(stderr, \"Cannot handle SIGINT\\n\");\n        return 1;\n    }\n    \n    printf(\"Running... Press Ctrl+C to stop.\\n\");\n    \n    while (keep_running) {\n        printf(\".\");\n        fflush(stdout);\n        sleep(1);\n    }\n    \n    printf(\"\\nSIGINT caught. Exiting gracefully.\\n\");\n    return 0;\n}",
          "explanation": "This example sets up a signal handler for SIGINT (typically triggered by Ctrl+C). The program runs until SIGINT is received, then exits gracefully.",
          "expectedOutput": "Running... Press Ctrl+C to stop.\n......\nSIGINT caught. Exiting gracefully."
        },
        {
          "title": "Ignoring a Signal",
          "code": "#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n\nint main() {\n    if (signal(SIGINT, SIG_IGN) == SIG_ERR) {\n        fprintf(stderr, \"Cannot ignore SIGINT\\n\");\n        return 1;\n    }\n    \n    printf(\"SIGINT is now ignored. This program will run for 10 seconds.\\n\");\n    printf(\"Try pressing Ctrl+C...\\n\");\n    \n    for (int i = 0; i < 10; i++) {\n        printf(\"%d \", i+1);\n        fflush(stdout);\n        sleep(1);\n    }\n    \n    printf(\"\\nProgram completed.\\n\");\n    return 0;\n}",
          "explanation": "This example demonstrates how to ignore a signal (SIGINT in this case) using the SIG_IGN special value.",
          "expectedOutput": "SIGINT is now ignored. This program will run for 10 seconds.\nTry pressing Ctrl+C...\n1 2 3 4 5 6 7 8 9 10 \nProgram completed."
        }
      ],
      "related_functions": ["raise", "sigaction"],
      "performance_considerations": "Signal handling can be tricky and may lead to race conditions in multi-threaded programs. For more complex signal handling needs, consider using sigaction instead of signal. Also, be aware that some library functions are not async-signal-safe and should not be called from within signal handlers."
    },
  
    {
      "function_name": "sin",
      "include_file": "math.h",
      "return_type": "double",
      "parameter_types": ["double"],
      "main_category": "Mathematical Operations",
      "sub_category": "Advanced Computation",
      "data_type_manipulated": "floating-point numbers",
      "description": "Calculates the sine of the specified angle in radians.",
      "extended_description": "The sin function computes the sine of x (measured in radians). A radian is the angle subtended at the center of a circle by an arc equal in length to the radius. The sin function is periodic with a period of 2π radians.",
      "return_value": "Returns the sine of x. If x is infinite, a domain error occurs and the function returns NaN. If x is NaN, NaN is returned.",
      "parameter_values": "x: The angle in radians for which to calculate the sine.",
      "function_prototype": "double sin(double x);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <math.h>\n\n#define PI 3.14159265358979323846\n\nint main() {\n    double angle_degrees = 30.0;\n    double angle_radians = angle_degrees * PI / 180.0;\n    double result = sin(angle_radians);\n    \n    printf(\"sin(%.2f degrees) = %.4f\\n\", angle_degrees, result);\n    \n    return 0;\n}",
          "explanation": "This example calculates the sine of 30 degrees (converted to radians).",
          "expectedOutput": "sin(30.00 degrees) = 0.5000"
        },
        {
          "title": "Plotting Sine Wave",
          "code": "#include <stdio.h>\n#include <math.h>\n\n#define PI 3.14159265358979323846\n\nint main() {\n    printf(\"Sine wave plot (0 to 2π):\\n\");\n    for (int i = 0; i <= 20; i++) {\n        double x = i * PI / 10;\n        double y = sin(x);\n        int stars = (int)((y + 1) * 10);\n        \n        printf(\"%4.2f: \", x);\n        for (int j = 0; j < stars; j++) {\n            printf(\"*\");\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}",
          "explanation": "This example creates a simple ASCII plot of the sine function from 0 to 2π.",
          "expectedOutput": "Sine wave plot (0 to 2π):\n0.00: **********\n0.31: ************\n0.63: *************\n0.94: **************\n1.26: *************\n1.57: ************\n1.88: **********\n2.20: ********\n2.51: ******\n2.83: ***\n3.14: *\n3.46: ***\n3.77: ******\n4.08: ********\n4.40: **********\n4.71: ************\n5.03: *************\n5.34: **************\n5.65: *************\n5.97: ************\n6.28: **********"
        }
      ],
      "related_functions": ["cos", "tan", "asin"],
      "performance_considerations": "The sin function is generally optimized and efficient for most use cases. However, for very small angles, consider using the Taylor series approximation for better accuracy. For performance-critical applications with many sin calculations, consider using lookup tables or SIMD instructions if available."
    },
    {
      "function_name": "sinh",
      "include_file": "math.h",
      "return_type": "double",
      "parameter_types": ["double"],
      "main_category": "Mathematical Operations",
      "sub_category": "Advanced Computation",
      "data_type_manipulated": "floating-point numbers",
      "description": "Calculates the hyperbolic sine of the specified number.",
      "extended_description": "The sinh function computes the hyperbolic sine of x. It is defined mathematically as (e^x - e^-x) / 2, where e is Euler's number (approximately 2.71828).",
      "return_value": "Returns the hyperbolic sine of x. If the result is too large to be represented, a range error occurs and the function returns ±HUGE_VAL (with the same sign as x).",
      "parameter_values": "x: The value for which to calculate the hyperbolic sine.",
      "function_prototype": "double sinh(double x);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = 1.0;\n    double result = sinh(x);\n    \n    printf(\"sinh(%.2f) = %.6f\\n\", x, result);\n    \n    return 0;\n}",
          "explanation": "This example calculates the hyperbolic sine of 1.0.",
          "expectedOutput": "sinh(1.00) = 1.175201"
        },
        {
          "title": "Hyperbolic Sine for Various Values",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double values[] = {-2.0, -1.0, 0.0, 1.0, 2.0};\n    int num_values = sizeof(values) / sizeof(values[0]);\n    \n    printf(\"x\\tsinh(x)\\n\");\n    printf(\"-----------------\\n\");\n    \n    for (int i = 0; i < num_values; i++) {\n        double x = values[i];\n        double result = sinh(x);\n        printf(\"%.2f\\t%.6f\\n\", x, result);\n    }\n    \n    return 0;\n}",
          "explanation": "This example calculates and prints the hyperbolic sine for a range of values.",
          "expectedOutput": "x\tsinh(x)\n-----------------\n-2.00\t-3.626860\n-1.00\t-1.175201\n0.00\t0.000000\n1.00\t1.175201\n2.00\t3.626860"
        }
      ],
      "related_functions": ["cosh", "tanh", "asinh"],
      "performance_considerations": "The sinh function involves exponential calculations, which can be computationally expensive. For very small x, consider using the Taylor series approximation for better performance. For large x, be aware of potential overflow issues. In performance-critical code with many sinh calculations, consider using lookup tables or approximation methods if high precision is not required."
    },
    {
      "function_name": "snprintf",
      "include_file": "stdio.h",
      "return_type": "int",
      "parameter_types": ["char*", "size_t", "const char*", "..."],
      "main_category": "File and I/O Operations",
      "sub_category": "Stream Manipulation",
      "data_type_manipulated": "strings",
      "description": "Writes formatted output to a string with a length limit.",
      "extended_description": "The snprintf function is similar to sprintf, but it allows you to specify the maximum number of characters to be written to the buffer. This helps prevent buffer overflows. It writes the output to the character string str.",
      "return_value": "Returns the number of characters that would have been written if n had been sufficiently large, not counting the terminating null character. If an encoding error occurs, a negative number is returned.",
      "parameter_values": "str: Pointer to a buffer where the resulting C-string is stored.\nn: Maximum number of bytes to be used in the buffer.\nformat: C string that contains the text to be written to the buffer.\n...: Additional arguments replacing the format specifiers in the format string.",
      "function_prototype": "int snprintf(char *str, size_t n, const char *format, ...);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n\nint main() {\n    char buffer[50];\n    int n = snprintf(buffer, sizeof(buffer), \"Hello, %s! You are %d years old.\", \"Alice\", 30);\n    \n    printf(\"Formatted string: %s\\n\", buffer);\n    printf(\"Number of characters (excluding null terminator): %d\\n\", n);\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of snprintf to format a string with a name and age.",
          "expectedOutput": "Formatted string: Hello, Alice! You are 30 years old.\nNumber of characters (excluding null terminator): 35"
        },
        {
          "title": "Handling Buffer Overflow",
          "code": "#include <stdio.h>\n\nint main() {\n    char short_buffer[10];\n    char long_buffer[50];\n    const char *long_string = \"This is a very long string that exceeds the buffer size\";\n    \n    int n1 = snprintf(short_buffer, sizeof(short_buffer), \"%s\", long_string);\n    int n2 = snprintf(long_buffer, sizeof(long_buffer), \"%s\", long_string);\n    \n    printf(\"Short buffer content: %s\\n\", short_buffer);\n    printf(\"Characters that would have been written to short buffer: %d\\n\", n1);\n    printf(\"Long buffer content: %s\\n\", long_buffer);\n    printf(\"Characters written to long buffer: %d\\n\", n2);\n    \n    return 0;\n}",
          "explanation": "This example shows how snprintf handles buffer overflow situations by truncating the output and returning the number of characters that would have been written.",
          "expectedOutput": "Short buffer content: This is a\nCharacters that would have been written to short buffer: 54\nLong buffer content: This is a very long string that exceeds the buffer\nCharacters written to long buffer: 54"
        },
        {
          "title": "Using snprintf for Safe String Concatenation",
          "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_BUFFER 100\n\nint main() {\n    char buffer[MAX_BUFFER] = \"Hello, \";\n    const char *name = \"World\";\n    const char *punctuation = \"!\";\n    \n    size_t current_length = strlen(buffer);\n    int remaining_space = MAX_BUFFER - current_length;\n    \n    snprintf(buffer + current_length, remaining_space, \"%s%s\", name, punctuation);\n    \n    printf(\"Final string: %s\\n\", buffer);\n    printf(\"String length: %zu\\n\", strlen(buffer));\n    \n    return 0;\n}",
          "explanation": "This example demonstrates how to use snprintf for safe string concatenation, ensuring that the buffer is not overflowed.",
          "expectedOutput": "Final string: Hello, World!\nString length: 13"
        }
      ],
      "related_functions": ["sprintf", "fprintf", "vsnprintf"],
      "performance_considerations": "snprintf is generally slower than sprintf due to the additional checks it performs to prevent buffer overflow. However, the added safety usually outweighs the performance cost. For performance-critical code that requires frequent string formatting, consider using a string builder pattern or pre-allocating buffers."
    },
  
    {
      "function_name": "sprintf",
      "include_file": "stdio.h",
      "return_type": "int",
      "parameter_types": ["char*", "const char*", "..."],
      "main_category": "File and I/O Operations",
      "sub_category": "Stream Manipulation",
      "data_type_manipulated": "strings",
      "description": "Writes formatted output to a string.",
      "extended_description": "The sprintf function writes formatted output to a string. It formats and stores a series of characters and values in the buffer pointed to by str. The format argument is a string containing literal text and format specifiers that describe how subsequent arguments are converted for output.",
      "return_value": "Returns the number of characters written if successful or a negative value if an error occurred.",
      "parameter_values": "str: Pointer to a buffer where the resulting C-string is stored.\nformat: C string that contains the text to be written to the buffer.\n...: Additional arguments replacing the format specifiers in the format string.",
      "function_prototype": "int sprintf(char *str, const char *format, ...);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n\nint main() {\n    char buffer[100];\n    int age = 30;\n    float height = 1.75;\n    \n    int chars_written = sprintf(buffer, \"I am %d years old and %.2f meters tall.\", age, height);\n    \n    printf(\"Formatted string: %s\\n\", buffer);\n    printf(\"Characters written: %d\\n\", chars_written);\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of sprintf to format a string with an integer and a float.",
          "expectedOutput": "Formatted string: I am 30 years old and 1.75 meters tall.\nCharacters written: 41"
        },
        {
          "title": "Using Various Format Specifiers",
          "code": "#include <stdio.h>\n\nint main() {\n    char buffer[100];\n    int num = 255;\n    char ch = 'A';\n    char* str = \"Hello\";\n    \n    sprintf(buffer, \"Decimal: %d, Hexadecimal: %X, Character: %c, String: %s\", num, num, ch, str);\n    \n    printf(\"%s\\n\", buffer);\n    \n    return 0;\n}",
          "explanation": "This example shows how to use various format specifiers with sprintf.",
          "expectedOutput": "Decimal: 255, Hexadecimal: FF, Character: A, String: Hello"
        },
        {
          "title": "Padding and Alignment",
          "code": "#include <stdio.h>\n\nint main() {\n    char buffer[50];\n    int num = 42;\n    \n    sprintf(buffer, \"Right-aligned: |%5d|\\nLeft-aligned: |%-5d|\", num, num);\n    \n    printf(\"%s\\n\", buffer);\n    \n    return 0;\n}",
          "explanation": "This example demonstrates how to use padding and alignment options in sprintf.",
          "expectedOutput": "Right-aligned: |   42|\nLeft-aligned: |42   |"
        }
      ],
      "related_functions": ["snprintf", "fprintf", "printf"],
      "performance_considerations": "sprintf is efficient for simple string formatting, but it doesn't provide buffer overflow protection. For safer alternatives, consider using snprintf or string-building libraries. In performance-critical code, pre-allocating buffers and reusing them can improve efficiency."
    },
    {
      "function_name": "sqrt",
      "include_file": "math.h",
      "return_type": "double",
      "parameter_types": ["double"],
      "main_category": "Mathematical Operations",
      "sub_category": "Advanced Computation",
      "data_type_manipulated": "floating-point numbers",
      "description": "Calculates the square root of the specified number.",
      "extended_description": "The sqrt function computes the non-negative square root of x. A square root is the number y such that y^2 = x.",
      "return_value": "Returns the non-negative square root of x. If x is negative, a domain error occurs and the function returns NaN.",
      "parameter_values": "x: The number for which to calculate the square root.",
      "function_prototype": "double sqrt(double x);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double number = 16.0;\n    double result = sqrt(number);\n    \n    printf(\"The square root of %.2f is %.4f\\n\", number, result);\n    \n    return 0;\n}",
          "explanation": "This example calculates and prints the square root of 16.",
          "expectedOutput": "The square root of 16.00 is 4.0000"
        },
        {
          "title": "Handling Negative Numbers",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double numbers[] = {25.0, 0.0, -4.0};\n    int count = sizeof(numbers) / sizeof(numbers[0]);\n    \n    for (int i = 0; i < count; i++) {\n        double result = sqrt(numbers[i]);\n        if (isnan(result)) {\n            printf(\"sqrt(%.2f) is not a real number\\n\", numbers[i]);\n        } else {\n            printf(\"sqrt(%.2f) = %.4f\\n\", numbers[i], result);\n        }\n    }\n    \n    return 0;\n}",
          "explanation": "This example demonstrates how sqrt handles positive, zero, and negative numbers.",
          "expectedOutput": "sqrt(25.00) = 5.0000\nsqrt(0.00) = 0.0000\nsqrt(-4.00) is not a real number"
        },
        {
          "title": "Using sqrt in Calculations",
          "code": "#include <stdio.h>\n#include <math.h>\n\ndouble hypotenuse(double a, double b) {\n    return sqrt(a*a + b*b);\n}\n\nint main() {\n    double side1 = 3.0;\n    double side2 = 4.0;\n    \n    double hyp = hypotenuse(side1, side2);\n    \n    printf(\"In a right triangle with sides %.2f and %.2f,\\n\", side1, side2);\n    printf(\"the hypotenuse is %.4f\\n\", hyp);\n    \n    return 0;\n}",
          "explanation": "This example uses sqrt to calculate the hypotenuse of a right triangle using the Pythagorean theorem.",
          "expectedOutput": "In a right triangle with sides 3.00 and 4.00,\nthe hypotenuse is 5.0000"
        }
      ],
      "related_functions": ["pow", "cbrt", "hypot"],
      "performance_considerations": "sqrt is generally optimized and efficient for most use cases. For very large numbers, be aware of potential precision loss. In performance-critical code with many sqrt calculations, consider using lookup tables or approximation methods if high precision is not required. Some hardware may have special instructions for square root calculation, which the compiler can utilize for better performance."
    },
    {
      "function_name": "srand",
      "include_file": "stdlib.h",
      "return_type": "void",
      "parameter_types": ["unsigned int"],
      "main_category": "Mathematical Operations",
      "sub_category": "Random Number Generation",
      "data_type_manipulated": "none",
      "description": "Seeds the pseudo-random number generator used by rand().",
      "extended_description": "The srand function sets the starting point for producing a series of pseudo-random integers. If srand is not called, the rand() function behaves as if srand(1) has been called at program start. Any other value for seed sets the generator to a different starting point.",
      "return_value": "This function does not return a value.",
      "parameter_values": "seed: An integer value to be used as seed by the pseudo-random number generator algorithm.",
      "function_prototype": "void srand(unsigned int seed);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n    \n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", rand() % 100);  // Generate random numbers between 0 and 99\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "explanation": "This example seeds the random number generator with the current time and generates 5 random numbers between 0 and 99.",
          "expectedOutput": "42 71 13 98 56\n\nNote: The actual numbers will vary each time the program is run."
        },
        {
          "title": "Demonstrating Seed Importance",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid print_random_numbers(unsigned int seed) {\n    srand(seed);\n    printf(\"Seed %u: \", seed);\n    for (int i = 0; i < 5; i++) {\n        printf(\"%d \", rand() % 100);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    print_random_numbers(12345);\n    print_random_numbers(67890);\n    print_random_numbers(12345);  // Same seed as first call\n    \n    return 0;\n}",
          "explanation": "This example demonstrates how the same seed produces the same sequence of random numbers, while different seeds produce different sequences.",
          "expectedOutput": "Seed 12345: 74 66 98 78 23\nSeed 67890: 54 9 87 45 67\nSeed 12345: 74 66 98 78 23"
        },
        {
          "title": "Using srand in a Simple Game",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint main() {\n    int secret_number, guess, attempts = 0;\n    \n    srand((unsigned int)time(NULL));\n    secret_number = rand() % 100 + 1;  // Random number between 1 and 100\n    \n    printf(\"Guess the number (1-100):\\n\");\n    \n    do {\n        scanf(\"%d\", &guess);\n        attempts++;\n        \n        if (guess > secret_number) {\n            printf(\"Too high! Try again.\\n\");\n        } else if (guess < secret_number) {\n            printf(\"Too low! Try again.\\n\");\n        } else {\n            printf(\"Congratulations! You guessed it in %d attempts.\\n\", attempts);\n        }\n    } while (guess != secret_number);\n    \n    return 0;\n}",
          "explanation": "This example uses srand to initialize a random number generator for a simple guessing game.",
          "expectedOutput": "Guess the number (1-100):\n50\nToo low! Try again.\n75\nToo high! Try again.\n62\nCongratulations! You guessed it in 3 attempts.\n\nNote: The actual game play will vary each time."
        }
      ],
      "related_functions": ["rand", "time"],
      "performance_considerations": "srand should typically be called only once at the start of the program. Calling it repeatedly (e.g., inside a loop) can lead to poor randomness. For cryptographic purposes or high-quality random numbers, consider using more sophisticated random number generators. In multi-threaded programs, be cautious about using rand() and srand(), as they may not be thread-safe."
    },
  
    {
      "function_name": "sscanf",
      "include_file": "stdio.h",
      "return_type": "int",
      "parameter_types": ["const char*", "const char*", "..."],
      "main_category": "File and I/O Operations",
      "sub_category": "Stream Manipulation",
      "data_type_manipulated": "strings",
      "description": "Reads formatted input from a string.",
      "extended_description": "The sscanf function reads formatted input from a string. It parses the C string str interpreting its content according to the format specified in format, which follows the same specifications as those for scanf. The resulting values are stored in the locations pointed by the additional arguments.",
      "return_value": "Returns the number of items successfully filled. This count can match the expected number of items or be less (even zero) in case of a matching failure. EOF is returned if the end of the input string is reached before any conversion.",
      "parameter_values": "str: C string containing the data to be scanned.\nformat: C string containing a format string that follows the same specifications as format in scanf.\n...: Additional arguments containing pointers to allocated objects of the type specified by their corresponding format specifier.",
      "function_prototype": "int sscanf(const char *str, const char *format, ...);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n\nint main() {\n    const char *input = \"John 25 180.5\";\n    char name[20];\n    int age;\n    float height;\n    \n    int result = sscanf(input, \"%s %d %f\", name, &age, &height);\n    \n    if (result == 3) {\n        printf(\"Name: %s\\nAge: %d\\nHeight: %.1f\\n\", name, age, height);\n    } else {\n        printf(\"Failed to parse all fields. Parsed %d field(s)\\n\", result);\n    }\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of sscanf to parse a string containing a name, age, and height.",
          "expectedOutput": "Name: John\nAge: 25\nHeight: 180.5"
        },
        {
          "title": "Parsing with Field Width",
          "code": "#include <stdio.h>\n\nint main() {\n    const char *input = \"12345678 abcdefgh\";\n    char first[5], second[5];\n    \n    sscanf(input, \"%4s %4s\", first, second);\n    \n    printf(\"First 4 characters: %s\\n\", first);\n    printf(\"Next 4 characters: %s\\n\", second);\n    \n    return 0;\n}",
          "explanation": "This example shows how to use field width in sscanf to limit the number of characters read.",
          "expectedOutput": "First 4 characters: 1234\nNext 4 characters: abcd"
        },
        {
          "title": "Parsing Date and Time",
          "code": "#include <stdio.h>\n\nint main() {\n    const char *input = \"2023-05-15 14:30:45\";\n    int year, month, day, hour, minute, second;\n    \n    int result = sscanf(input, \"%d-%d-%d %d:%d:%d\", &year, &month, &day, &hour, &minute, &second);\n    \n    if (result == 6) {\n        printf(\"Date: %04d-%02d-%02d\\n\", year, month, day);\n        printf(\"Time: %02d:%02d:%02d\\n\", hour, minute, second);\n    } else {\n        printf(\"Failed to parse date and time. Parsed %d field(s)\\n\", result);\n    }\n    \n    return 0;\n}",
          "explanation": "This example demonstrates how to use sscanf to parse a date and time string.",
          "expectedOutput": "Date: 2023-05-15\nTime: 14:30:45"
        }
      ],
      "related_functions": ["scanf", "fscanf", "sprintf"],
      "performance_considerations": "sscanf is generally efficient for parsing simple strings. However, for complex or large-scale parsing tasks, consider using more specialized parsing libraries or writing custom parsers. Be cautious about buffer overflows when reading strings; always specify a maximum field width for string inputs."
    },
    {
      "function_name": "strcasecmp",
      "include_file": "strings.h",
      "return_type": "int",
      "parameter_types": ["const char*", "const char*"],
      "main_category": "Data Search and Sorting",
      "sub_category": "String Comparison",
      "data_type_manipulated": "strings",
      "description": "Compares two strings ignoring the case of the characters.",
      "extended_description": "The strcasecmp function compares two strings s1 and s2, ignoring the case of the characters. It returns an integer less than, equal to, or greater than zero if s1 is found, respectively, to be less than, to match, or be greater than s2. This function is not part of the C standard library but is available in POSIX systems.",
      "return_value": "Returns an integer less than, equal to, or greater than zero if s1 is found, respectively, to be less than, to match, or be greater than s2.",
      "parameter_values": "s1: The first string to be compared.\ns2: The second string to be compared.",
      "function_prototype": "int strcasecmp(const char *s1, const char *s2);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <strings.h>\n\nint main() {\n    const char *str1 = \"Hello\";\n    const char *str2 = \"hello\";\n    const char *str3 = \"World\";\n    \n    printf(\"Comparing '%s' and '%s': %d\\n\", str1, str2, strcasecmp(str1, str2));\n    printf(\"Comparing '%s' and '%s': %d\\n\", str1, str3, strcasecmp(str1, str3));\n    printf(\"Comparing '%s' and '%s': %d\\n\", str3, str1, strcasecmp(str3, str1));\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of strcasecmp to compare strings ignoring case.",
          "expectedOutput": "Comparing 'Hello' and 'hello': 0\nComparing 'Hello' and 'World': -15\nComparing 'World' and 'Hello': 15"
        },
        {
          "title": "Case-Insensitive Sorting",
          "code": "#include <stdio.h>\n#include <strings.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return strcasecmp(*(const char **)a, *(const char **)b);\n}\n\nint main() {\n    const char *words[] = {\"apple\", \"Banana\", \"CHERRY\", \"Date\", \"elderberry\"};\n    int n = sizeof(words) / sizeof(words[0]);\n    \n    qsort(words, n, sizeof(words[0]), compare);\n    \n    printf(\"Sorted words (case-insensitive):\\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", words[i]);\n    }\n    \n    return 0;\n}",
          "explanation": "This example uses strcasecmp in a comparison function for qsort to sort an array of strings case-insensitively.",
          "expectedOutput": "Sorted words (case-insensitive):\napple\nBanana\nCHERRY\nDate\nelderberry"
        },
        {
          "title": "Case-Insensitive String Search",
          "code": "#include <stdio.h>\n#include <strings.h>\n#include <stdbool.h>\n\nbool case_insensitive_search(const char *haystack[], int size, const char *needle) {\n    for (int i = 0; i < size; i++) {\n        if (strcasecmp(haystack[i], needle) == 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    const char *fruits[] = {\"Apple\", \"Banana\", \"Cherry\", \"Date\", \"Elderberry\"};\n    int n = sizeof(fruits) / sizeof(fruits[0]);\n    \n    const char *search_terms[] = {\"banana\", \"CHERRY\", \"Fig\", \"date\"};\n    int m = sizeof(search_terms) / sizeof(search_terms[0]);\n    \n    for (int i = 0; i < m; i++) {\n        if (case_insensitive_search(fruits, n, search_terms[i])) {\n            printf(\"'%s' found in the list.\\n\", search_terms[i]);\n        } else {\n            printf(\"'%s' not found in the list.\\n\", search_terms[i]);\n        }\n    }\n    \n    return 0;\n}",
          "explanation": "This example demonstrates using strcasecmp to perform a case-insensitive search in an array of strings.",
          "expectedOutput": "'banana' found in the list.\n'CHERRY' found in the list.\n'Fig' not found in the list.\n'date' found in the list."
        }
      ],
      "related_functions": ["strcmp", "strncasecmp", "strcoll"],
      "performance_considerations": "strcasecmp is generally efficient for string comparisons. However, it may be slower than strcmp for case-sensitive comparisons. For frequent comparisons of the same strings, consider caching the results. In performance-critical code, if you know the strings are always in a specific case (e.g., all lowercase), using strcmp might be faster."
    },
    {
      "function_name": "strcat",
      "include_file": "string.h",
      "return_type": "char*",
      "parameter_types": ["char*", "const char*"],
      "main_category": "String Operations",
      "sub_category": "Manipulation",
      "data_type_manipulated": "strings",
      "description": "Appends the source string to the destination string.",
      "extended_description": "The strcat function appends a copy of the source string to the destination string. The terminating null character in destination is overwritten by the first character of source, and a new null-character is appended at the end of the new string formed by the concatenation of both in destination.",
      "return_value": "Returns a pointer to the resulting string destination.",
      "parameter_values": "destination: Pointer to the destination array, which should contain a C string, and be large enough to contain the concatenated resulting string.\nsource: C string to be appended. This should not overlap destination.",
      "function_prototype": "char *strcat(char *destination, const char *source);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[50] = \"Hello \";\n    char *result = strcat(str, \"World!\");\n    \n    printf(\"Concatenated string: %s\\n\", str);\n    printf(\"Return value: %s\\n\", result);\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of strcat to concatenate two strings.",
          "expectedOutput": "Concatenated string: Hello World!\nReturn value: Hello World!"
        },
        {
          "title": "Multiple Concatenations",
          "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[100] = \"The \";\n    strcat(str, \"quick \");\n    strcat(str, \"brown \");\n    strcat(str, \"fox \");\n    strcat(str, \"jumps.\");\n    \n    printf(\"Final string: %s\\n\", str);\n    printf(\"String length: %lu\\n\", strlen(str));\n    \n    return 0;\n}",
          "explanation": "This example shows how to use strcat multiple times to build a longer string.",
          "expectedOutput": "Final string: The quick brown fox jumps.\nString length: 26"
        },
        {
          "title": "Safe String Concatenation",
          "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_SIZE 20\n\nint safe_strcat(char *dest, const char *src, size_t dest_size) {\n    size_t dest_len = strlen(dest);\n    size_t space_left = dest_size - dest_len - 1;  // -1 for null terminator\n    \n    if (space_left < strlen(src)) {\n        strncpy(dest + dest_len, src, space_left);\n        dest[dest_size - 1] = '\\0';\n        return 0;  // Indicate truncation\n    } else {\n        strcat(dest, src);\n        return 1;  // Indicate success\n    }\n}\n\nint main() {\n    char str[MAX_SIZE] = \"Hello \";\n    const char *append1 = \"World!\";\n    const char *append2 = \" How are you?\";\n    \n    printf(\"Initial string: %s\\n\", str);\n    \n    if (safe_strcat(str, append1, MAX_SIZE)) {\n        printf(\"After first append: %s\\n\", str);\n    } else {\n        printf(\"First append truncated: %s\\n\", str);\n    }\n    \n    if (safe_strcat(str, append2, MAX_SIZE)) {\n        printf(\"After second append: %s\\n\", str);\n    } else {\n        printf(\"Second append truncated: %s\\n\", str);\n    }\n    \n    return 0;\n}",
          "explanation": "This example demonstrates a safer way to use strcat by implementing a function that checks for buffer overflow.",
          "expectedOutput": "Initial string: Hello \nAfter first append: Hello World!\nSecond append truncated: Hello World! How are"
        }
      ],
      "related_functions": ["strncat", "strcpy", "strlen"],
      "performance_considerations": "strcat can be inefficient for multiple concatenations as it needs to find the end of the destination string each time. For building strings from many parts, consider using a string builder pattern or preallocating a sufficiently large buffer. Be cautious about buffer overflows; strcat does not check for sufficient space in the destination buffer."
    },
    
      {
        "function_name": "strchr",
        "include_file": "string.h",
        "return_type": "char*",
        "parameter_types": ["const char*", "int"],
        "main_category": "String Operations",
        "sub_category": "Search",
        "data_type_manipulated": "strings",
        "description": "Searches for the first occurrence of the character in the string.",
        "extended_description": "The strchr function locates the first occurrence of c (converted to a char) in the string pointed to by s. The terminating null character is considered to be part of the string. If c is '\\0', strchr locates the terminating '\\0'.",
        "return_value": "Returns a pointer to the located character, or NULL if the character does not appear in the string.",
        "parameter_values": "s: The C string to be scanned.\nc: The character to be searched for.",
        "function_prototype": "char *strchr(const char *s, int c);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    const char *str = \"Hello, World!\";\n    char ch = 'o';\n    char *result = strchr(str, ch);\n    \n    if (result != NULL) {\n        printf(\"'%c' found at position: %ld\\n\", ch, result - str);\n        printf(\"Substring starting from '%c': %s\\n\", ch, result);\n    } else {\n        printf(\"'%c' not found in the string.\\n\", ch);\n    }\n    \n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of strchr to find the first occurrence of 'o' in a string.",
            "expectedOutput": "'o' found at position: 4\nSubstring starting from 'o': o, World!"
          },
          {
            "title": "Finding Multiple Occurrences",
            "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    const char *str = \"Hello, World!\";\n    char ch = 'l';\n    char *result = strchr(str, ch);\n    \n    while (result != NULL) {\n        printf(\"'%c' found at position: %ld\\n\", ch, result - str);\n        result = strchr(result + 1, ch);\n    }\n    \n    return 0;\n}",
            "explanation": "This example shows how to use strchr in a loop to find all occurrences of a character in a string.",
            "expectedOutput": "'l' found at position: 2\n'l' found at position: 3\n'l' found at position: 10"
          },
          {
            "title": "Checking for String Termination",
            "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    const char *str = \"Hello\\0World\";\n    char *result = strchr(str, '\\0');\n    \n    if (result != NULL) {\n        printf(\"Null terminator found at position: %ld\\n\", result - str);\n        printf(\"Characters after null: \");\n        for (const char *p = result + 1; *p != '\\0'; p++) {\n            putchar(*p);\n        }\n        printf(\"\\n\");\n    } else {\n        printf(\"Null terminator not found (this should never happen).\\n\");\n    }\n    \n    return 0;\n}",
            "explanation": "This example demonstrates using strchr to find the null terminator and examine characters beyond it in a string with embedded nulls.",
            "expectedOutput": "Null terminator found at position: 5\nCharacters after null: World"
          }
        ],
        "related_functions": ["strrchr", "memchr", "strstr"],
        "performance_considerations": "strchr is generally efficient for searching a single character in a string. For frequent searches in the same string, consider using more advanced string matching algorithms or data structures. For very long strings, strchr may not be as efficient as other algorithms like Boyer-Moore for single character search."
      },
      {
        "function_name": "strcmp",
        "include_file": "string.h",
        "return_type": "int",
        "parameter_types": ["const char*", "const char*"],
        "main_category": "Data Search and Sorting",
        "sub_category": "String Comparison",
        "data_type_manipulated": "strings",
        "description": "Compares two strings lexicographically.",
        "extended_description": "The strcmp function compares the C string str1 to the C string str2. This function starts comparing the first character of each string. If they are equal to each other, it continues with the following pairs until the characters differ or until a terminating null-character is reached.",
        "return_value": "Returns an integer less than, equal to, or greater than zero if str1 is found, respectively, to be less than, to match, or be greater than str2.",
        "parameter_values": "str1: The first string to be compared.\nstr2: The second string to be compared.",
        "function_prototype": "int strcmp(const char *str1, const char *str2);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    const char *str1 = \"apple\";\n    const char *str2 = \"banana\";\n    const char *str3 = \"apple\";\n    \n    printf(\"Comparing '%s' and '%s': %d\\n\", str1, str2, strcmp(str1, str2));\n    printf(\"Comparing '%s' and '%s': %d\\n\", str2, str1, strcmp(str2, str1));\n    printf(\"Comparing '%s' and '%s': %d\\n\", str1, str3, strcmp(str1, str3));\n    \n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of strcmp to compare different strings.",
            "expectedOutput": "Comparing 'apple' and 'banana': -1\nComparing 'banana' and 'apple': 1\nComparing 'apple' and 'apple': 0"
          },
          {
            "title": "Sorting Strings",
            "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint compare_strings(const void *a, const void *b) {\n    return strcmp(*(const char **)a, *(const char **)b);\n}\n\nint main() {\n    const char *fruits[] = {\"banana\", \"apple\", \"cherry\", \"date\", \"elderberry\"};\n    int n = sizeof(fruits) / sizeof(fruits[0]);\n    \n    printf(\"Before sorting:\\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", fruits[i]);\n    }\n    \n    qsort(fruits, n, sizeof(const char *), compare_strings);\n    \n    printf(\"\\nAfter sorting:\\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", fruits[i]);\n    }\n    \n    return 0;\n}",
            "explanation": "This example uses strcmp in a comparison function for qsort to sort an array of strings.",
            "expectedOutput": "Before sorting:\nbanana\napple\ncherry\ndate\nelderberry\n\nAfter sorting:\napple\nbanana\ncherry\ndate\nelderberry"
          },
          {
            "title": "String Matching",
            "code": "#include <stdio.h>\n#include <string.h>\n\nint find_string(const char *needle, const char *haystack[], int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(needle, haystack[i]) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    const char *words[] = {\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"};\n    int n = sizeof(words) / sizeof(words[0]);\n    \n    const char *search_words[] = {\"cherry\", \"fig\", \"banana\"};\n    int m = sizeof(search_words) / sizeof(search_words[0]);\n    \n    for (int i = 0; i < m; i++) {\n        int index = find_string(search_words[i], words, n);\n        if (index != -1) {\n            printf(\"'%s' found at index %d\\n\", search_words[i], index);\n        } else {\n            printf(\"'%s' not found\\n\", search_words[i]);\n        }\n    }\n    \n    return 0;\n}",
            "explanation": "This example demonstrates using strcmp for exact string matching in an array of strings.",
            "expectedOutput": "'cherry' found at index 2\n'fig' not found\n'banana' found at index 1"
          }
        ],
        "related_functions": ["strncmp", "strcasecmp", "memcmp"],
        "performance_considerations": "strcmp is generally efficient for string comparisons. However, for very long strings or frequent comparisons, consider using more advanced string matching algorithms. For case-insensitive comparisons, use strcasecmp instead. In performance-critical code, if you know the maximum length of the strings, consider using strncmp to potentially avoid scanning the entire string."
      },
      {
        "function_name": "strcoll",
        "include_file": "string.h",
        "return_type": "int",
        "parameter_types": ["const char*", "const char*"],
        "main_category": "Data Search and Sorting",
        "sub_category": "String Comparison",
        "data_type_manipulated": "strings",
        "description": "Compares two strings using the current locale.",
        "extended_description": "The strcoll function compares two strings using the collating sequence specified by the program's locale. It's particularly useful for creating sorted lists of strings that will be presented to users in their native language.",
        "return_value": "Returns a negative value if str1 appears before str2 in the current locale's collation sequence, a positive value if str1 appears after str2, and zero if the strings are equivalent in the current locale.",
        "parameter_values": "str1: The first string to be compared.\nstr2: The second string to be compared.",
        "function_prototype": "int strcoll(const char *str1, const char *str2);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <string.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_COLLATE, \"\");  // Set the locale to the system default\n    \n    const char *str1 = \"apple\";\n    const char *str2 = \"banana\";\n    \n    int result = strcoll(str1, str2);\n    \n    printf(\"Comparing '%s' and '%s' in the current locale:\\n\", str1, str2);\n    if (result < 0) {\n        printf(\"'%s' comes before '%s'\\n\", str1, str2);\n    } else if (result > 0) {\n        printf(\"'%s' comes after '%s'\\n\", str1, str2);\n    } else {\n        printf(\"'%s' and '%s' are equivalent in the current locale\\n\", str1, str2);\n    }\n    \n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of strcoll to compare two strings using the system's default locale.",
            "expectedOutput": "Comparing 'apple' and 'banana' in the current locale:\n'apple' comes before 'banana'"
          },
          {
            "title": "Locale-Specific Sorting",
            "code": "#include <stdio.h>\n#include <string.h>\n#include <locale.h>\n#include <stdlib.h>\n\nint compare_strings(const void *a, const void *b) {\n    return strcoll(*(const char **)a, *(const char **)b);\n}\n\nint main() {\n    const char *words[] = {\"café\", \"cafe\", \"apple\", \"étoile\", \"zebra\"};\n    int n = sizeof(words) / sizeof(words[0]);\n    \n    printf(\"Default locale sorting:\\n\");\n    setlocale(LC_COLLATE, \"C\");  // Use the \"C\" locale\n    qsort(words, n, sizeof(const char *), compare_strings);\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", words[i]);\n    }\n    \n    printf(\"\\nFrench locale sorting:\\n\");\n    setlocale(LC_COLLATE, \"fr_FR.UTF-8\");  // Use French locale\n    qsort(words, n, sizeof(const char *), compare_strings);\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", words[i]);\n    }\n    \n    return 0;\n}",
            "explanation": "This example shows how strcoll can be used to sort strings differently based on the locale settings.",
            "expectedOutput": "Default locale sorting:\napple\ncafe\ncafé\nzebra\nétoile\n\nFrench locale sorting:\napple\ncafe\ncafé\nétoile\nzebra\n\nNote: The exact output may vary depending on the system's locale support."
          },
          {
            "title": "Comparing Strings with Accents",
            "code": "#include <stdio.h>\n#include <string.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_COLLATE, \"\");  // Set the locale to the system default\n    \n    const char *str1 = \"résumé\";\n    const char *str2 = \"resume\";\n    \n    int result = strcoll(str1, str2);\n    \n    printf(\"Comparing '%s' and '%s' in the current locale:\\n\", str1, str2);\n    if (result < 0) {\n        printf(\"'%s' comes before '%s'\\n\", str1, str2);\n    } else if (result > 0) {\n        printf(\"'%s' comes after '%s'\\n\", str1, str2);\n    } else {\n        printf(\"'%s' and '%s' are equivalent in the current locale\\n\", str1, str2);\n    }\n    \n    return 0;\n}",
            "explanation": "This example demonstrates how strcoll handles strings with accented characters, which can vary depending on the locale.",
            "expectedOutput": "Comparing 'résumé' and 'resume' in the current locale:\n'résumé' comes after 'resume'\n\nNote: The exact output may vary depending on the system's locale settings."
          }
        ],
        "related_functions": ["strcmp", "setlocale", "strxfrm"],
        "performance_considerations": "strcoll can be significantly slower than strcmp because it needs to take into account complex locale-specific sorting rules. If performance is critical and you don't need locale-specific sorting, use strcmp instead. For repeated comparisons of the same strings, consider using strxfrm to transform the strings once and then compare the transformed strings with"
      },
      
        {
          "function_name": "strcpy",
          "include_file": "string.h",
          "return_type": "char*",
          "parameter_types": ["char*", "const char*"],
          "main_category": "String Operations",
          "sub_category": "Manipulation",
          "data_type_manipulated": "strings",
          "description": "Copies the source string to the destination string.",
          "extended_description": "The strcpy function copies the C string pointed by source (including the null character) to the destination. The destination string must be large enough to receive the copy. Copying overlapping strings is undefined.",
          "return_value": "Returns a pointer to the destination string.",
          "parameter_values": "destination: Pointer to the destination array where the content is to be copied.\nsource: C string to be copied.",
          "function_prototype": "char *strcpy(char *destination, const char *source);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char src[] = \"Hello, World!\";\n    char dest[20];\n    \n    strcpy(dest, src);\n    \n    printf(\"Source string: %s\\n\", src);\n    printf(\"Destination string: %s\\n\", dest);\n    \n    return 0;\n}",
              "explanation": "This example demonstrates basic usage of strcpy to copy a string from source to destination.",
              "expectedOutput": "Source string: Hello, World!\nDestination string: Hello, World!"
            },
            {
              "title": "Potential Buffer Overflow",
              "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char src[] = \"This is a very long string\";\n    char dest[10];\n    \n    strcpy(dest, src);  // Warning: This is unsafe!\n    \n    printf(\"Destination string: %s\\n\", dest);\n    \n    return 0;\n}",
              "explanation": "This example illustrates a potential buffer overflow issue with strcpy. The destination buffer is too small for the source string.",
              "expectedOutput": "Destination string: This is a\nNote: This may cause undefined behavior or crash the program."
            },
            {
              "title": "Safe String Copy",
              "code": "#include <stdio.h>\n#include <string.h>\n\n#define DEST_SIZE 20\n\nint main() {\n    char src[] = \"Hello, World!\";\n    char dest[DEST_SIZE];\n    \n    size_t src_len = strlen(src);\n    if (src_len < DEST_SIZE) {\n        strcpy(dest, src);\n        printf(\"String copied safely: %s\\n\", dest);\n    } else {\n        printf(\"Source string too long to copy safely.\\n\");\n    }\n    \n    return 0;\n}",
              "explanation": "This example shows a safer way to use strcpy by checking the length of the source string before copying.",
              "expectedOutput": "String copied safely: Hello, World!"
            }
          ],
          "related_functions": ["strncpy", "memcpy", "memmove"],
          "performance_considerations": "strcpy is generally efficient for copying strings. However, it doesn't provide bounds checking, which can lead to buffer overflows. For safer string copying, consider using strncpy or custom functions that perform bounds checking. In performance-critical code, if you know the string length, using memcpy might be faster."
        },
        {
          "function_name": "strcspn",
          "include_file": "string.h",
          "return_type": "size_t",
          "parameter_types": ["const char*", "const char*"],
          "main_category": "String Operations",
          "sub_category": "Search",
          "data_type_manipulated": "strings",
          "description": "Scans the first string for the first occurrence of any of the characters in the second string.",
          "extended_description": "The strcspn function calculates the length of the initial segment of str1 which consists entirely of characters not in str2. In other words, it returns the index of the first occurrence in str1 of any of the characters in str2, or the length of str1 if none of the characters in str2 are found in str1.",
          "return_value": "Returns the number of characters in the initial segment of str1 which are not in str2.",
          "parameter_values": "str1: C string to be scanned.\nstr2: C string containing the characters to match.",
          "function_prototype": "size_t strcspn(const char *str1, const char *str2);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    const char *str1 = \"Hello, World!\";\n    const char *str2 = \",.!\";\n    \n    size_t length = strcspn(str1, str2);\n    \n    printf(\"Length of initial segment: %zu\\n\", length);\n    printf(\"First matching character: '%c'\\n\", str1[length]);\n    \n    return 0;\n}",
              "explanation": "This example demonstrates basic usage of strcspn to find the first occurrence of any punctuation mark in a string.",
              "expectedOutput": "Length of initial segment: 5\nFirst matching character: ','"
            },
            {
              "title": "Using strcspn for Input Validation",
              "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_INPUT 100\n\nint main() {\n    char input[MAX_INPUT];\n    const char *valid_chars = \"0123456789\";\n    \n    printf(\"Enter a number: \");\n    fgets(input, sizeof(input), stdin);\n    \n    // Remove newline if present\n    input[strcspn(input, \"\\n\")] = 0;\n    \n    size_t valid_length = strcspn(input, valid_chars);\n    \n    if (valid_length == 0) {\n        printf(\"Valid input: %s\\n\", input);\n    } else {\n        printf(\"Invalid character '%c' found at position %zu\\n\", input[valid_length], valid_length);\n    }\n    \n    return 0;\n}",
              "explanation": "This example uses strcspn for input validation, checking if a string contains only numeric characters.",
              "expectedOutput": "Enter a number: 123a45\nInvalid character 'a' found at position 3"
            },
            {
              "title": "Finding Word Boundaries",
              "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    const char *sentence = \"This is a sample sentence.\";\n    const char *delimiters = \" \\t\\n.\";\n    size_t word_start = 0;\n    size_t word_end;\n    \n    printf(\"Words in the sentence:\\n\");\n    \n    while (sentence[word_start] != '\\0') {\n        word_end = word_start + strcspn(&sentence[word_start], delimiters);\n        \n        if (word_end > word_start) {\n            printf(\"%.*s\\n\", (int)(word_end - word_start), &sentence[word_start]);\n        }\n        \n        word_start = word_end + 1;\n    }\n    \n    return 0;\n}",
              "explanation": "This example uses strcspn to find word boundaries in a sentence by identifying sequences of non-delimiter characters.",
              "expectedOutput": "Words in the sentence:\nThis\nis\na\nsample\nsentence"
            }
          ],
          "related_functions": ["strspn", "strpbrk", "strtok"],
          "performance_considerations": "strcspn scans both strings character by character, which can be inefficient for very long strings or when called repeatedly. For frequent searches or long strings, consider using more advanced string searching algorithms or data structures like hash tables for the character set."
        },
        {
          "function_name": "strerror",
          "include_file": "string.h",
          "return_type": "char*",
          "parameter_types": ["int"],
          "main_category": "Error Handling and Debugging",
          "sub_category": "Error Reporting",
          "data_type_manipulated": "strings",
          "description": "Returns a pointer to the textual representation of the current errno value.",
          "extended_description": "The strerror function returns a pointer to a string that describes the error code passed in the argument errnum. The error strings returned by strerror depend on the developing platform and compiler. The returned string must not be modified by the program, but may be overwritten by a subsequent call to strerror.",
          "return_value": "Returns a pointer to the error string describing error errnum.",
          "parameter_values": "errnum: Error number, usually errno.",
          "function_prototype": "char *strerror(int errnum);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n\nint main() {\n    FILE *file = fopen(\"nonexistent_file.txt\", \"r\");\n    if (file == NULL) {\n        printf(\"Error opening file: %s\\n\", strerror(errno));\n    } else {\n        fclose(file);\n    }\n    \n    return 0;\n}",
              "explanation": "This example demonstrates basic usage of strerror to get a description of an error when trying to open a non-existent file.",
              "expectedOutput": "Error opening file: No such file or directory"
            },
            {
              "title": "Custom Error Handling",
              "code": "#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n\nvoid custom_error_handler(const char *function_name) {\n    fprintf(stderr, \"Error in %s: %s\\n\", function_name, strerror(errno));\n}\n\nint main() {\n    FILE *file = fopen(\"protected_file.txt\", \"w\");\n    if (file == NULL) {\n        custom_error_handler(\"fopen\");\n    } else {\n        fclose(file);\n    }\n    \n    int result = mkdir(\"/root/new_directory\", 0777);\n    if (result != 0) {\n        custom_error_handler(\"mkdir\");\n    }\n    \n    return 0;\n}",
              "explanation": "This example shows how to use strerror in a custom error handling function for different types of errors.",
              "expectedOutput": "Error in fopen: Permission denied\nError in mkdir: Permission denied\n\nNote: The exact error messages may vary depending on the system and permissions."
            },
            {
              "title": "Handling Multiple Errors",
              "code": "#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n\nvoid print_error(int error_code) {\n    printf(\"Error %d: %s\\n\", error_code, strerror(error_code));\n}\n\nint main() {\n    int error_codes[] = {EACCES, ENOENT, EINVAL, ENOMEM};\n    int num_errors = sizeof(error_codes) / sizeof(error_codes[0]);\n    \n    printf(\"Common error codes and their descriptions:\\n\");\n    for (int i = 0; i < num_errors; i++) {\n        print_error(error_codes[i]);\n    }\n    \n    return 0;\n}",
              "explanation": "This example demonstrates how to use strerror to print descriptions for multiple error codes.",
              "expectedOutput": "Common error codes and their descriptions:\nError 13: Permission denied\nError 2: No such file or directory\nError 22: Invalid argument\nError 12: Cannot allocate memory\n\nNote: The exact error numbers and messages may vary depending on the system."
            }
          ],
          "related_functions": ["perror", "errno"],
          "performance_considerations": "strerror is generally efficient for occasional use. However, it's not thread-safe in all implementations. For thread-safe error reporting, consider using strerror_r if available. In performance-critical code, if you're dealing with a fixed set of known error codes, you might consider creating a lookup table to avoid repeated calls to strerror."
        },
    
      {
        "function_name": "strfmon",
        "include_file": "monetary.h",
        "return_type": "ssize_t",
        "parameter_types": ["char*", "size_t", "const char*", "..."],
        "main_category": "Data Formatting",
        "sub_category": "Monetary Formatting",
        "data_type_manipulated": "strings",
        "description": "Formats monetary values according to the locale settings.",
        "extended_description": "The strfmon function formats monetary values into a string according to the current locale's settings. It allows for flexible formatting of currency amounts, including currency symbols, thousands separators, and decimal points.",
        "return_value": "Returns the number of characters placed in the array pointed to by s, not including the terminating null character. If the resulting string is too long to fit in n bytes, a negative value is returned and errno may be set to ERANGE.",
        "parameter_values": "s: Pointer to a character array where the formatted string will be stored.\nmax: Maximum number of bytes to be used in the array.\nformat: String containing literal characters and format specifications.\n...: Monetary amounts to be formatted.",
        "function_prototype": "ssize_t strfmon(char *s, size_t max, const char *format, ...);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <monetary.h>\n#include <locale.h>\n\nint main() {\n    char buffer[100];\n    double amount = 1234.56;\n    \n    setlocale(LC_ALL, \"\");  // Set locale to system default\n    \n    ssize_t result = strfmon(buffer, sizeof(buffer), \"%n\", amount);\n    \n    if (result >= 0) {\n        printf(\"Formatted amount: %s\\n\", buffer);\n    } else {\n        printf(\"Error formatting amount\\n\");\n    }\n    \n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of strfmon to format a monetary value using the system's default locale.",
            "expectedOutput": "Formatted amount: $1,234.56\nNote: The exact output may vary depending on the system's locale settings."
          },
          {
            "title": "Custom Formatting",
            "code": "#include <stdio.h>\n#include <monetary.h>\n#include <locale.h>\n\nint main() {\n    char buffer[100];\n    double amount1 = 1234.56;\n    double amount2 = -9876.54;\n    \n    setlocale(LC_ALL, \"en_US.UTF-8\");  // Set locale to US English\n    \n    ssize_t result = strfmon(buffer, sizeof(buffer),\n                              \"Amount 1: %^#5.2n\\nAmount 2: %^#5.2n\",\n                              amount1, amount2);\n    \n    if (result >= 0) {\n        printf(\"%s\\n\", buffer);\n    } else {\n        printf(\"Error formatting amounts\\n\");\n    }\n    \n    return 0;\n}",
            "explanation": "This example shows how to use custom format specifiers with strfmon to control the output format.",
            "expectedOutput": "Amount 1: USD 1,234.56\nAmount 2: USD -9,876.54\nNote: The exact output may vary depending on the system's locale settings."
          },
          {
            "title": "International Formatting",
            "code": "#include <stdio.h>\n#include <monetary.h>\n#include <locale.h>\n\nint main() {\n    char buffer[100];\n    double amount = 1234567.89;\n    \n    const char *locales[] = {\"en_US.UTF-8\", \"fr_FR.UTF-8\", \"de_DE.UTF-8\"};\n    int num_locales = sizeof(locales) / sizeof(locales[0]);\n    \n    for (int i = 0; i < num_locales; i++) {\n        if (setlocale(LC_ALL, locales[i]) != NULL) {\n            ssize_t result = strfmon(buffer, sizeof(buffer), \"%i\", amount);\n            if (result >= 0) {\n                printf(\"%s: %s\\n\", locales[i], buffer);\n            } else {\n                printf(\"%s: Error formatting amount\\n\", locales[i]);\n            }\n        } else {\n            printf(\"Failed to set locale: %s\\n\", locales[i]);\n        }\n    }\n    \n    return 0;\n}",
            "explanation": "This example demonstrates how strfmon formats the same monetary value differently based on various international locales.",
            "expectedOutput": "en_US.UTF-8: USD 1,234,567.89\nfr_FR.UTF-8: 1 234 567,89 €\nde_DE.UTF-8: 1.234.567,89 €\nNote: The exact output and available locales may vary depending on the system."
          }
        ],
        "related_functions": ["setlocale", "localeconv"],
        "performance_considerations": "strfmon relies on the current locale settings, which can make it relatively slow compared to hardcoded formatting. For high-performance applications dealing with a large number of monetary values, consider caching the locale information and implementing custom formatting functions."
      },
      {
        "function_name": "strftime",
        "include_file": "time.h",
        "return_type": "size_t",
        "parameter_types": ["char*", "size_t", "const char*", "const struct tm*"],
        "main_category": "Time and Date Management",
        "sub_category": "Time Formatting",
        "data_type_manipulated": "strings",
        "description": "Formats the time and date according to the locale settings and format string.",
        "extended_description": "The strftime function formats the time represented in the struct tm object according to the formatting rules defined in format. The resulting C string is stored in the character array pointed by str.",
        "return_value": "Returns the number of characters placed in the array str if the total number including the terminating null character is not more than max. Otherwise, it returns 0 and the contents of the array are indeterminate.",
        "parameter_values": "str: Pointer to the destination array where the resulting C string is copied.\nmax: Maximum number of characters to be copied to str.\nformat: C string containing any combination of regular characters and special format specifiers.\ntimeptr: Pointer to a tm structure that contains a calendar time broken down into its components.",
        "function_prototype": "size_t strftime(char *str, size_t max, const char *format, const struct tm *timeptr);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    time_t current_time;\n    struct tm *time_info;\n    char time_string[50];\n    \n    time(&current_time);\n    time_info = localtime(&current_time);\n    \n    strftime(time_string, sizeof(time_string), \"%Y-%m-%d %H:%M:%S\", time_info);\n    printf(\"Current time: %s\\n\", time_string);\n    \n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of strftime to format the current date and time.",
            "expectedOutput": "Current time: 2023-05-15 14:30:45\nNote: The actual output will reflect the current date and time when the program is run."
          },
          {
            "title": "Custom Formatting",
            "code": "#include <stdio.h>\n#include <time.h>\n#include <locale.h>\n\nint main() {\n    time_t current_time;\n    struct tm *time_info;\n    char time_string[100];\n    \n    setlocale(LC_TIME, \"\");  // Set locale to system default\n    time(&current_time);\n    time_info = localtime(&current_time);\n    \n    strftime(time_string, sizeof(time_string),\n              \"It's %I:%M %p on %A, %B %d, %Y (Week %U)\",\n              time_info);\n    printf(\"%s\\n\", time_string);\n    \n    return 0;\n}",
            "explanation": "This example shows how to use various format specifiers with strftime for a more customized output.",
            "expectedOutput": "It's 02:30 PM on Monday, May 15, 2023 (Week 20)\nNote: The actual output will reflect the current date and time when the program is run."
          },
          {
            "title": "Locale-Specific Formatting",
            "code": "#include <stdio.h>\n#include <time.h>\n#include <locale.h>\n\nint main() {\n    time_t current_time;\n    struct tm *time_info;\n    char time_string[100];\n    \n    const char *locales[] = {\"en_US.UTF-8\", \"fr_FR.UTF-8\", \"de_DE.UTF-8\"};\n    int num_locales = sizeof(locales) / sizeof(locales[0]);\n    \n    time(&current_time);\n    time_info = localtime(&current_time);\n    \n    for (int i = 0; i < num_locales; i++) {\n        if (setlocale(LC_TIME, locales[i]) != NULL) {\n            strftime(time_string, sizeof(time_string),\n                      \"%A, %d %B %Y\",\n                      time_info);\n            printf(\"%s: %s\\n\", locales[i], time_string);\n        } else {\n            printf(\"Failed to set locale: %s\\n\", locales[i]);\n        }\n    }\n    \n    return 0;\n}",
            "explanation": "This example demonstrates how strftime formats the same date differently based on various international locales.",
            "expectedOutput": "en_US.UTF-8: Monday, 15 May 2023\nfr_FR.UTF-8: lundi, 15 mai 2023\nde_DE.UTF-8: Montag, 15. Mai 2023\nNote: The exact output and available locales may vary depending on the system."
          }
        ],
        "related_functions": ["time", "localtime", "gmtime", "mktime"],
        "performance_considerations": "strftime is generally efficient for formatting dates and times. However, if you need to format many dates in a performance-critical section, consider caching the locale information and using a custom formatting function. Also, be aware that some format specifiers may be more computationally expensive than others."
      },
      {
        "function_name": "strlen",
        "include_file": "string.h",
        "return_type": "size_t",
        "parameter_types": ["const char*"],
        "main_category": "String Operations",
        "sub_category": "Measurement",
        "data_type_manipulated": "strings",
        "description": "Calculates the length of the string, excluding the null terminator.",
        "extended_description": "The strlen function computes the length of the string str up to, but not including the terminating null character. This function does not modify the string and does not check for a maximum length, so it can be dangerous if used on strings that are not properly null-terminated.",
        "return_value": "Returns the number of characters in the string before the first null character is encountered.",
        "parameter_values": "str: Pointer to the null-terminated byte string to be examined.",
        "function_prototype": "size_t strlen(const char *str);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    const char *str = \"Hello, World!\";\n    size_t length = strlen(str);\n    \n    printf(\"The length of \\\"%s\\\" is %zu characters.\\n\", str, length);\n    \n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of strlen to find the length of a string literal.",
            "expectedOutput": "The length of \"Hello, World!\" is 13 characters."
          },
          {
            "title": "Using strlen with User Input",
            "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_INPUT 100\n\nint main() {\n    char input[MAX_INPUT];\n    \n    printf(\"Enter a string: \");\n    fgets(input, sizeof(input), stdin);\n    \n    // Remove newline if present\n    input[strcspn(input, \"\\n\")] = 0;\n    \n    size_t length = strlen(input);\n    \n    printf(\"You entered: \\\"%s\\\"\\n\", input);\n    printf(\"The length of your input is %zu characters.\\n\", length);\n    \n    return 0;\n}",
            "explanation": "This example shows how to use strlen with user input, including handling the newline character from fgets.",
            "expectedOutput": "Enter a string: Hello, User!\nYou entered: \"Hello, User!\"\nThe length of your input is 12 characters."
          },
          {
            "title": "strlen with Empty and Null Strings",
            "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    const char *empty_str = \"\";\n    const char *null_str = NULL;\n    \n    printf(\"Length of empty string: %zu\\n\", strlen(empty_str));\n    \n    // Warning: This will cause undefined behavior!\n    // printf(\"Length of null string: %zu\\n\", strlen(null_str));\n    \n    // Safer approach\n    if (null_str != NULL) {\n        printf(\"Length of null_str: %zu\\n\", strlen(null_str));\n    } else {\n        printf(\"null_str is NULL, cannot calculate length\\n\");\n    }\n    \n    return 0;\n}",
            "explanation": "This example demonstrates strlen's behavior with empty strings and shows how to safely handle potential null pointers.",
            "expectedOutput": "Length of empty string: 0\nnull_str is NULL, cannot calculate length"
          }
        ],
        "related_functions": ["strnlen", "strcpy", "strncpy"],
        "performance_considerations": "strlen is generally efficient as it simply counts characters until it reaches the null terminator. However, for very long strings, it can become a performance bottleneck if called frequently. In such cases, consider caching the length if the string is not expected to change. Also, be aware that strlen needs to scan the entire string, so for operations where you only need to know if a string is empty or not, a simple check of the first character can be more efficient."
      },
      
        {
          "function_name": "strncasecmp",
          "include_file": "strings.h",
          "return_type": "int",
          "parameter_types": ["const char*", "const char*", "size_t"],
          "main_category": "Data Search and Sorting",
          "sub_category": "String Comparison",
          "data_type_manipulated": "strings",
          "description": "Compares a specified number of characters from two strings, ignoring case.",
          "extended_description": "The strncasecmp function compares up to n characters of two strings without sensitivity to case. It returns an integer less than, equal to, or greater than zero if s1 is found, respectively, to be less than, to match, or be greater than s2. This function is not part of the C standard library but is available in POSIX systems.",
          "return_value": "Returns an integer less than, equal to, or greater than zero if s1 (or the first n bytes thereof) is found, respectively, to be less than, to match, or be greater than s2.",
          "parameter_values": "s1: The first string to be compared.\ns2: The second string to be compared.\nn: The maximum number of characters to compare.",
          "function_prototype": "int strncasecmp(const char *s1, const char *s2, size_t n);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <strings.h>\n\nint main() {\n    const char *str1 = \"Hello, World!\";\n    const char *str2 = \"HELLO, EARTH!\";\n    size_t n = 5;\n    \n    int result = strncasecmp(str1, str2, n);\n    \n    if (result == 0) {\n        printf(\"The first %zu characters of the strings are equal (ignoring case).\\n\", n);\n    } else if (result < 0) {\n        printf(\"'%s' is less than '%s' (first %zu characters, ignoring case).\\n\", str1, str2, n);\n    } else {\n        printf(\"'%s' is greater than '%s' (first %zu characters, ignoring case).\\n\", str1, str2, n);\n    }\n    \n    return 0;\n}",
              "explanation": "This example demonstrates basic usage of strncasecmp to compare the first 5 characters of two strings, ignoring case.",
              "expectedOutput": "The first 5 characters of the strings are equal (ignoring case)."
            },
            {
              "title": "Partial String Comparison",
              "code": "#include <stdio.h>\n#include <strings.h>\n\nint main() {\n    const char *str1 = \"programming\";\n    const char *str2 = \"PROGRAMMER\";\n    size_t n = 7;\n    \n    int result = strncasecmp(str1, str2, n);\n    \n    printf(\"Comparing the first %zu characters:\\n\", n);\n    printf(\"str1: %s\\n\", str1);\n    printf(\"str2: %s\\n\", str2);\n    \n    if (result == 0) {\n        printf(\"Result: Strings are equal up to %zu characters.\\n\", n);\n    } else if (result < 0) {\n        printf(\"Result: str1 is less than str2.\\n\");\n    } else {\n        printf(\"Result: str1 is greater than str2.\\n\");\n    }\n    \n    return 0;\n}",
              "explanation": "This example shows how strncasecmp can be used to compare only a portion of two strings, which is useful when the strings have different lengths or when you're only interested in a specific part of the strings.",
              "expectedOutput": "Comparing the first 7 characters:\nstr1: programming\nstr2: PROGRAMMER\nResult: Strings are equal up to 7 characters."
            },
            {
              "title": "Using strncasecmp in String Sorting",
              "code": "#include <stdio.h>\n#include <strings.h>\n#include <stdlib.h>\n\n#define MAX_STRINGS 5\n#define MAX_LENGTH 20\n\nint compare_strings(const void *a, const void *b) {\n    return strncasecmp(*(const char **)a, *(const char **)b, MAX_LENGTH);\n}\n\nint main() {\n    char *strings[MAX_STRINGS] = {\n        \"Apple\",\n        \"banana\",\n        \"CHERRY\",\n        \"Date\",\n        \"elderberry\"\n    };\n    \n    printf(\"Before sorting:\\n\");\n    for (int i = 0; i < MAX_STRINGS; i++) {\n        printf(\"%s\\n\", strings[i]);\n    }\n    \n    qsort(strings, MAX_STRINGS, sizeof(char *), compare_strings);\n    \n    printf(\"\\nAfter case-insensitive sorting:\\n\");\n    for (int i = 0; i < MAX_STRINGS; i++) {\n        printf(\"%s\\n\", strings[i]);\n    }\n    \n    return 0;\n}",
              "explanation": "This example demonstrates how to use strncasecmp as a comparison function for qsort to perform case-insensitive sorting of an array of strings.",
              "expectedOutput": "Before sorting:\nApple\nbanana\nCHERRY\nDate\nelderberry\n\nAfter case-insensitive sorting:\nApple\nbanana\nCHERRY\nDate\nelderberry"
            }
          ],
          "related_functions": ["strcasecmp", "strncmp", "strcmp"],
          "performance_considerations": "strncasecmp is generally efficient for comparing short to medium-length strings. However, for very long strings or frequent comparisons, it may be less efficient than case-sensitive comparisons due to the additional case conversion operations. If you know the strings are always in a specific case (e.g., all lowercase), using strncmp might be faster. Also, be cautious about potential buffer overruns if the strings are not null-terminated within the first n characters."
        },
        {
          "function_name": "strncat",
          "include_file": "string.h",
          "return_type": "char*",
          "parameter_types": ["char*", "const char*", "size_t"],
          "main_category": "String Operations",
          "sub_category": "Manipulation",
          "data_type_manipulated": "strings",
          "description": "Appends a specified number of characters from the source string to the destination string.",
          "extended_description": "The strncat function appends not more than n characters from the string pointed to by src to the end of the string pointed to by dest. The first character of src overwrites the null character at the end of dest. A terminating null character is always appended to the result.",
          "return_value": "Returns a pointer to the resulting string dest.",
          "parameter_values": "dest: Pointer to the destination array, which should contain a C string, and be large enough to contain the concatenated resulting string.\nsrc: C string to be appended.\nn: Maximum number of characters to be appended.",
          "function_prototype": "char *strncat(char *dest, const char *src, size_t n);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char dest[20] = \"Hello, \";\n    const char *src = \"World!\";\n    \n    strncat(dest, src, 5);\n    \n    printf(\"Concatenated string: %s\\n\", dest);\n    \n    return 0;\n}",
              "explanation": "This example demonstrates basic usage of strncat to append the first 5 characters of 'World!' to 'Hello, '.",
              "expectedOutput": "Concatenated string: Hello, World"
            },
            {
              "title": "Appending with Length Limit",
              "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char dest[20] = \"Hello, \";\n    const char *src = \"Programming World!\";\n    size_t dest_len = strlen(dest);\n    size_t n = sizeof(dest) - dest_len - 1;  // Leave space for null terminator\n    \n    strncat(dest, src, n);\n    \n    printf(\"Original source: %s\\n\", src);\n    printf(\"Concatenated result: %s\\n\", dest);\n    printf(\"Length of result: %zu\\n\", strlen(dest));\n    \n    return 0;\n}",
              "explanation": "This example shows how to use strncat to append characters while ensuring the destination buffer is not overflowed.",
              "expectedOutput": "Original source: Programming World!\nConcatenated result: Hello, Programming Wo\nLength of result: 19"
            },
            {
              "title": "Multiple Concatenations",
              "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_SIZE 50\n\nint safe_strncat(char *dest, const char *src, size_t dest_size) {\n    size_t dest_len = strlen(dest);\n    size_t space_left = dest_size - dest_len - 1;\n    \n    if (space_left > 0) {\n        strncat(dest, src, space_left);\n        return 1;\n    }\n    return 0;\n}\n\nint main() {\n    char result[MAX_SIZE] = \"\";\n    const char *words[] = {\"The \", \"quick \", \"brown \", \"fox \", \"jumps \", \"over \", \"the \", \"lazy \", \"dog.\"};\n    int num_words = sizeof(words) / sizeof(words[0]);\n    \n    for (int i = 0; i < num_words; i++) {\n        if (!safe_strncat(result, words[i], MAX_SIZE)) {\n            printf(\"Warning: Buffer full, stopped at word %d\\n\", i);\n            break;\n        }\n    }\n    \n    printf(\"Final string: %s\\n\", result);\n    printf(\"Length: %zu\\n\", strlen(result));\n    \n    return 0;\n}",
              "explanation": "This example demonstrates a safe way to perform multiple concatenations using strncat, ensuring that the destination buffer is never overflowed.",
              "expectedOutput": "Final string: The quick brown fox jumps over the lazy\nLength: 38"
            }
          ],
          "related_functions": ["strcat", "strcpy", "strncpy"],
          "performance_considerations": "strncat is generally efficient for appending strings. However, it needs to find the end of the destination string each time it's called, which can be inefficient for multiple concatenations. For building strings from many parts, consider using a string builder pattern or preallocating a sufficiently large buffer. Also, be aware that strncat always null-terminates the result, which means it may write up to n+1 characters to dest."
        },
        {
          "function_name": "strncmp",
          "include_file": "string.h",
          "return_type": "int",
          "parameter_types": ["const char*", "const char*", "size_t"],
          "main_category": "Data Search and Sorting",
          "sub_category": "String Comparison",
          "data_type_manipulated": "strings",
          "description": "Compares a specified number of characters from two strings.",
          "extended_description": "The strncmp function compares up to n characters of the C string str1 to those of the C string str2. This function starts comparing the first character of each string. If they are equal to each other, it continues with the following pairs until the characters differ, until a terminating null-character is reached, or until n characters match in both strings, whichever happens first.",
          "return_value": "Returns an integer less than, equal to, or greater than zero if the first n bytes of str1 is found, respectively, to be less than, to match, or be greater than the first n bytes of str2.",
          "parameter_values": "str1: First string to be compared.\nstr2: Second string to be compared.\nn: Maximum number of characters to compare.",
          "function_prototype": "int strncmp(const char *str1, const char *str2, size_t n);",
          "examples": [
            {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    const char *str1 = \"Hello, World!\";\n    const char *str2 = \"Hello, There!\";\n    size_t n = 7;\n    \n    int result = strncmp(str1, str2, n);\n    \n    if (result == 0) {\n        printf(\"The first %zu characters of str1 and str2 are equal.\\n\", n);\n    } else if (result < 0) {\n        printf(\"The first %zu characters of str1 are less than str2.\\n\", n);\n    } else {\n        printf(\"The first %zu characters of str1 are greater than str2.\\n\", n);\n    }\n    \n    return 0;\n}",
              "explanation": "This example demonstrates basic usage of strncmp to compare the first 7 characters of two strings.",
              "expectedOutput": "The first 7 characters of str1 and str2 are equal."
            },
            {
              "title": "Comparing Strings with Different Lengths",
              "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    const char *str1 = \"apple\";\n    const char *str2 = \"appetite\";\n    size_t n = 3;\n    \n    int result = strncmp(str1, str2, n);\n    \n    printf(\"Comparing the first %zu characters:\\n\", n);\n    printf(\"str1: %s\\n\", str1);\n    printf(\"str2: %s\\n\", str2);\n    \n    if (result == 0) {\n        printf(\"Result: The first %zu characters are equal.\\n\", n);\n    } else if (result < 0) {\n        printf(\"Result: str1 is less than str2.\\n\");\n    } else {\n        printf(\"Result: str1 is greater than str2.\\n\");\n    }\n    \n    return 0;\n}",
              "explanation": "This example shows how strncmp behaves when comparing strings of different lengths, focusing only on the first n characters.",
              "expectedOutput": "Comparing the first 3 characters:\nstr1: apple\nstr2: appetite\nResult: The first 3 characters are equal."
            },
            {
              "title": "Using strncmp for Prefix Matching",
              "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_STRINGS 5\n#define PREFIX \"pro\"\n\nint main() {\n    const char *strings[MAX_STRINGS] = {\n        \"program\",\n        \"process\",\n        \"prototype\",\n        \"problem\",\n        \"practice\"\n    };\n    \n    printf(\"Strings starting with '%s':\\n\", PREFIX);\n    \n    for (int i = 0; i < MAX_STRINGS; i++) {\n        if (strncmp(strings[i], PREFIX, strlen(PREFIX)) == 0) {\n            printf(\"- %s\\n\", strings[i]);\n        }\n    }\n    \n    return 0;\n}",
              "explanation": "This example demonstrates how to use strncmp for prefix matching, finding all strings in an array that start with a specific prefix.",
              "expectedOutput": "Strings starting with 'pro':\n- program\n- process\n- prototype\n- problem"
            }
          ],
          "related_functions": ["strcmp", "strncasecmp", "memcmp"],
          "performance_considerations": "strncmp is generally efficient for comparing short to medium-length strings. For very long strings, consider using memcmp if you know the exact length to compare. Be cautious when using strncmp with strings that are not null-terminated within the first n characters, as it may lead to undefined behavior. For case-insensitive comparisons, use strncasecmp instead."
        },
    
      {
        "function_name": "strncpy",
        "include_file": "string.h",
        "return_type": "char*",
        "parameter_types": ["char*", "const char*", "size_t"],
        "main_category": "String Operations",
        "sub_category": "Manipulation",
        "data_type_manipulated": "strings",
        "description": "Copies a specified number of characters from the source string to the destination string.",
        "extended_description": "The strncpy function copies up to n characters from the string pointed to by src to the buffer pointed to by dest. If the length of src is less than n, the remainder of dest will be padded with null bytes. If the length of src is greater than or equal to n, dest may not be null-terminated.",
        "return_value": "Returns a pointer to the destination string dest.",
        "parameter_values": "dest: Pointer to the destination array where the content is to be copied.\nsrc: C string to be copied.\nn: Maximum number of characters to be copied from source.",
        "function_prototype": "char *strncpy(char *dest, const char *src, size_t n);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char src[] = \"Hello, World!\";\n    char dest[20];\n    \n    strncpy(dest, src, 5);\n    dest[5] = '\\0';  // Manually null-terminate the string\n    \n    printf(\"Source: %s\\n\", src);\n    printf(\"Destination: %s\\n\", dest);\n    \n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of strncpy to copy the first 5 characters of a string.",
            "expectedOutput": "Source: Hello, World!\nDestination: Hello"
          },
          {
            "title": "Padding with Null Bytes",
            "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char src[] = \"Short\";\n    char dest[10];\n    \n    strncpy(dest, src, sizeof(dest));\n    \n    printf(\"Source: %s\\n\", src);\n    printf(\"Destination: %s\\n\", dest);\n    printf(\"Dest array contents: \");\n    for (int i = 0; i < sizeof(dest); i++) {\n        printf(\"%d \", dest[i]);\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
            "explanation": "This example shows how strncpy pads the destination with null bytes when the source is shorter than the specified length.",
            "expectedOutput": "Source: Short\nDestination: Short\nDest array contents: 83 104 111 114 116 0 0 0 0 0"
          },
          {
            "title": "Truncation and Manual Null-Termination",
            "code": "#include <stdio.h>\n#include <string.h>\n\n#define DEST_SIZE 10\n\nint main() {\n    char src[] = \"This is a long string\";\n    char dest[DEST_SIZE];\n    \n    strncpy(dest, src, DEST_SIZE - 1);\n    dest[DEST_SIZE - 1] = '\\0';  // Ensure null-termination\n    \n    printf(\"Source: %s\\n\", src);\n    printf(\"Destination: %s\\n\", dest);\n    printf(\"Dest length: %zu\\n\", strlen(dest));\n    \n    return 0;\n}",
            "explanation": "This example demonstrates how to use strncpy safely when the source might be longer than the destination, ensuring null-termination.",
            "expectedOutput": "Source: This is a long string\nDestination: This is a\nDest length: 9"
          }
        ],
        "related_functions": ["strcpy", "memcpy", "memmove"],
        "performance_considerations": "strncpy can be less efficient than memcpy for large strings because it always writes exactly n bytes, potentially filling with unnecessary null bytes. For performance-critical code, consider using memcpy with explicit null-termination if the string lengths are known. Be cautious about potential buffer overflows and always ensure proper null-termination when using strncpy."
      },
      {
        "function_name": "strpbrk",
        "include_file": "string.h",
        "return_type": "char*",
        "parameter_types": ["const char*", "const char*"],
        "main_category": "String Operations",
        "sub_category": "Search",
        "data_type_manipulated": "strings",
        "description": "Searches a string for the first occurrence of any of the characters in a specified string.",
        "extended_description": "The strpbrk function locates the first occurrence in the string pointed to by s1 of any character from the string pointed to by s2. The terminating null characters are not compared.",
        "return_value": "Returns a pointer to the character in s1 that matches one of the characters in s2, or NULL if no such character is found.",
        "parameter_values": "s1: C string to be scanned.\ns2: C string containing the characters to match.",
        "function_prototype": "char *strpbrk(const char *s1, const char *s2);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    const char *str = \"Hello, World!\";\n    const char *chars = \"aeiou\";\n    \n    char *result = strpbrk(str, chars);\n    \n    if (result) {\n        printf(\"First vowel found: %c\\n\", *result);\n        printf(\"Position: %ld\\n\", result - str);\n    } else {\n        printf(\"No vowels found.\\n\");\n    }\n    \n    return 0;\n}",
            "explanation": "This example uses strpbrk to find the first vowel in a string.",
            "expectedOutput": "First vowel found: e\nPosition: 1"
          },
          {
            "title": "Finding Multiple Occurrences",
            "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    const char *str = \"Hello, World! How are you?\";\n    const char *chars = \" ,.?!\";\n    \n    printf(\"Original string: %s\\n\", str);\n    printf(\"Delimiters: %s\\n\", chars);\n    printf(\"Words:\\n\");\n    \n    char *token = (char *)str;\n    char *delimiter;\n    \n    while ((delimiter = strpbrk(token, chars)) != NULL) {\n        printf(\"%.*s\\n\", (int)(delimiter - token), token);\n        token = delimiter + 1;\n    }\n    \n    // Print the last word if it exists\n    if (*token) {\n        printf(\"%s\\n\", token);\n    }\n    \n    return 0;\n}",
            "explanation": "This example demonstrates how to use strpbrk to tokenize a string based on multiple delimiter characters.",
            "expectedOutput": "Original string: Hello, World! How are you?\nDelimiters:  ,.?!\nWords:\nHello\nWorld\nHow\nare\nyou"
          },
          {
            "title": "Character Set Validation",
            "code": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint is_valid_identifier(const char *str) {\n    if (!str || !*str || !isalpha(*str)) {\n        return 0;  // Empty string or doesn't start with a letter\n    }\n    \n    const char *invalid_chars = \"!@#$%^&*()+-=[]{}|\\\\:;\\\"'<>,.?/~`\";\n    return strpbrk(str, invalid_chars) == NULL;\n}\n\nint main() {\n    const char *identifiers[] = {\"valid_name\", \"invalid-name\", \"_underscore\", \"123numeric\"};\n    int count = sizeof(identifiers) / sizeof(identifiers[0]);\n    \n    for (int i = 0; i < count; i++) {\n        printf(\"\\\"%s\\\" is %s identifier\\n\", \n               identifiers[i], \n               is_valid_identifier(identifiers[i]) ? \"a valid\" : \"an invalid\");\n    }\n    \n    return 0;\n}",
            "explanation": "This example uses strpbrk as part of a function to validate whether a string is a valid identifier by checking for the presence of invalid characters.",
            "expectedOutput": "\"valid_name\" is a valid identifier\n\"invalid-name\" is an invalid identifier\n\"_underscore\" is an invalid identifier\n\"123numeric\" is an invalid identifier"
          }
        ],
        "related_functions": ["strchr", "strstr", "strtok"],
        "performance_considerations": "strpbrk scans the first string character by character, which can be inefficient for very long strings. For frequent searches or when searching for a large set of characters, consider using a lookup table or more advanced string searching algorithms for better performance."
      },
  
    {
      "function_name": "strptime",
      "include_file": "time.h",
      "return_type": "char*",
      "parameter_types": ["const char*", "const char*", "struct tm*"],
      "main_category": "Time and Date Management",
      "sub_category": "Time Parsing",
      "data_type_manipulated": "time structures",
      "description": "Parses a time/date string according to the format string and stores the result in a tm structure.",
      "extended_description": "The strptime function converts the character string pointed to by buf to values which are stored in the tm structure pointed to by tm, using the format specified by format. It is the converse function to strftime. The format string consists of zero or more conversion specifications and ordinary characters.",
      "return_value": "Returns a pointer to the first character not processed in this function call. If the entire string is consumed, the return value points to the null byte at the end of the string. If strptime() fails to match all of the format string, NULL is returned.",
      "parameter_values": "buf: The character string to parse.\nformat: The string containing the format of buf.\ntm: Pointer to a tm structure where the parsed time will be stored.",
      "function_prototype": "char *strptime(const char *buf, const char *format, struct tm *tm);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    struct tm tm = {0};\n    const char *time_string = \"2023-05-15 14:30:00\";\n    const char *format = \"%Y-%m-%d %H:%M:%S\";\n    \n    if (strptime(time_string, format, &tm) == NULL) {\n        fprintf(stderr, \"strptime failed\\n\");\n        return 1;\n    }\n    \n    printf(\"Parsed time:\\n\");\n    printf(\"Year: %d\\n\", tm.tm_year + 1900);\n    printf(\"Month: %d\\n\", tm.tm_mon + 1);\n    printf(\"Day: %d\\n\", tm.tm_mday);\n    printf(\"Hour: %d\\n\", tm.tm_hour);\n    printf(\"Minute: %d\\n\", tm.tm_min);\n    printf(\"Second: %d\\n\", tm.tm_sec);\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of strptime to parse a date and time string into a tm structure.",
          "expectedOutput": "Parsed time:\nYear: 2023\nMonth: 5\nDay: 15\nHour: 14\nMinute: 30\nSecond: 0"
        },
        {
          "title": "Parsing Different Date Formats",
          "code": "#include <stdio.h>\n#include <time.h>\n\nvoid parse_and_print(const char *time_string, const char *format) {\n    struct tm tm = {0};\n    if (strptime(time_string, format, &tm) == NULL) {\n        fprintf(stderr, \"Failed to parse: %s\\n\", time_string);\n        return;\n    }\n    \n    char output[64];\n    strftime(output, sizeof(output), \"%Y-%m-%d %H:%M:%S\", &tm);\n    printf(\"Input: %s\\nParsed: %s\\n\\n\", time_string, output);\n}\n\nint main() {\n    parse_and_print(\"2023-05-15 14:30:00\", \"%Y-%m-%d %H:%M:%S\");\n    parse_and_print(\"15/05/23 2:30 PM\", \"%d/%m/%y %I:%M %p\");\n    parse_and_print(\"Mon, 15 May 2023\", \"%a, %d %b %Y\");\n    \n    return 0;\n}",
          "explanation": "This example shows how to use strptime to parse dates in different formats, and then use strftime to output them in a consistent format.",
          "expectedOutput": "Input: 2023-05-15 14:30:00\nParsed: 2023-05-15 14:30:00\n\nInput: 15/05/23 2:30 PM\nParsed: 2023-05-15 14:30:00\n\nInput: Mon, 15 May 2023\nParsed: 2023-05-15 00:00:00"
        }
      ],
      "related_functions": ["strftime", "mktime", "localtime"],
      "performance_considerations": "strptime can be relatively slow due to the complexity of parsing various date formats. For performance-critical applications processing many dates, consider using a custom parser tailored to your specific format needs."
    },
    {
      "function_name": "strrchr",
      "include_file": "string.h",
      "return_type": "char*",
      "parameter_types": ["const char*", "int"],
      "main_category": "String Operations",
      "sub_category": "Search",
      "data_type_manipulated": "strings",
      "description": "Searches for the last occurrence of the character in the string.",
      "extended_description": "The strrchr function locates the last occurrence of c (converted to a char) in the string pointed to by s. The terminating null character is considered to be part of the string.",
      "return_value": "Returns a pointer to the last occurrence of the character c in the string s, or NULL if the character is not found.",
      "parameter_values": "s: The C string to be scanned.\nc: The character to be searched for.",
      "function_prototype": "char *strrchr(const char *s, int c);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    const char *str = \"Hello, World!\";\n    char ch = 'o';\n    char *result = strrchr(str, ch);\n    \n    if (result != NULL) {\n        printf(\"Last occurrence of '%c' found at position: %ld\\n\", ch, result - str);\n        printf(\"Substring from last occurrence: %s\\n\", result);\n    } else {\n        printf(\"'%c' not found in the string.\\n\", ch);\n    }\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of strrchr to find the last occurrence of 'o' in a string.",
          "expectedOutput": "Last occurrence of 'o' found at position: 7\nSubstring from last occurrence: orld!"
        },
        {
          "title": "File Extension Extraction",
          "code": "#include <stdio.h>\n#include <string.h>\n\nconst char* get_file_extension(const char *filename) {\n    const char *dot = strrchr(filename, '.');\n    if (!dot || dot == filename) {\n        return \"\";\n    }\n    return dot + 1;\n}\n\nint main() {\n    const char *filenames[] = {\"document.txt\", \"image.jpg\", \"script.py\", \"noextension\"};\n    int num_files = sizeof(filenames) / sizeof(filenames[0]);\n    \n    for (int i = 0; i < num_files; i++) {\n        printf(\"File: %s, Extension: %s\\n\", filenames[i], get_file_extension(filenames[i]));\n    }\n    \n    return 0;\n}",
          "explanation": "This example uses strrchr to extract file extensions from filenames.",
          "expectedOutput": "File: document.txt, Extension: txt\nFile: image.jpg, Extension: jpg\nFile: script.py, Extension: py\nFile: noextension, Extension: "
        }
      ],
      "related_functions": ["strchr", "memrchr", "strstr"],
      "performance_considerations": "strrchr scans the entire string from end to beginning, which can be inefficient for very long strings if the character is likely to be near the start. For frequent searches in long strings, consider using more advanced string matching algorithms or data structures."
    },
  
    {
      "function_name": "strspn",
      "include_file": "string.h",
      "return_type": "size_t",
      "parameter_types": ["const char*", "const char*"],
      "main_category": "String Operations",
      "sub_category": "Search",
      "data_type_manipulated": "strings",
      "description": "Calculates the length of the initial segment of the string which consists only of characters found in a specified string.",
      "extended_description": "The strspn function calculates the length of the initial segment of str1 which consists entirely of characters in str2. In other words, it returns the index of the first character in str1 that does not appear in str2.",
      "return_value": "Returns the number of characters in the initial segment of str1 which consist only of characters from str2.",
      "parameter_values": "str1: C string to be scanned.\nstr2: C string containing the characters to match.",
      "function_prototype": "size_t strspn(const char *str1, const char *str2);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    const char *str1 = \"129th Street\";\n    const char *str2 = \"1234567890\";\n    \n    size_t length = strspn(str1, str2);\n    \n    printf(\"Length of initial segment: %zu\\n\", length);\n    printf(\"Initial segment: %.*s\\n\", (int)length, str1);\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of strspn to find the length of the initial segment of digits in a string.",
          "expectedOutput": "Length of initial segment: 3\nInitial segment: 129"
        },
        {
          "title": "Validating Input",
          "code": "#include <stdio.h>\n#include <string.h>\n\nint is_valid_identifier(const char *str) {\n    const char *valid_chars = \"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n    size_t length = strspn(str, valid_chars);\n    return length == strlen(str) && (str[0] == '_' || (str[0] >= 'a' && str[0] <= 'z') || (str[0] >= 'A' && str[0] <= 'Z'));\n}\n\nint main() {\n    const char *identifiers[] = {\"valid_id\", \"123invalid\", \"also_valid_2\", \"not-valid\"};\n    int count = sizeof(identifiers) / sizeof(identifiers[0]);\n    \n    for (int i = 0; i < count; i++) {\n        printf(\"%s: %s\\n\", identifiers[i], \n               is_valid_identifier(identifiers[i]) ? \"Valid\" : \"Invalid\");\n    }\n    \n    return 0;\n}",
          "explanation": "This example uses strspn to validate if a string is a valid C identifier by checking if it contains only allowed characters and starts with a letter or underscore.",
          "expectedOutput": "valid_id: Valid\n123invalid: Invalid\nalso_valid_2: Valid\nnot-valid: Invalid"
        }
      ],
      "related_functions": ["strcspn", "strpbrk", "strchr"],
      "performance_considerations": "strspn scans the first string character by character, which can be inefficient for very long strings. For frequent use or when working with large strings, consider using a lookup table or more advanced string matching algorithms for better performance."
    },
    {
      "function_name": "strstr",
      "include_file": "string.h",
      "return_type": "char*",
      "parameter_types": ["const char*", "const char*"],
      "main_category": "String Operations",
      "sub_category": "Search",
      "data_type_manipulated": "strings",
      "description": "Finds the first occurrence of the substring in the string.",
      "extended_description": "The strstr function locates the first occurrence of the null-terminated string needle in the null-terminated string haystack. The terminating null characters are not compared.",
      "return_value": "Returns a pointer to the first occurrence of needle in haystack, or NULL if needle is not part of haystack.",
      "parameter_values": "haystack: The main C string to be scanned.\nneedle: The small string to be searched within haystack.",
      "function_prototype": "char *strstr(const char *haystack, const char *needle);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    const char *haystack = \"Hello, World!\";\n    const char *needle = \"World\";\n    \n    char *result = strstr(haystack, needle);\n    \n    if (result != NULL) {\n        printf(\"'%s' found at position: %ld\\n\", needle, result - haystack);\n        printf(\"Substring from match: %s\\n\", result);\n    } else {\n        printf(\"'%s' not found in '%s'\\n\", needle, haystack);\n    }\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of strstr to find a substring within a string.",
          "expectedOutput": "'World' found at position: 7\nSubstring from match: World!"
        },
        {
          "title": "Multiple Occurrences",
          "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    const char *haystack = \"one two one two one three\";\n    const char *needle = \"one\";\n    \n    char *result = (char *)haystack;\n    int count = 0;\n    \n    while ((result = strstr(result, needle)) != NULL) {\n        printf(\"Found '%s' at position: %ld\\n\", needle, result - haystack);\n        result++; // Move to the next character to avoid finding the same match\n        count++;\n    }\n    \n    printf(\"Total occurrences: %d\\n\", count);\n    \n    return 0;\n}",
          "explanation": "This example shows how to use strstr in a loop to find all occurrences of a substring.",
          "expectedOutput": "Found 'one' at position: 0\nFound 'one' at position: 8\nFound 'one' at position: 16\nTotal occurrences: 3"
        }
      ],
      "related_functions": ["strchr", "strrchr", "memchr"],
      "performance_considerations": "strstr uses a simple string matching algorithm which can be inefficient for very long strings or when searching for long substrings. For performance-critical applications or frequent searches, consider using more advanced string matching algorithms like Boyer-Moore or Knuth-Morris-Pratt."
    },
  
    {
      "function_name": "strtod",
      "include_file": "stdlib.h",
      "return_type": "double",
      "parameter_types": ["const char*", "char**"],
      "main_category": "Data Conversion and Formatting",
      "sub_category": "Type Conversion",
      "data_type_manipulated": "floating-point numbers",
      "description": "Converts the initial portion of the string to a double-precision floating-point number.",
      "extended_description": "The strtod function converts the initial portion of the string pointed to by nptr to a double. It skips leading whitespace, converts the subsequent characters as part of the number, and stops at the first character it cannot recognize as part of a number. If endptr is not NULL, it stores the address of the first invalid character in *endptr.",
      "return_value": "Returns the converted double value. If no conversion could be performed, 0.0 is returned. If the correct value is outside the range of representable values, HUGE_VAL (with the correct sign) is returned and errno is set to ERANGE.",
      "parameter_values": "nptr: The string to be converted.\nendptr: Reference to an object of type char*, whose value is set by the function to the next character in nptr after the numerical value.",
      "function_prototype": "double strtod(const char *nptr, char **endptr);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    const char *str = \"3.14159 is Pi\";\n    char *endptr;\n    \n    double value = strtod(str, &endptr);\n    \n    printf(\"Converted value: %f\\n\", value);\n    printf(\"Remaining string: \\\"%s\\\"\\n\", endptr);\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of strtod to convert a string to a double and identify the remainder of the string.",
          "expectedOutput": "Converted value: 3.141590\nRemaining string: \" is Pi\""
        },
        {
          "title": "Error Handling",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n\nint main() {\n    const char *str1 = \"1.23e308\";\n    const char *str2 = \"not a number\";\n    char *endptr;\n    \n    errno = 0;\n    double value1 = strtod(str1, &endptr);\n    if (errno == ERANGE) {\n        printf(\"Range error occurred for %s\\n\", str1);\n    } else {\n        printf(\"Converted value: %e\\n\", value1);\n    }\n    \n    errno = 0;\n    double value2 = strtod(str2, &endptr);\n    if (endptr == str2) {\n        printf(\"No conversion could be performed for %s\\n\", str2);\n    } else {\n        printf(\"Converted value: %f\\n\", value2);\n    }\n    \n    return 0;\n}",
          "explanation": "This example shows how to handle errors and edge cases when using strtod, including range errors and invalid input.",
          "expectedOutput": "Range error occurred for 1.23e308\nNo conversion could be performed for not a number"
        }
      ],
      "related_functions": ["atof", "strtof", "strtold"],
      "performance_considerations": "strtod is generally efficient for converting strings to doubles. However, for repeated conversions of fixed-format strings, custom parsing might be faster. Be cautious with very long strings or extreme values, as these may impact performance."
    },
    {
      "function_name": "strtod32",
      "include_file": "stdlib.h",
      "return_type": "_Decimal32",
      "parameter_types": ["const char*", "char**"],
      "main_category": "Data Conversion and Formatting",
      "sub_category": "Type Conversion",
      "data_type_manipulated": "decimal floating-point",
      "description": "Converts the initial portion of the string to a decimal floating-point number with 32-bit precision.",
      "extended_description": "The strtod32 function converts the initial portion of the string pointed to by nptr to a _Decimal32 value. It follows similar rules to strtod, but produces a decimal floating-point result. This function is part of the optional decimal floating-point arithmetic support in C.",
      "return_value": "Returns the converted _Decimal32 value. If no conversion could be performed, positive or negative zero is returned (depending on the sign of the input). If the correct value is outside the range of representable values, the function returns the appropriate positive or negative infinity and sets errno to ERANGE.",
      "parameter_values": "nptr: The string to be converted.\nendptr: Reference to an object of type char*, whose value is set by the function to the next character in nptr after the numerical value.",
      "function_prototype": "_Decimal32 strtod32(const char *nptr, char **endptr);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    const char *str = \"3.14159\";\n    char *endptr;\n    \n    _Decimal32 value = strtod32(str, &endptr);\n    \n    printf(\"Converted value: %.5Hf\\n\", value);\n    printf(\"Remaining string: \\\"%s\\\"\\n\", endptr);\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of strtod32 to convert a string to a _Decimal32 value. Note that _Decimal32 support is optional and may not be available on all systems.",
          "expectedOutput": "Converted value: 3.14159\nRemaining string: \"\""
        },
        {
          "title": "Handling Different Formats",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n\nint main() {\n    const char *str1 = \"1.23e-3\";\n    const char *str2 = \"-0.00456\";\n    char *endptr;\n    \n    _Decimal32 value1 = strtod32(str1, &endptr);\n    printf(\"Value 1: %.6Hf\\n\", value1);\n    \n    _Decimal32 value2 = strtod32(str2, &endptr);\n    printf(\"Value 2: %.6Hf\\n\", value2);\n    \n    return 0;\n}",
          "explanation": "This example shows how strtod32 handles different decimal formats, including scientific notation and negative values.",
          "expectedOutput": "Value 1: 0.001230\nValue 2: -0.004560"
        }
      ],
      "related_functions": ["strtod", "strtod64", "strtod128"],
      "performance_considerations": "strtod32 may be slower than strtod on systems without hardware support for decimal floating-point arithmetic. For performance-critical applications, consider using binary floating-point if exact decimal representation is not required."
    },
  
    {
      "function_name": "strtod64",
      "include_file": "stdlib.h",
      "return_type": "_Decimal64",
      "parameter_types": ["const char*", "char**"],
      "main_category": "Data Conversion and Formatting",
      "sub_category": "Type Conversion",
      "data_type_manipulated": "decimal floating-point",
      "description": "Converts the initial portion of the string to a decimal floating-point number with 64-bit precision.",
      "extended_description": "The strtod64 function converts the initial portion of the string pointed to by nptr to a _Decimal64 value. It follows similar rules to strtod, but produces a decimal floating-point result with higher precision than strtod32. This function is part of the optional decimal floating-point arithmetic support in C.",
      "return_value": "Returns the converted _Decimal64 value. If no conversion could be performed, positive or negative zero is returned (depending on the sign of the input). If the correct value is outside the range of representable values, the function returns the appropriate positive or negative infinity and sets errno to ERANGE.",
      "parameter_values": "nptr: The string to be converted.\nendptr: Reference to an object of type char*, whose value is set by the function to the next character in nptr after the numerical value.",
      "function_prototype": "_Decimal64 strtod64(const char *nptr, char **endptr);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    const char *str = \"3.14159265358979323846\";\n    char *endptr;\n    \n    _Decimal64 value = strtod64(str, &endptr);\n    \n    printf(\"Converted value: %.20Df\\n\", value);\n    printf(\"Remaining string: \\\"%s\\\"\\n\", endptr);\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of strtod64 to convert a string to a _Decimal64 value, showing its higher precision compared to strtod32.",
          "expectedOutput": "Converted value: 3.14159265358979323846\nRemaining string: \"\""
        },
        {
          "title": "Handling Large Numbers",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n\nint main() {\n    const char *str1 = \"1.23456789e200\";\n    const char *str2 = \"-9.87654321e-150\";\n    char *endptr;\n    \n    errno = 0;\n    _Decimal64 value1 = strtod64(str1, &endptr);\n    if (errno == ERANGE) {\n        printf(\"Range error occurred for %s\\n\", str1);\n    } else {\n        printf(\"Value 1: %.8De\\n\", value1);\n    }\n    \n    errno = 0;\n    _Decimal64 value2 = strtod64(str2, &endptr);\n    printf(\"Value 2: %.8De\\n\", value2);\n    \n    return 0;\n}",
          "explanation": "This example shows how strtod64 handles large and small numbers, demonstrating its wide range of representable values.",
          "expectedOutput": "Value 1: 1.23456789e+200\nValue 2: -9.87654321e-150"
        }
      ],
      "related_functions": ["strtod", "strtod32", "strtod128"],
      "performance_considerations": "strtod64 may be slower than strtod on systems without hardware support for decimal floating-point arithmetic. However, it provides higher precision than strtod32, which may be necessary for financial calculations or other applications requiring exact decimal representation."
    },
    {
      "function_name": "strtod128",
      "include_file": "stdlib.h",
      "return_type": "_Decimal128",
      "parameter_types": ["const char*", "char**"],
      "main_category": "Data Conversion and Formatting",
      "sub_category": "Type Conversion",
      "data_type_manipulated": "decimal floating-point",
      "description": "Converts the initial portion of the string to a decimal floating-point number with 128-bit precision.",
      "extended_description": "The strtod128 function converts the initial portion of the string pointed to by nptr to a _Decimal128 value. It follows similar rules to strtod, but produces a decimal floating-point result with the highest precision among the decimal conversion functions. This function is part of the optional decimal floating-point arithmetic support in C.",
      "return_value": "Returns the converted _Decimal128 value. If no conversion could be performed, positive or negative zero is returned (depending on the sign of the input). If the correct value is outside the range of representable values, the function returns the appropriate positive or negative infinity and sets errno to ERANGE.",
      "parameter_values": "nptr: The string to be converted.\nendptr: Reference to an object of type char*, whose value is set by the function to the next character in nptr after the numerical value.",
      "function_prototype": "_Decimal128 strtod128(const char *nptr, char **endptr);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    const char *str = \"3.141592653589793238462643383279502884\";\n    char *endptr;\n    \n    _Decimal128 value = strtod128(str, &endptr);\n    \n    printf(\"Converted value: %.36DDf\\n\", value);\n    printf(\"Remaining string: \\\"%s\\\"\\n\", endptr);\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of strtod128 to convert a string to a _Decimal128 value, showing its very high precision.",
          "expectedOutput": "Converted value: 3.141592653589793238462643383279502884\nRemaining string: \"\""
        },
        {
          "title": "Handling Extreme Values",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n\nint main() {\n    const char *str1 = \"1.23456789e1000\";\n    const char *str2 = \"1e-1000\";\n    char *endptr;\n    \n    errno = 0;\n    _Decimal128 value1 = strtod128(str1, &endptr);\n    if (errno == ERANGE) {\n        printf(\"Range error occurred for %s\\n\", str1);\n    } else {\n        printf(\"Value 1: %.8DDe\\n\", value1);\n    }\n    \n    errno = 0;\n    _Decimal128 value2 = strtod128(str2, &endptr);\n    printf(\"Value 2: %.1000DDf\\n\", value2);\n    \n    return 0;\n}",
          "explanation": "This example shows how strtod128 handles extremely large and small numbers, demonstrating its ability to represent a wide range of values with high precision.",
          "expectedOutput": "Value 1: 1.23456789e+1000\nValue 2: 0.0000...0001 (with 999 zeros after the decimal point)"
        }
      ],
      "related_functions": ["strtod", "strtod32", "strtod64"],
      "performance_considerations": "strtod128 provides the highest precision among the decimal conversion functions, but it may also be the slowest, especially on systems without hardware support for 128-bit decimal floating-point arithmetic. Use it when the extra precision is necessary, such as in high-precision scientific calculations or financial applications requiring exact decimal representation of large numbers."
    },
  
    {
      "function_name": "strtof",
      "include_file": "stdlib.h",
      "return_type": "float",
      "parameter_types": ["const char*", "char**"],
      "main_category": "Data Conversion and Formatting",
      "sub_category": "Type Conversion",
      "data_type_manipulated": "floating-point numbers",
      "description": "Converts the initial portion of the string to a floating-point number.",
      "extended_description": "The strtof function converts the initial portion of the string pointed to by nptr to a float. It skips leading whitespace, converts the subsequent characters as part of the number, and stops at the first character it cannot recognize as part of a number. If endptr is not NULL, it stores the address of the first invalid character in *endptr.",
      "return_value": "Returns the converted float value. If no conversion could be performed, 0.0f is returned. If the correct value is outside the range of representable values, HUGE_VALF (with the correct sign) is returned and errno is set to ERANGE.",
      "parameter_values": "nptr: The string to be converted.\nendptr: Reference to an object of type char*, whose value is set by the function to the next character in nptr after the numerical value.",
      "function_prototype": "float strtof(const char *nptr, char **endptr);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    const char *str = \"3.14159 is Pi\";\n    char *endptr;\n    \n    float value = strtof(str, &endptr);\n    \n    printf(\"Converted value: %f\\n\", value);\n    printf(\"Remaining string: \\\"%s\\\"\\n\", endptr);\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of strtof to convert a string to a float and identify the remainder of the string.",
          "expectedOutput": "Converted value: 3.141590\nRemaining string: \" is Pi\""
        },
        {
          "title": "Error Handling",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <math.h>\n\nint main() {\n    const char *str1 = \"1.23e38\";\n    const char *str2 = \"not a number\";\n    char *endptr;\n    \n    errno = 0;\n    float value1 = strtof(str1, &endptr);\n    if (errno == ERANGE) {\n        printf(\"Range error occurred for %s\\n\", str1);\n    } else {\n        printf(\"Converted value: %e\\n\", value1);\n    }\n    \n    errno = 0;\n    float value2 = strtof(str2, &endptr);\n    if (endptr == str2) {\n        printf(\"No conversion could be performed for %s\\n\", str2);\n    } else {\n        printf(\"Converted value: %f\\n\", value2);\n    }\n    \n    return 0;\n}",
          "explanation": "This example shows how to handle errors and edge cases when using strtof, including range errors and invalid input.",
          "expectedOutput": "Range error occurred for 1.23e38\nNo conversion could be performed for not a number"
        }
      ],
      "related_functions": ["atof", "strtod", "strtold"],
      "performance_considerations": "strtof is generally efficient for converting strings to floats. However, it has less precision than strtod. For applications requiring high precision, consider using strtod instead. For repeated conversions of fixed-format strings, custom parsing might be faster."
    },
    {
      "function_name": "strtok",
      "include_file": "string.h",
      "return_type": "char*",
      "parameter_types": ["char*", "const char*"],
      "main_category": "String Operations",
      "sub_category": "Tokenization",
      "data_type_manipulated": "strings",
      "description": "Tokenizes a string into sequences separated by the delimiters specified.",
      "extended_description": "The strtok function breaks a string into a sequence of zero or more nonempty tokens. On the first call, the string to be parsed should be specified in str. In each subsequent call that should parse the same string, str must be NULL. The delimiters used to identify token boundaries can be different from call to call.",
      "return_value": "Returns a pointer to the next token, or NULL if there are no more tokens.",
      "parameter_values": "str: On first call, the string to be parsed. In subsequent calls, it should be NULL.\ndelim: String containing the delimiter characters.",
      "function_prototype": "char *strtok(char *str, const char *delim);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Hello,World,How,Are,You\";\n    const char delim[] = \",\";\n    \n    char *token = strtok(str, delim);\n    while (token != NULL) {\n        printf(\"%s\\n\", token);\n        token = strtok(NULL, delim);\n    }\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of strtok to split a string into tokens based on a delimiter.",
          "expectedOutput": "Hello\nWorld\nHow\nAre\nYou"
        },
        {
          "title": "Using Multiple Delimiters",
          "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Hello, World! How are you?\";\n    const char delim[] = \" ,!?\";\n    \n    char *token = strtok(str, delim);\n    while (token != NULL) {\n        printf(\"%s\\n\", token);\n        token = strtok(NULL, delim);\n    }\n    \n    return 0;\n}",
          "explanation": "This example shows how to use multiple delimiters with strtok.",
          "expectedOutput": "Hello\nWorld\nHow\nare\nyou"
        }
      ],
      "related_functions": ["strtok_r", "strpbrk", "strcspn"],
      "performance_considerations": "strtok modifies the original string by inserting null characters. It also uses static storage for holding the position between calls, making it unsafe for use in multi-threaded programs. For thread-safe tokenization, consider using strtok_r. For performance-critical applications or when preserving the original string is necessary, custom tokenization methods might be more appropriate."
    },
  
    {
      "function_name": "strtok_r",
      "include_file": "string.h",
      "return_type": "char*",
      "parameter_types": ["char*", "const char*", "char**"],
      "main_category": "String Operations",
      "sub_category": "Tokenization",
      "data_type_manipulated": "strings",
      "description": "A reentrant version of strtok that tokenizes a string into sequences using specified delimiters, storing the context.",
      "extended_description": "The strtok_r function is a reentrant version of strtok. It breaks a string into a sequence of zero or more nonempty tokens. Unlike strtok, it is thread-safe because it uses a user-provided pointer saveptr to maintain context between successive calls that parse the same string.",
      "return_value": "Returns a pointer to the next token, or NULL if there are no more tokens.",
      "parameter_values": "str: On first call, the string to be parsed. In subsequent calls, it should be NULL.\ndelim: String containing the delimiter characters.\nsaveptr: Pointer to a char* variable that is used by strtok_r to maintain context between calls.",
      "function_prototype": "char *strtok_r(char *str, const char *delim, char **saveptr);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Hello,World,How,Are,You\";\n    const char delim[] = \",\";\n    char *saveptr;\n    \n    char *token = strtok_r(str, delim, &saveptr);\n    while (token != NULL) {\n        printf(\"%s\\n\", token);\n        token = strtok_r(NULL, delim, &saveptr);\n    }\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of strtok_r to split a string into tokens based on a delimiter.",
          "expectedOutput": "Hello\nWorld\nHow\nAre\nYou"
        },
        {
          "title": "Thread-Safe Tokenization",
          "code": "#include <stdio.h>\n#include <string.h>\n#include <pthread.h>\n\nvoid *tokenize(void *arg) {\n    char *str = (char *)arg;\n    const char delim[] = \" \";\n    char *saveptr;\n    \n    char *token = strtok_r(str, delim, &saveptr);\n    while (token != NULL) {\n        printf(\"%s\\n\", token);\n        token = strtok_r(NULL, delim, &saveptr);\n    }\n    \n    return NULL;\n}\n\nint main() {\n    char str1[] = \"Hello World How Are You\";\n    char str2[] = \"This Is Another String\";\n    pthread_t thread1, thread2;\n    \n    pthread_create(&thread1, NULL, tokenize, (void *)str1);\n    pthread_create(&thread2, NULL, tokenize, (void *)str2);\n    \n    pthread_join(thread1, NULL);\n    pthread_join(thread2, NULL);\n    \n    return 0;\n}",
          "explanation": "This example shows how strtok_r can be used safely in a multi-threaded environment, where each thread tokenizes a different string.",
          "expectedOutput": "The output will be the words from both strings, potentially interleaved due to concurrent execution."
        }
      ],
      "related_functions": ["strtok", "strpbrk", "strcspn"],
      "performance_considerations": "strtok_r is generally more efficient and safer than strtok for multi-threaded applications. However, like strtok, it modifies the original string. For performance-critical applications or when preserving the original string is necessary, custom tokenization methods might be more appropriate."
    },
    {
      "function_name": "strtol",
      "include_file": "stdlib.h",
      "return_type": "long",
      "parameter_types": ["const char*", "char**", "int"],
      "main_category": "Data Conversion and Formatting",
      "sub_category": "Type Conversion",
      "data_type_manipulated": "integers",
      "description": "Converts the initial portion of the string to a long integer.",
      "extended_description": "The strtol function converts the initial part of the string in nptr to a long integer value according to the given base, which must be between 2 and 36 inclusive, or be the special value 0. It skips leading whitespace, optional '+' or '-' sign, and stops at the first character it cannot recognize as part of a number.",
      "return_value": "Returns the converted long int value. If no conversion could be performed, 0 is returned. If the correct value is outside the range of representable values, LONG_MAX or LONG_MIN is returned, and errno is set to ERANGE.",
      "parameter_values": "nptr: The string to be converted.\nendptr: Reference to an object of type char*, whose value is set by the function to the next character in nptr after the numerical value.\nbase: The base to use for the conversion (between 2 and 36, or 0 for auto-detection based on the string prefix).",
      "function_prototype": "long int strtol(const char *nptr, char **endptr, int base);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    const char *str = \"1234567 with words\";\n    char *endptr;\n    \n    long value = strtol(str, &endptr, 10);\n    \n    printf(\"Converted value: %ld\\n\", value);\n    printf(\"Remaining string: \\\"%s\\\"\\n\", endptr);\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of strtol to convert a string to a long integer and identify the remainder of the string.",
          "expectedOutput": "Converted value: 1234567\nRemaining string: \" with words\""
        },
        {
          "title": "Using Different Bases",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    const char *str1 = \"0xFF\";  // Hexadecimal\n    const char *str2 = \"0755\";  // Octal\n    const char *str3 = \"1010101\";  // Binary\n    \n    printf(\"Hex 0xFF = %ld\\n\", strtol(str1, NULL, 0));\n    printf(\"Oct 0755 = %ld\\n\", strtol(str2, NULL, 0));\n    printf(\"Bin 1010101 = %ld\\n\", strtol(str3, NULL, 2));\n    \n    return 0;\n}",
          "explanation": "This example shows how to use strtol with different bases, including auto-detection of base for hexadecimal and octal numbers.",
          "expectedOutput": "Hex 0xFF = 255\nOct 0755 = 493\nBin 1010101 = 85"
        }
      ],
      "related_functions": ["atoi", "atol", "strtoul", "strtoll"],
      "performance_considerations": "strtol is generally efficient for converting strings to long integers. It's more flexible than atoi or atol as it allows specifying the base and provides error checking. For very large numbers, consider using strtoll for 64-bit integers. In performance-critical code, if the input format is known and fixed, custom parsing might be faster."
    },
    
      {
        "function_name": "strtold",
        "include_file": "stdlib.h",
        "return_type": "long double",
        "parameter_types": ["const char*", "char**"],
        "main_category": "Data Conversion and Formatting",
        "sub_category": "Type Conversion",
        "data_type_manipulated": "floating-point numbers",
        "description": "Converts the initial portion of the string to a long double.",
        "extended_description": "The strtold function converts the initial part of the string in nptr to a long double value. It skips leading whitespace, converts the subsequent characters as part of the number, and stops at the first character it cannot recognize as part of a number. This function provides the highest precision among the string-to-float conversion functions in C.",
        "return_value": "Returns the converted long double value. If no conversion could be performed, 0.0 is returned. If the correct value is outside the range of representable values, HUGE_VALL (with the correct sign) is returned and errno is set to ERANGE.",
        "parameter_values": "nptr: The string to be converted.\nendptr: Reference to an object of type char*, whose value is set by the function to the next character in nptr after the numerical value.",
        "function_prototype": "long double strtold(const char *nptr, char **endptr);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    const char *str = \"3.14159265358979323846 is Pi\";\n    char *endptr;\n    \n    long double value = strtold(str, &endptr);\n    \n    printf(\"Converted value: %.20Lf\\n\", value);\n    printf(\"Remaining string: \\\"%s\\\"\\n\", endptr);\n    \n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of strtold to convert a string to a long double and identify the remainder of the string.",
            "expectedOutput": "Converted value: 3.14159265358979323846\nRemaining string: \" is Pi\""
          },
          {
            "title": "Handling Very Large and Small Numbers",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <math.h>\n\nint main() {\n    const char *str1 = \"1.23e+4932\";\n    const char *str2 = \"1.23e-4932\";\n    char *endptr;\n    \n    errno = 0;\n    long double value1 = strtold(str1, &endptr);\n    if (errno == ERANGE) {\n        printf(\"Range error occurred for %s\\n\", str1);\n    } else {\n        printf(\"Converted value 1: %.6Le\\n\", value1);\n    }\n    \n    errno = 0;\n    long double value2 = strtold(str2, &endptr);\n    printf(\"Converted value 2: %.6Le\\n\", value2);\n    \n    return 0;\n}",
            "explanation": "This example shows how strtold handles very large and very small numbers, demonstrating its wide range of representable values.",
            "expectedOutput": "Converted value 1: 1.230000e+4932\nConverted value 2: 1.230000e-4932\n\nNote: The exact output may vary depending on the system's long double precision."
          }
        ],
        "related_functions": ["strtod", "strtof", "atof"],
        "performance_considerations": "strtold provides the highest precision among the string-to-float conversion functions, but it may also be the slowest. Use it when the extra precision is necessary, such as in scientific calculations or financial applications requiring exact decimal representation. For less demanding applications, strtod or strtof might be more appropriate."
      },
      {
        "function_name": "strtoul",
        "include_file": "stdlib.h",
        "return_type": "unsigned long",
        "parameter_types": ["const char*", "char**", "int"],
        "main_category": "Data Conversion and Formatting",
        "sub_category": "Type Conversion",
        "data_type_manipulated": "integers",
        "description": "Converts the initial portion of the string to an unsigned long integer.",
        "extended_description": "The strtoul function converts the initial part of the string in nptr to an unsigned long int value according to the given base, which must be between 2 and 36 inclusive, or be the special value 0. It skips leading whitespace and stops at the first character it cannot recognize as part of a number.",
        "return_value": "Returns the converted unsigned long int value. If no conversion could be performed, 0 is returned. If the correct value is outside the range of representable values, ULONG_MAX is returned, and errno is set to ERANGE.",
        "parameter_values": "nptr: The string to be converted.\nendptr: Reference to an object of type char*, whose value is set by the function to the next character in nptr after the numerical value.\nbase: The base to use for the conversion (between 2 and 36, or 0 for auto-detection based on the string prefix).",
        "function_prototype": "unsigned long int strtoul(const char *nptr, char **endptr, int base);",
        "examples": [
          {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    const char *str = \"12345678 with words\";\n    char *endptr;\n    \n    unsigned long value = strtoul(str, &endptr, 10);\n    \n    printf(\"Converted value: %lu\\n\", value);\n    printf(\"Remaining string: \\\"%s\\\"\\n\", endptr);\n    \n    return 0;\n}",
            "explanation": "This example demonstrates basic usage of strtoul to convert a string to an unsigned long integer and identify the remainder of the string.",
            "expectedOutput": "Converted value: 12345678\nRemaining string: \" with words\""
          },
          {
            "title": "Using Different Bases",
            "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    const char *str1 = \"0xFFFFFFFF\";  // Hexadecimal\n    const char *str2 = \"037777777777\";  // Octal\n    const char *str3 = \"1111111111111111111111111111111\";  // Binary\n    \n    printf(\"Hex 0xFFFFFFFF = %lu\\n\", strtoul(str1, NULL, 0));\n    printf(\"Oct 037777777777 = %lu\\n\", strtoul(str2, NULL, 0));\n    printf(\"Bin 1111111111111111111111111111111 = %lu\\n\", strtoul(str3, NULL, 2));\n    \n    return 0;\n}",
            "explanation": "This example shows how to use strtoul with different bases, including auto-detection of base for hexadecimal and octal numbers.",
            "expectedOutput": "Hex 0xFFFFFFFF = 4294967295\nOct 037777777777 = 4294967295\nBin 1111111111111111111111111111111 = 4294967295"
          }
        ],
        "related_functions": ["strtol", "strtoull", "atoi", "atol"],
        "performance_considerations": "strtoul is generally efficient for converting strings to unsigned long integers. It's more flexible than atoi or atol as it allows specifying the base and provides error checking. For very large numbers that exceed the range of unsigned long, consider using strtoull for 64-bit unsigned integers. In performance-critical code, if the input format is known and fixed, custom parsing might be faster."
      },
  
    {
      "function_name": "strxfrm",
      "include_file": "string.h",
      "return_type": "size_t",
      "parameter_types": ["char*", "const char*", "size_t"],
      "main_category": "String Operations",
      "sub_category": "Transformation",
      "data_type_manipulated": "strings",
      "description": "Transforms the string to another string such that the result of strcmp on these is the same as strcoll on the original strings.",
      "extended_description": "The strxfrm function transforms the string src and places the resulting string into dest. The transformation is such that if strcmp is applied to two transformed strings, it returns the same result as strcoll applied to the original strings. This is useful for preparing strings for locale-specific sorting.",
      "return_value": "Returns the length of the transformed string (not including the terminating null byte). If the return value is greater than or equal to n, the contents of dest are indeterminate.",
      "parameter_values": "dest: Pointer to the destination array where the transformed string is stored.\nsrc: String to be transformed.\nn: Maximum number of characters to be written to dest, including the terminating null byte.",
      "function_prototype": "size_t strxfrm(char *dest, const char *src, size_t n);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <string.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");  // Set locale to system default\n    \n    char src[] = \"hello\";\n    char dest[20];\n    size_t len = strxfrm(dest, src, sizeof(dest));\n    \n    printf(\"Original string: %s\\n\", src);\n    printf(\"Transformed string: %s\\n\", dest);\n    printf(\"Length of transformed string: %zu\\n\", len);\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of strxfrm to transform a string according to the current locale.",
          "expectedOutput": "Original string: hello\nTransformed string: hello\nLength of transformed string: 5\n\nNote: The actual output may vary depending on the system's locale settings."
        },
        {
          "title": "Comparing Transformed Strings",
          "code": "#include <stdio.h>\n#include <string.h>\n#include <locale.h>\n\nint compare_strings(const char *str1, const char *str2) {\n    char xform1[100], xform2[100];\n    strxfrm(xform1, str1, sizeof(xform1));\n    strxfrm(xform2, str2, sizeof(xform2));\n    return strcmp(xform1, xform2);\n}\n\nint main() {\n    setlocale(LC_ALL, \"en_US.UTF-8\");  // Set locale to US English\n    \n    const char *str1 = \"apple\";\n    const char *str2 = \"Banana\";\n    \n    int result = compare_strings(str1, str2);\n    \n    printf(\"Comparing '%s' and '%s':\\n\", str1, str2);\n    if (result < 0) {\n        printf(\"%s comes before %s\\n\", str1, str2);\n    } else if (result > 0) {\n        printf(\"%s comes after %s\\n\", str1, str2);\n    } else {\n        printf(\"%s and %s are equivalent\\n\", str1, str2);\n    }\n    \n    return 0;\n}",
          "explanation": "This example shows how to use strxfrm in combination with strcmp to achieve the same result as strcoll, which is useful for locale-aware string comparisons.",
          "expectedOutput": "Comparing 'apple' and 'Banana':\napple comes after Banana\n\nNote: The actual output may vary depending on the system's locale settings."
        }
      ],
      "related_functions": ["strcoll", "strcmp", "setlocale"],
      "performance_considerations": "strxfrm can be computationally expensive, especially for long strings or complex locale rules. For repeated comparisons of the same strings, it's more efficient to transform them once with strxfrm and then use strcmp for comparisons, rather than using strcoll repeatedly. However, strxfrm requires additional memory for the transformed strings."
    },
    {
      "function_name": "swprintf",
      "include_file": "wchar.h",
      "return_type": "int",
      "parameter_types": ["wchar_t*", "size_t", "const wchar_t*", "..."],
      "main_category": "File and I/O Operations",
      "sub_category": "Wide Character Support",
      "data_type_manipulated": "wide characters",
      "description": "Writes formatted wide character output to a string.",
      "extended_description": "The swprintf function is the wide-character equivalent of sprintf. It writes the formatted wide character output to the wide string pointed to by wcs. The function follows the same formatting rules as sprintf, but operates on wide characters and strings.",
      "return_value": "Returns the number of wide characters written, not including the terminating null wide character. If an encoding error occurs, a negative number is returned.",
      "parameter_values": "wcs: Pointer to a wide character array where the resulting wide string is stored.\nn: Maximum number of wide characters to be written.\nformat: Wide string containing the format string.\n...: Additional arguments replacing the format specifiers in the format string.",
      "function_prototype": "int swprintf(wchar_t *wcs, size_t n, const wchar_t *format, ...);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");  // Set locale to system default\n    \n    wchar_t wcs[100];\n    wchar_t *name = L\"John\";\n    int age = 30;\n    \n    int chars_written = swprintf(wcs, sizeof(wcs)/sizeof(wchar_t), L\"Name: %ls, Age: %d\", name, age);\n    \n    wprintf(L\"Formatted wide string: %ls\\n\", wcs);\n    wprintf(L\"Characters written: %d\\n\", chars_written);\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of swprintf to format a wide string with a name and age.",
          "expectedOutput": "Formatted wide string: Name: John, Age: 30\nCharacters written: 19"
        },
        {
          "title": "Handling Unicode Characters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");  // Set locale to system default\n    \n    wchar_t wcs[100];\n    wchar_t *emoji = L\"😊\";  // Smiling face emoji\n    \n    int chars_written = swprintf(wcs, sizeof(wcs)/sizeof(wchar_t), L\"Hello, World! %ls\", emoji);\n    \n    wprintf(L\"Formatted wide string: %ls\\n\", wcs);\n    wprintf(L\"Characters written: %d\\n\", chars_written);\n    \n    return 0;\n}",
          "explanation": "This example shows how swprintf can handle Unicode characters, including emojis, in wide strings.",
          "expectedOutput": "Formatted wide string: Hello, World! 😊\nCharacters written: 15\n\nNote: The emoji may not display correctly in all console environments."
        }
      ],
      "related_functions": ["sprintf", "snprintf", "vswprintf"],
      "performance_considerations": "swprintf is generally efficient for formatting wide strings. However, for very long strings or when performance is critical, consider using a wide string builder pattern or pre-allocating buffers. Be cautious about buffer overflows and always specify the maximum number of characters to be written."
    },
  
    {
      "function_name": "swscanf",
      "include_file": "wchar.h",
      "return_type": "int",
      "parameter_types": ["const wchar_t*", "const wchar_t*", "..."],
      "main_category": "File and I/O Operations",
      "sub_category": "Wide Character Support",
      "data_type_manipulated": "wide characters",
      "description": "Reads formatted input from a wide character string.",
      "extended_description": "The swscanf function is the wide-character equivalent of sscanf. It reads formatted input from a wide string, interprets it according to the format string, and stores the results in the locations given by the additional arguments. This function is particularly useful for parsing wide character strings in internationalized applications.",
      "return_value": "Returns the number of input items successfully matched and assigned. Returns EOF if an error occurred before any conversion.",
      "parameter_values": "ws: Wide string to be parsed.\nformat: Wide string containing the format specifiers.\n...: Additional arguments pointing to the objects where the converted input should be stored.",
      "function_prototype": "int swscanf(const wchar_t *ws, const wchar_t *format, ...);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");  // Set locale to system default\n    \n    const wchar_t *input = L\"John 30 180.5\";\n    wchar_t name[20];\n    int age;\n    float height;\n    \n    int result = swscanf(input, L\"%ls %d %f\", name, &age, &height);\n    \n    if (result == 3) {\n        wprintf(L\"Name: %ls\\nAge: %d\\nHeight: %.1f\\n\", name, age, height);\n    } else {\n        wprintf(L\"Failed to parse all fields. Parsed %d field(s)\\n\", result);\n    }\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of swscanf to parse a wide string containing a name, age, and height.",
          "expectedOutput": "Name: John\nAge: 30\nHeight: 180.5"
        },
        {
          "title": "Parsing Unicode Characters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");  // Set locale to system default\n    \n    const wchar_t *input = L\"😊 42\";\n    wchar_t emoji[5];  // Enough space for a single emoji and null terminator\n    int number;\n    \n    int result = swscanf(input, L\"%ls %d\", emoji, &number);\n    \n    if (result == 2) {\n        wprintf(L\"Emoji: %ls\\nNumber: %d\\n\", emoji, number);\n    } else {\n        wprintf(L\"Failed to parse all fields. Parsed %d field(s)\\n\", result);\n    }\n    \n    return 0;\n}",
          "explanation": "This example shows how swscanf can handle Unicode characters, including emojis, when parsing wide strings.",
          "expectedOutput": "Emoji: 😊\nNumber: 42\n\nNote: The emoji may not display correctly in all console environments."
        }
      ],
      "related_functions": ["sscanf", "wscanf", "fwscanf"],
      "performance_considerations": "swscanf is generally efficient for parsing wide strings. However, for complex parsing tasks or when performance is critical, consider using custom parsing functions. Be aware that parsing Unicode characters may have additional overhead compared to parsing ASCII characters."
    },
    {
      "function_name": "system",
      "include_file": "stdlib.h",
      "return_type": "int",
      "parameter_types": ["const char*"],
      "main_category": "System Interaction",
      "sub_category": "Process Control",
      "data_type_manipulated": "system commands",
      "description": "Executes a command string in a command processor or shell.",
      "extended_description": "The system function passes the command string to the host environment to be executed by a command processor. The command is executed in a separate process, and the calling process waits for its completion. This function provides a way to execute system commands from within a C program.",
      "return_value": "If command is NULL, returns nonzero if a command processor is available. If command is not NULL, returns the exit status of the command executed (implementation-defined). If a child process could not be created or its status could not be retrieved, -1 is returned.",
      "parameter_values": "command: String containing the system command to be executed. If command is NULL, the function only checks if a command processor is available.",
      "function_prototype": "int system(const char *command);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int result = system(\"ls -l\");\n    \n    if (result == -1) {\n        printf(\"The command processor couldn't be invoked\\n\");\n    } else {\n        printf(\"Command executed with exit status: %d\\n\", result);\n    }\n    \n    return 0;\n}",
          "explanation": "This example demonstrates basic usage of system to execute the 'ls -l' command on a Unix-like system. It also checks the return value to determine if the command was executed successfully.",
          "expectedOutput": "(Output of 'ls -l' command)\nCommand executed with exit status: 0\n\nNote: The actual output will depend on the contents of the current directory."
        },
        {
          "title": "Checking Command Processor Availability",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    if (system(NULL)) {\n        printf(\"Command processor is available.\\n\");\n        \n        // Execute a system-specific command\n        #ifdef _WIN32\n            system(\"dir\");\n        #else\n            system(\"ls\");\n        #endif\n    } else {\n        printf(\"Command processor is not available.\\n\");\n    }\n    \n    return 0;\n}",
          "explanation": "This example first checks if a command processor is available using system(NULL). If available, it then executes a system-specific command (dir on Windows, ls on Unix-like systems).",
          "expectedOutput": "Command processor is available.\n(Output of 'dir' or 'ls' command)\n\nNote: The actual output will depend on the system and the contents of the current directory."
        }
      ],
      "related_functions": ["exec", "fork", "popen"],
      "performance_considerations": "The system function is relatively slow as it creates a new process and invokes a shell. For frequent or performance-critical operations, consider using lower-level system calls or language-specific APIs. Be cautious when using system with user-supplied input, as it can lead to security vulnerabilities if not properly sanitized."
    },
  
    {
      "function_name": "tan",
      "include_file": "math.h",
      "return_type": "double",
      "parameter_types": ["double"],
      "main_category": "Mathematical Operations",
      "sub_category": "Advanced Computation",
      "data_type_manipulated": "floating-point numbers",
      "description": "Calculates the tangent of the specified angle in radians.",
      "extended_description": "The tan function computes the tangent of x (measured in radians). Mathematically, it is equivalent to sin(x) / cos(x). The tangent function is periodic with a period of π radians.",
      "return_value": "Returns the tangent of x. If x is infinite, a domain error occurs and the function returns NaN. If x is NaN, NaN is returned.",
      "parameter_values": "x: The angle in radians for which to calculate the tangent.",
      "function_prototype": "double tan(double x);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <math.h>\n\n#define PI 3.14159265358979323846\n\nint main() {\n    double angle_degrees = 45.0;\n    double angle_radians = angle_degrees * PI / 180.0;\n    double result = tan(angle_radians);\n    \n    printf(\"tan(%.2f degrees) = %.4f\\n\", angle_degrees, result);\n    \n    return 0;\n}",
          "explanation": "This example calculates the tangent of 45 degrees (converted to radians).",
          "expectedOutput": "tan(45.00 degrees) = 1.0000"
        },
        {
          "title": "Plotting Tangent Function",
          "code": "#include <stdio.h>\n#include <math.h>\n\n#define PI 3.14159265358979323846\n\nint main() {\n    printf(\"Tangent function plot (-π/2 to π/2):\\n\");\n    for (int i = -9; i <= 9; i++) {\n        double x = i * PI / 18;\n        double y = tan(x);\n        if (fabs(y) > 10) continue;  // Skip very large values\n        int stars = (int)((y + 10) * 2);\n        printf(\"%5.2f: %*s%*s\\n\", x, stars, \"*\", 40 - stars, \"\");\n    }\n    \n    return 0;\n}",
          "explanation": "This example creates a simple ASCII plot of the tangent function from -π/2 to π/2.",
          "expectedOutput": "Tangent function plot (-π/2 to π/2):\n-1.57: *\n-1.40:  *\n-1.22:   *\n-1.05:    *\n-0.87:     *\n-0.70:      *\n-0.52:       *\n-0.35:        *\n-0.17:         *\n 0.00:          *\n 0.17:           *\n 0.35:            *\n 0.52:             *\n 0.70:              *\n 0.87:               *\n 1.05:                *\n 1.22:                 *\n 1.40:                  *\n 1.57:                   *"
        },
        {
          "title": "Handling Special Cases",
          "code": "#include <stdio.h>\n#include <math.h>\n\n#define PI 3.14159265358979323846\n\nint main() {\n    printf(\"tan(0) = %.2f\\n\", tan(0));\n    printf(\"tan(π/4) = %.2f\\n\", tan(PI/4));\n    printf(\"tan(π/2) = %.2f\\n\", tan(PI/2));\n    printf(\"tan(π) = %.2f\\n\", tan(PI));\n    printf(\"tan(3π/2) = %.2f\\n\", tan(3*PI/2));\n    printf(\"tan(2π) = %.2f\\n\", tan(2*PI));\n    \n    return 0;\n}",
          "explanation": "This example demonstrates the behavior of tan for special angle values, including those where tan is undefined (π/2 and 3π/2).",
          "expectedOutput": "tan(0) = 0.00\ntan(π/4) = 1.00\ntan(π/2) = 16331239353195370.00\ntan(π) = -0.00\ntan(3π/2) = 5443746451065123.00\ntan(2π) = -0.00\n\nNote: The exact values for π/2 and 3π/2 may vary due to floating-point precision limitations."
        }
      ],
      "related_functions": ["sin", "cos", "atan"],
      "performance_considerations": "The tan function is generally optimized and efficient for most use cases. However, for angles near π/2 + nπ (where n is an integer), the function can produce very large values that may lead to loss of precision. For very small angles, consider using the approximation tan(x) ≈ x for better performance and accuracy."
    },
    {
      "function_name": "tanh",
      "include_file": "math.h",
      "return_type": "double",
      "parameter_types": ["double"],
      "main_category": "Mathematical Operations",
      "sub_category": "Advanced Computation",
      "data_type_manipulated": "floating-point numbers",
      "description": "Calculates the hyperbolic tangent of the specified number.",
      "extended_description": "The tanh function computes the hyperbolic tangent of x. It is defined mathematically as sinh(x) / cosh(x), or equivalently, (e^x - e^-x) / (e^x + e^-x), where e is Euler's number (approximately 2.71828). The hyperbolic tangent function always returns a value between -1 and 1.",
      "return_value": "Returns the hyperbolic tangent of x, a value between -1 and 1.",
      "parameter_values": "x: The value for which to calculate the hyperbolic tangent.",
      "function_prototype": "double tanh(double x);",
      "examples": [
        {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = 1.0;\n    double result = tanh(x);\n    \n    printf(\"tanh(%.2f) = %.6f\\n\", x, result);\n    \n    return 0;\n}",
          "explanation": "This example calculates the hyperbolic tangent of 1.0.",
          "expectedOutput": "tanh(1.00) = 0.761594"
        },
        {
          "title": "Hyperbolic Tangent for Various Values",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double values[] = {-2.0, -1.0, -0.5, 0.0, 0.5, 1.0, 2.0};\n    int num_values = sizeof(values) / sizeof(values[0]);\n    \n    printf(\"x\\ttanh(x)\\n\");\n    printf(\"-----------------\\n\");\n    \n    for (int i = 0; i < num_values; i++) {\n        double x = values[i];\n        double result = tanh(x);\n        printf(\"%.2f\\t%.6f\\n\", x, result);\n    }\n    \n    return 0;\n}",
          "explanation": "This example calculates and prints the hyperbolic tangent for a range of values, demonstrating its behavior across different inputs.",
          "expectedOutput": "x\ttanh(x)\n-----------------\n-2.00\t-0.964028\n-1.00\t-0.761594\n-0.50\t-0.462117\n0.00\t0.000000\n0.50\t0.462117\n1.00\t0.761594\n2.00\t0.964028"
        },
        {
          "title": "Plotting Hyperbolic Tangent",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    printf(\"Hyperbolic tangent function plot (-3 to 3):\\n\");\n    for (int i = -30; i <= 30; i++) {\n        double x = i / 10.0;\n        double y = tanh(x);\n        int stars = (int)((y + 1) * 20);\n        printf(\"%5.2f: %*s%*s\\n\", x, stars, \"*\", 40 - stars, \"\");\n    }\n    \n    return 0;\n}",
          "explanation": "This example creates a simple ASCII plot of the hyperbolic tangent function from -3 to 3, visually demonstrating its S-shaped curve and asymptotic behavior.",
          "expectedOutput": "Hyperbolic tangent function plot (-3 to 3):\n-3.00: *\n-2.80:  *\n...\n0.00:                    *\n...\n2.80:                                       *\n3.00:                                        *"
        }
      ],
      "related_functions": ["sinh", "cosh", "atanh"],
      "performance_considerations": "The tanh function is generally efficient and well-behaved for most inputs. Unlike the regular tangent function, it doesn't have singularities. For very large positive or negative inputs, tanh approaches 1 or -1 respectively, which can lead to loss of precision in some cases. For small inputs (|x| < 0.1), the approximation tanh(x) ≈ x might be used for improved performance if extreme accuracy is not required."
    },
    {
      "function_name": "time",
      "include_file": "time.h",
      "return_type": "time_t",
      "parameter_types": ["time_t*"],
      "main_category": "Time and Date Management",
      "sub_category": "Time Measurement",
      "data_type_manipulated": "time",
      "description": "Gets the current calendar time.",
      "extended_description": "The time function returns the current calendar time as a time_t value, which represents the number of seconds elapsed since the Epoch (00:00:00 UTC, January 1, 1970). If the argument is not NULL, the return value is also stored in the location pointed to by the argument.",
      "return_value": "Returns the current calendar time as a time_t value, or -1 if the time is not available.",
      "parameter_values": "timer: Pointer to a time_t object to store the time value. If timer is NULL, the return value is not stored.",
      "function_prototype": "time_t time(time_t *timer);",
      "examples": [
          {
              "title": "Basic Usage",
              "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    time_t current_time = time(NULL);\n    printf(\"Current time: %ld\\n\", current_time);\n    return 0;\n}",
              "explanation": "This example gets the current time and prints it as a long integer.",
              "expectedOutput": "Current time: 1625671234"
          },
          {
              "title": "Using time to measure duration",
              "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    time_t start = time(NULL);\n    // Simulate some work\n    for(long i = 0; i < 1000000000; i++) {}\n    time_t end = time(NULL);\n    printf(\"Operation took %ld seconds\\n\", end - start);\n    return 0;\n}",
              "explanation": "This example uses time() to measure the duration of an operation.",
              "expectedOutput": "Operation took 5 seconds"
          },
          {
              "title": "Converting time_t to string",
              "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    time_t current_time;\n    time(&current_time);\n    char* time_str = ctime(&current_time);\n    printf(\"Current time: %s\", time_str);\n    return 0;\n}",
              "explanation": "This example demonstrates how to convert a time_t value to a human-readable string using ctime().",
              "expectedOutput": "Current time: Wed Jul 07 15:20:34 2021\n"
          }
      ],
      "related_functions": ["ctime", "localtime", "gmtime", "difftime"],
      "performance_considerations": "The time() function is generally fast and efficient. However, it only has second-level precision. For higher precision timing, consider using clock_gettime() or similar functions."
  },
  {
    "function_name": "time64",
    "include_file": "time.h",
    "return_type": "__time64_t",
    "parameter_types": ["__time64_t*"],
    "main_category": "Time and Date Management",
    "sub_category": "Time Measurement",
    "data_type_manipulated": "time",
    "description": "Gets the current calendar time as a 64-bit value, suitable for representing times beyond 2038.",
    "extended_description": "The time64 function returns the current calendar time as a __time64_t value, which is a 64-bit representation of the number of seconds elapsed since the Epoch (00:00:00 UTC, January 1, 1970). This allows for representing dates well beyond the year 2038, avoiding the 'Year 2038 problem' associated with 32-bit time_t values.",
    "return_value": "Returns the current calendar time as a __time64_t value, or -1 if the time is not available.",
    "parameter_values": "timer: Pointer to a __time64_t object to store the time value. If timer is NULL, the return value is not stored.",
    "function_prototype": "__time64_t _time64(__time64_t *timer);",
    "examples": [
        {
            "title": "Basic Usage",
            "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    __time64_t current_time;\n    _time64(&current_time);\n    printf(\"Current time (64-bit): %lld\\n\", current_time);\n    return 0;\n}",
            "explanation": "This example gets the current time using the 64-bit function and prints it as a long long integer.",
            "expectedOutput": "Current time (64-bit): 1625671234"
        },
        {
            "title": "Calculating a future date",
            "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    __time64_t current_time = _time64(NULL);\n    __time64_t future_time = current_time + (365LL * 24 * 60 * 60 * 100);\n    printf(\"Time 100 years from now: %lld\\n\", future_time);\n    return 0;\n}",
            "explanation": "This example calculates a date 100 years in the future, demonstrating the ability to work with dates far beyond 2038.",
            "expectedOutput": "Time 100 years from now: 4777671234"
        },
        {
            "title": "Converting __time64_t to string",
            "code": "#include <stdio.h>\n#include <time.h>\n\nint main() {\n    __time64_t current_time;\n    _time64(&current_time);\n    char time_str[26];\n    _ctime64_s(time_str, sizeof(time_str), &current_time);\n    printf(\"Current time: %s\", time_str);\n    return 0;\n}",
            "explanation": "This example shows how to convert a __time64_t value to a human-readable string using _ctime64_s().",
            "expectedOutput": "Current time: Wed Jul 07 15:20:34 2021\n"
        }
    ],
    "related_functions": ["_ctime64", "_localtime64", "_gmtime64", "_difftime64"],
    "performance_considerations": "The time64() function has similar performance characteristics to time(). The main advantage is its ability to handle dates beyond 2038, which is crucial for long-term date calculations or systems that need to work with dates far in the future."
},
{
  "function_name": "tmpfile",
  "include_file": "stdio.h",
  "return_type": "FILE*",
  "parameter_types": [],
  "main_category": "File and I/O Operations",
  "sub_category": "File Management",
  "data_type_manipulated": "file streams",
  "description": "Creates a temporary binary file that is automatically deleted when closed or the program terminates.",
  "extended_description": "The tmpfile function creates a temporary binary file in update mode (wb+). This file is automatically deleted when it is closed or when the program terminates normally. The file is created in the directory determined by the TMP environment variable.",
  "return_value": "Returns a pointer to the temporary file stream if successful, or NULL if an error occurred.",
  "parameter_values": "None",
  "function_prototype": "FILE *tmpfile(void);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n\nint main() {\n    FILE *temp = tmpfile();\n    if (temp) {\n        fputs(\"Hello, temporary world!\", temp);\n        rewind(temp);\n        char buffer[100];\n        if (fgets(buffer, sizeof(buffer), temp)) {\n            printf(\"Read from temp file: %s\\n\", buffer);\n        }\n        fclose(temp);\n    }\n    return 0;\n}",
          "explanation": "This example creates a temporary file, writes to it, reads from it, and then closes it (which automatically deletes the file).",
          "expectedOutput": "Read from temp file: Hello, temporary world!"
      },
      {
          "title": "Error Handling",
          "code": "#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n\nint main() {\n    FILE *temp = tmpfile();\n    if (!temp) {\n        fprintf(stderr, \"Failed to create temp file: %s\\n\", strerror(errno));\n        return 1;\n    }\n    // Use the temporary file...\n    fclose(temp);\n    return 0;\n}",
          "explanation": "This example demonstrates proper error handling when creating a temporary file.",
          "expectedOutput": "No output if successful. Error message if file creation fails."
      },
      {
          "title": "Using tmpfile for intermediate calculations",
          "code": "#include <stdio.h>\n\nint main() {\n    FILE *temp = tmpfile();\n    if (temp) {\n        for (int i = 0; i < 10; i++) {\n            fprintf(temp, \"%d\\n\", i * i);\n        }\n        rewind(temp);\n        int sum = 0, value;\n        while (fscanf(temp, \"%d\", &value) == 1) {\n            sum += value;\n        }\n        printf(\"Sum of squares: %d\\n\", sum);\n        fclose(temp);\n    }\n    return 0;\n}",
          "explanation": "This example uses a temporary file to store intermediate results of a calculation, then processes those results.",
          "expectedOutput": "Sum of squares: 285"
      }
  ],
  "related_functions": ["fopen", "fclose", "remove", "tmpnam"],
  "performance_considerations": "tmpfile() is generally efficient, but frequent creation and deletion of temporary files can impact I/O performance. For very short-lived temporary data, consider using memory-based alternatives if possible."
},
{
  "function_name": "tmpnam",
  "include_file": "stdio.h",
  "return_type": "char*",
  "parameter_types": ["char*"],
  "main_category": "File and I/O Operations",
  "sub_category": "File Management",
  "data_type_manipulated": "strings",
  "description": "Generates a unique temporary filename.",
  "extended_description": "The tmpnam function generates a string that is a valid filename and that is not the same as the name of an existing file. This function is potentially dangerous because it creates a window of opportunity between the generation of the name and the creation of the file. For a safer alternative, consider using tmpfile().",
  "return_value": "If the argument is NULL, returns a pointer to an internal static array. If the argument is not NULL, returns the argument.",
  "parameter_values": "s: Pointer to an array of at least L_tmpnam chars, or NULL.",
  "function_prototype": "char *tmpnam(char *s);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n\nint main() {\n    char buffer[L_tmpnam];\n    char *filename = tmpnam(buffer);\n    if (filename == NULL) {\n        printf(\"Failed to generate temporary filename\\n\");\n    } else {\n        printf(\"Temporary filename: %s\\n\", filename);\n    }\n    return 0;\n}",
          "explanation": "This example generates a temporary filename and stores it in a buffer.",
          "expectedOutput": "Temporary filename: /tmp/file1a2b3c"
      },
      {
          "title": "Using Internal Static Buffer",
          "code": "#include <stdio.h>\n\nint main() {\n    char *filename = tmpnam(NULL);\n    if (filename == NULL) {\n        printf(\"Failed to generate temporary filename\\n\");\n    } else {\n        printf(\"Temporary filename: %s\\n\", filename);\n    }\n    return 0;\n}",
          "explanation": "This example uses the internal static buffer of tmpnam by passing NULL.",
          "expectedOutput": "Temporary filename: /tmp/file4d5e6f"
      },
      {
          "title": "Creating a Temporary File",
          "code": "#include <stdio.h>\n\nint main() {\n    char filename[L_tmpnam];\n    tmpnam(filename);\n    FILE *fp = fopen(filename, \"w\");\n    if (fp != NULL) {\n        fprintf(fp, \"This is a temporary file.\\n\");\n        fclose(fp);\n        printf(\"Temporary file created: %s\\n\", filename);\n        remove(filename);\n    } else {\n        printf(\"Failed to create temporary file\\n\");\n    }\n    return 0;\n}",
          "explanation": "This example creates a temporary file using the generated filename, writes to it, and then removes it.",
          "expectedOutput": "Temporary file created: /tmp/file7g8h9i"
      }
  ],
  "related_functions": ["tmpfile", "tempnam"],
  "performance_considerations": "tmpnam is not thread-safe and has potential security risks. It's generally recommended to use tmpfile() or mkstemp() instead for creating temporary files."
},
{
  "function_name": "toascii",
  "include_file": "ctype.h",
  "return_type": "int",
  "parameter_types": ["int"],
  "main_category": "Character Type and Conversion",
  "sub_category": "Character Manipulation",
  "data_type_manipulated": "characters",
  "description": "Converts a character to its ASCII equivalent.",
  "extended_description": "The toascii function converts the given integer to a 7-bit unsigned char value that fits into the ASCII character set, by clearing all but the least significant 7 bits. This function is often used when ensuring that a character is within the ASCII range.",
  "return_value": "The value returned is that of the converted letter, or the value of c if it's already an ASCII character.",
  "parameter_values": "c: The character to be converted.",
  "function_prototype": "int toascii(int c);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    int ch = 0x80;\n    printf(\"Original: 0x%X, ASCII: 0x%X\\n\", ch, toascii(ch));\n    return 0;\n}",
          "explanation": "This example converts a non-ASCII character to its ASCII equivalent.",
          "expectedOutput": "Original: 0x80, ASCII: 0x0"
      },
      {
          "title": "Converting Extended ASCII",
          "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    for (int i = 0; i < 256; i++) {\n        printf(\"0x%02X -> 0x%02X\\n\", i, toascii(i));\n    }\n    return 0;\n}",
          "explanation": "This example shows how toascii behaves for all possible byte values.",
          "expectedOutput": "0x00 -> 0x00\n0x01 -> 0x01\n...\n0x7F -> 0x7F\n0x80 -> 0x00\n0x81 -> 0x01\n...\n0xFF -> 0x7F"
      },
      {
          "title": "Preserving ASCII Characters",
          "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char str[] = \"Hello, World!\";\n    for (int i = 0; str[i]; i++) {\n        printf(\"%c\", toascii(str[i]));\n    }\n    printf(\"\\n\");\n    return 0;\n}",
          "explanation": "This example demonstrates that toascii doesn't change ASCII characters.",
          "expectedOutput": "Hello, World!"
      }
  ],
  "related_functions": ["isascii", "toupper", "tolower"],
  "performance_considerations": "toascii is a simple bitwise operation and is generally very fast. However, it's important to note that it can lose information for characters outside the ASCII range."
},
{
  "function_name": "tolower",
  "include_file": "ctype.h",
  "return_type": "int",
  "parameter_types": ["int"],
  "main_category": "Character Type and Conversion",
  "sub_category": "Character Manipulation",
  "data_type_manipulated": "characters",
  "description": "Converts a character to lowercase.",
  "extended_description": "The tolower function converts an uppercase letter to the corresponding lowercase letter. If the argument is not an uppercase letter, it is returned unchanged. This function is commonly used for case-insensitive string comparisons or to ensure consistent casing in text processing.",
  "return_value": "If c is an uppercase letter, returns the corresponding lowercase letter. Otherwise, it returns c unchanged.",
  "parameter_values": "c: The character to be converted.",
  "function_prototype": "int tolower(int c);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char ch = 'A';\n    printf(\"Original: %c, Lowercase: %c\\n\", ch, tolower(ch));\n    ch = 'a';\n    printf(\"Original: %c, Lowercase: %c\\n\", ch, tolower(ch));\n    return 0;\n}",
          "explanation": "This example demonstrates tolower on both uppercase and lowercase letters.",
          "expectedOutput": "Original: A, Lowercase: a\nOriginal: a, Lowercase: a"
      },
      {
          "title": "Converting a String to Lowercase",
          "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Hello, WORLD!\";\n    for (int i = 0; i < strlen(str); i++) {\n        str[i] = tolower(str[i]);\n    }\n    printf(\"Lowercase string: %s\\n\", str);\n    return 0;\n}",
          "explanation": "This example converts an entire string to lowercase.",
          "expectedOutput": "Lowercase string: hello, world!"
      },
      {
          "title": "Case-Insensitive Comparison",
          "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint strcicmp(const char *a, const char *b) {\n    while (*a && *b) {\n        if (tolower((unsigned char)*a) != tolower((unsigned char)*b))\n            return tolower((unsigned char)*a) - tolower((unsigned char)*b);\n        a++;\n        b++;\n    }\n    return tolower((unsigned char)*a) - tolower((unsigned char)*b);\n}\n\nint main() {\n    const char *s1 = \"Hello\";\n    const char *s2 = \"HELLO\";\n    printf(\"\\\"%s\\\" and \\\"%s\\\" are %s\\n\", s1, s2,\n           strcicmp(s1, s2) == 0 ? \"equal\" : \"not equal\");\n    return 0;\n}",
          "explanation": "This example implements a case-insensitive string comparison function using tolower.",
          "expectedOutput": "\"Hello\" and \"HELLO\" are equal"
      }
  ],
  "related_functions": ["toupper", "islower", "isupper"],
  "performance_considerations": "tolower is generally efficient for single character conversions. For converting large amounts of text, consider using wide character functions or platform-specific optimized functions if available."
} ,

{
  "function_name": "toupper",
  "include_file": "ctype.h",
  "return_type": "int",
  "parameter_types": ["int"],
  "main_category": "Character Type and Conversion",
  "sub_category": "Character Manipulation",
  "data_type_manipulated": "characters",
  "description": "Converts a character to uppercase.",
  "extended_description": "The toupper function converts a lowercase letter to the corresponding uppercase letter. If the argument is not a lowercase letter, it is returned unchanged. This function is commonly used for case conversion in text processing or to ensure consistent casing in certain applications.",
  "return_value": "If c is a lowercase letter, returns the corresponding uppercase letter. Otherwise, it returns c unchanged.",
  "parameter_values": "c: The character to be converted.",
  "function_prototype": "int toupper(int c);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char ch = 'a';\n    printf(\"Original: %c, Uppercase: %c\\n\", ch, toupper(ch));\n    ch = 'A';\n    printf(\"Original: %c, Uppercase: %c\\n\", ch, toupper(ch));\n    return 0;\n}",
          "explanation": "This example demonstrates toupper on both lowercase and uppercase letters.",
          "expectedOutput": "Original: a, Uppercase: A\nOriginal: A, Uppercase: A"
      },
      {
          "title": "Converting a String to Uppercase",
          "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"Hello, world!\";\n    for (int i = 0; i < strlen(str); i++) {\n        str[i] = toupper(str[i]);\n    }\n    printf(\"Uppercase string: %s\\n\", str);\n    return 0;\n}",
          "explanation": "This example converts an entire string to uppercase.",
          "expectedOutput": "Uppercase string: HELLO, WORLD!"
      },
      {
          "title": "Capitalizing First Letter of Each Word",
          "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint main() {\n    char str[] = \"the quick brown fox\";\n    int capitalize_next = 1;\n    \n    for (int i = 0; str[i]; i++) {\n        if (isspace(str[i])) {\n            capitalize_next = 1;\n        } else if (capitalize_next) {\n            str[i] = toupper(str[i]);\n            capitalize_next = 0;\n        }\n    }\n    \n    printf(\"Capitalized string: %s\\n\", str);\n    return 0;\n}",
          "explanation": "This example uses toupper to capitalize the first letter of each word in a string.",
          "expectedOutput": "Capitalized string: The Quick Brown Fox"
      }
  ],
  "related_functions": ["tolower", "isupper", "islower"],
  "performance_considerations": "toupper is generally efficient for single character conversions. For converting large amounts of text, consider using wide character functions or platform-specific optimized functions if available."
},
{
  "function_name": "towctrans",
  "include_file": "wctype.h",
  "return_type": "wint_t",
  "parameter_types": ["wint_t", "wctrans_t"],
  "main_category": "Character Type and Conversion",
  "sub_category": "Wide Character Manipulation",
  "data_type_manipulated": "wide characters",
  "description": "Applies a specified transformation to a wide character, such as tolower or toupper.",
  "extended_description": "The towctrans function applies a specified locale-specific character mapping to a wide character. It's a generalized character conversion function that can perform various transformations depending on the wctrans_t descriptor provided. Common uses include converting between uppercase and lowercase.",
  "return_value": "Returns the transformed wide character if a mapping is defined, otherwise returns the input character unchanged.",
  "parameter_values": "wc: The wide character to be transformed. desc: The transformation descriptor obtained from wctrans().",
  "function_prototype": "wint_t towctrans(wint_t wc, wctrans_t desc);",
  "examples": [
      {
          "title": "Basic Usage with Lowercase Conversion",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wint_t wc = L'A';\n    wctrans_t lower_desc = wctrans(\"tolower\");\n    wint_t result = towctrans(wc, lower_desc);\n    wprintf(L\"Original: %lc, Transformed: %lc\\n\", wc, result);\n    return 0;\n}",
          "explanation": "This example uses towctrans to convert an uppercase wide character to lowercase.",
          "expectedOutput": "Original: A, Transformed: a"
      },
      {
          "title": "Using towctrans for Uppercase Conversion",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t str[] = L\"Hello, World!\";\n    wctrans_t upper_desc = wctrans(\"toupper\");\n    \n    for (int i = 0; str[i]; i++) {\n        str[i] = towctrans(str[i], upper_desc);\n    }\n    \n    wprintf(L\"Uppercase string: %ls\\n\", str);\n    return 0;\n}",
          "explanation": "This example uses towctrans to convert a wide character string to uppercase.",
          "expectedOutput": "Uppercase string: HELLO, WORLD!"
      },
      {
          "title": "Custom Character Mapping",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nwint_t custom_map(wint_t wc) {\n    if (wc >= L'a' && wc <= L'z') {\n        return wc - L'a' + L'A';\n    }\n    return wc;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t str[] = L\"Hello, World!\";\n    wctrans_t custom_desc = wctrans(\"toupper\"); // Using toupper as a base\n    \n    for (int i = 0; str[i]; i++) {\n        str[i] = custom_map(towctrans(str[i], custom_desc));\n    }\n    \n    wprintf(L\"Transformed string: %ls\\n\", str);\n    return 0;\n}",
          "explanation": "This example demonstrates using towctrans with a custom mapping function to transform a string.",
          "expectedOutput": "Transformed string: HELLO, WORLD!"
      }
  ],
  "related_functions": ["wctrans", "towupper", "towlower"],
  "performance_considerations": "towctrans is more flexible than specific functions like towupper or towlower, but it may be slightly slower due to the need to look up the transformation descriptor. For simple uppercase or lowercase conversions, using towupper or towlower directly might be more efficient."
},
{
  "function_name": "towlower",
  "include_file": "wctype.h",
  "return_type": "wint_t",
  "parameter_types": ["wint_t"],
  "main_category": "Character Type and Conversion",
  "sub_category": "Wide Character Manipulation",
  "data_type_manipulated": "wide characters",
  "description": "Converts a wide character to lowercase.",
  "extended_description": "The towlower function converts an uppercase wide character to the corresponding lowercase wide character. If the argument is not an uppercase letter, it is returned unchanged. This function is the wide-character counterpart of tolower and is used for case conversion in wide character text processing.",
  "return_value": "If wc is an uppercase letter, returns the corresponding lowercase letter. Otherwise, it returns wc unchanged.",
  "parameter_values": "wc: The wide character to be converted.",
  "function_prototype": "wint_t towlower(wint_t wc);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wint_t wc = L'A';\n    wprintf(L\"Original: %lc, Lowercase: %lc\\n\", wc, towlower(wc));\n    wc = L'a';\n    wprintf(L\"Original: %lc, Lowercase: %lc\\n\", wc, towlower(wc));\n    return 0;\n}",
          "explanation": "This example demonstrates towlower on both uppercase and lowercase wide characters.",
          "expectedOutput": "Original: A, Lowercase: a\nOriginal: a, Lowercase: a"
      },
      {
          "title": "Converting a Wide String to Lowercase",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t str[] = L\"Hello, WORLD!\";\n    for (int i = 0; str[i]; i++) {\n        str[i] = towlower(str[i]);\n    }\n    wprintf(L\"Lowercase string: %ls\\n\", str);\n    return 0;\n}",
          "explanation": "This example converts an entire wide character string to lowercase.",
          "expectedOutput": "Lowercase string: hello, world!"
      },
      {
          "title": "Case-Insensitive Wide String Comparison",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint wcscasecmp(const wchar_t *s1, const wchar_t *s2) {\n    while (*s1 && towlower(*s1) == towlower(*s2)) {\n        s1++;\n        s2++;\n    }\n    return towlower(*s1) - towlower(*s2);\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *str1 = L\"Hello\";\n    const wchar_t *str2 = L\"HELLO\";\n    int result = wcscasecmp(str1, str2);\n    wprintf(L\"\\\"%ls\\\" and \\\"%ls\\\" are %ls\\n\", str1, str2,\n            result == 0 ? L\"equal\" : L\"not equal\");\n    return 0;\n}",
          "explanation": "This example implements a case-insensitive wide string comparison function using towlower.",
          "expectedOutput": "\"Hello\" and \"HELLO\" are equal"
      }
  ],
  "related_functions": ["towupper", "iswlower", "iswupper"],
  "performance_considerations": "towlower is generally efficient for single wide character conversions. For converting large amounts of text, consider using platform-specific optimized functions if available. Also, ensure proper locale settings for correct behavior with non-ASCII characters."
},
{
  "function_name": "towupper",
  "include_file": "wctype.h",
  "return_type": "wint_t",
  "parameter_types": ["wint_t"],
  "main_category": "Character Type and Conversion",
  "sub_category": "Wide Character Manipulation",
  "data_type_manipulated": "wide characters",
  "description": "Converts a wide character to uppercase.",
  "extended_description": "The towupper function converts a lowercase wide character to the corresponding uppercase wide character. If the argument is not a lowercase letter, it is returned unchanged. This function is the wide-character counterpart of toupper and is used for case conversion in wide character text processing.",
  "return_value": "If wc is a lowercase letter, returns the corresponding uppercase letter. Otherwise, it returns wc unchanged.",
  "parameter_values": "wc: The wide character to be converted.",
  "function_prototype": "wint_t towupper(wint_t wc);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wint_t wc = L'a';\n    wprintf(L\"Original: %lc, Uppercase: %lc\\n\", wc, towupper(wc));\n    wc = L'A';\n    wprintf(L\"Original: %lc, Uppercase: %lc\\n\", wc, towupper(wc));\n    return 0;\n}",
          "explanation": "This example demonstrates towupper on both lowercase and uppercase wide characters.",
          "expectedOutput": "Original: a, Uppercase: A\nOriginal: A, Uppercase: A"
      },
      {
          "title": "Converting a Wide String to Uppercase",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t str[] = L\"Hello, world!\";\n    for (int i = 0; str[i]; i++) {\n        str[i] = towupper(str[i]);\n    }\n    wprintf(L\"Uppercase string: %ls\\n\", str);\n    return 0;\n}",
          "explanation": "This example converts an entire wide character string to uppercase.",
          "expectedOutput": "Uppercase string: HELLO, WORLD!"
      },
      {
          "title": "Uppercase First Letter of Each Word",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t str[] = L\"the quick brown fox\";\n    int capitalize_next = 1;\n    \n    for (int i = 0; str[i]; i++) {\n        if (iswspace(str[i])) {\n            capitalize_next = 1;\n        } else if (capitalize_next) {\n            str[i] = towupper(str[i]);\n            capitalize_next = 0;\n        }\n    }\n    \n    wprintf(L\"Capitalized string: %ls\\n\", str);\n    return 0;\n}",
          "explanation": "This example uses towupper to capitalize the first letter of each word in a wide character string.",
          "expectedOutput": "Capitalized string: The Quick Brown Fox"
      }
  ],
  "related_functions": ["towlower", "iswupper", "iswlower"],
  "performance_considerations": "towupper is generally efficient for single wide character conversions. For converting large amounts of text, consider using platform-specific optimized functions if available. Ensure proper locale settings for correct behavior with non-ASCII characters."
},
{
  "function_name": "ungetc",
  "include_file": "stdio.h",
  "return_type": "int",
  "parameter_types": ["int", "FILE*"],
  "main_category": "File and I/O Operations",
  "sub_category": "Stream Manipulation",
  "data_type_manipulated": "file streams",
  "description": "Pushes a character back onto a stream, where it is available for subsequent read operations.",
  "extended_description": "The ungetc function pushes the character specified by c back onto the input stream pointed to by stream. This character will be the next character read by fgetc(), getc(), or any other input function on that stream. ungetc() guarantees only one character of pushback.",
  "return_value": "Returns the character pushed back after conversion to an unsigned char, or EOF if the operation fails.",
  "parameter_values": "c: The character to be pushed back. stream: Pointer to a FILE object that identifies the stream.",
  "function_prototype": "int ungetc(int c, FILE *stream);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n\nint main() {\n    FILE *file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) return 1;\n    \n    int ch = fgetc(file);\n    if (ch != EOF) {\n        printf(\"Read: %c\\n\", ch);\n        ungetc(ch, file);\n        ch = fgetc(file);\n        printf(\"Read again: %c\\n\", ch);\n    }\n    \n    fclose(file);\n    return 0;\n}",
          "explanation": "This example reads a character from a file, pushes it back, and then reads it again.",
          "expectedOutput": "Read: H\nRead again: H"
      },
      {
          "title": "Peeking at the Next Character",
          "code": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char str[] = \"123 abc\";\n    FILE *stream = fmemopen(str, sizeof(str), \"r\");\n    \n    int ch;\n    while ((ch = fgetc(stream)) != EOF) {\n        if (isdigit(ch)) {\n            printf(\"Digit: %c\\n\", ch);\n        } else {\n            ungetc(ch, stream);\n            break;\n        }\n    }\n    \n    printf(\"Next non-digit: %c\\n\", fgetc(stream));\n    fclose(stream);\n    return 0;\n}",
          "explanation": "This example uses ungetc to peek at the next character without consuming it if it's not a digit.",
          "expectedOutput": "Digit: 1\nDigit: 2\nDigit: 3\nNext non-digit:  "
      },
      {
          "title": "Token Parsing",
          "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint main() {\n    char input[] = \"123+456\";\n    FILE *stream = fmemopen(input, strlen(input), \"r\");\n    \n    char token[10];\n    int i = 0, ch;\n    \n    while ((ch = fgetc(stream)) != EOF && i < 9) {\n        if (isdigit(ch)) {\n            token[i++] = ch;\n        } else {\n            ungetc(ch, stream);\n            break;\n        }\n    }\n    token[i] = '\\0';\n    \n    printf(\"First token: %s\\n\", token);\n    printf(\"Next character: %c\\n\", fgetc(stream));\n    \n    fclose(stream);\n    return 0;\n}",
          "explanation": "This example uses ungetc in a simple token parser to separate numbers and operators.",
          "expectedOutput": "First token: 123\nNext character: +"
      }
  ],
  "related_functions": ["fgetc", "getc", "ungetwc"],
  "performance_considerations": "ungetc is generally efficient for pushing back a single character. However, it's guaranteed to work only for one character of pushback. Excessive use of ungetc can lead to inefficient parsing algorithms and should be avoided when possible."
},
{
  "function_name": "ungetwc",
  "include_file": "wchar.h",
  "return_type": "wint_t",
  "parameter_types": ["wint_t", "FILE*"],
  "main_category": "File and I/O Operations",
  "sub_category": "Wide Character Support",
  "data_type_manipulated": "file streams",
  "description": "Pushes a wide character back onto a stream, where it is available for subsequent read operations.",
  "extended_description": "The ungetwc function pushes the wide character specified by wc back onto the input stream pointed to by stream. This wide character will be the next character read by fgetwc(), getwc(), or any other wide character input function on that stream. ungetwc() guarantees only one wide character of pushback.",
  "return_value": "Returns the wide character pushed back, or WEOF if the operation fails.",
  "parameter_values": "wc: The wide character to be pushed back. stream: Pointer to a FILE object that identifies the stream.",
  "function_prototype": "wint_t ungetwc(wint_t wc, FILE *stream);",
  "examples": [
      {
          "title": "Basic Usage",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    FILE *file = fopen(\"example.txt\", \"r\");\n    if (file == NULL) return 1;\n    \n    wint_t wc = fgetwc(file);\n    if (wc != WEOF) {\n        wprintf(L\"Read: %lc\\n\", wc);\n        ungetwc(wc, file);\n        wc = fgetwc(file);\n        wprintf(L\"Read again: %lc\\n\", wc);\n    }\n    \n    fclose(file);\n    return 0;\n}",
          "explanation": "This example reads a wide character from a file, pushes it back, and then reads it again.",
          "expectedOutput": "Read: H\nRead again: H"
      },
      {
          "title": "Peeking at the Next Wide Character",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t str[] = L\"123 αβγ\";\n    FILE *stream = fmemopen(str, sizeof(wchar_t) * wcslen(str), \"r\");\n    \n    wint_t wc;\n    while ((wc = fgetwc(stream)) != WEOF) {\n        if (iswdigit(wc)) {\n            wprintf(L\"Digit: %lc\\n\", wc);\n        } else {\n            ungetwc(wc, stream);\n            break;\n        }\n    }\n    \n    wprintf(L\"Next non-digit: %lc\\n\", fgetwc(stream));\n    fclose(stream);\n    return 0;\n}",
          "explanation": "This example uses ungetwc to peek at the next wide character without consuming it if it's not a digit.",
          "expectedOutput": "Digit: 1\nDigit: 2\nDigit: 3\nNext non-digit:  "
      },
      {
          "title": "Wide Character Token Parsing",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t input[] = L\"123+αβγ\";\n    FILE *stream = fmemopen(input, sizeof(wchar_t) * wcslen(input), \"r\");\n    \n    wchar_t token[10];\n    int i = 0;\n    wint_t wc;\n    \n    while ((wc = fgetwc(stream)) != WEOF && i < 9) {\n        if (iswdigit(wc)) {\n            token[i++] = wc;\n        } else {\n            ungetwc(wc, stream);\n            break;\n        }\n    }\n    token[i] = L'\\0';\n    \n    wprintf(L\"First token: %ls\\n\", token);\n    wprintf(L\"Next character: %lc\\n\", fgetwc(stream));\n    \n    fclose(stream);\n    return 0;\n}",
          "explanation": "This example uses ungetwc in a simple wide character token parser to separate numbers and other characters.",
          "expectedOutput": "First token: 123\nNext character: +"
      }
  ],
  "related_functions": ["fgetwc", "getwc", "ungetc"],
  "performance_considerations": "ungetwc is generally efficient for pushing back a single wide character. However, it's guaranteed to work only for one wide character of pushback. Excessive use of ungetwc can lead to inefficient parsing algorithms and should be avoided when possible. Ensure proper locale settings for correct behavior with non-ASCII characters."
},
{
  "function_name": "va_arg",
  "include_file": "stdarg.h",
  "return_type": "type",
  "parameter_types": ["va_list", "type"],
  "main_category": "Data Handling",
  "sub_category": "Variable Argument Lists",
  "data_type_manipulated": "variadic functions",
  "description": "Retrieves the next argument in a function with a variable number of arguments.",
  "extended_description": "va_arg is a macro that expands to an expression of the type and value of the next argument in a call to a variadic function. It modifies ap so that the next call to va_arg returns the next argument. The type parameter is a type name specified so that the type of the object after promotion can be determined.",
  "return_value": "Returns the next argument in the variable argument list.",
  "parameter_values": "ap: A va_list object initialized by va_start. type: The type of the next argument to be retrieved.",
  "function_prototype": "type va_arg(va_list ap, type);",
  "examples": [
      {
          "title": "Basic Usage in a Variadic Function",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nvoid print_numbers(int count, ...) {\n    va_list args;\n    va_start(args, count);\n    \n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        printf(\"%d \", num);\n    }\n    printf(\"\\n\");\n    \n    va_end(args);\n}\n\nint main() {\n    print_numbers(4, 10, 20, 30, 40);\n    return 0;\n}",
          "explanation": "This example demonstrates using va_arg to retrieve integer arguments in a variadic function.",
          "expectedOutput": "10 20 30 40 "
      },
      {
          "title": "Handling Different Types",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nvoid print_formatted(const char *format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    while (*format) {\n        if (*format == 'd') {\n            int i = va_arg(args, int);\n            printf(\"%d \", i);\n        } else if (*format == 'f') {\n            double d = va_arg(args, double);\n            printf(\"%.2f \", d);\n        } else if (*format == 's') {\n            char *s = va_arg(args, char*);\n            printf(\"%s \", s);\n        }\n        format++;\n    }\n    printf(\"\\n\");\n    \n    va_end(args);\n}\n\nint main() {\n    print_formatted(\"dfs\", 42, 3.14, \"hello\");\n    return 0;\n}",
          "explanation": "This example shows how to use va_arg with different types based on a format string.",
          "expectedOutput": "42 3.14 hello "
      },
      {
          "title": "Implementing a Simple printf-like Function",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nvoid my_printf(const char *format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    while (*format) {\n        if (*format == '%') {\n            format++;\n            switch (*format) {\n                case 'd': {\n                    int i = va_arg(args, int);\n                    printf(\"%d\", i);\n                    break;\n                }\n                case 'f': {\n                    double d = va_arg(args, double);\n                    printf(\"%f\", d);\n                    break;\n                }\n                case 's': {\n                    char *s = va_arg(args, char*);\n                    printf(\"%s\", s);\n                    break;\n                }\n            }\n        } else {\n            putchar(*format);\n        }\n        format++;\n    }\n    \n    va_end(args);\n}\n\nint main() {\n    my_printf(\"Int: %d, Float: %f, String: %s\\n\", 42, 3.14, \"Hello\");\n    return 0;\n}",
          "explanation": "This example implements a simple printf-like function using va_arg to handle different argument types.",
          "expectedOutput": "Int: 42, Float: 3.140000, String: Hello"
      }
  ],
  "related_functions": ["va_start", "va_end", "va_copy"],
  "performance_considerations": "va_arg is generally efficient, but care must be taken to ensure that the correct type is specified for each argument. Mismatched types can lead to undefined behavior and potential security vulnerabilities."
},
{
  "function_name": "va_copy",
  "include_file": "stdarg.h",
  "return_type": "void",
  "parameter_types": ["va_list", "va_list"],
  "main_category": "Data Handling",
  "sub_category": "Variable Argument Lists",
  "data_type_manipulated": "variadic functions",
  "description": "Copies the content of one va_list to another.",
  "extended_description": "va_copy is a macro that copies the (previously initialized) variable argument list src to dest. This is useful in scenarios where you need to scan the argument list more than once or pass it to another function. After va_copy, dest is equivalent to src at the moment va_copy was called.",
  "return_value": "None (void function).",
  "parameter_values": "dest: The destination va_list. src: The source va_list to be copied.",
  "function_prototype": "void va_copy(va_list dest, va_list src);",
  "examples": [
      {
          "title": "Basic Usage of va_copy",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nvoid print_numbers(int count, ...) {\n    va_list args, args_copy;\n    va_start(args, count);\n    va_copy(args_copy, args);\n    \n    printf(\"Original list: \");\n    for (int i = 0; i < count; i++) {\n        printf(\"%d \", va_arg(args, int));\n    }\n    printf(\"\\n\");\n    \n    printf(\"Copied list: \");\n    for (int i = 0; i < count; i++) {\n        printf(\"%d \", va_arg(args_copy, int));\n    }\n    printf(\"\\n\");\n    \n    va_end(args);\n    va_end(args_copy);\n}\n\nint main() {\n    print_numbers(4, 10, 20, 30, 40);\n    return 0;\n}",
          "explanation": "This example demonstrates how to use va_copy to create a copy of a va_list and process both lists independently.",
          "expectedOutput": "Original list: 10 20 30 40 \nCopied list: 10 20 30 40 "
      },
      {
          "title": "Using va_copy for Multiple Passes",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nvoid process_args(const char* format, ...) {\n    va_list args, args_copy;\n    va_start(args, format);\n    va_copy(args_copy, args);\n    \n    // First pass: count arguments\n    int count = 0;\n    for (const char* p = format; *p; p++) {\n        if (*p == '%') count++;\n    }\n    printf(\"Number of arguments: %d\\n\", count);\n    \n    // Second pass: print arguments\n    printf(\"Arguments: \");\n    for (const char* p = format; *p; p++) {\n        if (*p == '%') {\n            int arg = va_arg(args_copy, int);\n            printf(\"%d \", arg);\n        }\n    }\n    printf(\"\\n\");\n    \n    va_end(args);\n    va_end(args_copy);\n}\n\nint main() {\n    process_args(\"%d %d %d\", 10, 20, 30);\n    return 0;\n}",
          "explanation": "This example uses va_copy to allow multiple passes through the argument list: first to count arguments, then to print them.",
          "expectedOutput": "Number of arguments: 3\nArguments: 10 20 30 "
      },
      {
          "title": "va_copy in a Wrapper Function",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nint sum_wrapper(int count, ...) {\n    va_list args, args_copy;\n    va_start(args, count);\n    va_copy(args_copy, args);\n    \n    int sum = 0;\n    for (int i = 0; i < count; i++) {\n        sum += va_arg(args, int);\n    }\n    \n    printf(\"Arguments: \");\n    for (int i = 0; i < count; i++) {\n        printf(\"%d \", va_arg(args_copy, int));\n    }\n    printf(\"\\n\");\n    \n    va_end(args);\n    va_end(args_copy);\n    return sum;\n}\n\nint main() {\n    int result = sum_wrapper(4, 10, 20, 30, 40);\n    printf(\"Sum: %d\\n\", result);\n    return 0;\n}",
          "explanation": "This example demonstrates using va_copy in a wrapper function that both processes the arguments (summing them) and prints them.",
          "expectedOutput": "Arguments: 10 20 30 40 \nSum: 100"
      }
  ],
  "related_functions": ["va_start", "va_end", "va_arg"],
  "performance_considerations": "va_copy is generally efficient, but it's important to ensure that va_end is called on both the original and copied va_list to avoid resource leaks. In most implementations, va_copy performs a shallow copy, so it's typically a fast operation."
},
{
  "function_name": "va_end",
  "include_file": "stdarg.h",
  "return_type": "void",
  "parameter_types": ["va_list"],
  "main_category": "Data Handling",
  "sub_category": "Variable Argument Lists",
  "data_type_manipulated": "variadic functions",
  "description": "Ends traversal of the variable arguments, allowing a va_list to be reused.",
  "extended_description": "va_end is a macro that facilitates a normal return from a function whose variable argument list was initialized by va_start or va_copy. It should be called on each va_list before the function returns or before calling va_start or va_copy again on the same va_list. After va_end is called, the va_list is undefined.",
  "return_value": "None (void function).",
  "parameter_values": "ap: The va_list to be ended.",
  "function_prototype": "void va_end(va_list ap);",
  "examples": [
      {
          "title": "Basic Usage in a Variadic Function",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nint sum(int count, ...) {\n    va_list args;\n    va_start(args, count);\n    \n    int total = 0;\n    for (int i = 0; i < count; i++) {\n        total += va_arg(args, int);\n    }\n    \n    va_end(args);\n    return total;\n}\n\nint main() {\n    int result = sum(4, 10, 20, 30, 40);\n    printf(\"Sum: %d\\n\", result);\n    return 0;\n}",
          "explanation": "This example demonstrates the proper use of va_end in a variadic function that calculates the sum of its arguments.",
          "expectedOutput": "Sum: 100"
      },
      {
          "title": "Multiple va_start and va_end Calls",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nvoid print_groups(int group_count, ...) {\n    va_list args;\n    \n    for (int i = 0; i < group_count; i++) {\n        va_start(args, group_count);\n        \n        // Skip to the i-th group\n        for (int j = 0; j < i; j++) {\n            int skip = va_arg(args, int);\n            for (int k = 0; k < skip; k++) {\n                va_arg(args, int);\n            }\n        }\n        \n        int count = va_arg(args, int);\n        printf(\"Group %d: \", i + 1);\n        for (int j = 0; j < count; j++) {\n            printf(\"%d \", va_arg(args, int));\n        }\n        printf(\"\\n\");\n        \n        va_end(args);\n    }\n}\n\nint main() {\n    print_groups(2, 3, 10, 20, 30, 2, 40, 50);\n    return 0;\n}",
          "explanation": "This example shows how to use va_start and va_end multiple times to process grouped arguments.",
          "expectedOutput": "Group 1: 10 20 30 \nGroup 2: 40 50 "
      },
      {
          "title": "Error Handling with va_end",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n\nvoid log_error(const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    fprintf(stderr, \"Error: \");\n    vfprintf(stderr, format, args);\n    fprintf(stderr, \"\\n\");\n    \n    va_end(args);\n    exit(1);\n}\n\nint divide(int a, int b) {\n    if (b == 0) {\n        log_error(\"Division by zero: %d / %d\", a, b);\n    }\n    return a / b;\n}\n\nint main() {\n    divide(10, 0);\n    return 0;\n}",
          "explanation": "This example demonstrates using va_end in an error logging function, ensuring proper cleanup before program termination.",
          "expectedOutput": "Error: Division by zero: 10 / 0\n[Program exits with status 1]"
      }
  ],
  "related_functions": ["va_start", "va_copy", "va_arg"],
  "performance_considerations": "va_end is typically a very lightweight operation. Its primary purpose is to clean up any resources associated with the va_list. Failing to call va_end can lead to undefined behavior and potential resource leaks, especially on some platforms where va_list might allocate memory."
},
{
  "function_name": "va_start",
  "include_file": "stdarg.h",
  "return_type": "void",
  "parameter_types": ["va_list", "param"],
  "main_category": "Data Handling",
  "sub_category": "Variable Argument Lists",
  "data_type_manipulated": "variadic functions",
  "description": "Initializes a va_list to retrieve the additional arguments passed to the function.",
  "extended_description": "va_start is a macro that initializes the va_list for subsequent use by va_arg and va_end. It must be called before any access to the unnamed arguments. The param argument is the name of the last named parameter in the function definition.",
  "return_value": "None (void function).",
  "parameter_values": "ap: The va_list to be initialized. param: The name of the last named parameter before the ellipsis in the function definition.",
  "function_prototype": "void va_start(va_list ap, param);",
  "examples": [
      {
          "title": "Basic Usage in a Variadic Function",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nvoid print_numbers(int count, ...) {\n    va_list args;\n    va_start(args, count);\n    \n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        printf(\"%d \", num);\n    }\n    printf(\"\\n\");\n    \n    va_end(args);\n}\n\nint main() {\n    print_numbers(4, 10, 20, 30, 40);\n    return 0;\n}",
          "explanation": "This example demonstrates how to use va_start to initialize a va_list in a function that prints a variable number of integers.",
          "expectedOutput": "10 20 30 40 "
      },
      {
          "title": "Variadic Function with Mixed Types",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nvoid print_formatted(const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    while (*format) {\n        if (*format == '%') {\n            format++;\n            switch (*format) {\n                case 'd':\n                    printf(\"%d\", va_arg(args, int));\n                    break;\n                case 'f':\n                    printf(\"%f\", va_arg(args, double));\n                    break;\n                case 's':\n                    printf(\"%s\", va_arg(args, char*));\n                    break;\n            }\n        } else {\n            putchar(*format);\n        }\n        format++;\n    }\n    printf(\"\\n\");\n    \n    va_end(args);\n}\n\nint main() {\n    print_formatted(\"Int: %d, Float: %f, String: %s\", 42, 3.14, \"Hello\");\n    return 0;\n}",
          "explanation": "This example shows how to use va_start in a function that handles multiple argument types based on a format string.",
          "expectedOutput": "Int: 42, Float: 3.140000, String: Hello"
      },
      {
          "title": "Error Logging with Variable Arguments",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n\nvoid log_error(const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    time_t now = time(NULL);\n    char timestamp[20];\n    strftime(timestamp, sizeof(timestamp), \"%Y-%m-%d %H:%M:%S\", localtime(&now));\n    \n    fprintf(stderr, \"[%s] ERROR: \", timestamp);\n    vfprintf(stderr, format, args);\n    fprintf(stderr, \"\\n\");\n    \n    va_end(args);\n}\n\nint main() {\n    int error_code = 404;\n    log_error(\"Failed to process request. Error code: %d\", error_code);\n    return 0;\n}",
          "explanation": "This example demonstrates using va_start in an error logging function that includes a timestamp and supports formatted error messages.",
          "expectedOutput": "[2023-07-07 15:30:45] ERROR: Failed to process request. Error code: 404"
      }
  ],
  "related_functions": ["va_end", "va_arg", "va_copy"],
  "performance_considerations": "va_start is generally efficient, but it's crucial to ensure that va_end is called before the function returns to avoid potential undefined behavior or resource leaks. The exact implementation of va_start can vary between platforms, which may affect performance in some cases."
},
{
  "function_name": "vfprintf",
  "include_file": "stdio.h",
  "return_type": "int",
  "parameter_types": ["FILE*", "const char*", "va_list"],
  "main_category": "File and I/O Operations",
  "sub_category": "Stream Manipulation",
  "data_type_manipulated": "file streams",
  "description": "Prints formatted output to the specified stream using a va_list.",
  "extended_description": "vfprintf is similar to fprintf, but instead of taking a variable number of arguments, it takes a va_list that has been initialized by va_start. This function is useful for implementing custom variadic functions that need to forward their arguments to fprintf.",
  "return_value": "Returns the number of characters written, or a negative value if an error occurred.",
  "parameter_values": "stream: Pointer to a FILE object that identifies the output stream. format: C string that contains the text to be written to the stream. arg: A va_list containing the arguments to be formatted.",
  "function_prototype": "int vfprintf(FILE *stream, const char *format, va_list arg);",
  "examples": [
      {
          "title": "Basic Usage of vfprintf",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nvoid log_message(FILE* stream, const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    vfprintf(stream, format, args);\n    va_end(args);\n}\n\nint main() {\n    FILE* log_file = fopen(\"log.txt\", \"w\");\n    if (log_file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    \n    log_message(log_file, \"Log entry: %s - %d\\n\", \"Test message\", 42);\n    log_message(stdout, \"Console message: %s\\n\", \"Hello, World!\");\n    \n    fclose(log_file);\n    return 0;\n}",
          "explanation": "This example demonstrates using vfprintf in a custom logging function that can write to different streams.",
          "expectedOutput": "Console message: Hello, World!\n[log.txt contains: Log entry: Test message - 42]"
      },
      {
          "title": "Error Handling with vfprintf",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n\nvoid error_exit(const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    fprintf(stderr, \"ERROR: \");\n    vfprintf(stderr, format, args);\n    fprintf(stderr, \"\\n\");\n    \n    va_end(args);\n    exit(1);\n}\n\nint main() {\n    FILE* file = fopen(\"nonexistent.txt\", \"r\");\n    if (file == NULL) {\n        error_exit(\"Could not open file: %s\", \"nonexistent.txt\");\n    }\n    \n    // This line is never reached\n    fclose(file);\n    return 0;\n}",
          "explanation": "This example uses vfprintf in an error handling function that prints to stderr and then exits the program.",
          "expectedOutput": "ERROR: Could not open file: nonexistent.txt\n[Program exits with status 1]"
      },
      {
          "title": "Implementing a Custom printf-like Function",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nint my_printf(const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    int result = vfprintf(stdout, format, args);\n    \n    va_end(args);\n    return result;\n}\n\nint main() {\n    int num = 42;\n    float pi = 3.14159f;\n    char* str = \"Hello\";\n    \n    my_printf(\"Number: %d, Pi: %.2f, String: %s\\n\", num, pi, str);\n    \n    return 0;\n}",
          "explanation": "This example implements a custom printf-like function using vfprintf, demonstrating how to create variadic wrapper functions.",
          "expectedOutput": "Number: 42, Pi: 3.14, String: Hello"
      }
  ],
  "related_functions": ["fprintf", "printf", "vsprintf"],
  "performance_considerations": "vfprintf is generally as efficient as fprintf for the same output. However, creating many small formatted strings might be less efficient than building a larger string and writing it once. For very frequent calls or performance-critical sections, consider using lower-level I/O functions or buffering techniques."
},
{
  "function_name": "vfscanf",
  "include_file": "stdio.h",
  "return_type": "int",
  "parameter_types": ["FILE*", "const char*", "va_list"],
  "main_category": "File and I/O Operations",
  "sub_category": "Stream Manipulation",
  "data_type_manipulated": "file streams",
  "description": "Reads formatted input from a stream using a va_list.",
  "extended_description": "vfscanf is similar to fscanf, but instead of taking a variable number of arguments, it takes a va_list that has been initialized by va_start. This function is useful for implementing custom variadic functions that need to forward their arguments to fscanf.",
  "return_value": "Returns the number of input items successfully matched and assigned, or EOF if an error occurred before any conversion.",
  "parameter_values": "stream: Pointer to a FILE object that identifies the input stream. format: C string that contains a format string. arg: A va_list containing the arguments where the scanned values are stored.",
  "function_prototype": "int vfscanf(FILE *stream, const char *format, va_list arg);",
  "examples": [
      {
          "title": "Basic Usage of vfscanf",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nint read_data(FILE* stream, const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    int result = vfscanf(stream, format, args);\n    va_end(args);\n    return result;\n}\n\nint main() {\n    FILE* file = fopen(\"data.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    \n    int num;\n    float fnum;\n    char str[20];\n    \n    int items_read = read_data(file, \"%d %f %s\", &num, &fnum, str);\n    \n    printf(\"Items read: %d\\n\", items_read);\n    printf(\"Number: %d, Float: %.2f, String: %s\\n\", num, fnum, str);\n    \n    fclose(file);\n    return 0;\n}",
          "explanation": "This example demonstrates using vfscanf in a custom function to read formatted data from a file.",
          "expectedOutput": "Items read: 3\nNumber: 42, Float: 3.14, String: Hello\n[Assuming data.txt contains: 42 3.14 Hello]"
      },
      {
          "title": "Reading Multiple Sets of Data",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nint read_multiple(FILE* stream, int count, const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    int total_read = 0;\n    for (int i = 0; i < count; i++) {\n        va_list args_copy;\n        va_copy(args_copy, args);\n        int read = vfscanf(stream, format, args_copy);\n        va_end(args_copy);\n        \n        if (read == EOF) break;\n        total_read += read;\n    }\n    \n    va_end(args);\n    return total_read;\n}\n\nint main() {\n    FILE* file = fopen(\"multi_data.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    \n    int num1, num2, num3;\n    int items_read = read_multiple(file, 3, \"%d\", &num1, &num2, &num3);\n    \n    printf(\"Items read: %d\\n\", items_read);\n    printf(\"Numbers: %d, %d, %d\\n\", num1, num2, num3);\n    \n    fclose(file);\n    return 0;\n}",
          "explanation": "This example uses vfscanf to read multiple sets of data from a file, demonstrating how to handle repeated format parsing.",
          "expectedOutput": "Items read: 3\nNumbers: 10, 20, 30\n[Assuming multi_data.txt contains: 10 20 30]"
      },
      {
          "title": "Error Handling with vfscanf",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <string.h>\n\nint safe_read(FILE* stream, const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    int result = vfscanf(stream, format, args);\n    \n    if (result == EOF) {\n        if (ferror(stream)) {\n            fprintf(stderr, \"Error reading from stream: %s\\n\", strerror(errno));\n        } else if (feof(stream)) {\n            fprintf(stderr, \"End of file reached\\n\");\n        }\n    } else if (result != 2) {  // Expecting 2 items\n        fprintf(stderr, \"Invalid input format\\n\");\n    }\n    \n    va_end(args);\n    return result;\n}\n\nint main() {\n    FILE* file = fopen(\"input.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    \n    int num;\n    float fnum;\n    \n    int items_read = safe_read(file, \"%d %f\", &num, &fnum);\n    \n    if (items_read == 2) {\n        printf(\"Read successfully: %d, %.2f\\n\", num, fnum);\n    }\n    \n    fclose(file);\n    return 0;\n}",
          "explanation": "This example demonstrates error handling when using vfscanf. It implements a safe_read function that uses vfscanf to read data and checks for various error conditions. It detects end-of-file, I/O errors, and format mismatches, providing appropriate error messages. This approach ensures robust input handling in situations where the input might be malformed or incomplete.",
          "expectedOutput": "Read successfully: 42, 3.14\n[If input.txt contains valid data]\nOR\nInvalid input format\n[If input.txt contains malformed data]\nOR\nEnd of file reached\n[If input.txt is empty]\nOR\nError reading from stream: [error message]\n[If there's an I/O error]"
      }
  ],
  "related_functions": ["fscanf", "vscanf", "vsscanf"],
  "performance_considerations": "vfscanf is generally as efficient as fscanf for the same input. However, parsing complex format strings or reading large amounts of data might impact performance. For performance-critical applications, consider using lower-level I/O functions or custom parsing techniques if needed."
},
{
  "function_name": "vfwprintf",
  "include_file": "wchar.h",
  "return_type": "int",
  "parameter_types": ["FILE*", "const wchar_t*", "va_list"],
  "main_category": "File and I/O Operations",
  "sub_category": "Wide Character Support",
  "data_type_manipulated": "file streams",
  "description": "Writes formatted wide character output to the specified stream using a va_list.",
  "extended_description": "vfwprintf is similar to fwprintf, but instead of taking a variable number of arguments, it takes a va_list that has been initialized by va_start. This function is useful for implementing custom variadic functions that need to forward their arguments to fwprintf for wide character output.",
  "return_value": "Returns the number of wide characters written, or a negative value if an error occurred.",
  "parameter_values": "stream: Pointer to a FILE object that identifies the output stream. format: Wide string that contains the text to be written to the stream. arg: A va_list containing the arguments to be formatted.",
  "function_prototype": "int vfwprintf(FILE *stream, const wchar_t *format, va_list arg);",
  "examples": [
      {
          "title": "Basic Usage of vfwprintf",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <stdarg.h>\n#include <locale.h>\n\nvoid log_message(FILE* stream, const wchar_t* format, ...) {\n    va_list args;\n    va_start(args, format);\n    vfwprintf(stream, format, args);\n    va_end(args);\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    FILE* log_file = fopen(\"log.txt\", \"w\");\n    if (log_file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    \n    log_message(log_file, L\"Log entry: %ls - %d\\n\", L\"Test message\", 42);\n    log_message(stdout, L\"Console message: %ls\\n\", L\"Hello, World!\");\n    \n    fclose(log_file);\n    return 0;\n}\n",
          "explanation": "This example demonstrates using vfwprintf in a custom logging function that can write wide character strings to different streams.",
          "expectedOutput": "Console message: Hello, World!\n[log.txt contains: Log entry: Test message - 42]"
      },
      {
          "title": "Formatting Wide Characters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <stdarg.h>\n#include <locale.h>\n\nvoid print_formatted(const wchar_t* format, ...) {\n    va_list args;\n    va_start(args, format);\n    vfwprintf(stdout, format, args);\n    va_end(args);\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t wide_char = L'\\u03A9';  // Greek capital letter Omega\n    wchar_t* wide_string = L\"\\u03B1\\u03B2\\u03B3\";  // Greek letters alpha, beta, gamma\n    \n    print_formatted(L\"Wide character: %lc\\n\", wide_char);\n    print_formatted(L\"Wide string: %ls\\n\", wide_string);\n    print_formatted(L\"Formatted number: %'d\\n\", 1000000);\n    \n    return 0;\n}\n",
          "explanation": "This example shows how to use vfwprintf to format and print wide characters, wide strings, and numbers with locale-specific formatting.",
          "expectedOutput": "Wide character: Ω\nWide string: αβγ\nFormatted number: 1,000,000"
      },
      {
          "title": "Error Handling with vfwprintf",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <errno.h>\n\nint safe_write(FILE* stream, const wchar_t* format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    int result = vfwprintf(stream, format, args);\n    \n    if (result < 0) {\n        fwprintf(stderr, L\"Error writing to stream: %s\\n\", strerror(errno));\n    }\n    \n    va_end(args);\n    return result;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    FILE* file = fopen(\"output.txt\", \"w\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    \n    safe_write(file, L\"Test message: %ls %d\\n\", L\"Hello\", 42);\n    safe_write(stdout, L\"Console output: %ls\\n\", L\"This is a test\");\n    \n    fclose(file);\n    return 0;\n}\n",
          "explanation": "This example demonstrates error handling when using vfwprintf. It implements a safe_write function that checks for errors and reports them using wide character output.",
          "expectedOutput": "Console output: This is a test\n[output.txt contains: Test message: Hello 42]"
      }
  ],
  "related_functions": ["fwprintf", "wprintf", "vswprintf"],
  "performance_considerations": "vfwprintf is generally as efficient as fwprintf for the same output. However, formatting wide characters and strings may have additional overhead compared to their narrow character counterparts. For very frequent calls or performance-critical sections, consider using lower-level wide character I/O functions or buffering techniques."
},
{
  "function_name": "vfwscanf",
  "include_file": "wchar.h",
  "return_type": "int",
  "parameter_types": ["FILE*", "const wchar_t*", "va_list"],
  "main_category": "File and I/O Operations",
  "sub_category": "Wide Character Support",
  "data_type_manipulated": "file streams",
  "description": "Reads formatted wide character input from a stream using a va_list.",
  "extended_description": "vfwscanf is similar to fwscanf, but instead of taking a variable number of arguments, it takes a va_list that has been initialized by va_start. This function is useful for implementing custom variadic functions that need to forward their arguments to fwscanf for wide character input parsing.",
  "return_value": "Returns the number of input items successfully matched and assigned, or EOF if an error occurred before any conversion.",
  "parameter_values": "stream: Pointer to a FILE object that identifies the input stream. format: Wide string that contains a format string. arg: A va_list containing the arguments where the scanned values are stored.",
  "function_prototype": "int vfwscanf(FILE *stream, const wchar_t *format, va_list arg);",
  "examples": [
      {
          "title": "Basic Usage of vfwscanf",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <stdarg.h>\n#include <locale.h>\n\nint read_data(FILE* stream, const wchar_t* format, ...) {\n    va_list args;\n    va_start(args, format);\n    int result = vfwscanf(stream, format, args);\n    va_end(args);\n    return result;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    FILE* file = fopen(\"data.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    \n    int num;\n    float fnum;\n    wchar_t str[20];\n    \n    int items_read = read_data(file, L\"%d %f %ls\", &num, &fnum, str);\n    \n    wprintf(L\"Items read: %d\\n\", items_read);\n    wprintf(L\"Number: %d, Float: %.2f, String: %ls\\n\", num, fnum, str);\n    \n    fclose(file);\n    return 0;\n}\n",
          "explanation": "This example demonstrates using vfwscanf in a custom function to read formatted wide character data from a file.",
          "expectedOutput": "Items read: 3\nNumber: 42, Float: 3.14, String: Hello\n[Assuming data.txt contains: 42 3.14 Hello]"
      },
      {
          "title": "Reading Wide Characters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <stdarg.h>\n#include <locale.h>\n\nint read_wide_chars(FILE* stream, const wchar_t* format, ...) {\n    va_list args;\n    va_start(args, format);\n    int result = vfwscanf(stream, format, args);\n    va_end(args);\n    return result;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    FILE* file = fopen(\"wide_data.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    \n    wchar_t ch1, ch2, ch3;\n    wchar_t str[20];\n    \n    int items_read = read_wide_chars(file, L\"%lc %lc %lc %ls\", &ch1, &ch2, &ch3, str);\n    \n    wprintf(L\"Items read: %d\\n\", items_read);\n    wprintf(L\"Characters: %lc %lc %lc\\n\", ch1, ch2, ch3);\n    wprintf(L\"String: %ls\\n\", str);\n    \n    fclose(file);\n    return 0;\n}\n",
          "explanation": "This example shows how to use vfwscanf to read individual wide characters and wide character strings from a file.",
          "expectedOutput": "Items read: 4\nCharacters: α β γ\nString: Hello\n[Assuming wide_data.txt contains: α β γ Hello]"
      },
      {
          "title": "Error Handling with vfwscanf",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <stdarg.h>\n#include <locale.h>\n#include <errno.h>\n\nint safe_read(FILE* stream, const wchar_t* format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    int result = vfwscanf(stream, format, args);\n    \n    if (result == EOF) {\n        if (ferror(stream)) {\n            fwprintf(stderr, L\"Error reading from stream: %s\\n\", strerror(errno));\n        } else if (feof(stream)) {\n            fwprintf(stderr, L\"End of file reached\\n\");\n        }\n    } else if (result != 2) {  // Expecting 2 items\n        fwprintf(stderr, L\"Invalid input format\\n\");\n    }\n    \n    va_end(args);\n    return result;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    FILE* file = fopen(\"input.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"Error opening file\");\n        return 1;\n    }\n    \n    int num;\n    float fnum;\n    \n    int items_read = safe_read(file, L\"%d %f\", &num, &fnum);\n    \n    if (items_read == 2) {\n        wprintf(L\"Read successfully: %d, %.2f\\n\", num, fnum);\n    }\n    \n    fclose(file);\n    return 0;\n}\n",
          "explanation": "This example demonstrates error handling when using vfwscanf. It implements a safe_read function that checks for various error conditions and reports them using wide character output.",
          "expectedOutput": "Read successfully: 42, 3.14\n[If input.txt contains valid data]\nOR\nInvalid input format\n[If input.txt contains malformed data]\nOR\nEnd of file reached\n[If input.txt is empty]\nOR\nError reading from stream: [error message]\n[If there's an I/O error]"
      }
  ],
  "related_functions": ["fwscanf", "wscanf", "vswscanf"],
  "performance_considerations": "vfwscanf is generally as efficient as fwscanf for the same input. However, parsing wide character input may have additional overhead compared to narrow character input. For performance-critical applications, consider using lower-level wide character I/O functions or custom parsing techniques if needed."
},
{
  "function_name": "vprintf",
  "include_file": "stdio.h",
  "return_type": "int",
  "parameter_types": ["const char*", "va_list"],
  "main_category": "File and I/O Operations",
  "sub_category": "Standard Output",
  "data_type_manipulated": "standard output",
  "description": "Prints formatted output to the standard output using a va_list.",
  "extended_description": "vprintf is similar to printf, but instead of taking a variable number of arguments, it takes a va_list that has been initialized by va_start. This function is useful for implementing custom variadic functions that need to forward their arguments to printf for output.",
  "return_value": "Returns the number of characters written, or a negative value if an error occurred.",
  "parameter_values": "format: C string that contains the text to be written to stdout. arg: A va_list containing the arguments to be formatted.",
  "function_prototype": "int vprintf(const char *format, va_list arg);",
  "examples": [
      {
          "title": "Basic Usage of vprintf",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nvoid log_message(const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    vprintf(format, args);\n    va_end(args);\n}\n\nint main() {\n    int num = 42;\n    double pi = 3.14159;\n    char* str = \"Hello, World!\";\n    \n    log_message(\"Number: %d\\n\", num);\n    log_message(\"Pi: %.2f\\n\", pi);\n    log_message(\"String: %s\\n\", str);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates using vprintf in a custom logging function that can handle various types of arguments.",
          "expectedOutput": "Number: 42\nPi: 3.14\nString: Hello, World!"
      },
      {
          "title": "Implementing a Simple Debugging Function",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdbool.h>\n\nbool debug_mode = false;\n\nvoid debug_print(const char* format, ...) {\n    if (!debug_mode) return;\n    \n    va_list args;\n    va_start(args, format);\n    printf(\"[DEBUG] \");\n    vprintf(format, args);\n    va_end(args);\n}\n\nint main() {\n    debug_mode = true;\n    int x = 10, y = 20;\n    \n    debug_print(\"x = %d, y = %d\\n\", x, y);\n    debug_print(\"Sum: %d\\n\", x + y);\n    \n    debug_mode = false;\n    debug_print(\"This won't be printed\\n\");\n    \n    return 0;\n}\n",
          "explanation": "This example uses vprintf to implement a simple debugging function that only prints when debug mode is enabled.",
          "expectedOutput": "[DEBUG] x = 10, y = 20\n[DEBUG] Sum: 30"
      },
      {
          "title": "Formatting with Field Width and Precision",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nvoid print_formatted(const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    vprintf(format, args);\n    va_end(args);\n}\n\nint main() {\n    int num = 42;\n    double pi = 3.14159;\n    char* str = \"Hello\";\n    \n    print_formatted(\"%-10d|%10d|%+10d\\n\", num, num, num);\n    print_formatted(\"%10.2f|%-10.2f|%+10.2f\\n\", pi, pi, pi);\n    print_formatted(\"%10s|%-10s|%.3s\\n\", str, str, str);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates using vprintf with various formatting options, including field width, precision, and alignment.",
          "expectedOutput": "42        |        42|       +42\n      3.14|3.14      |     +3.14\n     Hello|Hello     |Hel"
      }
  ],
  "related_functions": ["printf", "fprintf", "sprintf"],
  "performance_considerations": "vprintf is generally as efficient as printf for the same output. However, for very frequent calls or performance-critical sections, consider using lower-level I/O functions or buffering techniques if needed."
},
{
  "function_name": "vscanf",
  "include_file": "stdio.h",
  "return_type": "int",
  "parameter_types": ["const char*", "va_list"],
  "main_category": "File and I/O Operations",
  "sub_category": "Standard Input",
  "data_type_manipulated": "standard input",
  "description": "Reads formatted input from the standard input using a va_list.",
  "extended_description": "vscanf is similar to scanf, but instead of taking a variable number of arguments, it takes a va_list that has been initialized by va_start. This function is useful for implementing custom variadic functions that need to forward their arguments to scanf for input parsing.",
  "return_value": "Returns the number of input items successfully matched and assigned, or EOF if an error occurred before any conversion.",
  "parameter_values": "format: C string that contains a format string. arg: A va_list containing the arguments where the scanned values are stored.",
  "function_prototype": "int vscanf(const char *format, va_list arg);",
  "examples": [
      {
          "title": "Basic Usage of vscanf",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nint read_input(const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    int result = vscanf(format, args);\n    va_end(args);\n    return result;\n}\n\nint main() {\n    int num;\n    float fnum;\n    char str[20];\n    \n    printf(\"Enter an integer, a float, and a string: \");\n    int items_read = read_input(\"%d %f %s\", &num, &fnum, str);\n    \n    printf(\"Items read: %d\\n\", items_read);\n    printf(\"Number: %d, Float: %.2f, String: %s\\n\", num, fnum, str);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates using vscanf in a custom function to read formatted input from the standard input.",
          "expectedOutput": "Enter an integer, a float, and a string: 42 3.14 Hello\nItems read: 3\nNumber: 42, Float: 3.14, String: Hello"
      },
      {
          "title": "Reading Multiple Sets of Data",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nint read_multiple(int count, const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    int total_read = 0;\n    for (int i = 0; i < count; i++) {\n        va_list args_copy;\n        va_copy(args_copy, args);\n        int read = vscanf(format, args_copy);\n        va_end(args_copy);\n        \n        if (read == EOF) break;\n        total_read += read;\n    }\n    \n    va_end(args);\n    return total_read;\n}\n\nint main() {\n    int num1, num2, num3;\n    \n    printf(\"Enter three integers: \");\n    int items_read = read_multiple(3, \"%d\", &num1, &num2, &num3);\n    \n    printf(\"Items read: %d\\n\", items_read);\n    printf(\"Numbers: %d, %d, %d\\n\", num1, num2, num3);\n    \n    return 0;\n}\n",
          "explanation": "This example uses vscanf to read multiple sets of data from the standard input, demonstrating how to handle repeated format parsing.",
          "expectedOutput": "Enter three integers: 10 20 30\nItems read: 3\nNumbers: 10, 20, 30"
      },
      {
          "title": "Error Handling with vscanf",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <string.h>\n\nint safe_read(const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    int result = vscanf(format, args);\n    \n    if (result == EOF) {\n        if (ferror(stdin)) {\n            fprintf(stderr, \"Error reading from stdin: %s\\n\", strerror(errno));\n        } else if (feof(stdin)) {\n            fprintf(stderr, \"End of input reached\\n\");\n        }\n    } else if (result != 2) {  // Expecting 2 items\n        fprintf(stderr, \"Invalid input format\\n\");\n    }\n    \n    va_end(args);\n    return result;\n}\n\nint main() {\n    int num;\n    float fnum;\n    \n    printf(\"Enter an integer and a float: \");\n    int items_read = safe_read(\"%d %f\", &num, &fnum);\n    \n    if (items_read == 2) {\n        printf(\"Read successfully: %d, %.2f\\n\", num, fnum);\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates error handling when using vscanf. It implements a safe_read function that checks for various error conditions and reports them.",
          "expectedOutput": "Enter an integer and a float: 42 3.14\nRead successfully: 42, 3.14\nOR\nInvalid input format\n[If input is malformed]\nOR\nEnd of input reached\n[If input is empty]\nOR\nError reading from stdin: [error message]\n[If there's an I/O error]"
      }
  ],
  "related_functions": ["scanf", "fscanf", "sscanf"],
  "performance_considerations": "vscanf is generally as efficient as scanf for the same input. However, for performance-critical applications, consider using lower-level I/O functions or custom parsing techniques if needed. Be aware that vscanf can be vulnerable to buffer overflows if not used carefully with proper input validation."
},
{
  "function_name": "vsprintf",
  "include_file": "stdio.h",
  "return_type": "int",
  "parameter_types": ["char*", "const char*", "va_list"],
  "main_category": "File and I/O Operations",
  "sub_category": "Stream Manipulation",
  "data_type_manipulated": "strings",
  "description": "Writes formatted output to a string using a va_list.",
  "extended_description": "vsprintf is similar to sprintf, but instead of taking a variable number of arguments, it takes a va_list that has been initialized by va_start. This function writes the formatted data to the character string str. The resulting string is always null-terminated.",
  "return_value": "Returns the number of characters written, not including the terminating null character. If an error occurs, a negative number is returned.",
  "parameter_values": "str: Pointer to a buffer where the resulting C-string is stored. format: C string that contains a format string. arg: A va_list object containing the arguments for the format string.",
  "function_prototype": "int vsprintf(char *str, const char *format, va_list arg);",
  "examples": [
      {
          "title": "Basic Usage of vsprintf",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nvoid format_string(char* buffer, const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    vsprintf(buffer, format, args);\n    va_end(args);\n}\n\nint main() {\n    char buffer[100];\n    int num = 42;\n    float pi = 3.14159f;\n    char* name = \"John\";\n    \n    format_string(buffer, \"Number: %d, Pi: %.2f, Name: %s\", num, pi, name);\n    \n    printf(\"Formatted string: %s\\n\", buffer);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates using vsprintf in a custom function to format a string with various types of arguments.",
          "expectedOutput": "Formatted string: Number: 42, Pi: 3.14, Name: John"
      },
      {
          "title": "Building a Custom Error Message",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n\nvoid build_error_message(char* buffer, const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    strcpy(buffer, \"ERROR: \");\n    vsprintf(buffer + strlen(buffer), format, args);\n    \n    va_end(args);\n}\n\nint main() {\n    char error_buffer[100];\n    int error_code = 404;\n    char* file_name = \"example.txt\";\n    \n    build_error_message(error_buffer, \"File '%s' not found (Error %d)\", file_name, error_code);\n    \n    printf(\"%s\\n\", error_buffer);\n    \n    return 0;\n}\n",
          "explanation": "This example uses vsprintf to build a custom error message by concatenating a prefix with a formatted string.",
          "expectedOutput": "ERROR: File 'example.txt' not found (Error 404)"
      },
      {
          "title": "Formatting with Field Width and Precision",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nvoid format_table_row(char* buffer, const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    vsprintf(buffer, format, args);\n    va_end(args);\n}\n\nint main() {\n    char buffer[100];\n    int id = 1;\n    char* name = \"Alice\";\n    float score = 95.5f;\n    \n    format_table_row(buffer, \"|%3d|%-10s|%6.2f|\", id, name, score);\n    printf(\"Table row: %s\\n\", buffer);\n    \n    id = 2;\n    name = \"Bob\";\n    score = 87.25f;\n    \n    format_table_row(buffer, \"|%3d|%-10s|%6.2f|\", id, name, score);\n    printf(\"Table row: %s\\n\", buffer);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates using vsprintf with field width and precision specifiers to format a table-like output.",
          "expectedOutput": "Table row: |  1|Alice     | 95.50|\nTable row: |  2|Bob       | 87.25|"
      }
  ],
  "related_functions": ["sprintf", "snprintf", "vsnprintf"],
  "performance_considerations": "vsprintf does not perform bounds checking, which can lead to buffer overflows if the resulting string is longer than the provided buffer. For safer string formatting, consider using vsnprintf instead."
},
{
  "function_name": "vsnprintf",
  "include_file": "stdio.h",
  "return_type": "int",
  "parameter_types": ["char*", "size_t", "const char*", "va_list"],
  "main_category": "File and I/O Operations",
  "sub_category": "Stream Manipulation",
  "data_type_manipulated": "strings",
  "description": "Writes formatted output to a string with size limitation using a va_list.",
  "extended_description": "vsnprintf is similar to snprintf, but instead of taking a variable number of arguments, it takes a va_list that has been initialized by va_start. This function writes at most size - 1 characters to the output string, ensuring it's always null-terminated. It's a safer alternative to vsprintf as it prevents buffer overflows.",
  "return_value": "Returns the number of characters that would have been written if size had been sufficiently large, not counting the terminating null character. If an encoding error occurs, a negative number is returned.",
  "parameter_values": "str: Pointer to a buffer where the resulting C-string is stored. size: Maximum number of bytes to be used in the buffer. format: C string that contains a format string. arg: A va_list object containing the arguments for the format string.",
  "function_prototype": "int vsnprintf(char *str, size_t size, const char *format, va_list arg);",
  "examples": [
      {
          "title": "Basic Usage of vsnprintf",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nvoid safe_format_string(char* buffer, size_t size, const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    vsnprintf(buffer, size, format, args);\n    va_end(args);\n}\n\nint main() {\n    char buffer[20];  // Intentionally small buffer\n    int num = 42;\n    float pi = 3.14159f;\n    char* name = \"John Doe\";\n    \n    safe_format_string(buffer, sizeof(buffer), \"Num: %d, Pi: %.2f, Name: %s\", num, pi, name);\n    \n    printf(\"Formatted string: %s\\n\", buffer);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates using vsnprintf in a custom function to safely format a string with various types of arguments, even when the buffer is too small to hold the entire formatted string.",
          "expectedOutput": "Formatted string: Num: 42, Pi: 3.14, N"
      },
      {
          "title": "Handling Truncation",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n\nint format_message(char* buffer, size_t size, const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    int result = vsnprintf(buffer, size, format, args);\n    va_end(args);\n    return result;\n}\n\nint main() {\n    char buffer[20];\n    const char* long_text = \"This is a very long string that will be truncated\";\n    \n    int chars_needed = format_message(buffer, sizeof(buffer), \"Message: %s\", long_text);\n    \n    printf(\"Buffer content: %s\\n\", buffer);\n    printf(\"Characters needed: %d\\n\", chars_needed);\n    printf(\"Truncated: %s\\n\", chars_needed >= sizeof(buffer) ? \"Yes\" : \"No\");\n    \n    return 0;\n}\n",
          "explanation": "This example shows how to use vsnprintf to handle potential truncation, by checking the return value against the buffer size.",
          "expectedOutput": "Buffer content: Message: This is a\nCharacters needed: 54\nTruncated: Yes"
      },
      {
          "title": "Dynamic Buffer Allocation",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n\nchar* dynamic_format(const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    // Determine required buffer size\n    va_list args_copy;\n    va_copy(args_copy, args);\n    int size = vsnprintf(NULL, 0, format, args_copy) + 1;  // +1 for null terminator\n    va_end(args_copy);\n    \n    // Allocate buffer\n    char* buffer = (char*)malloc(size);\n    if (buffer == NULL) {\n        va_end(args);\n        return NULL;\n    }\n    \n    // Format string\n    vsnprintf(buffer, size, format, args);\n    va_end(args);\n    \n    return buffer;\n}\n\nint main() {\n    int num = 42;\n    float pi = 3.14159f;\n    char* name = \"Alice\";\n    \n    char* formatted = dynamic_format(\"Number: %d, Pi: %.2f, Name: %s\", num, pi, name);\n    if (formatted) {\n        printf(\"Formatted string: %s\\n\", formatted);\n        free(formatted);\n    } else {\n        printf(\"Memory allocation failed\\n\");\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example uses vsnprintf to determine the required buffer size, then allocates memory dynamically to store the full formatted string.",
          "expectedOutput": "Formatted string: Number: 42, Pi: 3.14, Name: Alice"
      }
  ],
  "related_functions": ["snprintf", "sprintf", "vsprintf"],
  "performance_considerations": "vsnprintf is generally safer than vsprintf as it prevents buffer overflows. However, it may be slightly slower due to the additional size checking. For performance-critical applications, consider using static buffers of sufficient size or custom string handling routines if appropriate."
},
{
  "function_name": "vsscanf",
  "include_file": "stdio.h",
  "return_type": "int",
  "parameter_types": ["const char*", "const char*", "va_list"],
  "main_category": "File and I/O Operations",
  "sub_category": "Stream Manipulation",
  "data_type_manipulated": "strings",
  "description": "Reads formatted data from a string using a va_list.",
  "extended_description": "vsscanf is similar to sscanf, but instead of taking a variable number of arguments, it takes a va_list that has been initialized by va_start. This function reads formatted data from a string and stores the results in the locations pointed to by the elements in the va_list.",
  "return_value": "Returns the number of input items successfully matched and assigned. Returns EOF if an error occurred before any conversion.",
  "parameter_values": "str: C string that the function processes as its source to retrieve the data. format: C string containing a format string. arg: A va_list object containing pointers to store the retrieved values.",
  "function_prototype": "int vsscanf(const char *str, const char *format, va_list arg);",
  "examples": [
      {
          "title": "Basic Usage of vsscanf",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nint parse_string(const char* input, const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    int result = vsscanf(input, format, args);\n    va_end(args);\n    return result;\n}\n\nint main() {\n    const char* input = \"42 3.14 Hello\";\n    int num;\n    float fnum;\n    char str[20];\n    \n    int items_read = parse_string(input, \"%d %f %s\", &num, &fnum, str);\n    \n    printf(\"Items read: %d\\n\", items_read);\n    printf(\"Number: %d, Float: %.2f, String: %s\\n\", num, fnum, str);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates using vsscanf in a custom function to parse a string containing different types of data.",
          "expectedOutput": "Items read: 3\nNumber: 42, Float: 3.14, String: Hello"
      },
      {
          "title": "Parsing Comma-Separated Values",
          "code": "#include <stdio.h>\n#include <stdarg.h>\n\nint parse_csv_line(const char* line, const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    int result = vsscanf(line, format, args);\n    va_end(args);\n    return result;\n}\n\nint main() {\n    const char* csv_line = \"John,30,Software Engineer,75000.50\";\n    char name[50];\n    int age;\n    char job[50];\n    float salary;\n    \n    int items_read = parse_csv_line(csv_line, \"%[^,],%d,%[^,],%f\", name, &age, job, &salary);\n    \n    printf(\"Items read: %d\\n\", items_read);\n    printf(\"Name: %s\\nAge: %d\\nJob: %s\\nSalary: %.2f\\n\", name, age, job, salary);\n    \n    return 0;\n}\n",
          "explanation": "This example uses vsscanf to parse a comma-separated value (CSV) string, demonstrating more complex format specifiers.",
          "expectedOutput": "Items read: 4\nName: John\nAge: 30\nJob: Software Engineer\nSalary: 75000.50"
      },
      {
        "title": "Parsing with Error Handling",
        "code": "#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n\nint safe_parse(const char* input, const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    int result = vsscanf(input, format, args);\n    \n    if (result == EOF) {\n        printf(\"Error: parsing failed\\n\");\n    } else if (result == 0) {\n        printf(\"Error: no items matched\\n\");\n    } else if (result < strlen(format) - strlen(strpbrk(format, \"%\"))) {\n        printf(\"Warning: some items were not matched\\n\");\n    }\n    \n    va_end(args);\n    return result;\n}\n\nint main() {\n    int num1, num2;\n    \n    safe_parse(\"42 abc\", \"%d %d\", &num1, &num2);\n    printf(\"num1: %d\\n\", num1);\n    \n    safe_parse(\"not a number\", \"%d\", &num1);\n    \n    safe_parse(\"123 456 789\", \"%d %d\", &num1, &num2);\n    printf(\"num1: %d, num2: %d\\n\", num1, num2);\n    \n    return 0;\n}\n",
        "explanation": "This example implements a safe_parse function using vsscanf that includes error handling for various parsing scenarios.",
        "expectedOutput": "Warning: some items were not matched\nnum1: 42\nError: no items matched\nnum1: 42, num2: 456"
    }
  ],
  "related_functions": ["sscanf", "fscanf", "vscanf"],
  "performance_considerations": "vsscanf is generally efficient for parsing strings. However, for very large strings or complex parsing tasks, consider using more specialized parsing libraries or custom parsing functions for better performance and flexibility."
},
{
  "function_name": "vswprintf",
  "include_file": "wchar.h",
  "return_type": "int",
  "parameter_types": ["wchar_t*", "size_t", "const wchar_t*", "va_list"],
  "main_category": "File and I/O Operations",
  "sub_category": "Wide Character Support",
  "data_type_manipulated": "wide characters",
  "description": "Writes formatted wide character output to a string with size limitation using a va_list.",
  "extended_description": "vswprintf is similar to swprintf, but instead of taking a variable number of arguments, it takes a va_list that has been initialized by va_start. This function writes at most size - 1 wide characters to the output string, ensuring it's always null-terminated. It's used for formatting wide character strings with the added safety of buffer overflow prevention.",
  "return_value": "Returns the number of wide characters written, not including the terminating null wide character. If an encoding error occurs or if the number of wide characters to be written would exceed size, a negative number is returned.",
  "parameter_values": "wcs: Pointer to a buffer where the resulting wide string is stored. size: Maximum number of wide characters to be written. format: Wide string that contains a format string. arg: A va_list object containing the arguments for the format string.",
  "function_prototype": "int vswprintf(wchar_t *wcs, size_t size, const wchar_t *format, va_list arg);",
  "examples": [
      {
          "title": "Basic Usage of vswprintf",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <stdarg.h>\n#include <locale.h>\n\nvoid format_wide_string(wchar_t* buffer, size_t size, const wchar_t* format, ...) {\n    va_list args;\n    va_start(args, format);\n    vswprintf(buffer, size, format, args);\n    va_end(args);\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t buffer[50];\n    int num = 42;\n    double pi = 3.14159;\n    wchar_t* name = L\"John\";\n    \n    format_wide_string(buffer, sizeof(buffer) / sizeof(wchar_t),\n                       L\"Number: %d, Pi: %.2f, Name: %ls\", num, pi, name);\n    \n    wprintf(L\"Formatted string: %ls\\n\", buffer);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates using vswprintf in a custom function to format a wide character string with various types of arguments.",
          "expectedOutput": "Formatted string: Number: 42, Pi: 3.14, Name: John"
      },
      {
          "title": "Handling Unicode Characters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <stdarg.h>\n#include <locale.h>\n\nvoid format_unicode(wchar_t* buffer, size_t size, const wchar_t* format, ...) {\n    va_list args;\n    va_start(args, format);\n    vswprintf(buffer, size, format, args);\n    va_end(args);\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t buffer[50];\n    wchar_t* emoji = L\"\\U0001F600\";  // Grinning face emoji\n    wchar_t* greek = L\"\\u03A9\";     // Greek capital letter Omega\n    \n    format_unicode(buffer, sizeof(buffer) / sizeof(wchar_t),\n                   L\"Emoji: %ls, Greek: %ls\", emoji, greek);\n    \n    wprintf(L\"Formatted string: %ls\\n\", buffer);\n    \n    return 0;\n}\n",
          "explanation": "This example shows how to use vswprintf to format a string containing Unicode characters, including emoji and non-Latin scripts.",
          "expectedOutput": "Formatted string: Emoji: 😀, Greek: Ω"
      },
      {
        "title": "Truncation Handling",
        "code": "#include <stdio.h>\n#include <wchar.h>\n#include <stdarg.h>\n#include <locale.h>\n\nint safe_wide_format(wchar_t* buffer, size_t size, const wchar_t* format, ...) {\n    va_list args;\n    va_start(args, format);\n    int result = vswprintf(buffer, size, format, args);\n    va_end(args);\n    \n    if (result >= 0 && (size_t)result < size) {\n        return result;\n    } else if (size > 0) {\n        buffer[size - 1] = L'\\0';  // Ensure null-termination\n        return -1;  // Indicate truncation\n    } else {\n        return -1;  // Error or zero-size buffer\n    }\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t short_buffer[10];\n    wchar_t long_buffer[50];\n    const wchar_t* long_text = L\"This is a very long string that will be truncated\";\n    \n    int result1 = safe_wide_format(short_buffer, sizeof(short_buffer) / sizeof(wchar_t),\n                                   L\"%ls\", long_text);\n    int result2 = safe_wide_format(long_buffer, sizeof(long_buffer) / sizeof(wchar_t),\n                                   L\"%ls\", long_text);\n    \n    wprintf(L\"Short buffer (truncated): %ls\\n\", short_buffer);\n    wprintf(L\"Short buffer result: %d\\n\", result1);\n    wprintf(L\"Long buffer: %ls\\n\", long_buffer);\n    wprintf(L\"Long buffer result: %d\\n\", result2);\n    \n    return 0;\n}\n",
        "explanation": "This example demonstrates how to handle potential truncation when using vswprintf, ensuring the output is always null-terminated and checking the return value for truncation or errors.",
        "expectedOutput": "Short buffer (truncated): This is a\nShort buffer result: -1\nLong buffer: This is a very long string that will be truncated\nLong buffer result: 48"
    }
  ],
  "related_functions": ["swprintf", "vwprintf", "vfwprintf"],
  "performance_considerations": "vswprintf is generally efficient for formatting wide character strings. However, for very frequent calls or when formatting large amounts of data, consider using a custom formatting solution or a more specialized library. Be aware that handling wide characters and Unicode may have additional performance overhead compared to narrow character operations."
},
{
  "function_name": "vswscanf",
  "include_file": "wchar.h",
  "return_type": "int",
  "parameter_types": ["const wchar_t*", "const wchar_t*", "va_list"],
  "main_category": "File and I/O Operations",
  "sub_category": "Wide Character Support",
  "data_type_manipulated": "wide characters",
  "description": "Reads formatted wide character input from a string using a va_list.",
  "extended_description": "vswscanf is similar to swscanf, but instead of taking a variable number of arguments, it takes a va_list that has been initialized by va_start. This function reads formatted wide character data from a wide string and stores the results in the locations pointed to by the elements in the va_list.",
  "return_value": "Returns the number of input items successfully matched and assigned. Returns EOF if an error occurred before any conversion.",
  "parameter_values": "ws: Wide string that the function processes as its source to retrieve the data. format: Wide string containing a format string. arg: A va_list object containing pointers to store the retrieved values.",
  "function_prototype": "int vswscanf(const wchar_t *ws, const wchar_t *format, va_list arg);",
  "examples": [
      {
          "title": "Basic Usage of vswscanf",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <stdarg.h>\n#include <locale.h>\n\nint parse_wide_string(const wchar_t* input, const wchar_t* format, ...) {\n    va_list args;\n    va_start(args, format);\n    int result = vswscanf(input, format, args);\n    va_end(args);\n    return result;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t* input = L\"42 3.14 Hello\";\n    int num;\n    float fnum;\n    wchar_t str[20];\n    \n    int items_read = parse_wide_string(input, L\"%d %f %ls\", &num, &fnum, str);\n    \n    wprintf(L\"Items read: %d\\n\", items_read);\n    wprintf(L\"Number: %d, Float: %.2f, String: %ls\\n\", num, fnum, str);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates using vswscanf in a custom function to parse a wide string containing different types of data.",
          "expectedOutput": "Items read: 3\nNumber: 42, Float: 3.14, String: Hello"
      },
      {
          "title": "Parsing Unicode Characters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <stdarg.h>\n#include <locale.h>\n\nint parse_unicode(const wchar_t* input, const wchar_t* format, ...) {\n    va_list args;\n    va_start(args, format);\n    int result = vswscanf(input, format, args);\n    va_end(args);\n    return result;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t* input = L\"\\U0001F600 \\u03A9 Unicode\";\n    wchar_t emoji[5], greek[2], word[20];\n    \n    int items_read = parse_unicode(input, L\"%ls %ls %ls\", emoji, greek, word);\n    \n    wprintf(L\"Items read: %d\\n\", items_read);\n    wprintf(L\"Emoji: %ls, Greek: %ls, Word: %ls\\n\", emoji, greek, word);\n    \n    return 0;\n}\n",
          "explanation": "This example shows how to use vswscanf to parse a wide string containing Unicode characters, including emoji and non-Latin scripts.",
          "expectedOutput": "Items read: 3\nEmoji: 😀, Greek: Ω, Word: Unicode"
      },
      {
          "title": "Error Handling with vswscanf",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <stdarg.h>\n#include <locale.h>\n\nint safe_wide_parse(const wchar_t* input, const wchar_t* format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    int result = vswscanf(input, format, args);\n    \n    if (result == EOF) {\n        wprintf(L\"Error: parsing failed\\n\");\n    } else if (result == 0) {\n        wprintf(L\"Error: no items matched\\n\");\n    } else if (result < wcslen(format) - wcslen(wcschr(format, L'%'))) {\n        wprintf(L\"Warning: some items were not matched\\n\");\n    }\n    \n    va_end(args);\n    return result;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    int num1, num2;\n    \n    safe_wide_parse(L\"42 abc\", L\"%d %d\", &num1, &num2);\n    wprintf(L\"num1: %d\\n\", num1);\n    \n    safe_wide_parse(L\"not a number\", L\"%d\", &num1);\n    \n    safe_wide_parse(L\"123 456 789\", L\"%d %d\", &num1, &num2);\n    wprintf(L\"num1: %d, num2: %d\\n\", num1, num2);\n    \n    return 0;\n}\n",
          "explanation": "This example implements a safe_wide_parse function using vswscanf that includes error handling for various parsing scenarios with wide characters.",
          "expectedOutput": "Warning: some items were not matched\nnum1: 42\nError: no items matched\nnum1: 42, num2: 456"
      }
  ],
  "related_functions": ["swscanf", "wscanf", "vwscanf"],
  "performance_considerations": "vswscanf is generally efficient for parsing wide character strings. However, for very large strings or complex parsing tasks, consider using more specialized parsing libraries or custom parsing functions for better performance and flexibility. Be aware that handling wide characters and Unicode may have additional performance overhead compared to narrow character operations."
},
{
  "function_name": "vwprintf",
  "include_file": "wchar.h",
  "return_type": "int",
  "parameter_types": ["const wchar_t*", "va_list"],
  "main_category": "File and I/O Operations",
  "sub_category": "Wide Character Support",
  "data_type_manipulated": "standard output",
  "description": "Prints formatted wide character output to the standard output using a va_list.",
  "extended_description": "vwprintf is similar to wprintf, but instead of taking a variable number of arguments, it takes a va_list that has been initialized by va_start. This function writes the formatted wide character output to the standard output stream (stdout).",
  "return_value": "Returns the number of wide characters written, or a negative value if an error occurred.",
  "parameter_values": "format: Wide string that contains the text to be written to stdout. arg: A va_list containing the arguments to be formatted.",
  "function_prototype": "int vwprintf(const wchar_t *format, va_list arg);",
  "examples": [
      {
          "title": "Basic Usage of vwprintf",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <stdarg.h>\n#include <locale.h>\n\nvoid log_message(const wchar_t* format, ...) {\n    va_list args;\n    va_start(args, format);\n    vwprintf(format, args);\n    va_end(args);\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    int num = 42;\n    double pi = 3.14159;\n    wchar_t* name = L\"John\";\n    \n    log_message(L\"Number: %d\\n\", num);\n    log_message(L\"Pi: %.2f\\n\", pi);\n    log_message(L\"Name: %ls\\n\", name);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates using vwprintf in a custom logging function that can handle various types of wide character arguments.",
          "expectedOutput": "Number: 42\nPi: 3.14\nName: John"
      },
      {
          "title": "Formatting with Unicode Characters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <stdarg.h>\n#include <locale.h>\n\nvoid print_unicode(const wchar_t* format, ...) {\n    va_list args;\n    va_start(args, format);\n    vwprintf(format, args);\n    va_end(args);\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t* emoji = L\"\\U0001F600\";  // Grinning face emoji\n    wchar_t* greek = L\"\\u03A9\";     // Greek capital letter Omega\n    int count = 3;\n    \n    print_unicode(L\"Emoji: %ls, Greek: %ls, Count: %d\\n\", emoji, greek, count);\n    print_unicode(L\"Unicode string: %ls %ls %d times\\n\", emoji, greek, count);\n    \n    return 0;\n}\n",
          "explanation": "This example shows how to use vwprintf to format and print wide strings containing Unicode characters, including emoji and non-Latin scripts.",
          "expectedOutput": "Emoji: 😀, Greek: Ω, Count: 3\nUnicode string: 😀 Ω 3 times"
      },
      {
          "title": "Error Handling and Return Value",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <stdarg.h>\n#include <locale.h>\n\nint safe_wide_print(const wchar_t* format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    int result = vwprintf(format, args);\n    \n    if (result < 0) {\n        fwprintf(stderr, L\"Error: printing failed\\n\");\n    }\n    \n    va_end(args);\n    return result;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t* text = L\"Hello, World!\";\n    int num = 42;\n    \n    int chars_written = safe_wide_print(L\"%ls: %d\\n\", text, num);\n    \n    if (chars_written >= 0) {\n        wprintf(L\"Successfully wrote %d characters\\n\", chars_written);\n    }\n    \n    // Simulate an error (e.g., by redirecting stdout to a file without write permissions)\n    // freopen(\"/path/to/read/only/file\", \"w\", stdout);\n    // safe_wide_print(L\"This will fail\\n\");\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates error handling when using vwprintf and shows how to use the return value to determine the number of characters written.",
          "expectedOutput": "Hello, World!: 42\nSuccessfully wrote 16 characters"
      }
  ],
  "related_functions": ["wprintf", "fwprintf", "swprintf"],
  "performance_considerations": "vwprintf is generally efficient for standard output operations with wide characters. However, for very frequent calls or when outputting large amounts of data, consider using buffered I/O or custom output handling for better performance. Be aware that handling wide characters and Unicode may have additional performance overhead compared to narrow character operations."
},
{
  "function_name": "vwscanf",
  "include_file": "wchar.h",
  "return_type": "int",
  "parameter_types": ["const wchar_t*", "va_list"],
  "main_category": "File and I/O Operations",
  "sub_category": "Wide Character Support",
  "data_type_manipulated": "standard input",
  "description": "Reads formatted wide character input from the standard input using a va_list.",
  "extended_description": "vwscanf is similar to wscanf, but instead of taking a variable number of arguments, it takes a va_list that has been initialized by va_start. This function reads formatted wide character data from the standard input and stores the results in the locations pointed to by the elements in the va_list.",
  "return_value": "Returns the number of input items successfully matched and assigned. Returns EOF if an error occurred before any conversion.",
  "parameter_values": "format: Wide string containing a format string. arg: A va_list object containing pointers to store the retrieved values.",
  "function_prototype": "int vwscanf(const wchar_t *format, va_list arg);",
  "examples": [
      {
          "title": "Basic Usage of vwscanf",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <stdarg.h>\n#include <locale.h>\n\nint read_input(const wchar_t* format, ...) {\n    va_list args;\n    va_start(args, format);\n    int result = vwscanf(format, args);\n    va_end(args);\n    return result;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    int num;\n    float fnum;\n    wchar_t str[20];\n    \n    wprintf(L\"Enter an integer, a float, and a string: \");\n    int items_read = read_input(L\"%d %f %ls\", &num, &fnum, str);\n    \n    wprintf(L\"Items read: %d\\n\", items_read);\n    wprintf(L\"Number: %d, Float: %.2f, String: %ls\\n\", num, fnum, str);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates using vwscanf in a custom function to read formatted wide character input from the standard input.",
          "expectedOutput": "Enter an integer, a float, and a string: 42 3.14 Hello\nItems read: 3\nNumber: 42, Float: 3.14, String: Hello"
      },
      {
          "title": "Reading Unicode Characters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <stdarg.h>\n#include <locale.h>\n\nint read_unicode(const wchar_t* format, ...) {\n    va_list args;\n    va_start(args, format);\n    int result = vwscanf(format, args);\n    va_end(args);\n    return result;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t emoji[5], greek[2], word[20];\n    \n    wprintf(L\"Enter an emoji, a Greek letter, and a word: \");\n    int items_read = read_unicode(L\"%ls %ls %ls\", emoji, greek, word);\n    \n    wprintf(L\"Items read: %d\\n\", items_read);\n    wprintf(L\"Emoji: %ls, Greek: %ls, Word: %ls\\n\", emoji, greek, word);\n    \n    return 0;\n}\n",
          "explanation": "This example shows how to use vwscanf to read Unicode characters, including emoji and non-Latin scripts, from the standard input.",
          "expectedOutput": "Enter an emoji, a Greek letter, and a word: 😀 Ω Unicode\nItems read: 3\nEmoji: 😀, Greek: Ω, Word: Unicode"
      },
      {
          "title": "Error Handling with vwscanf",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <stdarg.h>\n#include <locale.h>\n\nint safe_wide_scan(const wchar_t* format, ...) {\n    va_list args;\n    va_start(args, format);\n    \n    int result = vwscanf(format, args);\n    \n    if (result == EOF) {\n        fwprintf(stderr, L\"Error: input failed\\n\");\n    } else if (result == 0) {\n        fwprintf(stderr, L\"Error: no items matched\\n\");\n    } else if (result < wcslen(format) - wcslen(wcschr(format, L'%'))) {\n        fwprintf(stderr, L\"Warning: some items were not matched\\n\");\n    }\n    \n    va_end(args);\n    return result;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    int num1, num2;\n    \n    wprintf(L\"Enter two integers: \");\n    int items_read = safe_wide_scan(L\"%d %d\", &num1, &num2);\n    \n    if (items_read == 2) {\n        wprintf(L\"Read successfully: %d, %d\\n\", num1, num2);\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example implements a safe_wide_scan function using vwscanf that includes error handling for various input scenarios with wide characters.",
          "expectedOutput": "Enter two integers: 42 abc\nWarning: some items were not matched\nOR\nEnter two integers: not_a_number\nError: no items matched\nOR\nEnter two integers: 10 20\nRead successfully: 10, 20"
      }
  ],
  "related_functions": ["wscanf", "fwscanf", "vswscanf"],
  "performance_considerations": "vwscanf is generally efficient for parsing wide character input from standard input. However, for very complex parsing tasks or performance-critical applications, consider using custom parsing techniques or specialized libraries. Be aware that handling wide characters and Unicode may have additional performance overhead compared to narrow character operations."
},
{
  "function_name": "wcrtomb",
  "include_file": "wchar.h",
  "return_type": "size_t",
  "parameter_types": ["char*", "wchar_t", "mbstate_t*"],
  "main_category": "Character Type and Conversion",
  "sub_category": "Wide Character Conversion",
  "data_type_manipulated": "characters",
  "description": "Converts a wide character to a multibyte sequence.",
  "extended_description": "wcrtomb converts a wide character to its multibyte representation. It stores the multibyte character representation of wc in the array pointed to by s (if s is not NULL). The conversion is affected by the LC_CTYPE category of the current locale and the conversion state pointed to by ps.",
  "return_value": "Returns the number of bytes stored in the array pointed to by s if s is not NULL. If wc can be represented as a multibyte sequence (according to the current locale), the value returned is the number of bytes that make up the converted multibyte character. If wc cannot be represented as a multibyte sequence, it returns (size_t)(-1) and sets errno to EILSEQ.",
  "parameter_values": "s: Pointer to an array of chars where the resulting multibyte character is stored. wc: Wide character to be converted. ps: Pointer to an object of type mbstate_t that contains the conversion state.",
  "function_prototype": "size_t wcrtomb(char *s, wchar_t wc, mbstate_t *ps);",
  "examples": [
      {
          "title": "Basic Usage of wcrtomb",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n#include <string.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t wc = L'A';\n    char mb[MB_CUR_MAX];\n    mbstate_t mbs = {0};\n    \n    size_t result = wcrtomb(mb, wc, &mbs);\n    \n    if (result != (size_t)(-1)) {\n        printf(\"Converted '%lc' to %zu bytes: \", wc, result);\n        for (size_t i = 0; i < result; i++) {\n            printf(\"%02X \", (unsigned char)mb[i]);\n        }\n        printf(\"\\n\");\n    } else {\n        printf(\"Conversion failed\\n\");\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcrtomb to convert a wide character to its multibyte representation.",
          "expectedOutput": "Converted 'A' to 1 bytes: 41"
      },
      {
          "title": "Converting Unicode Characters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n#include <string.h>\n\nvoid print_mb_hex(const char* mb, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        printf(\"%02X \", (unsigned char)mb[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t wc_array[] = {L'A', L'Ω', L'你', L'😀'};\n    char mb[MB_CUR_MAX];\n    mbstate_t mbs = {0};\n    \n    for (size_t i = 0; i < sizeof(wc_array) / sizeof(wchar_t); i++) {\n        size_t result = wcrtomb(mb, wc_array[i], &mbs);\n        \n        if (result != (size_t)(-1)) {\n            printf(\"Converted '%lc' to %zu bytes: \", wc_array[i], result);\n            print_mb_hex(mb, result);\n        } else {\n            printf(\"Conversion failed for '%lc'\\n\", wc_array[i]);\n        }\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example shows how to use wcrtomb to convert various Unicode characters, including non-Latin scripts and emoji, to their multibyte representations.",
          "expectedOutput": "Converted 'A' to 1 bytes: 41\nConverted 'Ω' to 2 bytes: CE A9\nConverted '你' to 3 bytes: E4 BD A0\nConverted '😀' to 4 bytes: F0 9F 98 80"
      },
      {
          "title": "Error Handling and Null Conversion",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n#include <string.h>\n#include <errno.h>\n\nsize_t safe_wcrtomb(char *s, wchar_t wc, mbstate_t *ps) {\n    errno = 0;\n    size_t result = wcrtomb(s, wc, ps);\n    \n    if (result == (size_t)(-1)) {\n        if (errno == EILSEQ) {\n            fprintf(stderr, \"Error: Invalid wide character\\n\");\n        } else {\n            fprintf(stderr, \"Error: Conversion failed\\n\");\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    char mb[MB_CUR_MAX];\n    mbstate_t mbs = {0};\n    \n    // Convert a valid character\n    safe_wcrtomb(mb, L'A', &mbs);\n    \n    // Try to convert an invalid wide character\n    safe_wcrtomb(mb, (wchar_t)0xFFFFFFFF, &mbs);\n    \n    // Perform a null conversion\n    size_t null_size = safe_wcrtomb(NULL, L'\\0', &mbs);\n    printf(\"Null conversion size: %zu\\n\", null_size);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates error handling when using wcrtomb, including dealing with invalid wide characters. It also shows how to perform a null conversion, which can be used to get the number of bytes needed to return the conversion state to the initial state.",
          "expectedOutput": "Error: Invalid wide character\nNull conversion size: 1"
      }
  ],
  "related_functions": ["mbrtowc", "wctomb", "wcstombs"],
  "performance_considerations": "wcrtomb is generally efficient for converting individual wide characters to multibyte sequences. However, for converting large amounts of text, consider using wide string functions or more specialized conversion libraries. The performance may vary depending on the complexity of the character and the current locale settings."
},
{
  "function_name": "wcscat",
  "include_file": "wchar.h",
  "return_type": "wchar_t*",
  "parameter_types": ["wchar_t*", "const wchar_t*"],
  "main_category": "String Operations",
  "sub_category": "Manipulation",
  "data_type_manipulated": "wide characters",
  "description": "Appends a wide character string to the end of another wide character string.",
  "extended_description": "wcscat appends a copy of the wide character string pointed to by src (including the terminating null wide character) to the end of the wide character string pointed to by dest. The initial wide character of src overwrites the null wide character at the end of dest. The behavior is undefined if the destination array is not large enough to hold both strings.",
  "return_value": "Returns a pointer to the destination string dest.",
  "parameter_values": "dest: Pointer to the destination array, which should contain a wide character string, and be large enough to contain the concatenated resulting string. src: Pointer to the null-terminated wide character string to be appended.",
  "function_prototype": "wchar_t *wcscat(wchar_t *dest, const wchar_t *src);",
  "examples": [
      {
          "title": "Basic Usage of wcscat",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t dest[50] = L\"Hello, \";\n    const wchar_t *src = L\"World!\";\n    \n    wcscat(dest, src);\n    \n    wprintf(L\"Concatenated string: %ls\\n\", dest);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcscat to concatenate two wide character strings.",
          "expectedOutput": "Concatenated string: Hello, World!"
      },
      {
          "title": "Concatenating Multiple Strings",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t sentence[100] = L\"The \";\n    const wchar_t *adjectives[] = {L\"quick \", L\"brown \", L\"lazy \"};\n    const wchar_t *noun = L\"fox\";\n    \n    for (int i = 0; i < 3; i++) {\n        wcscat(sentence, adjectives[i]);\n    }\n    wcscat(sentence, noun);\n    \n    wprintf(L\"Resulting sentence: %ls\\n\", sentence);\n    \n    return 0;\n}\n",
          "explanation": "This example shows how to use wcscat in a loop to concatenate multiple strings.",
          "expectedOutput": "Resulting sentence: The quick brown lazy fox"
      },
      {
          "title": "Safe String Concatenation",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nwchar_t* safe_wcscat(wchar_t *dest, size_t dest_size, const wchar_t *src) {\n    size_t dest_len = wcslen(dest);\n    size_t space_left = dest_size - dest_len - 1;  // -1 for null terminator\n    \n    size_t src_len = wcslen(src);\n    size_t to_copy = (src_len < space_left) ? src_len : space_left;\n    \n    wmemcpy(dest + dest_len, src, to_copy);\n    dest[dest_len + to_copy] = L'\\0';\n    \n    return dest;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t buffer[20] = L\"Hello, \";\n    const wchar_t *world = L\"World!\";\n    const wchar_t *long_text = L\"This is a very long text that won't fit.\";\n    \n    safe_wcscat(buffer, sizeof(buffer)/sizeof(wchar_t), world);\n    wprintf(L\"After first concat: %ls\\n\", buffer);\n    \n    safe_wcscat(buffer, sizeof(buffer)/sizeof(wchar_t), long_text);\n    wprintf(L\"After second concat: %ls\\n\", buffer);\n    \n    return 0;\n}\n",
          "explanation": "This example implements a safe version of wcscat that prevents buffer overflows by limiting the number of characters copied based on the available space in the destination buffer.",
          "expectedOutput": "After first concat: Hello, World!\nAfter second concat: Hello, World!This is"
      }
  ],
  "related_functions": ["wcscpy", "wcsncpy", "wcsncat"],
  "performance_considerations": "wcscat is generally efficient for simple string concatenations. However, for multiple concatenations or when building strings incrementally, it can be inefficient as it needs to find the end of the destination string each time. In such cases, consider using a wide string builder approach or keeping track of the end position manually."
},
{
  "function_name": "wcschr",
  "include_file": "wchar.h",
  "return_type": "wchar_t*",
  "parameter_types": ["const wchar_t*", "wchar_t"],
  "main_category": "String Operations",
  "sub_category": "Search",
  "data_type_manipulated": "wide characters",
  "description": "Searches for the first occurrence of a wide character in a wide character string.",
  "extended_description": "wcschr locates the first occurrence of wc in the wide-character string pointed to by ws. The terminating null wide character is considered to be part of the wide-character string. If wc is L'\\0', wcschr locates the terminating L'\\0'.",
  "return_value": "Returns a pointer to the located wide character, or NULL if the wide character does not appear in the string.",
  "parameter_values": "ws: Pointer to the null-terminated wide character string to be searched. wc: Wide character to be located.",
  "function_prototype": "wchar_t *wcschr(const wchar_t *ws, wchar_t wc);",
  "examples": [
      {
          "title": "Basic Usage of wcschr",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str = L\"Hello, World!\";\n    wchar_t search_char = L'o';\n    \n    wchar_t *result = wcschr(str, search_char);\n    \n    if (result != NULL) {\n        wprintf(L\"'%lc' found at position: %td\\n\", search_char, result - str);\n    } else {\n        wprintf(L\"'%lc' not found in the string\\n\", search_char);\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcschr to find the first occurrence of a character in a wide character string.",
          "expectedOutput": "'o' found at position: 4"
      },
      {
          "title": "Finding Multiple Occurrences",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str = L\"Hello, World!\";\n    wchar_t search_char = L'o';\n    \n    wprintf(L\"Occurrences of '%lc' in \\\"%ls\\\":\\n\", search_char, str);\n    \n    const wchar_t *ptr = str;\n    while ((ptr = wcschr(ptr, search_char)) != NULL) {\n        wprintf(L\"Found at position: %td\\n\", ptr - str);\n        ptr++;  // Move to the next character\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example shows how to use wcschr in a loop to find all occurrences of a character in a wide character string.",
          "expectedOutput": "Occurrences of 'o' in \"Hello, World!\":\nFound at position: 4\nFound at position: 7"
      },
      {
          "title": "Searching for Null Terminator",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nsize_t custom_wcslen(const wchar_t *str) {\n    const wchar_t *end = wcschr(str, L'\\0');\n    return end - str;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str1 = L\"Hello\";\n    const wchar_t *str2 = L\"\";\n    \n    wprintf(L\"Length of \\\"%ls\\\": %zu\\n\", str1, custom_wcslen(str1));\n    wprintf(L\"Length of \\\"%ls\\\": %zu\\n\", str2, custom_wcslen(str2));\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates using wcschr to find the null terminator, effectively implementing a custom wide character string length function.",
          "expectedOutput": "Length of \"Hello\": 5\nLength of \"\": 0"
      }
  ],
  "related_functions": ["wcsrchr", "wcscspn", "wcspbrk"],
  "performance_considerations": "wcschr is generally efficient for searching a single character in a string. For repeated searches of the same character, consider using a loop with pointer arithmetic for potentially better performance. For more complex search patterns, other string searching algorithms or functions might be more appropriate."
},
{
  "function_name": "wcscmp",
  "include_file": "wchar.h",
  "return_type": "int",
  "parameter_types": ["const wchar_t*", "const wchar_t*"],
  "main_category": "Data Search and Sorting",
  "sub_category": "String Comparison",
  "data_type_manipulated": "wide characters",
  "description": "Compares two wide character strings lexicographically.",
  "extended_description": "wcscmp compares the wide character string pointed to by s1 to the wide character string pointed to by s2. The comparison is done lexicographically. The function starts comparing the first character of each string. If they are equal to each other, it continues with the following pairs until the characters differ or until a terminating null-character is reached.",
  "return_value": "Returns an integer less than, equal to, or greater than zero if s1 is found, respectively, to be less than, to match, or be greater than s2.",
  "parameter_values": "s1: Pointer to the first wide character string to be compared. s2: Pointer to the second wide character string to be compared.",
  "function_prototype": "int wcscmp(const wchar_t *s1, const wchar_t *s2);",
  "examples": [
      {
          "title": "Basic Usage of wcscmp",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str1 = L\"apple\";\n    const wchar_t *str2 = L\"banana\";\n    \n    int result = wcscmp(str1, str2);\n    \n    if (result < 0) {\n        wprintf(L\"\"%ls\" comes before \"%ls\"\\n\", str1, str2);\n    } else if (result > 0) {\n        wprintf(L\"\"%ls\" comes after \"%ls\"\\n\", str1, str2);\n    } else {\n        wprintf(L\"\"%ls\" is equal to \"%ls\"\\n\", str1, str2);\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcscmp to compare two wide character strings lexicographically.",
          "expectedOutput": "\"apple\" comes before \"banana\""
      },
      {
          "title": "Sorting Wide Character Strings",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nvoid sort_strings(wchar_t *arr[], int n) {\n    for (int i = 0; i < n-1; i++) {\n        for (int j = 0; j < n-i-1; j++) {\n            if (wcscmp(arr[j], arr[j+1]) > 0) {\n                wchar_t *temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t *words[] = {L\"banana\", L\"apple\", L\"cherry\", L\"date\"};\n    int n = sizeof(words) / sizeof(words[0]);\n    \n    wprintf(L\"Before sorting:\\n\");\n    for (int i = 0; i < n; i++) {\n        wprintf(L\"%ls \", words[i]);\n    }\n    \n    sort_strings(words, n);\n    \n    wprintf(L\"\\nAfter sorting:\\n\");\n    for (int i = 0; i < n; i++) {\n        wprintf(L\"%ls \", words[i]);\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example uses wcscmp in a bubble sort algorithm to sort an array of wide character strings.",
          "expectedOutput": "Before sorting:\nbanana apple cherry date \nAfter sorting:\napple banana cherry date"
      },
      {
          "title": "Case-Insensitive Comparison",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint wcscasecmp(const wchar_t *s1, const wchar_t *s2) {\n    while (*s1 && *s2) {\n        wchar_t c1 = towlower(*s1);\n        wchar_t c2 = towlower(*s2);\n        if (c1 != c2) {\n            return c1 - c2;\n        }\n        s1++;\n        s2++;\n    }\n    return *s1 - *s2;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str1 = L\"Apple\";\n    const wchar_t *str2 = L\"apple\";\n    \n    int result = wcscmp(str1, str2);\n    int case_insensitive_result = wcscasecmp(str1, str2);\n    \n    wprintf(L\"wcscmp result: %d\\n\", result);\n    wprintf(L\"Case-insensitive comparison result: %d\\n\", case_insensitive_result);\n    \n    return 0;\n}\n",
          "explanation": "This example implements a case-insensitive version of wcscmp and compares its behavior with the standard wcscmp.",
          "expectedOutput": "wcscmp result: -32\nCase-insensitive comparison result: 0"
      }
  ],
  "related_functions": ["wcsncmp", "wcscoll", "wmemcmp"],
  "performance_considerations": "wcscmp is generally efficient for comparing wide character strings. However, for very long strings or frequent comparisons, consider using memory comparison functions like wmemcmp if you know the string lengths in advance. For case-insensitive comparisons, implementing a custom function (as shown in the example) may be less efficient due to the character-by-character conversion."
},
{
  "function_name": "wcscoll",
  "include_file": "wchar.h",
  "return_type": "int",
  "parameter_types": ["const wchar_t*", "const wchar_t*"],
  "main_category": "Data Search and Sorting",
  "sub_category": "String Comparison",
  "data_type_manipulated": "wide characters",
  "description": "Compares two wide character strings using the current locale's collation rules.",
  "extended_description": "wcscoll compares the wide character string pointed to by s1 to the wide character string pointed to by s2, both interpreted as appropriate to the LC_COLLATE category of the current locale. It uses the collation rules specific to the current locale for the comparison, which can handle language-specific sorting rules.",
  "return_value": "Returns an integer less than, equal to, or greater than zero if s1 is found, respectively, to be less than, to match, or be greater than s2 according to the current locale's collation rules.",
  "parameter_values": "s1: Pointer to the first wide character string to be compared. s2: Pointer to the second wide character string to be compared.",
  "function_prototype": "int wcscoll(const wchar_t *s1, const wchar_t *s2);",
  "examples": [
      {
          "title": "Basic Usage of wcscoll",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str1 = L\"résumé\";\n    const wchar_t *str2 = L\"resume\";\n    \n    int result = wcscoll(str1, str2);\n    \n    if (result < 0) {\n        wprintf(L\"\"%ls\" comes before \"%ls\" in the current locale\\n\", str1, str2);\n    } else if (result > 0) {\n        wprintf(L\"\"%ls\" comes after \"%ls\" in the current locale\\n\", str1, str2);\n    } else {\n        wprintf(L\"\"%ls\" is equal to \"%ls\" in the current locale\\n\", str1, str2);\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcscoll to compare two wide character strings using the current locale's collation rules.",
          "expectedOutput": "The output may vary depending on the locale, but it will show the relative order of \"résumé\" and \"resume\" according to the current locale's rules."
      },
      {
          "title": "Comparing Strings in Different Locales",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nvoid compare_strings(const wchar_t *s1, const wchar_t *s2, const char *locale) {\n    setlocale(LC_COLLATE, locale);\n    int result = wcscoll(s1, s2);\n    wprintf(L\"In %s locale: \", locale);\n    if (result < 0) {\n        wprintf(L\"\"%ls\" comes before \"%ls\"\\n\", s1, s2);\n    } else if (result > 0) {\n        wprintf(L\"\"%ls\" comes after \"%ls\"\\n\", s1, s2);\n    } else {\n        wprintf(L\"\"%ls\" is equal to \"%ls\"\\n\", s1, s2);\n    }\n}\n\nint main() {\n    const wchar_t *str1 = L\"ß\";  // German sharp S\n    const wchar_t *str2 = L\"ss\";\n    \n    compare_strings(str1, str2, \"en_US.UTF-8\");\n    compare_strings(str1, str2, \"de_DE.UTF-8\");\n    \n    return 0;\n}\n",
          "explanation": "This example compares two strings that may be considered equivalent in some locales but different in others, demonstrating how wcscoll behaves differently based on the locale.",
          "expectedOutput": "The output will show how the German sharp S (ß) compares to \"ss\" in English and German locales. The exact output may vary depending on the system's locale support."
      },
      {
          "title": "Sorting with wcscoll",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nvoid sort_strings(wchar_t *arr[], int n) {\n    for (int i = 0; i < n-1; i++) {\n        for (int j = 0; j < n-i-1; j++) {\n            if (wcscoll(arr[j], arr[j+1]) > 0) {\n                wchar_t *temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t *words[] = {L\"café\", L\"résumé\", L\"naïve\", L\"coöperate\"};\n    int n = sizeof(words) / sizeof(words[0]);\n    \n    wprintf(L\"Before sorting:\\n\");\n    for (int i = 0; i < n; i++) {\n        wprintf(L\"%ls \", words[i]);\n    }\n    \n    sort_strings(words, n);\n    \n    wprintf(L\"\\nAfter sorting:\\n\");\n    for (int i = 0; i < n; i++) {\n        wprintf(L\"%ls \", words[i]);\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example uses wcscoll in a bubble sort algorithm to sort an array of wide character strings according to the current locale's collation rules.",
          "expectedOutput": "The output will show the words sorted according to the current locale's rules. The exact order may vary depending on the locale."
      }
  ],
  "related_functions": ["wcscmp", "setlocale", "wcsxfrm"],
  "performance_considerations": "wcscoll can be significantly slower than wcscmp, especially for complex locales, as it needs to apply locale-specific rules for each comparison. For performance-critical applications with many string comparisons, consider using wcsxfrm to transform the strings once and then compare the transformed strings using wcscmp."
},
{
  "function_name": "wcscpy",
  "include_file": "wchar.h",
  "return_type": "wchar_t*",
  "parameter_types": ["wchar_t*", "const wchar_t*"],
  "main_category": "String Operations",
  "sub_category": "Manipulation",
  "data_type_manipulated": "wide characters",
  "description": "Copies a wide character string to another wide character string.",
  "extended_description": "wcscpy copies the wide character string pointed to by src, including the terminating null wide character, to the array pointed to by dest. The strings may not overlap, and the destination string dest must be large enough to receive the copy.",
  "return_value": "Returns a pointer to the destination string dest.",
  "parameter_values": "dest: Pointer to the destination array where the content is to be copied. src: Pointer to the null-terminated wide character string to be copied.",
  "function_prototype": "wchar_t *wcscpy(wchar_t *dest, const wchar_t *src);",
  "examples": [
      {
          "title": "Basic Usage of wcscpy",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t src[] = L\"Hello, World!\";\n    wchar_t dest[20];\n    \n    wcscpy(dest, src);\n    \n    wprintf(L\"Source string: %ls\\n\", src);\n    wprintf(L\"Copied string: %ls\\n\", dest);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcscpy to copy a wide character string from src to dest.",
          "expectedOutput": "Source string: Hello, World!\nCopied string: Hello, World!"
      },
      {
          "title": "Copying Partial Strings",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nwchar_t* wcscpy_partial(wchar_t *dest, const wchar_t *src, size_t n) {\n    wchar_t *d = dest;\n    while (n > 0 && *src != L'\\0') {\n        *d++ = *src++;\n        n--;\n    }\n    *d = L'\\0';\n    return dest;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t src[] = L\"Hello, World!\";\n    wchar_t dest[20];\n    \n    wcscpy_partial(dest, src, 5);\n    \n    wprintf(L\"Source string: %ls\\n\", src);\n    wprintf(L\"Partially copied string: %ls\\n\", dest);\n    \n    return 0;\n}\n",
          "explanation": "This example implements a custom function wcscpy_partial that copies only a specified number of characters, demonstrating how wcscpy can be modified for more specific use cases.",
          "expectedOutput": "Source string: Hello, World!\nPartially copied string: Hello"
      },
      {
          "title": "Safe String Copy",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nwchar_t* wcscpy_safe(wchar_t *dest, size_t dest_size, const wchar_t *src) {\n    if (dest == NULL || src == NULL || dest_size == 0) {\n        return NULL;\n    }\n    \n    size_t i;\n    for (i = 0; i < dest_size - 1 && src[i] != L'\\0'; i++) {\n        dest[i] = src[i];\n    }\n    dest[i] = L'\\0';\n    \n    return dest;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t src[] = L\"This is a very long string that might cause buffer overflow\";\n    wchar_t dest[20];\n    \n    wcscpy_safe(dest, sizeof(dest)/sizeof(wchar_t), src);\n    \n    wprintf(L\"Source string: %ls\\n\", src);\n    wprintf(L\"Safely copied string: %ls\\n\", dest);\n    \n    return 0;\n}\n",
          "explanation": "This example implements a safe version of wcscpy that prevents buffer overflows by limiting the number of characters copied based on the size of the destination buffer.",
          "expectedOutput": "Source string: This is a very long string that might cause buffer overflow\nSafely copied string: This is a very long"
      }
  ],
  "related_functions": ["wcsncpy", "wmemcpy", "wcscat"],
  "performance_considerations": "wcscpy is generally efficient for copying strings. However, it doesn't perform any bounds checking, which can lead to buffer overflows if not used carefully. For safer string copying, consider using wcsncpy or implementing a bounds-checked version as shown in the 'Safe String Copy' example."
},
{
  "function_name": "wcscpy",
  "include_file": "wchar.h",
  "return_type": "wchar_t*",
  "parameter_types": ["wchar_t*", "const wchar_t*"],
  "main_category": "String Operations",
  "sub_category": "Manipulation",
  "data_type_manipulated": "wide characters",
  "description": "Copies a wide character string to another wide character string.",
  "extended_description": "wcscpy copies the wide character string pointed to by src, including the terminating null wide character, to the array pointed to by dest. The strings may not overlap, and the destination string dest must be large enough to receive the copy.",
  "return_value": "Returns a pointer to the destination string dest.",
  "parameter_values": "dest: Pointer to the destination array where the content is to be copied. src: Pointer to the null-terminated wide character string to be copied.",
  "function_prototype": "wchar_t *wcscpy(wchar_t *dest, const wchar_t *src);",
  "examples": [
      {
          "title": "Basic Usage of wcscpy",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t src[] = L\"Hello, World!\";\n    wchar_t dest[20];\n    \n    wcscpy(dest, src);\n    \n    wprintf(L\"Source string: %ls\\n\", src);\n    wprintf(L\"Copied string: %ls\\n\", dest);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcscpy to copy a wide character string from src to dest.",
          "expectedOutput": "Source string: Hello, World!\nCopied string: Hello, World!"
      },
      {
          "title": "Copying Partial Strings",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nwchar_t* wcscpy_partial(wchar_t *dest, const wchar_t *src, size_t n) {\n    wchar_t *d = dest;\n    while (n > 0 && *src != L'\\0') {\n        *d++ = *src++;\n        n--;\n    }\n    *d = L'\\0';\n    return dest;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t src[] = L\"Hello, World!\";\n    wchar_t dest[20];\n    \n    wcscpy_partial(dest, src, 5);\n    \n    wprintf(L\"Source string: %ls\\n\", src);\n    wprintf(L\"Partially copied string: %ls\\n\", dest);\n    \n    return 0;\n}\n",
          "explanation": "This example implements a custom function wcscpy_partial that copies only a specified number of characters, demonstrating how wcscpy can be modified for more specific use cases.",
          "expectedOutput": "Source string: Hello, World!\nPartially copied string: Hello"
      },
      {
          "title": "Safe String Copy",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nwchar_t* wcscpy_safe(wchar_t *dest, size_t dest_size, const wchar_t *src) {\n    if (dest == NULL || src == NULL || dest_size == 0) {\n        return NULL;\n    }\n    \n    size_t i;\n    for (i = 0; i < dest_size - 1 && src[i] != L'\\0'; i++) {\n        dest[i] = src[i];\n    }\n    dest[i] = L'\\0';\n    \n    return dest;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t src[] = L\"This is a very long string that might cause buffer overflow\";\n    wchar_t dest[20];\n    \n    wcscpy_safe(dest, sizeof(dest)/sizeof(wchar_t), src);\n    \n    wprintf(L\"Source string: %ls\\n\", src);\n    wprintf(L\"Safely copied string: %ls\\n\", dest);\n    \n    return 0;\n}\n",
          "explanation": "This example implements a safe version of wcscpy that prevents buffer overflows by limiting the number of characters copied based on the size of the destination buffer.",
          "expectedOutput": "Source string: This is a very long string that might cause buffer overflow\nSafely copied string: This is a very long"
      }
  ],
  "related_functions": ["wcsncpy", "wmemcpy", "wcscat"],
  "performance_considerations": "wcscpy is generally efficient for copying strings. However, it doesn't perform any bounds checking, which can lead to buffer overflows if not used carefully. For safer string copying, consider using wcsncpy or implementing a bounds-checked version as shown in the 'Safe String Copy' example."
},
{
  "function_name": "wcsftime",
  "include_file": "wchar.h",
  "return_type": "size_t",
  "parameter_types": ["wchar_t*", "size_t", "const wchar_t*", "const struct tm*"],
  "main_category": "Time and Date Management",
  "sub_category": "Time Formatting",
  "data_type_manipulated": "wide characters",
  "description": "Formats the time and date as a wide character string according to the locale settings and format string.",
  "extended_description": "wcsftime converts the time information from a given calendar time (struct tm) into a wide character string according to a specified format. It is the wide character equivalent of strftime. The function uses the current locale settings for formatting.",
  "return_value": "Returns the number of wide characters placed in the array wcs if the total number including the terminating null wide character is not more than maxsize. Otherwise, it returns 0, and the contents of the array are indeterminate.",
  "parameter_values": "wcs: Pointer to the destination wide character array. maxsize: Maximum number of wide characters to be written to wcs. format: Wide character string containing format specifiers. timeptr: Pointer to a struct tm containing a calendar time broken down into its components.",
  "function_prototype": "size_t wcsftime(wchar_t *wcs, size_t maxsize, const wchar_t *format, const struct tm *timeptr);",
  "examples": [
      {
          "title": "Basic Usage of wcsftime",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <time.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    time_t rawtime;\n    struct tm *timeinfo;\n    wchar_t buffer[80];\n\n    time(&rawtime);\n    timeinfo = localtime(&rawtime);\n\n    wcsftime(buffer, 80, L\"%A, %d %B %Y %I:%M %p\", timeinfo);\n    wprintf(L\"Formatted date and time: %ls\\n\", buffer);\n\n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcsftime to format the current date and time as a wide character string.",
          "expectedOutput": "Formatted date and time: Sunday, 07 July 2024 03:45 PM (Note: actual output will depend on the current date and time)"
      },
      {
          "title": "Locale-Specific Formatting",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <time.h>\n#include <locale.h>\n\nint main() {\n    time_t rawtime;\n    struct tm *timeinfo;\n    wchar_t buffer[80];\n\n    time(&rawtime);\n    timeinfo = localtime(&rawtime);\n\n    setlocale(LC_ALL, \"en_US.UTF-8\");\n    wcsftime(buffer, 80, L\"%c\", timeinfo);\n    wprintf(L\"US locale: %ls\\n\", buffer);\n\n    setlocale(LC_ALL, \"fr_FR.UTF-8\");\n    wcsftime(buffer, 80, L\"%c\", timeinfo);\n    wprintf(L\"French locale: %ls\\n\", buffer);\n\n    return 0;\n}\n",
          "explanation": "This example shows how wcsftime formats the date and time differently based on the current locale settings.",
          "expectedOutput": "US locale: Sun Jul 7 15:45:00 2024\nFrench locale: dim. 07 juil. 2024 15:45:00 (Note: actual output will depend on the current date and time and available locales)"
      },
      {
          "title": "Custom Date and Time Formatting",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <time.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    time_t rawtime;\n    struct tm *timeinfo;\n    wchar_t buffer[100];\n\n    time(&rawtime);\n    timeinfo = localtime(&rawtime);\n\n    wcsftime(buffer, 100, L\"Year: %Y, Month: %B, Day: %d\\nTime: %H:%M:%S\\nWeek of the year: %W\\nDay of the year: %j\", timeinfo);\n    wprintf(L\"Custom formatted date and time:\\n%ls\\n\", buffer);\n\n    return 0;\n}\n",
          "explanation": "This example demonstrates using various format specifiers with wcsftime to create a custom date and time representation.",
          "expectedOutput": "Custom formatted date and time:\nYear: 2024, Month: July, Day: 07\nTime: 15:45:00\nWeek of the year: 27\nDay of the year: 189 (Note: actual output will depend on the current date and time)"
      }
  ],
  "related_functions": ["strftime", "localtime", "gmtime"],
  "performance_considerations": "wcsftime is generally efficient for formatting date and time. However, repeated calls with the same format string might benefit from caching the format string. Be mindful of the buffer size to avoid potential overflow. For high-performance scenarios with many time formatting operations, consider creating a custom formatter using lower-level time functions."
},
{
  "function_name": "wcslen",
  "include_file": "wchar.h",
  "return_type": "size_t",
  "parameter_types": ["const wchar_t*"],
  "main_category": "String Operations",
  "sub_category": "Measurement",
  "data_type_manipulated": "wide characters",
  "description": "Calculates the length of a wide character string, excluding the null terminator.",
  "extended_description": "wcslen computes the length of the wide character string pointed to by s, excluding the terminating null wide character. It is the wide character equivalent of strlen.",
  "return_value": "Returns the number of wide characters in the string pointed to by s.",
  "parameter_values": "s: Pointer to the null-terminated wide character string to be examined.",
  "function_prototype": "size_t wcslen(const wchar_t *s);",
  "examples": [
      {
          "title": "Basic Usage of wcslen",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str = L\"Hello, World!\";\n    size_t length = wcslen(str);\n    \n    wprintf(L\"String: %ls\\n\", str);\n    wprintf(L\"Length: %zu\\n\", length);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcslen to calculate the length of a wide character string.",
          "expectedOutput": "String: Hello, World!\nLength: 13"
      },
      {
          "title": "Using wcslen with Unicode Characters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str1 = L\"こんにちは世界\";\n    const wchar_t *str2 = L\"Hello, 世界!\";\n    \n    wprintf(L\"String 1: %ls\\n\", str1);\n    wprintf(L\"Length of string 1: %zu\\n\", wcslen(str1));\n    \n    wprintf(L\"String 2: %ls\\n\", str2);\n    wprintf(L\"Length of string 2: %zu\\n\", wcslen(str2));\n    \n    return 0;\n}\n",
          "explanation": "This example shows how wcslen handles strings containing Unicode characters, demonstrating that it counts wide characters, not bytes.",
          "expectedOutput": "String 1: こんにちは世界\nLength of string 1: 7\nString 2: Hello, 世界!\nLength of string 2: 9"
      },
      {
          "title": "Implementing a Safe String Copy Function",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nwchar_t* safe_wcscpy(wchar_t *dest, size_t dest_size, const wchar_t *src) {\n    if (dest == NULL || src == NULL || dest_size == 0) {\n        return NULL;\n    }\n    \n    size_t src_len = wcslen(src);\n    size_t copy_len = (src_len < dest_size - 1) ? src_len : dest_size - 1;\n    \n    wmemcpy(dest, src, copy_len);\n    dest[copy_len] = L'\\0';\n    \n    return dest;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *src = L\"This is a long string that might cause buffer overflow\";\n    wchar_t dest[20];\n    \n    safe_wcscpy(dest, sizeof(dest)/sizeof(wchar_t), src);\n    \n    wprintf(L\"Source string: %ls\\n\", src);\n    wprintf(L\"Copied string: %ls\\n\", dest);\n    wprintf(L\"Length of copied string: %zu\\n\", wcslen(dest));\n    \n    return 0;\n}\n",
          "explanation": "This example uses wcslen in a custom safe string copy function to ensure that the destination buffer is not overflowed.",
          "expectedOutput": "Source string: This is a long string that might cause buffer overflow\nCopied string: This is a long stri\nLength of copied string: 19"
      }
  ],
  "related_functions": ["strlen", "wcsnlen", "wcsncpy"],
  "performance_considerations": "wcslen is generally efficient as it simply counts characters until it reaches the null terminator. However, for very long strings, the operation can become costly. In performance-critical scenarios where the string length is needed multiple times, consider storing the length separately. Also, be aware that wcslen needs to scan the entire string, so for operations that don't require the full length, other functions might be more appropriate."
},
{
  "function_name": "wcslocaleconv",
  "include_file": "locale.h",
  "return_type": "struct lconv*",
  "parameter_types": [],
  "main_category": "System Interaction",
  "sub_category": "Localization Support",
  "data_type_manipulated": "locale settings",
  "description": "Returns a pointer to the structure containing locale-specific information, formatted as wide characters.",
  "extended_description": "wcslocaleconv is the wide-character version of localeconv. It returns a pointer to a structure of type struct lconv with the members containing locale-specific information. The structure may be overwritten by subsequent calls to wcslocaleconv or localeconv.",
  "return_value": "Returns a pointer to a filled struct lconv. The structure pointed to by the return value shall not be modified by the program, but may be overwritten by subsequent calls to wcslocaleconv.",
  "parameter_values": "None",
  "function_prototype": "struct lconv *wcslocaleconv(void);",
  "examples": [
      {
          "title": "Basic Usage of wcslocaleconv",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    struct lconv *lc = wcslocaleconv();\n    \n    wprintf(L\"Decimal point: %ls\\n\", lc->decimal_point);\n    wprintf(L\"Thousands separator: %ls\\n\", lc->thousands_sep);\n    wprintf(L\"Grouping: %s\\n\", lc->grouping);\n    wprintf(L\"Int'l currency symbol: %ls\\n\", lc->int_curr_symbol);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcslocaleconv to retrieve locale-specific information such as decimal point, thousands separator, and currency symbol.",
          "expectedOutput": "Decimal point: .\nThousands separator: ,\nGrouping: 3\nInt'l currency symbol: USD \n(Note: Actual output may vary depending on the system's locale settings)"
      },
      {
          "title": "Comparing Different Locales",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nvoid print_locale_info(const char* locale_name) {\n    setlocale(LC_ALL, locale_name);\n    struct lconv *lc = wcslocaleconv();\n    \n    wprintf(L\"Locale: %s\\n\", locale_name);\n    wprintf(L\"Currency symbol: %ls\\n\", lc->currency_symbol);\n    wprintf(L\"Positive sign: %ls\\n\", lc->positive_sign);\n    wprintf(L\"Negative sign: %ls\\n\", lc->negative_sign);\n    wprintf(L\"\\n\");\n}\n\nint main() {\n    print_locale_info(\"en_US.UTF-8\");\n    print_locale_info(\"fr_FR.UTF-8\");\n    print_locale_info(\"de_DE.UTF-8\");\n    \n    return 0;\n}\n",
          "explanation": "This example compares locale-specific information for different locales using wcslocaleconv.",
          "expectedOutput": "Locale: en_US.UTF-8\nCurrency symbol: $\nPositive sign: \nNegative sign: -\n\nLocale: fr_FR.UTF-8\nCurrency symbol: €\nPositive sign: \nNegative sign: -\n\nLocale: de_DE.UTF-8\nCurrency symbol: €\nPositive sign: \nNegative sign: -\n\n(Note: Actual output may vary depending on the system's locale support)"
      },
      {
          "title": "Formatting Currency Values",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nvoid format_currency(double value, const char* locale_name) {\n    setlocale(LC_ALL, locale_name);\n    struct lconv *lc = wcslocaleconv();\n    \n    wchar_t formatted[50];\n    swprintf(formatted, 50, L\"%ls%'.2f\", lc->currency_symbol, value);\n    \n    wprintf(L\"Locale: %s\\n\", locale_name);\n    wprintf(L\"Formatted value: %ls\\n\\n\", formatted);\n}\n\nint main() {\n    double amount = 1234567.89;\n    \n    format_currency(amount, \"en_US.UTF-8\");\n    format_currency(amount, \"fr_FR.UTF-8\");\n    format_currency(amount, \"de_DE.UTF-8\");\n    \n    return 0;\n}\n",
          "explanation": "This example uses wcslocaleconv to format currency values according to different locale settings.",
          "expectedOutput": "Locale: en_US.UTF-8\nFormatted value: $1,234,567.89\n\nLocale: fr_FR.UTF-8\nFormatted value: 1 234 567,89 €\n\nLocale: de_DE.UTF-8\nFormatted value: 1.234.567,89 €\n\n(Note: Actual output may vary depending on the system's locale support)"
      }
  ],
  "related_functions": ["localeconv", "setlocale"],
  "performance_considerations": "wcslocaleconv is generally efficient as it returns a pointer to a pre-allocated structure. However, repeatedly calling wcslocaleconv in a tight loop should be avoided. Instead, store the returned pointer and reuse it as needed, keeping in mind that its contents may change if setlocale is called."
},
{
  "function_name": "wcsncat",
  "include_file": "wchar.h",
  "return_type": "wchar_t*",
  "parameter_types": ["wchar_t*", "const wchar_t*", "size_t"],
  "main_category": "String Operations",
  "sub_category": "Manipulation",
  "data_type_manipulated": "wide characters",
  "description": "Appends a specified number of wide characters from the source wide character string to the destination wide character string.",
  "extended_description": "wcsncat appends not more than n wide characters from the wide string pointed to by src to the end of the wide string pointed to by dest. The first wide character of src overwrites the null wide character at the end of dest. A terminating null wide character is always appended to the result.",
  "return_value": "Returns a pointer to the resulting wide string dest.",
  "parameter_values": "dest: Pointer to the destination wide string to append to. src: Pointer to the source wide string to append from. n: Maximum number of wide characters to append.",
  "function_prototype": "wchar_t *wcsncat(wchar_t *dest, const wchar_t *src, size_t n);",
  "examples": [
      {
          "title": "Basic Usage of wcsncat",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t dest[20] = L\"Hello, \";\n    const wchar_t *src = L\"World!\";\n    \n    wcsncat(dest, src, 5);  // Append at most 5 characters\n    \n    wprintf(L\"Result: %ls\\n\", dest);\n    wprintf(L\"Length: %zu\\n\", wcslen(dest));\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcsncat to append a limited number of characters from one wide string to another.",
          "expectedOutput": "Result: Hello, World\nLength: 12"
      },
      {
          "title": "Handling Buffer Overflow",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t dest[10] = L\"12345\";\n    const wchar_t *src = L\"6789012345\";\n    \n    wcsncat(dest, src, 10);  // Try to append more than the buffer can hold\n    \n    wprintf(L\"Result: %ls\\n\", dest);\n    wprintf(L\"Length: %zu\\n\", wcslen(dest));\n    \n    return 0;\n}\n",
          "explanation": "This example shows how wcsncat behaves when trying to append more characters than the destination buffer can hold. It demonstrates that wcsncat ensures null-termination even in case of potential overflow.",
          "expectedOutput": "Result: 123456789\nLength: 9"
      },
      {
          "title": "Implementing a Safe String Concatenation",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nwchar_t* safe_wcsncat(wchar_t *dest, size_t dest_size, const wchar_t *src, size_t n) {\n    size_t dest_len = wcslen(dest);\n    size_t space_left = dest_size - dest_len - 1;  // -1 for null terminator\n    \n    if (space_left == 0) return dest;  // No space left for concatenation\n    \n    size_t to_copy = (n < space_left) ? n : space_left;\n    wcsncat(dest, src, to_copy);\n    \n    return dest;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t dest[15] = L\"Hello, \";\n    const wchar_t *src = L\"World! This is a long string.\";\n    \n    safe_wcsncat(dest, sizeof(dest)/sizeof(wchar_t), src, 20);\n    \n    wprintf(L\"Result: %ls\\n\", dest);\n    wprintf(L\"Length: %zu\\n\", wcslen(dest));\n    \n    return 0;\n}\n",
          "explanation": "This example implements a safe version of wcsncat that takes into account the size of the destination buffer to prevent overflow.",
          "expectedOutput": "Result: Hello, World! T\nLength: 14"
      }
  ],
  "related_functions": ["wcscat", "wcscpy", "wcsncpy"],
  "performance_considerations": "wcsncat is generally efficient for appending strings. However, it needs to find the end of the destination string before appending, which can be inefficient for very long strings. For better performance when building strings incrementally, consider keeping track of the end position manually or using a wide string builder approach."
},
{
  "function_name": "wcsncmp",
  "include_file": "wchar.h",
  "return_type": "int",
  "parameter_types": ["const wchar_t*", "const wchar_t*", "size_t"],
  "main_category": "Data Search and Sorting",
  "sub_category": "String Comparison",
  "data_type_manipulated": "wide characters",
  "description": "Compares a specified number of characters from two wide character strings.",
  "extended_description": "wcsncmp compares up to n wide characters from the wide string pointed to by s1 to the wide string pointed to by s2. The comparison is done lexicographically. If the strings are equal, the function returns 0. If they differ, it returns a value greater than or less than 0 depending on whether the first differing wide character in s1 is greater or less than the corresponding character in s2.",
  "return_value": "Returns an integer less than, equal to, or greater than zero if s1 (or the first n wide characters thereof) is found, respectively, to be less than, to match, or be greater than s2.",
  "parameter_values": "s1: Pointer to the first wide string to be compared. s2: Pointer to the second wide string to be compared. n: Maximum number of wide characters to compare.",
  "function_prototype": "int wcsncmp(const wchar_t *s1, const wchar_t *s2, size_t n);",
  "examples": [
      {
          "title": "Basic Usage of wcsncmp",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str1 = L\"Hello, World!\";\n    const wchar_t *str2 = L\"Hello, There!\";\n    \n    int result = wcsncmp(str1, str2, 7);\n    \n    if (result == 0) {\n        wprintf(L\"The first 7 characters are equal\\n\");\n    } else if (result < 0) {\n        wprintf(L\"str1 is less than str2 in the first 7 characters\\n\");\n    } else {\n        wprintf(L\"str1 is greater than str2 in the first 7 characters\\n\");\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcsncmp to compare the first 7 characters of two wide strings.",
          "expectedOutput": "The first 7 characters are equal"
      },
      {
          "title": "Comparing Strings with Different Lengths",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str1 = L\"Short\";\n    const wchar_t *str2 = L\"Shorter\";\n    \n    int result1 = wcsncmp(str1, str2, 5);\n    int result2 = wcsncmp(str1, str2, 6);\n    \n    wprintf(L\"Comparing first 5 characters: %d\\n\", result1);\n    wprintf(L\"Comparing first 6 characters: %d\\n\", result2);\n    \n    return 0;\n}\n",
          "explanation": "This example shows how wcsncmp behaves when comparing strings of different lengths and when the comparison length exceeds one of the string lengths.",
          "expectedOutput": "Comparing first 5 characters: 0\nComparing first 6 characters: -1"
      },
      {
          "title": "Case-Insensitive Comparison",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nint wcsncasecmp(const wchar_t *s1, const wchar_t *s2, size_t n) {\n    while (n > 0) {\n        wchar_t c1 = towlower(*s1);\n        wchar_t c2 = towlower(*s2);\n        if (c1 != c2) {\n            return c1 - c2;\n        }\n        if (c1 == L'\\0') {\n            return 0;\n        }\n        s1++;\n        s2++;\n        n--;\n    }\n    return 0;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str1 = L\"Hello, World!\";\n    const wchar_t *str2 = L\"HELLO, THERE!\";\n    \n    int result = wcsncasecmp(str1, str2, 5);\n    \n    if (result == 0) {\n        wprintf(L\"The first 5 characters are equal (case-insensitive)\\n\");\n    } else if (result < 0) {\n        wprintf(L\"str1 is less than str2 in the first 5 characters (case-insensitive)\\n\");\n    } else {\n        wprintf(L\"str1 is greater than str2 in the first 5 characters (case-insensitive)\\n\");\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example implements a case-insensitive version of wcsncmp and uses it to compare two wide strings.",
          "expectedOutput": "The first 5 characters are equal (case-insensitive)"
      }
  ],
  "related_functions": ["wcscmp", "wmemcmp", "strncmp"],
  "performance_considerations": "wcsncmp is generally efficient for comparing wide strings. However, for very long strings where only a small prefix needs to be compared, it can be more efficient than wcscmp. For performance-critical applications, consider using wmemcmp if you know the exact number of wide characters to compare."
},
{
  "function_name": "wcsncpy",
  "include_file": "wchar.h",
  "return_type": "wchar_t*",
  "parameter_types": ["wchar_t*", "const wchar_t*", "size_t"],
  "main_category": "String Operations",
  "sub_category": "Manipulation",
  "data_type_manipulated": "wide characters",
  "description": "Copies a specified number of characters from one wide character string to another, ensuring that the destination string will not be overrun.",
  "extended_description": "wcsncpy copies at most n wide characters from the wide string pointed to by src to the wide string pointed to by dest. If the length of src is less than n, the remainder of dest will be padded with null wide characters. If the length of src is greater than or equal to n, dest may not be null-terminated.",
  "return_value": "Returns a pointer to the destination string dest.",
  "parameter_values": "dest: Pointer to the destination array where the content is to be copied. src: Pointer to the source of data to be copied. n: Maximum number of wide characters to be copied.",
  "function_prototype": "wchar_t *wcsncpy(wchar_t *dest, const wchar_t *src, size_t n);",
  "examples": [
      {
          "title": "Basic Usage of wcsncpy",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t src[] = L\"Hello, World!\";\n    wchar_t dest[20];\n    \n    wcsncpy(dest, src, 5);\n    dest[5] = L'\\0';  // Ensure null-termination\n    \n    wprintf(L\"Source: %ls\\n\", src);\n    wprintf(L\"Destination: %ls\\n\", dest);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcsncpy to copy a portion of a wide string.",
          "expectedOutput": "Source: Hello, World!\nDestination: Hello"
      },
      {
          "title": "Handling Short Source Strings",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t src[] = L\"Short\";\n    wchar_t dest[10];\n    \n    wcsncpy(dest, src, sizeof(dest)/sizeof(wchar_t));\n    \n    wprintf(L\"Source: %ls\\n\", src);\n    wprintf(L\"Destination: %ls\\n\", dest);\n    \n    for (int i = 0; i < 10; i++) {\n        wprintf(L\"dest[%d] = %d\\n\", i, dest[i]);\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example shows how wcsncpy pads the destination with null wide characters when the source string is shorter than the specified length.",
          "expectedOutput": "Source: Short\nDestination: Short\ndest[0] = 83\ndest[1] = 104\ndest[2] = 111\ndest[3] = 114\ndest[4] = 116\ndest[5] = 0\ndest[6] = 0\ndest[7] = 0\ndest[8] = 0\ndest[9] = 0"
      },
      {
          "title": "Implementing a Safe String Copy",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nwchar_t* safe_wcsncpy(wchar_t *dest, size_t dest_size, const wchar_t *src, size_t count) {\n    if (dest == NULL || src == NULL || dest_size == 0) {\n        return NULL;\n    }\n    \n    size_t to_copy = (count < dest_size) ? count : dest_size - 1;\n    wcsncpy(dest, src, to_copy);\n    dest[to_copy] = L'\\0';\n    \n    return dest;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t src[] = L\"This is a very long source string\";\n    wchar_t dest[15];\n    \n    safe_wcsncpy(dest, sizeof(dest)/sizeof(wchar_t), src, wcslen(src));\n    \n    wprintf(L\"Source: %ls\\n\", src);\n    wprintf(L\"Destination: %ls\\n\", dest);\n    wprintf(L\"Destination length: %zu\\n\", wcslen(dest));\n    \n    return 0;\n}\n",
          "explanation": "This example implements a safe version of wcsncpy that ensures the destination string is always null-terminated and does not overflow the buffer.",
          "expectedOutput": "Source: This is a very long source string\nDestination: This is a very\nDestination length: 14"
      }
  ],
  "related_functions": ["wcscpy", "wmemcpy", "strncpy"],
  "performance_considerations": "wcsncpy is generally efficient for copying wide strings. However, it always writes exactly n wide characters to the destination, which can be inefficient if the source string is much shorter than n. For performance-critical applications, consider using wmemcpy if you know the exact number of wide characters to copy, or implement a custom copy function that stops at the null terminator."
},
{
  "function_name": "wcspbrk",
  "include_file": "wchar.h",
  "return_type": "wchar_t*",
  "parameter_types": ["const wchar_t*", "const wchar_t*"],
  "main_category": "String Operations",
  "sub_category": "Search",
  "data_type_manipulated": "wide characters",
  "description": "Searches a wide character string for the first occurrence of any of the characters that are part of another wide character string.",
  "extended_description": "wcspbrk scans the wide string s1 for the first occurrence of any of the wide characters that are part of s2. The search does not include the terminating null characters.",
  "return_value": "Returns a pointer to the first occurrence in s1 of any of the characters in s2, or NULL if none of the characters in s2 occurs in s1.",
  "parameter_values": "s1: Pointer to the wide string to be scanned. s2: Pointer to the wide string containing the characters to match.",
  "function_prototype": "wchar_t *wcspbrk(const wchar_t *s1, const wchar_t *s2);",
  "examples": [
      {
          "title": "Basic Usage of wcspbrk",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str = L\"Hello, World!\";\n    const wchar_t *charset = L\"aeiou\";\n    \n    wchar_t *result = wcspbrk(str, charset);\n    \n    if (result) {\n        wprintf(L\"First vowel found: %lc\\n\", *result);\n        wprintf(L\"Position: %td\\n\", result - str);\n    } else {\n        wprintf(L\"No vowels found.\\n\");\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcspbrk to find the first occurrence of any vowel in a wide string.",
          "expectedOutput": "First vowel found: e\nPosition: 1"
      },
      {
          "title": "Finding Multiple Occurrences",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str = L\"Hello, World! How are you?\";\n    const wchar_t *charset = L\" ,.?!\";\n    \n    wprintf(L\"Original string: %ls\\n\", str);\n    wprintf(L\"Searching for: %ls\\n\", charset);\n    \n    const wchar_t *ptr = str;\n    while ((ptr = wcspbrk(ptr, charset)) != NULL) {\n        wprintf(L\"Found '%lc' at position %td\\n\", *ptr, ptr - str);\n        ptr++;  // Move to the next character\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example shows how to use wcspbrk in a loop to find all occurrences of specified characters in a wide string.",
          "expectedOutput": "Original string: Hello, World! How are you?\nSearching for:  ,.?!\nFound ' ' at position 5\nFound ',' at position 6\nFound ' ' at position 7\nFound '!' at position 12\nFound ' ' at position 13\nFound ' ' at position 17\nFound ' ' at position 21\nFound '?' at position 24"
      },
      {
          "title": "Custom Tokenization",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nvoid tokenize(const wchar_t *str, const wchar_t *delimiters) {\n    const wchar_t *start = str;\n    const wchar_t *end;\n    \n    while (*start) {\n        // Skip leading delimiters\n        start += wcsspn(start, delimiters);\n        if (*start == L'\\0') break;\n        \n        // Find end of current token\n        end = wcspbrk(start, delimiters);\n        if (end == NULL) end = start + wcslen(start);\n        \n        // Print the token\n        wprintf(L\"%.*ls\\n\", (int)(end - start), start);\n        \n        start = end;\n    }\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str = L\"Hello,  World! How are you?\";\n    const wchar_t *delimiters = L\" ,!?\";\n    \n    wprintf(L\"Original string: %ls\\n\", str);\n    wprintf(L\"Tokens:\\n\");\n    tokenize(str, delimiters);\n    \n    return 0;\n}\n",
          "explanation": "This example uses wcspbrk along with wcsspn to implement a custom tokenization function that splits a wide string into tokens based on specified delimiters.",
          "expectedOutput": "Original string: Hello,  World! How are you?\nTokens:\nHello\nWorld\nHow\nare\nyou"
      }
  ],
  "related_functions": ["wcscspn", "wcschr", "wcsstr"],
  "performance_considerations": "wcspbrk is generally efficient for searching multiple characters in a string. However, for very long strings or frequent searches, consider using more optimized search algorithms or pre-processing techniques if the same search needs to be performed multiple times."
},
{
  "function_name": "wcsptime",
  "include_file": "wchar.h",
  "return_type": "wchar_t*",
  "parameter_types": ["const wchar_t*", "const wchar_t*", "struct tm*"],
  "main_category": "Time and Date Management",
  "sub_category": "Time Parsing",
  "data_type_manipulated": "wide characters",
  "description": "Parses a wide character string representing a time according to a format string and stores the information in a structure.",
  "extended_description": "wcsptime converts the wide character string pointed to by buf to values which are stored in the tm structure pointed to by tm, using the format specified by format. It is the wide-character counterpart of strptime.",
  "return_value": "Returns a pointer to the first wide character following the last parsed character in buf. If the parse fails, a null pointer is returned.",
  "parameter_values": "buf: Pointer to the wide string to be parsed. format: Pointer to the wide string specifying the format of the time representation. tm: Pointer to a struct tm where the parsed time information will be stored.",
  "function_prototype": "wchar_t *wcsptime(const wchar_t *buf, const wchar_t *format, struct tm *tm);",
  "examples": [
      {
          "title": "Basic Usage of wcsptime",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <time.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *date_string = L\"2023-07-07 15:30:00\";\n    const wchar_t *format = L\"%Y-%m-%d %H:%M:%S\";\n    struct tm tm = {0};\n    \n    wchar_t *result = wcsptime(date_string, format, &tm);\n    \n    if (result) {\n        wprintf(L\"Parsed date: %04d-%02d-%02d %02d:%02d:%02d\\n\",\n                tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,\n                tm.tm_hour, tm.tm_min, tm.tm_sec);\n    } else {\n        wprintf(L\"Parsing failed\\n\");\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcsptime to parse a date and time string into a struct tm.",
          "expectedOutput": "Parsed date: 2023-07-07 15:30:00"
      },
      {
          "title": "Parsing Different Date Formats",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <time.h>\n#include <locale.h>\n\nvoid parse_date(const wchar_t *date_string, const wchar_t *format) {\n    struct tm tm = {0};\n    wchar_t *result = wcsptime(date_string, format, &tm);\n    \n    if (result) {\n        wchar_t output[100];\n        wcsftime(output, sizeof(output)/sizeof(wchar_t), L\"%A, %B %d, %Y\", &tm);\n        wprintf(L\"Input: %ls\\nParsed: %ls\\n\\n\", date_string, output);\n    } else {\n        wprintf(L\"Parsing failed for: %ls\\n\\n\", date_string);\n    }\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    parse_date(L\"2023-07-07\", L\"%Y-%m-%d\");\n    parse_date(L\"07/07/23\", L\"%d/%m/%y\");\n    parse_date(L\"July 7, 2023\", L\"%B %d, %Y\");\n    \n    return 0;\n}\n",
          "explanation": "This example shows how to use wcsptime to parse dates in different formats and then format the parsed date uniformly.",
          "expectedOutput": "Input: 2023-07-07\nParsed: Friday, July 07, 2023\n\nInput: 07/07/23\nParsed: Friday, July 07, 2023\n\nInput: July 7, 2023\nParsed: Friday, July 07, 2023"
      },
      {
          "title": "Handling Partial Parsing and Errors",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <time.h>\n#include <locale.h>\n\nvoid parse_and_check(const wchar_t *date_string, const wchar_t *format) {\n    struct tm tm = {0};\n    wchar_t *result = wcsptime(date_string, format, &tm);\n    \n    wprintf(L\"Input: %ls\\nFormat: %ls\\n\", date_string, format);\n    \n    if (result) {\n        wprintf(L\"Parsed date: %04d-%02d-%02d %02d:%02d:%02d\\n\",\n                tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,\n                tm.tm_hour, tm.tm_min, tm.tm_sec);\n        \n        if (*result != L'\\0') {\n            wprintf(L\"Remaining unparsed: %ls\\n\", result);\n        }\n    } else {\n        wprintf(L\"Parsing failed\\n\");\n    }\n    wprintf(L\"\\n\");\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    parse_and_check(L\"2023-07-07 15:30:00\", L\"%Y-%m-%d %H:%M:%S\");\n    parse_and_check(L\"2023-07-07 15:30\", L\"%Y-%m-%d %H:%M:%S\");\n    parse_and_check(L\"2023-13-07\", L\"%Y-%m-%d\");\n    parse_and_check(L\"15:30:00 2023-07-07\", L\"%H:%M:%S %Y-%m-%d\");\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates how wcsptime handles partial parsing and errors, showing how to check for successful parsing and handle remaining unparsed parts of the input string.",
          "expectedOutput": "Input: 2023-07-07 15:30:00\nFormat: %Y-%m-%d %H:%M:%S\nParsed date: 2023-07-07 15:30:00\n\nInput: 2023-07-07 15:30\nFormat: %Y-%m-%d %H:%M:%S\nParsed date: 2023-07-07 15:30:00\n\nInput: 2023-13-07\nFormat: %Y-%m-%d\nParsing failed\n\nInput: 15:30:00 2023-07-07\nFormat: %H:%M:%S %Y-%m-%d\nParsed date: 2023-07-07 15:30:00"
      }
  ],
  "related_functions": ["strptime", "wcsftime", "mktime"],
  "performance_considerations": "wcsptime is generally efficient for parsing date and time strings. However, repeated parsing of similar date strings can be inefficient. For performance-critical applications dealing with many date strings in the same format, consider creating a custom parser or using lower-level functions if appropriate."
},
{
  "function_name": "wcsrchr",
  "include_file": "wchar.h",
  "return_type": "wchar_t*",
  "parameter_types": ["const wchar_t*", "wchar_t"],
  "main_category": "String Operations",
  "sub_category": "Search",
  "data_type_manipulated": "wide characters",
  "description": "Searches for the last occurrence of a specified wide character in a wide character string.",
  "extended_description": "wcsrchr locates the last occurrence of wc in the wide-character string pointed to by ws. The terminating null wide character is considered to be part of the wide-character string.",
  "return_value": "Returns a pointer to the last occurrence of wc in ws, or NULL if wc does not occur in the string.",
  "parameter_values": "ws: Pointer to the wide-character string to be scanned. wc: Wide character to be located.",
  "function_prototype": "wchar_t *wcsrchr(const wchar_t *ws, wchar_t wc);",
  "examples": [
      {
          "title": "Basic Usage of wcsrchr",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str = L\"Hello, World! Hello, Universe!\";\n    wchar_t search_char = L'o';\n    \n    wchar_t *result = wcsrchr(str, search_char);\n    \n    if (result) {\n        wprintf(L\"Last occurrence of '%lc' found at position: %td\\n\", search_char, result - str);\n    } else {\n        wprintf(L\"Character '%lc' not found in the string.\\n\", search_char);\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcsrchr to find the last occurrence of a character in a wide string.",
          "expectedOutput": "Last occurrence of 'o' found at position: 25"
      },
      {
          "title": "Finding File Extension",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nconst wchar_t* get_file_extension(const wchar_t *filename) {\n    wchar_t *dot = wcsrchr(filename, L'.');\n    if (!dot || dot == filename) {\n        return NULL;\n    }\n    return dot + 1;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *filenames[] = {\n        L\"document.txt\",\n        L\"image.jpeg\",\n        L\"noextension\",\n        L\".hiddenfile\"\n    };\n    \n    for (int i = 0; i < 4; i++) {\n        const wchar_t *ext = get_file_extension(filenames[i]);\n        if (ext) {\n            wprintf(L\"File: %ls, Extension: %ls\\n\", filenames[i], ext);\n        } else {\n            wprintf(L\"File: %ls, No extension found\\n\", filenames[i]);\n        }\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example uses wcsrchr to implement a function that finds the file extension in a filename.",
          "expectedOutput": "File: document.txt, Extension: txt\nFile: image.jpeg, Extension: jpeg\nFile: noextension, No extension found\nFile: .hiddenfile, No extension found"
      },
      {
          "title": "Reverse Tokenization",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nvoid reverse_tokenize(const wchar_t *str, wchar_t delimiter) {\n    const wchar_t *end = str + wcslen(str);\n    const wchar_t *token_end = end;\n    \n    while (token_end > str) {\n        const wchar_t *token_start = wcsrchr(str, delimiter);\n        \n        if (token_start == NULL) {\n            token_start = str;\n        } else {\n            token_start++;\n        }\n        \n        wprintf(L\"%.*ls\\n\", (int)(token_end - token_start), token_start);\n        \n        if (token_start == str) break;\n        token_end = token_start - 1;\n    }\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str = L\"This/is/a/path/to/file.txt\";\n    \n    wprintf(L\"Original string: %ls\\n\", str);\n    wprintf(L\"Tokens in reverse order:\\n\");\n    reverse_tokenize(str, L'/');\n    \n    return 0;\n}\n",
          "explanation": "This example uses wcsrchr to implement a reverse tokenization function that splits a string from right to left based on a delimiter.",
          "expectedOutput": "Original string: This/is/a/path/to/file.txt\nTokens in reverse order:\nfile.txt\nto\npath\na\nis\nThis"
      }
  ],
  "related_functions": ["wcschr", "wcsstr", "memrchr"],
  "performance_considerations": "wcsrchr is generally efficient for finding the last occurrence of a character in a string. However, for very long strings, it may be less efficient than forward search functions like wcschr if the character is known to be near the beginning of the string. For complex search patterns or frequent searches in the same string, consider using more advanced string searching algorithms."
},
{
  "function_name": "wcsrtombs",
  "include_file": "wchar.h",
  "return_type": "size_t",
  "parameter_types": ["char*", "const wchar_t**", "size_t", "mbstate_t*"],
  "main_category": "Character Type and Conversion",
  "sub_category": "Wide Character Conversion",
  "data_type_manipulated": "characters",
  "description": "Converts a sequence of wide characters from a wide character string to a multibyte string, considering the current locale.",
  "extended_description": "wcsrtombs converts a sequence of wide characters from the array indirectly pointed to by src into a sequence of corresponding multibyte characters that begins in the initial shift state described by ps. If dst is not a null pointer, the converted characters are then stored into the array pointed to by dst. Conversion continues up to and including a terminating null wide character, which is also converted.",
  "return_value": "If dst is not NULL, returns the number of bytes in the resulting multibyte character sequence, not including the terminating null byte. If dst is NULL, returns the required size of the destination string. If an invalid wide character is encountered, (size_t)(-1) is returned and errno is set to EILSEQ.",
  "parameter_values": "dst: Pointer to a byte array where the resulting multibyte string is stored. src: Pointer to a pointer to the wide character string to be converted. len: Maximum number of bytes to be written to dst. ps: Pointer to an object of type mbstate_t that is used to keep track of the shift state.",
  "function_prototype": "size_t wcsrtombs(char *dst, const wchar_t **src, size_t len, mbstate_t *ps);",
  "examples": [
    {
        "title": "Basic Usage of wcsrtombs",
        "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n#include <string.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *wstr = L\"Hello, 世界!\";\n    const wchar_t *wp = wstr;\n    char mb[100];\n    mbstate_t mbs = {0};\n    \n    size_t result = wcsrtombs(mb, &wp, sizeof(mb), &mbs);\n    \n    if (result != (size_t)(-1)) {\n        printf(\"Converted string: %s\\n\", mb);\n        printf(\"Number of bytes written: %zu\\n\", result);\n    } else {\n        printf(\"Conversion error\\n\");\n    }\n    \n    return 0;\n}\n",
        "explanation": "This example demonstrates the basic usage of wcsrtombs to convert a wide character string to a multibyte string.",
        "expectedOutput": "Converted string: Hello, 世界!\nNumber of bytes written: 13\n(Note: The actual byte count may vary depending on the locale)"
    },
    {
        "title": "Conversion with NULL Destination",
        "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *wstr = L\"Hello, 世界!\";\n    const wchar_t *wp = wstr;\n    mbstate_t mbs = {0};\n    \n    size_t required_size = wcsrtombs(NULL, &wp, 0, &mbs);\n    \n    printf(\"Required buffer size: %zu bytes\\n\", required_size + 1);  // +1 for null terminator\n    \n    char *mb = malloc(required_size + 1);\n    if (mb == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        return 1;\n    }\n    \n    wp = wstr;  // Reset the pointer\n    size_t result = wcsrtombs(mb, &wp, required_size + 1, &mbs);\n    \n    if (result != (size_t)(-1)) {\n        printf(\"Converted string: %s\\n\", mb);\n    } else {\n        printf(\"Conversion error\\n\");\n    }\n    \n    free(mb);\n    return 0;\n}\n",
        "explanation": "This example shows how to use wcsrtombs with a NULL destination to determine the required buffer size before performing the actual conversion.",
        "expectedOutput": "Required buffer size: 14 bytes\nConverted string: Hello, 世界!\n(Note: The actual byte count may vary depending on the locale)"
    },
    {
        "title": "Handling Conversion Errors",
        "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n#include <string.h>\n#include <errno.h>\n\nsize_t safe_wcsrtombs(char *dst, const wchar_t **src, size_t len) {\n    mbstate_t mbs = {0};\n    size_t result = wcsrtombs(dst, src, len, &mbs);\n    \n    if (result == (size_t)(-1)) {\n        switch (errno) {\n            case EILSEQ:\n                printf(\"Error: Invalid wide character encountered\\n\");\n                break;\n            case E2BIG:\n                printf(\"Error: Insufficient space in destination buffer\\n\");\n                break;\n            default:\n                printf(\"Unknown error occurred\\n\");\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *valid_wstr = L\"Valid string\";\n    const wchar_t *invalid_wstr = L\"Invalid \\xFFFF string\";\n    char mb[10];  // Intentionally small buffer\n    \n    printf(\"Converting valid string:\\n\");\n    safe_wcsrtombs(mb, &valid_wstr, sizeof(mb));\n    \n    printf(\"\\nConverting invalid string:\\n\");\n    safe_wcsrtombs(mb, &invalid_wstr, sizeof(mb));\n    \n    return 0;\n}\n",
        "explanation": "This example demonstrates how to handle various error conditions that may occur during the conversion process with wcsrtombs.",
        "expectedOutput": "Converting valid string:\nError: Insufficient space in destination buffer\n\nConverting invalid string:\nError: Invalid wide character encountered"
    }
],
  "related_functions": ["wcstombs", "mbsrtowcs", "mbrtowc"],
  "performance_considerations": "wcsrtombs is generally efficient for converting wide character strings to multibyte strings. However, for very long strings or frequent conversions, consider using lower-level conversion functions or maintaining both wide and multibyte versions of strings if memory usage is not a concern. The performance may also vary depending on the complexity of the locale's encoding."
},
{
  "function_name": "wcsspn",
  "include_file": "wchar.h",
  "return_type": "size_t",
  "parameter_types": ["const wchar_t*", "const wchar_t*"],
  "main_category": "String Operations",
  "sub_category": "Search",
  "data_type_manipulated": "wide characters",
  "description": "Calculates the length of the initial segment of a wide character string which consists only of characters that are part of another wide character string.",
  "extended_description": "wcsspn computes the length of the maximum initial segment of the wide-character string pointed to by s1 which consists entirely of wide-characters from the wide-character string pointed to by s2.",
  "return_value": "Returns the length of the initial substring of s1 that contains only characters found in s2.",
  "parameter_values": "s1: Pointer to the null-terminated wide string to be scanned. s2: Pointer to the null-terminated wide string containing the characters to match.",
  "function_prototype": "size_t wcsspn(const wchar_t *s1, const wchar_t *s2);",
  "examples": [
      {
          "title": "Basic Usage of wcsspn",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str = L\"12345abc789\";\n    const wchar_t *digits = L\"0123456789\";\n    \n    size_t length = wcsspn(str, digits);\n    \n    wprintf(L\"String: %ls\\n\", str);\n    wprintf(L\"Length of initial digit segment: %zu\\n\", length);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcsspn to find the length of the initial segment of a string containing only digits.",
          "expectedOutput": "String: 12345abc789\nLength of initial digit segment: 5"
      },
      {
          "title": "Using wcsspn for Input Validation",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint is_valid_identifier(const wchar_t *str) {\n    const wchar_t *valid_start = L\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_\";\n    const wchar_t *valid_chars = L\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\";\n    \n    if (*str == L'\\0' || wcsspn(str, valid_start) == 0) {\n        return 0;  // Empty string or invalid start character\n    }\n    \n    return wcsspn(str, valid_chars) == wcslen(str);\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *identifiers[] = {L\"valid_id\", L\"123invalid\", L\"also_valid_2\", L\"not valid\"};\n    int num_identifiers = sizeof(identifiers) / sizeof(identifiers[0]);\n    \n    for (int i = 0; i < num_identifiers; i++) {\n        wprintf(L\"\"%ls\" is %ls\\n\", identifiers[i], \n                is_valid_identifier(identifiers[i]) ? L\"valid\" : L\"invalid\");\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example uses wcsspn to implement a function that checks if a given string is a valid identifier (starts with a letter or underscore and contains only letters, digits, or underscores).",
          "expectedOutput": "\"valid_id\" is valid\n\"123invalid\" is invalid\n\"also_valid_2\" is valid\n\"not valid\" is invalid"
      },
      {
        "title": "Finding the First Non-Matching Character",
        "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str = L\"AAAbbbCCCddd\";\n    const wchar_t *uppercase = L\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    \n    size_t uppercase_length = wcsspn(str, uppercase);\n    \n    wprintf(L\"String: %ls\\n\", str);\n    wprintf(L\"Length of initial uppercase segment: %zu\\n\", uppercase_length);\n    \n    if (uppercase_length < wcslen(str)) {\n        wprintf(L\"First non-uppercase character: %lc\\n\", str[uppercase_length]);\n    } else {\n        wprintf(L\"All characters are uppercase\\n\");\n    }\n    \n    return 0;\n}\n",
        "explanation": "This example uses wcsspn to find the first character in a string that is not an uppercase letter, effectively segmenting the string.",
        "expectedOutput": "String: AAAbbbCCCddd\nLength of initial uppercase segment: 3\nFirst non-uppercase character: b"
    }
  ],
  "related_functions": ["wcscspn", "strspn", "wcspbrk"],
  "performance_considerations": "wcsspn is generally efficient for short strings or small character sets. For very long strings or large character sets, consider using more optimized search algorithms or pre-processing techniques if the same search needs to be performed multiple times."
},
{
  "function_name": "wcsstr",
  "include_file": "wchar.h",
  "return_type": "wchar_t*",
  "parameter_types": ["const wchar_t*", "const wchar_t*"],
  "main_category": "String Operations",
  "sub_category": "Search",
  "data_type_manipulated": "wide characters",
  "description": "Finds the first occurrence of a specified wide substring in a wide character string.",
  "extended_description": "wcsstr locates the first occurrence of the wide-character string pointed to by s2 (excluding the terminating null wide character) in the wide-character string pointed to by s1.",
  "return_value": "Returns a pointer to the located wide string, or NULL if the wide string is not found.",
  "parameter_values": "s1: Pointer to the null-terminated wide string to be scanned. s2: Pointer to the null-terminated wide string to be searched for.",
  "function_prototype": "wchar_t *wcsstr(const wchar_t *s1, const wchar_t *s2);",
  "examples": [
      {
          "title": "Basic Usage of wcsstr",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *haystack = L\"Hello, World! Welcome to the world of programming.\";\n    const wchar_t *needle = L\"World\";\n    \n    wchar_t *result = wcsstr(haystack, needle);\n    \n    if (result) {\n        wprintf(L\"Substring found: %ls\\n\", result);\n        wprintf(L\"Position: %td\\n\", result - haystack);\n    } else {\n        wprintf(L\"Substring not found\\n\");\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcsstr to find a substring within a larger string.",
          "expectedOutput": "Substring found: World! Welcome to the world of programming.\nPosition: 7"
      },
      {
          "title": "Case-Insensitive Search",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <locale.h>\n\nwchar_t *wcsistr(const wchar_t *haystack, const wchar_t *needle) {\n    size_t needle_len = wcslen(needle);\n    \n    while (*haystack) {\n        if (towlower(*haystack) == towlower(*needle)) {\n            if (wcsncasecmp(haystack, needle, needle_len) == 0) {\n                return (wchar_t *)haystack;\n            }\n        }\n        haystack++;\n    }\n    \n    return NULL;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *text = L\"This is a SAMPLE text for case-insensitive search.\";\n    const wchar_t *search = L\"sample\";\n    \n    wchar_t *result = wcsistr(text, search);\n    \n    if (result) {\n        wprintf(L\"Found: %ls\\n\", result);\n    } else {\n        wprintf(L\"Not found\\n\");\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example implements a case-insensitive version of wcsstr called wcsistr, which finds a substring regardless of case.",
          "expectedOutput": "Found: SAMPLE text for case-insensitive search."
      },
      {
          "title": "Finding Multiple Occurrences",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nvoid find_all_occurrences(const wchar_t *haystack, const wchar_t *needle) {\n    const wchar_t *ptr = haystack;\n    int count = 0;\n    \n    while ((ptr = wcsstr(ptr, needle)) != NULL) {\n        wprintf(L\"Found at position: %td\\n\", ptr - haystack);\n        ptr += wcslen(needle);\n        count++;\n    }\n    \n    wprintf(L\"Total occurrences: %d\\n\", count);\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *text = L\"The quick brown fox jumps over the lazy dog. The fox is quick.\";\n    const wchar_t *search = L\"quick\";\n    \n    wprintf(L\"Searching for \"%ls\" in:\\n%ls\\n\\n\", search, text);\find_all_occurrences(text, search);\n    \n    return 0;\n}\n",
          "explanation": "This example uses wcsstr in a loop to find all occurrences of a substring within a larger string.",
          "expectedOutput": "Searching for \"quick\" in:\nThe quick brown fox jumps over the lazy dog. The fox is quick.\n\nFound at position: 4\nFound at position: 55\nTotal occurrences: 2"
      }
  ],
  "related_functions": ["wcschr", "wcsrchr", "strstr"],
  "performance_considerations": "wcsstr uses a simple string matching algorithm and can be inefficient for very long strings or when searching for multiple patterns. For more complex search requirements or performance-critical applications, consider using more advanced string matching algorithms like Boyer-Moore or Knuth-Morris-Pratt, especially if the same pattern is searched for multiple times."
},
{
  "function_name": "wcstod",
  "include_file": "wchar.h",
  "return_type": "double",
  "parameter_types": ["const wchar_t*", "wchar_t**"],
  "main_category": "Data Conversion and Formatting",
  "sub_category": "Type Conversion",
  "data_type_manipulated": "floating-point numbers",
  "description": "Converts the initial portion of a wide character string to a double-precision floating-point number.",
  "extended_description": "wcstod interprets the wide-character string pointed to by nptr, producing a double value as a result. It skips leading whitespace, recognizes an optional plus or minus sign, and then parses the longest sequence of characters that form a valid floating-point representation.",
  "return_value": "Returns the converted double value. If no conversion can be performed, 0.0 is returned. If the correct value would cause overflow, HUGE_VAL (with the proper sign) is returned. If the correct value would cause underflow, a value whose magnitude is no greater than the smallest normalized positive number is returned.",
  "parameter_values": "nptr: Pointer to the wide-character string to be converted. endptr: Pointer to a pointer to wchar_t, which will be updated to point to the character immediately following the last character used in the conversion.",
  "function_prototype": "double wcstod(const wchar_t *nptr, wchar_t **endptr);",
  "examples": [
      {
          "title": "Basic Usage of wcstod",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str = L\"3.14159 is PI\";\n    wchar_t *endptr;\n    \n    double value = wcstod(str, &endptr);\n    \n    wprintf(L\"Parsed value: %f\\n\", value);\n    wprintf(L\"Remaining string: %ls\\n\", endptr);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcstod to convert a wide string to a double value.",
          "expectedOutput": "Parsed value: 3.141590\nRemaining string:  is PI"
      },
      {
          "title": "Handling Invalid Input",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n#include <errno.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *valid = L\"123.45\";\n    const wchar_t *invalid = L\"not a number\";\n    wchar_t *endptr;\n    \n    errno = 0;\n    double value1 = wcstod(valid, &endptr);\n    if (errno == 0 && *endptr == L'\\0') {\n        wprintf(L\"Valid conversion: %f\\n\", value1);\n    } else {\n        wprintf(L\"Conversion error for valid input\\n\");\n    }\n    \n    errno = 0;\n    double value2 = wcstod(invalid, &endptr);\n    if (errno == 0 && *endptr == L'\\0') {\n        wprintf(L\"Invalid conversion: %f\\n\", value2);\n    } else {\n        wprintf(L\"Conversion error for invalid input\\n\");\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example shows how to handle both valid and invalid inputs when using wcstod, including checking for conversion errors.",
          "expectedOutput": "Valid conversion: 123.450000\nConversion error for invalid input"
      },
      {
          "title": "Parsing Multiple Numbers",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str = L\"10.5 -3.7 2.0e3 0.0001\";\n    wchar_t *endptr;\n    double sum = 0.0;\n    \n    wprintf(L\"Parsing: %ls\\n\", str);\n    \n    while (*str) {\n        double value = wcstod(str, &endptr);\n        if (str == endptr) {\n            // No conversion performed, move to next character\n            str++;\n        } else {\n            sum += value;\n            str = endptr;\n            wprintf(L\"Parsed: %f, Running sum: %f\\n\", value, sum);\n        }\n    }\n    \n    wprintf(L\"Total sum: %f\\n\", sum);\n    \n    return 0;\n}\n",
          "explanation": "This example uses wcstod in a loop to parse multiple numbers from a single string and calculate their sum.",
          "expectedOutput": "Parsing: 10.5 -3.7 2.0e3 0.0001\nParsed: 10.500000, Running sum: 10.500000\nParsed: -3.700000, Running sum: 6.800000\nParsed: 2000.000000, Running sum: 2006.800000\nParsed: 0.000100, Running sum: 2006.800100\nTotal sum: 2006.800100"
      }
  ],
  "related_functions": ["wcstof", "wcstold", "strtod"],
  "performance_considerations": "wcstod is generally efficient for converting wide character strings to double values. However, for performance-critical applications that need to parse many floating-point numbers, consider using specialized parsing libraries or techniques. Also, be aware that the exact behavior of wcstod can depend on the current locale settings."
},
{
    "function_name": "wcstod32",
    "include_file": "wchar.h",
    "return_type": "_Decimal32",
    "parameter_types": ["const wchar_t*", "wchar_t**"],
    "main_category": "Data Conversion and Formatting",
    "sub_category": "Type Conversion",
    "data_type_manipulated": "decimal floating-point",
    "description": "Converts the initial portion of a wide character string to a decimal floating-point number with 32-bit precision.",
    "extended_description": "wcstod32 converts the initial portion of the wide-character string pointed to by nptr to a _Decimal32 representation. It follows the same rules as wcstod but produces a decimal floating-point result with 32-bit precision.",
    "return_value": "Returns the converted _Decimal32 value. If no conversion could be performed, 0.0 is returned. If the correct value is outside the range of representable values, ±HUGE_VAL_D32 is returned (according to the sign of the value), and the value of the macro ERANGE is stored in errno.",
    "parameter_values": "nptr: Pointer to the wide-character string to be converted. endptr: Pointer to a pointer to wchar_t, which will be updated to point to the character immediately following the last character used in the conversion.",
    "function_prototype": "_Decimal32 wcstod32(const wchar_t * restrict nptr, wchar_t ** restrict endptr);",
    "examples": [
        {
            "title": "Basic Usage of wcstod32",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\n#ifdef __STDC_WANT_DEC_FP__\n#include <decimal.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str = L\"3.14159\";\n    wchar_t *endptr;\n    \n    _Decimal32 value = wcstod32(str, &endptr);\n    \n    printf(\"Parsed value: %.5Hf\\n\", value);\n    wprintf(L\"Remaining string: %ls\\n\", endptr);\n    \n    return 0;\n}\n#else\nint main() {\n    printf(\"Decimal floating-point not supported\\n\");\n    return 0;\n}\n#endif\n",
            "explanation": "This example demonstrates the basic usage of wcstod32 to convert a wide string to a _Decimal32 value. Note that decimal floating-point support is optional and may not be available on all systems.",
            "expectedOutput": "Parsed value: 3.14159\nRemaining string: "
        },
        {
            "title": "Handling Precision and Rounding",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\n#ifdef __STDC_WANT_DEC_FP__\n#include <decimal.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str1 = L\"3.14159265358979323846\";\n    const wchar_t *str2 = L\"1.23456789\";\n    wchar_t *endptr;\n    \n    _Decimal32 value1 = wcstod32(str1, &endptr);\n    _Decimal32 value2 = wcstod32(str2, &endptr);\n    \n    printf(\"Value 1: %.7Hf\\n\", value1);\n    printf(\"Value 2: %.7Hf\\n\", value2);\n    \n    _Decimal32 sum = value1 + value2;\n    printf(\"Sum: %.7Hf\\n\", sum);\n    \n    return 0;\n}\n#else\nint main() {\n    printf(\"Decimal floating-point not supported\\n\");\n    return 0;\n}\n#endif\n",
            "explanation": "This example shows how wcstod32 handles precision and rounding when converting to _Decimal32, which has limited precision compared to the input strings.",
            "expectedOutput": "Value 1: 3.1415927\nValue 2: 1.2345679\nSum: 4.3761606"
        },
        {
            "title": "Error Handling with wcstod32",
            "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n#include <errno.h>\n\n#ifdef __STDC_WANT_DEC_FP__\n#include <decimal.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *valid = L\"123.45\";\n    const wchar_t *invalid = L\"not a number\";\n    const wchar_t *overflow = L\"1.0e1000\";\n    wchar_t *endptr;\n    \n    errno = 0;\n    _Decimal32 value1 = wcstod32(valid, &endptr);\n    if (errno == 0 && *endptr == L'\\0') {\n        printf(\"Valid conversion: %.2Hf\\n\", value1);\n    } else {\n        wprintf(L\"Conversion error for valid input\\n\");\n    }\n    \n    errno = 0;\n    _Decimal32 value2 = wcstod32(invalid, &endptr);\n    if (errno == 0 && *endptr == L'\\0') {\n        printf(\"Invalid conversion: %.2Hf\\n\", value2);\n    } else {\n        wprintf(L\"Conversion error for invalid input\\n\");\n    }\n    \n    errno = 0;\n    _Decimal32 value3 = wcstod32(overflow, &endptr);\n    if (errno == ERANGE) {\n        wprintf(L\"Overflow detected\\n\");} else {\n        printf(\"Overflow value: %.2Hf\\n\", value3);\n    }\n    \n    return 0;\n}\n#else\nint main() {\n    printf(\"Decimal floating-point not supported\\n\");\n    return 0;\n}\n#endif\n",
            "explanation": "This example demonstrates error handling with wcstod32, including checking for conversion errors and handling overflow conditions.",
            "expectedOutput": "Valid conversion: 123.45\nConversion error for invalid input\nOverflow detected"
        }
    ],
    "related_functions": ["wcstod", "wcstod64", "wcstod128"],
    "performance_considerations": "wcstod32 is generally efficient for converting wide character strings to _Decimal32 values. However, decimal floating-point operations may be slower than binary floating-point operations on some systems. For performance-critical applications, consider using binary floating-point types if exact decimal representation is not required."
},
{
  "function_name": "wcstod64",
  "include_file": "wchar.h",
  "return_type": "_Decimal64",
  "parameter_types": ["const wchar_t*", "wchar_t**"],
  "main_category": "Data Conversion and Formatting",
  "sub_category": "Type Conversion",
  "data_type_manipulated": "decimal floating-point",
  "description": "Converts the initial portion of a wide character string to a decimal floating-point number with 64-bit precision.",
  "extended_description": "wcstod64 converts the initial portion of the wide-character string pointed to by nptr to a _Decimal64 representation. It follows similar rules to wcstod but produces a decimal floating-point result with 64-bit precision.",
  "return_value": "Returns the converted _Decimal64 value. If no conversion could be performed, 0.0 is returned. If the correct value is outside the range of representable values, ±HUGE_VAL_D64 is returned (according to the sign of the value), and the value of the macro ERANGE is stored in errno.",
  "parameter_values": "nptr: Pointer to the wide-character string to be converted. endptr: Pointer to a pointer to wchar_t, which will be updated to point to the character immediately following the last character used in the conversion.",
  "function_prototype": "_Decimal64 wcstod64(const wchar_t * restrict nptr, wchar_t ** restrict endptr);",
  "examples": [
      {
          "title": "Basic Usage of wcstod64",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\n#ifdef __STDC_WANT_DEC_FP__\n#include <decimal.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str = L\"3.14159265358979323846\";\n    wchar_t *endptr;\n    \n    _Decimal64 value = wcstod64(str, &endptr);\n    \n    printf(\"Parsed value: %.16Df\\n\", value);\n    wprintf(L\"Remaining string: %ls\\n\", endptr);\n    \n    return 0;\n}\n#else\nint main() {\n    printf(\"Decimal floating-point not supported\\n\");\n    return 0;\n}\n#endif\n",
          "explanation": "This example demonstrates the basic usage of wcstod64 to convert a wide string to a _Decimal64 value, showing its higher precision compared to wcstod32.",
          "expectedOutput": "Parsed value: 3.1415926535897932\nRemaining string: "
      },
      {
          "title": "Handling Large and Small Numbers",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n#include <errno.h>\n\n#ifdef __STDC_WANT_DEC_FP__\n#include <decimal.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *large = L\"1.23456789e200\";\n    const wchar_t *small = L\"1.23456789e-200\";\n    wchar_t *endptr;\n    \n    errno = 0;\n    _Decimal64 large_value = wcstod64(large, &endptr);\n    if (errno == 0) {\n        printf(\"Large value: %.8De\\n\", large_value);\n    } else {\n        printf(\"Error converting large value\\n\");\n    }\n    \n    errno = 0;\n    _Decimal64 small_value = wcstod64(small, &endptr);\n    if (errno == 0) {\n        printf(\"Small value: %.8De\\n\", small_value);\n    } else {\n        printf(\"Error converting small value\\n\");\n    }\n    \n    return 0;\n}\n#else\nint main() {\n    printf(\"Decimal floating-point not supported\\n\");\n    return 0;\n}\n#endif\n",
          "explanation": "This example shows how wcstod64 handles very large and very small numbers, demonstrating its wide range of representable values.",
          "expectedOutput": "Large value: 1.23456789e+200\nSmall value: 1.23456789e-200"
      },
      {
          "title": "Comparing wcstod64 with wcstod",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\n#ifdef __STDC_WANT_DEC_FP__\n#include <decimal.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str = L\"0.1 + 0.2\";\n    wchar_t *endptr;\n    \n    double binary_sum = wcstod(str, &endptr) + wcstod(endptr + 3, NULL);\n    \n    _Decimal64 decimal_sum = wcstod64(str, &endptr) + wcstod64(endptr + 3, NULL);\n    \n    printf(\"Binary result:  %.20f\\n\", binary_sum);\n    printf(\"Decimal result: %.20Df\\n\", decimal_sum);\n    \n    return 0;\n}\n#else\nint main() {\n    printf(\"Decimal floating-point not supported\\n\");\n    return 0;\n}\n#endif\n",
          "explanation": "This example compares the results of wcstod64 with wcstod, highlighting the difference in precision and representation between binary and decimal floating-point types.",
          "expectedOutput": "Binary result:  0.30000000000000004441\nDecimal result: 0.30000000000000000000"
      }
  ],
  "related_functions": ["wcstod", "wcstod32", "wcstod128"],
  "performance_considerations": "wcstod64 provides higher precision than wcstod32 but may be slower and use more memory. Consider the trade-off between precision and performance when choosing between different decimal floating-point types."
},
{
  "function_name": "wcstod128",
  "include_file": "wchar.h",
  "return_type": "_Decimal128",
  "parameter_types": ["const wchar_t*", "wchar_t**"],
  "main_category": "Data Conversion and Formatting",
  "sub_category": "Type Conversion",
  "data_type_manipulated": "decimal floating-point",
  "description": "Converts the initial portion of a wide character string to a decimal floating-point number with 128-bit precision.",
  "extended_description": "wcstod128 converts the initial portion of the wide-character string pointed to by nptr to a _Decimal128 representation. It follows similar rules to wcstod but produces a decimal floating-point result with 128-bit precision, offering the highest precision among decimal floating-point types.",
  "return_value": "Returns the converted _Decimal128 value. If no conversion could be performed, 0.0 is returned. If the correct value is outside the range of representable values, ±HUGE_VAL_D128 is returned (according to the sign of the value), and the value of the macro ERANGE is stored in errno.",
  "parameter_values": "nptr: Pointer to the wide-character string to be converted. endptr: Pointer to a pointer to wchar_t, which will be updated to point to the character immediately following the last character used in the conversion.",
  "function_prototype": "_Decimal128 wcstod128(const wchar_t * restrict nptr, wchar_t ** restrict endptr);",
  "examples": [
      {
          "title": "Basic Usage of wcstod128",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\n#ifdef __STDC_WANT_DEC_FP__\n#include <decimal.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str = L\"3.14159265358979323846264338327950288\";\n    wchar_t *endptr;\n    \n    _Decimal128 value = wcstod128(str, &endptr);\n    \n    printf(\"Parsed value: %.34DDf\\n\", value);\n    wprintf(L\"Remaining string: %ls\\n\", endptr);\n    \n    return 0;\n}\n#else\nint main() {\n    printf(\"Decimal floating-point not supported\\n\");\n    return 0;\n}\n#endif\n",
          "explanation": "This example demonstrates the basic usage of wcstod128 to convert a wide string to a _Decimal128 value, showing its high precision capability.",
          "expectedOutput": "Parsed value: 3.1415926535897932384626433832795029\nRemaining string: "
      },
      {
          "title": "High Precision Calculations",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\n#ifdef __STDC_WANT_DEC_FP__\n#include <decimal.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *num1 = L\"1.000000000000000000000000000000001\";\n    const wchar_t *num2 = L\"0.999999999999999999999999999999999\";\n    \n    _Decimal128 value1 = wcstod128(num1, NULL);\n    _Decimal128 value2 = wcstod128(num2, NULL);\n    _Decimal128 diff = value1 - value2;\n    \n    printf(\"Difference: %.36DDf\\n\", diff);\n    \n    return 0;\n}\n#else\nint main() {\n    printf(\"Decimal floating-point not supported\\n\");\n    return 0;\n}\n#endif\n",
          "explanation": "This example showcases the high precision capabilities of _Decimal128 by performing a subtraction that requires many decimal places of precision.",
          "expectedOutput": "Difference: 0.000000000000000000000000000000002"
      },
      {
          "title": "Handling Scientific Notation and Error Checking",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n#include <errno.h>\n\n#ifdef __STDC_WANT_DEC_FP__\n#include <decimal.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *numbers[] = {\n        L\"1.23e-6000\",\n        L\"9.87e+6000\",\n        L\"not a number\"\n    };\n    \n    for (int i = 0; i < 3; i++) {\n        wchar_t *endptr;\n        errno = 0;\n        \n        _Decimal128 value = wcstod128(numbers[i], &endptr);\n        \n        if (errno == 0 && *endptr == L'\\0') {\n            printf(\"Converted value: %.6DDe\\n\", value);\n        } else if (errno == ERANGE) {\n            printf(\"Value out of range\\n\");} else {\n            printf(\"Conversion error\\n\");\n        }\n    }\n    \n    return 0;\n}\n#else\nint main() {\n    printf(\"Decimal floating-point not supported\\n\");\n    return 0;\n}\n#endif\n",
          "explanation": "This example demonstrates how wcstod128 handles scientific notation and various error conditions, including out-of-range values and invalid input.",
          "expectedOutput": "Value out of range\nValue out of range\nConversion error"
      }
  ],
  "related_functions": ["wcstod", "wcstod32", "wcstod64"],
  "performance_considerations": "wcstod128 offers the highest precision among decimal floating-point types, but it also has the highest memory usage and potentially the slowest performance. Use it when the extra precision is absolutely necessary, and be aware of the potential performance impact in performance-critical applications."
},
{
  "function_name": "wcstof",
  "include_file": "wchar.h",
  "return_type": "float",
  "parameter_types": ["const wchar_t*", "wchar_t**"],
  "main_category": "Data Conversion and Formatting",
  "sub_category": "Type Conversion",
  "data_type_manipulated": "floating-point numbers",
  "description": "Converts the initial portion of a wide character string to a floating-point number.",
  "extended_description": "wcstof converts the initial portion of the wide-character string pointed to by nptr to float representation. It's similar to wcstod, but returns a float instead of a double.",
  "return_value": "Returns the converted float value. If no conversion could be performed, 0.0f is returned. If the correct value is outside the range of representable values, ±HUGE_VALF is returned with the proper sign, and errno is set to ERANGE.",
  "parameter_values": "nptr: Pointer to the wide-character string to be converted. endptr: Pointer to a pointer to wchar_t, which will be updated to point to the character immediately following the last character used in the conversion.",
  "function_prototype": "float wcstof(const wchar_t *nptr, wchar_t **endptr);",
  "examples": [
      {
          "title": "Basic Usage of wcstof",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str = L\"3.14159 is pi\";\n    wchar_t *endptr;\n    \n    float value = wcstof(str, &endptr);\n    \n    wprintf(L\"Parsed value: %f\\n\", value);\n    wprintf(L\"Remaining string: %ls\\n\", endptr);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcstof to convert a wide string to a float value.",
          "expectedOutput": "Parsed value: 3.141590\nRemaining string:  is pi"
      },
      {
          "title": "Handling Invalid Input",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n#include <errno.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *valid = L\"123.45\";\n    const wchar_t *invalid = L\"not a number\";\n    wchar_t *endptr;\n    \n    errno = 0;\n    float value1 = wcstof(valid, &endptr);\n    if (errno == 0 && *endptr == L'\\0') {\n        wprintf(L\"Valid conversion: %f\\n\", value1);\n    } else {\n        wprintf(L\"Conversion error for valid input\\n\");\n    }\n    \n    errno = 0;\n    float value2 = wcstof(invalid, &endptr);\n    if (errno == 0 && *endptr == L'\\0') {\n        wprintf(L\"Invalid conversion: %f\\n\", value2);\n    } else {\n        wprintf(L\"Conversion error for invalid input\\n\");\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example shows how to handle both valid and invalid inputs when using wcstof, including checking for conversion errors.",
          "expectedOutput": "Valid conversion: 123.450000\nConversion error for invalid input"
      },
      {
          "title": "Handling Overflow and Underflow",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n#include <errno.h>\n#include <float.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *overflow = L\"1e+50\";\n    const wchar_t *underflow = L\"1e-50\";\n    wchar_t *endptr;\n    \n    errno = 0;\n    float value1 = wcstof(overflow, &endptr);\n    if (errno == ERANGE) {\n        wprintf(L\"Overflow detected: %f\\n\", value1);\n    } else {\n        wprintf(L\"Overflow value: %f\\n\", value1);\n    }\n    \n    errno = 0;\n    float value2 = wcstof(underflow, &endptr);\n    if (errno == ERANGE) {\n        wprintf(L\"Underflow detected: %f\\n\", value2);\n    } else {\n        wprintf(L\"Underflow value: %f\\n\", value2);\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates how wcstof handles overflow and underflow conditions.",
          "expectedOutput": "Overflow detected: inf\nUnderflow detected: 0.000000"
      }
  ],
  "related_functions": ["wcstod", "wcstold", "strtof"],
  "performance_considerations": "wcstof is generally efficient for converting wide character strings to float values. However, it may be less precise than wcstod for very large or small numbers due to the limited range and precision of the float type."
},
{
  "function_name": "wcstok",
  "include_file": "wchar.h",
  "return_type": "wchar_t*",
  "parameter_types": ["wchar_t*", "const wchar_t*", "wchar_t**"],
  "main_category": "String Operations",
  "sub_category": "Tokenization",
  "data_type_manipulated": "wide characters",
  "description": "Tokenizes a wide character string using specified delimiters, storing the context.",
  "extended_description": "wcstok breaks the wide string pointed to by s1 into a sequence of tokens, each of which is delimited by one or more characters from the wide string pointed to by s2. The first call to wcstok should have s1 as its first argument. Subsequent calls to break the same string should have NULL as their first argument. The separator string s2 may be different for each call. The parsing state is stored in the pointer pointed to by ptr between calls.",
  "return_value": "Returns a pointer to the next token, or NULL if there are no more tokens.",
  "parameter_values": "s1: Pointer to the wide string to tokenize (or NULL for subsequent calls). s2: Pointer to the wide string containing delimiter characters. ptr: Pointer to a wchar_t* variable that stores the parsing state between calls.",
  "function_prototype": "wchar_t *wcstok(wchar_t *s1, const wchar_t *s2, wchar_t **ptr);",
  "examples": [
      {
          "title": "Basic Usage of wcstok",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t str[] = L\"Hello,World;How are:you\";\n    const wchar_t *delim = L\",;:\";\n    wchar_t *token;\n    wchar_t *context;\n    \n    token = wcstok(str, delim, &context);\n    while (token != NULL) {\n        wprintf(L\"%ls\\n\", token);\n        token = wcstok(NULL, delim, &context);\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcstok to tokenize a wide string using multiple delimiters.",
          "expectedOutput": "Hello\nWorld\nHow are\nyou"
      },
      {
          "title": "Tokenizing with Preservation of Delimiters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t str[] = L\"abc,,def;;;ghi::jkl\";\n    const wchar_t *delim = L\",;:\";\n    wchar_t *token;\n    wchar_t *context;\n    wchar_t *prev = str;\n    \n    token = wcstok(str, delim, &context);\n    while (token != NULL) {\n        if (token != prev) {\n            wprintf(L\"Delimiter: %lc\\n\", *(token - 1));\n        }\n        wprintf(L\"Token: %ls\\n\", token);\n        prev = token + wcslen(token) + 1;\n        token = wcstok(NULL, delim, &context);\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example shows how to preserve and identify the delimiters while tokenizing.",
          "expectedOutput": "Token: abc\nDelimiter: ,\nToken: def\nDelimiter: ;\nToken: ghi\nDelimiter: :\nToken: jkl"
      },
      {
          "title": "Tokenizing Multiple Strings",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nvoid tokenize(wchar_t *str, const wchar_t *delim) {\n    wchar_t *token;\n    wchar_t *context;\n    \n    token = wcstok(str, delim, &context);\n    while (token != NULL) {\n        wprintf(L\"%ls\\n\", token);\n        token = wcstok(NULL, delim, &context);\n    }\n    wprintf(L\"\\n\");\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    wchar_t str1[] = L\"First,string;to tokenize\";\n    wchar_t str2[] = L\"Second:string,to;tokenize\";\n    const wchar_t *delim = L\",;:\";\n    \n    wprintf(L\"Tokenizing first string:\\n\");\n    tokenize(str1, delim);\n    \n    wprintf(L\"Tokenizing second string:\\n\");\n    tokenize(str2, delim);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates how to use wcstok to tokenize multiple strings independently.",
          "expectedOutput": "Tokenizing first string:\nFirst\nstring\nto tokenize\n\nTokenizing second string:\nSecond\nstring\nto\ntokenize\n"
      }
  ],
  "related_functions": ["strtok", "wcstok_s", "wcsstr"],
  "performance_considerations": "wcstok modifies the original string, which can be inefficient for large strings or when the original string needs to be preserved. For thread-safe operations or when performance is critical, consider using wcstok_s or implementing custom tokenization functions."
},
{
  "function_name": "wcstol",
  "include_file": "wchar.h",
  "return_type": "long",
  "parameter_types": ["const wchar_t*", "wchar_t**", "int"],
  "main_category": "Data Conversion and Formatting",
  "sub_category": "Type Conversion",
  "data_type_manipulated": "integers",
  "description": "Converts the initial portion of a wide character string to a long integer.",
  "extended_description": "wcstol converts the initial portion of the wide-character string pointed to by nptr to a long integer representation. It skips leading whitespace, recognizes an optional sign, and converts the subsequent sequence of digits. The conversion is done according to the given base, which must be between 2 and 36 inclusive, or be the special value 0.",
  "return_value": "Returns the converted value, if any. If no conversion could be performed, 0 is returned. If the correct value is outside the range of representable values, LONG_MAX or LONG_MIN is returned, and errno is set to ERANGE.",
  "parameter_values": "nptr: Pointer to the wide-character string to be converted. endptr: Pointer to a pointer to wchar_t, which will be updated to point to the character immediately following the last character used in the conversion. base: An integer value that determines the base used in interpreting the string. If 0, the base is determined by the format of the string.",
  "function_prototype": "long wcstol(const wchar_t *nptr, wchar_t **endptr, int base);",
  "examples": [
      {
          "title": "Basic Usage of wcstol",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str = L\"1234567 with words\";\n    wchar_t *endptr;\n    \n    long value = wcstol(str, &endptr, 10);\n    \n    wprintf(L\"Converted value: %ld\\n\", value);\n    wprintf(L\"Remaining string: %ls\\n\", endptr);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcstol to convert a wide string to a long integer.",
          "expectedOutput": "Converted value: 1234567\nRemaining string:  with words"
      },
      {
          "title": "Using Different Bases",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *hex = L\"0xFF\";\n    const wchar_t *oct = L\"0777\";\n    const wchar_t *bin = L\"1010\";\n    \n    wprintf(L\"Hex (0xFF): %ld\\n\", wcstol(hex, NULL, 16));\n    wprintf(L\"Oct (0777): %ld\\n\", wcstol(oct, NULL, 8));\n    wprintf(L\"Bin (1010): %ld\\n\", wcstol(bin, NULL, 2));\n    \n    return 0;\n}\n",
          "explanation": "This example shows how to use wcstol with different bases for hexadecimal, octal, and binary conversions.",
          "expectedOutput": "Hex (0xFF): 255\nOct (0777): 511\nBin (1010): 10"
      },
      {
          "title": "Error Handling",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n#include <errno.h>\n#include <limits.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *valid = L\"123456789\";\n    const wchar_t *invalid = L\"not a number\";\n    const wchar_t *overflow = L\"99999999999999999999\";\n    wchar_t *endptr;\n    \n    errno = 0;\n    long value1 = wcstol(valid, &endptr, 10);\n    if (errno == 0 && *endptr == L'\\0') {\n        wprintf(L\"Valid conversion: %ld\\n\", value1);\n    } else {\n        wprintf(L\"Conversion error for valid input\\n\");\n    }\n    \n    errno = 0;\n    long value2 = wcstol(invalid, &endptr, 10);\n    if (errno == 0 && *endptr == L'\\0') {\n        wprintf(L\"Invalid conversion: %ld\\n\", value2);\n    } else {\n        wprintf(L\"Conversion error for invalid input\\n\");\n    }\n    \n    errno = 0;\n    long value3 = wcstol(overflow, &endptr, 10);\n    if (errno == ERANGE) {\n        wprintf(L\"Overflow detected: %ld\\n\", value3); } else {\n        wprintf(L\"Unexpected result for overflow input\\n\");\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates error handling with wcstol, including checking for conversion errors and handling overflow conditions.",
          "expectedOutput": "Valid conversion: 123456789\nConversion error for invalid input\nOverflow detected: 9223372036854775807"
      }
  ],
  "related_functions": ["wcstoll", "wcstoul", "strtol"],
  "performance_considerations": "wcstol is generally efficient for converting wide character strings to long integers. However, for performance-critical applications that need to parse many integers, consider using custom parsing techniques or specialized libraries."
},
{
  "function_name": "wcstold",
  "include_file": "wchar.h",
  "return_type": "long double",
  "parameter_types": ["const wchar_t*", "wchar_t**"],
  "main_category": "Data Conversion and Formatting",
  "sub_category": "Type Conversion",
  "data_type_manipulated": "floating-point numbers",
  "description": "Converts the initial portion of a wide character string to a long double.",
  "extended_description": "wcstold converts the initial portion of the wide-character string pointed to by nptr to a long double representation. It's similar to wcstod, but returns a long double instead of a double, providing higher precision for floating-point numbers.",
  "return_value": "Returns the converted long double value. If no conversion could be performed, 0.0 is returned. If the correct value is outside the range of representable values, ±HUGE_VALL is returned with the proper sign, and errno is set to ERANGE.",
  "parameter_values": "nptr: Pointer to the wide-character string to be converted. endptr: Pointer to a pointer to wchar_t, which will be updated to point to the character immediately following the last character used in the conversion.",
  "function_prototype": "long double wcstold(const wchar_t *nptr, wchar_t **endptr);",
  "examples": [
      {
          "title": "Basic Usage of wcstold",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str = L\"3.14159265358979323846\";\n    wchar_t *endptr;\n    \n    long double value = wcstold(str, &endptr);\n    \n    wprintf(L\"Converted value: %.20Lf\\n\", value);\n    wprintf(L\"Remaining string: %ls\\n\", endptr);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcstold to convert a wide string to a long double value, showing its high precision capability.",
          "expectedOutput": "Converted value: 3.14159265358979323846\nRemaining string: "
      },
      {
          "title": "Handling Different Number Formats",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *num1 = L\"1.23e-45\";\n    const wchar_t *num2 = L\"-0.0000000000000000000123\";\n    const wchar_t *num3 = L\"1,234,567.89\";\n    \n    wprintf(L\"Scientific notation: %.20Le\\n\", wcstold(num1, NULL));\n    wprintf(L\"Very small number: %.25Lf\\n\", wcstold(num2, NULL));\n    \n    // Note: This assumes a locale where ',' is used as a thousands separator\n    setlocale(LC_NUMERIC, \"en_US.UTF-8\");\n    wprintf(L\"Number with separators: %.2Lf\\n\", wcstold(num3, NULL));\n    \n    return 0;\n}\n",
          "explanation": "This example shows how wcstold handles different number formats, including scientific notation, very small numbers, and numbers with thousands separators (locale-dependent).",
          "expectedOutput": "Scientific notation: 1.23000000000000000000e-45\nVery small number: -0.0000000000000000000123000\nNumber with separators: 1234567.89"
      },
      {
          "title": "Error Handling and Precision Comparison",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n#include <errno.h>\n#include <float.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *num = L\"0.1234567890123456789\";\n    const wchar_t *overflow = L\"1e10000\";\n    wchar_t *endptr;\n    \n    long double ld_value = wcstold(num, &endptr);\n    double d_value = wcstod(num, &endptr);\n    \n    wprintf(L\"Long double precision: %.20Lf\\n\", ld_value);\n    wprintf(L\"Double precision: %.20f\\n\", d_value);\n    \n    errno = 0;\n    long double overflow_value = wcstold(overflow, &endptr);\n \t if (errno == ERANGE) {\n        wprintf(L\"Overflow detected: %Lf\\n\", overflow_value);\n    } else {\n        wprintf(L\"Unexpected result for overflow input\\n\");\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates error handling with wcstold, comparing its precision with wcstod, and handling overflow conditions.",
          "expectedOutput": "Long double precision: 0.12345678901234567890\nDouble precision: 0.12345678901234568000\nOverflow detected: inf"
      }
  ],
  "related_functions": ["wcstod", "wcstof", "strtold"],
  "performance_considerations": "wcstold provides the highest precision among floating-point conversion functions, but it may be slower and use more memory than wcstod or wcstof. Use it when the extra precision is necessary, and be aware of the potential performance impact in performance-critical applications."
},
{
  "function_name": "wcstombs",
  "include_file": "stdlib.h",
  "return_type": "size_t",
  "parameter_types": ["char*", "const wchar_t*", "size_t"],
  "main_category": "Character Type and Conversion",
  "sub_category": "Wide Character Conversion",
  "data_type_manipulated": "characters",
  "description": "Converts a wide character string to a multibyte character string.",
  "extended_description": "wcstombs converts a sequence of wide characters from the array pointed to by wcs to a sequence of corresponding multibyte characters that begins in the initial shift state, and stores them in the array pointed to by s. The conversion continues up to and including the terminating null wide character.",
  "return_value": "Returns the number of bytes written to the destination string. If an invalid multibyte character is encountered, (size_t)(-1) is returned.",
  "parameter_values": "s: Pointer to the destination array where the multibyte string is stored. wcs: Pointer to the wide character string to be converted. n: Maximum number of bytes to be written to s.",
  "function_prototype": "size_t wcstombs(char *s, const wchar_t *wcs, size_t n);",
  "examples": [
      {
          "title": "Basic Usage of wcstombs",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *wcs = L\"Hello, 世界!\";\n    char mbs[20];\n    size_t converted = wcstombs(mbs, wcs, sizeof(mbs));\n    \n    if (converted != (size_t)(-1)) {\n        printf(\"Converted string: %s\\n\", mbs);\n        printf(\"Number of bytes written: %zu\\n\", converted);\n } else {\n        printf(\"Conversion error\\n\");\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcstombs to convert a wide character string to a multibyte string.",
          "expectedOutput": "Converted string: Hello, 世界!\nNumber of bytes written: 13"
      },
      {
          "title": "Handling Buffer Overflow",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <wchar.h>\n#include <locale.h>\n#include <string.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *wcs = L\"This is a long string that won't fit in the buffer\";\n    char mbs[20];\n    size_t converted = wcstombs(mbs, wcs, sizeof(mbs) - 1);  // Leave space for null terminator\n    \n    if (converted != (size_t)(-1)) {\n        mbs[converted] = '\\0';  // Ensure null termination\n        printf(\"Converted string: %s\\n\", mbs);\n        printf(\"Number of bytes written: %zu\\n\", converted);\n   \t \t printf(\"Original length: %zu\\n\", wcslen(wcs));\n    } else {\n \t     printf(\"Conversion error\\n\");\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example shows how to handle cases where the destination buffer is smaller than the converted string.",
          "expectedOutput": "Converted string: This is a long stri\nNumber of bytes written: 19\nOriginal length: 48"
      },
      {
          "title": "Converting Multiple Strings",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <wchar.h>\n#include <locale.h>\n\nsize_t safe_wcstombs(char *s, const wchar_t *wcs, size_t n) {\n    size_t converted = wcstombs(s, wcs, n - 1);\n    if (converted != (size_t)(-1) && converted < n) {\n        s[converted] = '\\0';\n    }\n    return converted;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *strings[] = {L\"Hello\", L\"世界\", L\"🌍\"};\n    char mbs[20];\n    \n    for (int i = 0; i < 3; i++) {\n        size_t converted = safe_wcstombs(mbs, strings[i], sizeof(mbs));\n        if (converted != (size_t)(-1)) {\n            printf(\"String %d: %s (bytes: %zu)\\n\", i + 1, mbs, converted);\n        } else {\n            printf(\"Conversion error for string %d\\n\", i + 1);\n        }\n    }\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates converting multiple wide character strings, including non-ASCII characters and emojis.",
          "expectedOutput": "String 1: Hello (bytes: 5)\nString 2: 世界 (bytes: 6)\nString 3: 🌍 (bytes: 4)"
      }
  ],
  "related_functions": ["mbstowcs", "wcsrtombs", "wcstombs_s"],
  "performance_considerations": "wcstombs is generally efficient for converting wide character strings to multibyte strings. However, for very long strings or frequent conversions, consider using wcsrtombs for more control over the conversion process. Be aware that the performance may vary depending on the complexity of the character encodings and the current locale settings."
},
{
  "function_name": "wcstoul",
  "include_file": "wchar.h",
  "return_type": "unsigned long",
  "parameter_types": ["const wchar_t*", "wchar_t**", "int"],
  "main_category": "Data Conversion and Formatting",
  "sub_category": "Type Conversion",
  "data_type_manipulated": "integers",
  "description": "Converts the initial portion of a wide character string to an unsigned long integer.",
  "extended_description": "wcstoul converts the initial portion of the wide-character string pointed to by nptr to an unsigned long integer representation. It skips leading whitespace, recognizes an optional plus or minus sign, and converts the subsequent sequence of digits. The conversion is done according to the given base, which must be between 2 and 36 inclusive, or be the special value 0.",
  "return_value": "Returns the converted value, if any. If no conversion could be performed, 0 is returned. If the correct value is outside the range of representable values, ULONG_MAX is returned, and errno is set to ERANGE.",
  "parameter_values": "nptr: Pointer to the wide-character string to be converted. endptr: Pointer to a pointer to wchar_t, which will be updated to point to the character immediately following the last character used in the conversion. base: An integer value that determines the base used in interpreting the string. If 0, the base is determined by the format of the string.",
  "function_prototype": "unsigned long wcstoul(const wchar_t *nptr, wchar_t **endptr, int base);",
  "examples": [
      {
          "title": "Basic Usage of wcstoul",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *str = L\"12345678 with words\";\n    wchar_t *endptr;\n    \n    unsigned long value = wcstoul(str, &endptr, 10);\n    \n    wprintf(L\"Converted value: %lu\\n\", value);\n    wprintf(L\"Remaining string: %ls\\n\", endptr);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcstoul to convert a wide string to an unsigned long integer.",
          "expectedOutput": "Converted value: 12345678\nRemaining string:  with words"
      },
      {
          "title": "Using Different Bases",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *hex = L\"0xFFFFFFFF\";\n    const wchar_t *oct = L\"037777777777\";\n    const wchar_t *bin = L\"11111111111111111111111111111111\";\n    \n    wprintf(L\"Hex (0xFFFFFFFF): %lu\\n\", wcstoul(hex, NULL, 0));\n    wprintf(L\"Oct (037777777777): %lu\\n\", wcstoul(oct, NULL, 0));\n    wprintf(L\"Bin (11111111111111111111111111111111): %lu\\n\", wcstoul(bin, NULL, 2));\n    \n    return 0;\n}\n",
          "explanation": "This example shows how to use wcstoul with different bases for hexadecimal, octal, and binary conversions. Note the use of base 0 for automatic base detection.",
          "expectedOutput": "Hex (0xFFFFFFFF): 4294967295\nOct (037777777777): 4294967295\nBin (11111111111111111111111111111111): 4294967295"
      },
      {
        "title": "Error Handling and Range Checking",
        "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n#include <errno.h>\n#include <limits.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *valid = L\"4294967295\";\n    const wchar_t *invalid = L\"not a number\";\n    const wchar_t *overflow = L\"18446744073709551615\";\n    wchar_t *endptr;\n    \n    errno = 0;\n    unsigned long value1 = wcstoul(valid, &endptr, 10);\n    if (errno == 0 && *endptr == L'\\0') {\n        wprintf(L\"Valid conversion: %lu\\n\", value1);\n    } else {\n        wprintf(L\"Conversion error for valid input\\n\");\n    }\n    \n    errno = 0;\n    unsigned long value2 = wcstoul(invalid, &endptr, 10);\n    if (errno == 0 && *endptr == L'\\0') {\n        wprintf(L\"Invalid conversion: %lu\\n\", value2);\n    } else {\n        wprintf(L\"Conversion error for invalid input\\n\");\n    }\n    \n    errno = 0;\n    unsigned long value3 = wcstoul(overflow, &endptr, 10);\n    if (errno == ERANGE) {\n        wprintf(L\"Overflow detected: %lu\\n\", value3);\n    } else {\n        wprintf(L\"Unexpected result for overflow input\\n\");\n    }\n    \n    return 0;\n}\n",
        "explanation": "This example demonstrates error handling with wcstoul, including checking for conversion errors and handling overflow conditions.",
        "expectedOutput": "Valid conversion: 4294967295\nConversion error for invalid input\nOverflow detected: 4294967295"
    }
  ],
  "related_functions": ["wcstol", "wcstoull", "strtoul"],
  "performance_considerations": "wcstoul is generally efficient for converting wide character strings to unsigned long integers. However, for performance-critical applications that need to parse many integers, consider using custom parsing techniques or specialized libraries. Be aware that the performance may vary depending on the input string length and the specified base."
},
{
  "function_name": "wcsxfrm",
  "include_file": "wchar.h",
  "return_type": "size_t",
  "parameter_types": ["wchar_t*", "const wchar_t*", "size_t"],
  "main_category": "String Operations",
  "sub_category": "Transformation",
  "data_type_manipulated": "wide characters",
  "description": "Transforms a wide character string such that the result of wcscmp on these transformed strings is the same as wcscoll on the original strings.",
  "extended_description": "wcsxfrm transforms the wide-character string pointed to by src and places the result into the array pointed to by dest. The transformation is such that if wcscmp is applied to two transformed strings, it returns the same result as wcscoll applied to the original strings. No more than n wide characters are placed into the resulting array pointed to by dest, including the terminating null wide character.",
  "return_value": "Returns the length of the transformed wide string (not including the terminating null wide character). If the value returned is n or more, the contents of dest are indeterminate.",
  "parameter_values": "dest: Pointer to the destination array where the transformed string is stored. src: Pointer to the source wide string to be transformed. n: Maximum number of wide characters to be written to dest.",
  "function_prototype": "size_t wcsxfrm(wchar_t *dest, const wchar_t *src, size_t n);",
  "examples": [
      {
          "title": "Basic Usage of wcsxfrm",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *src = L\"hello\";\n    wchar_t dest[10];\n    size_t len = wcsxfrm(dest, src, 10);\n    \n    wprintf(L\"Original string: %ls\\n\", src);\n    wprintf(L\"Transformed string: %ls\\n\", dest);\n    wprintf(L\"Transformed length: %zu\\n\", len);\n    \n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcsxfrm to transform a wide character string.",
          "expectedOutput": "Original string: hello\nTransformed string: hello\nTransformed length: 5"
      },
      {
          "title": "Comparing Transformed Strings",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"en_US.UTF-8\");\n    \n    const wchar_t *str1 = L\"ábc\";\n    const wchar_t *str2 = L\"abc\";\n    wchar_t xform1[10], xform2[10];\n    \n    wcsxfrm(xform1, str1, 10);\n    wcsxfrm(xform2, str2, 10);\n    \n    int cmp_orig = wcscoll(str1, str2);\n    int cmp_xform = wcscmp(xform1, xform2);\n    \n    wprintf(L\"Original strings: %ls, %ls\\n\", str1, str2);\n    wprintf(L\"wcscoll result: %d\\n\", cmp_orig);\n    wprintf(L\"wcscmp on transformed strings result: %d\\n\", cmp_xform);\n    \n    return 0;\n}\n",
          "explanation": "This example compares two strings using wcscoll and their transformed versions using wcscmp to demonstrate the equivalence.",
          "expectedOutput": "Original strings: ábc, abc\nwcscoll result: 1\nwcscmp on transformed strings result: 1"
      },
      {
          "title": "Handling Insufficient Buffer Size",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n#include <stdlib.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    \n    const wchar_t *src = L\"This is a long string for transformation\";\n    wchar_t *dest;\n    size_t len, buf_size = 1;\n    \n    do {\n        dest = (wchar_t*)malloc(buf_size * sizeof(wchar_t));\n        len = wcsxfrm(dest, src, buf_size);\n        \n        if (len >= buf_size) {\n            free(dest);\n            buf_size = len + 1;\n        }\n    } while (len >= buf_size);\n    \n    wprintf(L\"Original string: %ls\\n\", src);\n    wprintf(L\"Transformed string: %ls\\n\", dest);\n    wprintf(L\"Buffer size needed: %zu\\n\", buf_size);\n    \n    free(dest);\n    return 0;\n}\n",
          "explanation": "This example shows how to handle cases where the initial buffer size is insufficient for the transformed string.",
          "expectedOutput": "Original string: This is a long string for transformation\nTransformed string: This is a long string for transformation\nBuffer size needed: 40"
      }
  ],
  "related_functions": ["wcscmp", "wcscoll", "strxfrm"],
  "performance_considerations": "wcsxfrm can be slower than wcscmp, especially for complex locales. For performance-critical applications that require many string comparisons, consider transforming strings once and then using wcscmp for comparisons."
},
{
  "function_name": "wctob",
  "include_file": "wchar.h",
  "return_type": "int",
  "parameter_types": ["wint_t"],
  "main_category": "Character Type and Conversion",
  "sub_category": "Wide Character Conversion",
  "data_type_manipulated": "characters",
  "description": "Attempts to convert a wide character to a single-byte character.",
  "extended_description": "wctob determines whether c corresponds to a member of the extended character set whose multibyte character representation is a single byte when in the initial shift state. If so, wctob returns the single-byte representation of that character as an unsigned char converted to an int. The behavior of this function is affected by the LC_CTYPE category of the current locale.",
  "return_value": "Returns the single-byte representation of the wide character, or EOF if the wide character does not correspond to a single-byte character.",
  "parameter_values": "c: The wide character to be converted.",
  "function_prototype": "int wctob(wint_t c);",
  "examples": [
      {
          "title": "Basic Usage of wctob",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wint_t wc = L'A';\n    int result = wctob(wc);\n    if (result != EOF) {\n        printf(\"Wide character '%lc' converted to: '%c'\\n\", wc, (char)result);\n    } else {\n        printf(\"Conversion failed for '%lc'\\n\", wc);\n    }\n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wctob to convert a wide character to a single-byte character.",
          "expectedOutput": "Wide character 'A' converted to: 'A'"
      },
      {
          "title": "Handling Non-Convertible Characters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nvoid try_convert(wchar_t wc) {\n    int result = wctob(wc);\n    if (result != EOF) {\n        printf(\"'%lc' converted to: '%c'\\n\", wc, (char)result);\n    } else {\n        printf(\"'%lc' cannot be converted to a single byte\\n\", wc);\n    }\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    try_convert(L'A');\n    try_convert(L'€');\n    try_convert(L'あ');\n    return 0;\n}\n",
          "explanation": "This example shows how wctob handles both convertible and non-convertible wide characters.",
          "expectedOutput": "'A' converted to: 'A'\n'€' cannot be converted to a single byte\n'あ' cannot be converted to a single byte"
      },
      {
          "title": "Using wctob in a Loop",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *wstr = L\"Hello, 世界!\";\n    printf(\"Original: %ls\\n\", wstr);\n    printf(\"Converted: \");\n    for (int i = 0; wstr[i] != L'\\0'; i++) {\n        int result = wctob(wstr[i]);\n        if (result != EOF) {\n            putchar(result);\n        } else {\n            printf(\"[?]\");\n        }\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "explanation": "This example uses wctob in a loop to convert a wide character string, replacing non-convertible characters with a placeholder.",
          "expectedOutput": "Original: Hello, 世界!\nConverted: Hello, [?][?]!"
      }
  ],
  "related_functions": ["btowc", "mbrtowc", "wcrtomb"],
  "performance_considerations": "wctob is generally efficient for converting single characters. However, for converting entire strings, consider using dedicated string conversion functions for better performance. The behavior and performance of wctob can vary depending on the current locale settings."
},
{
  "function_name": "wctomb",
  "include_file": "stdlib.h",
  "return_type": "int",
  "parameter_types": ["char*", "wchar_t"],
  "main_category": "Character Type and Conversion",
  "sub_category": "Wide Character Conversion",
  "data_type_manipulated": "characters",
  "description": "Converts a wide character to its multibyte representation.",
  "extended_description": "wctomb converts a wide character to its multibyte character representation. It stores the multibyte character representation of wchar in the array pointed to by s (if s is not NULL). The function affects the mbstate_t object maintained internally by the function.",
  "return_value": "Returns the number of bytes that constitute the multibyte character corresponding to wchar. If s is NULL, the function returns a nonzero value if multibyte character encodings are state-dependent, and zero otherwise. If wchar is an invalid wide character, -1 is returned.",
  "parameter_values": "s: Pointer to an array of chars where the multibyte character is stored. wchar: The wide character to be converted.",
  "function_prototype": "int wctomb(char *s, wchar_t wchar);",
  "examples": [
      {
          "title": "Basic Usage of wctomb",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    char mb[MB_CUR_MAX];\n    wchar_t wc = L'A';\n    int result = wctomb(mb, wc);\n    if (result > 0) {\n        printf(\"'%lc' converted to %d bytes: \", wc, result);\n        for (int i = 0; i < result; i++) {\n            printf(\"%02X \", (unsigned char)mb[i]);\n        }\n        printf(\"\\n\");\n    } else if (result == -1) {\n        printf(\"Conversion failed\\n\");\n    }\n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wctomb to convert a wide character to its multibyte representation.",
          "expectedOutput": "'A' converted to 1 bytes: 41"
      },
      {
          "title": "Converting Non-ASCII Characters",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n#include <wchar.h>\n\nvoid convert_and_print(wchar_t wc) {\n    char mb[MB_CUR_MAX];\n    int result = wctomb(mb, wc);\n    if (result > 0) {\n        printf(\"'%lc' converted to %d bytes: \", wc, result);\n        for (int i = 0; i < result; i++) {\n            printf(\"%02X \", (unsigned char)mb[i]);\n        }\n        printf(\"\\n\");\n    } else if (result == -1) {\n        printf(\"Conversion failed for '%lc'\\n\", wc);\n    }\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    convert_and_print(L'A');\n    convert_and_print(L'€');\n    convert_and_print(L'あ');\n    return 0;\n}\n",
          "explanation": "This example shows how wctomb handles both ASCII and non-ASCII wide characters.",
          "expectedOutput": "'A' converted to 1 bytes: 41\n'€' converted to 3 bytes: E2 82 AC\n'あ' converted to 3 bytes: E3 81 82"
      },
      {
          "title": "Checking State Dependency",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    int result = wctomb(NULL, L'A');\n    if (result == 0) {\n        printf(\"Multibyte encodings are not state-dependent\\n\");\n    } else {\n        printf(\"Multibyte encodings are state-dependent\\n\");\n    }\n    return 0;\n}\n",
          "explanation": "This example demonstrates how to use wctomb to check if multibyte encodings are state-dependent in the current locale.",
          "expectedOutput": "Multibyte encodings are not state-dependent"
      }
  ],
  "related_functions": ["mblen", "mbtowc", "wcrtomb"],
  "performance_considerations": "wctomb is generally efficient for converting single wide characters. However, for converting entire strings, consider using wcsrtombs for better performance. The behavior and performance of wctomb can vary depending on the current locale settings."
},
{
  "function_name": "wctrans",
  "include_file": "wctype.h",
  "return_type": "wctrans_t",
  "parameter_types": ["const char*"],
  "main_category": "Character Type and Conversion",
  "sub_category": "Wide Character Manipulation",
  "data_type_manipulated": "wide characters",
  "description": "Returns a type that represents a class of wide characters that can be converted to each other (e.g., tolower, toupper).",
  "extended_description": "wctrans constructs a value with type wctrans_t that describes a mapping between wide characters identified by the string argument property. If property identifies a valid mapping of wide characters according to the LC_CTYPE category of the current locale, the wctrans function returns a nonzero value that is valid as the second argument to the towctrans function; otherwise, it returns zero.",
  "return_value": "Returns a value of type wctrans_t, which represents the mapping described by property. If the given property is not valid, it returns zero.",
  "parameter_values": "property: A string that identifies the mapping. Valid values are typically \"tolower\" and \"toupper\".",
  "function_prototype": "wctrans_t wctrans(const char *property);",
  "examples": [
      {
          "title": "Basic Usage of wctrans",
          "code": "#include <stdio.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wctrans_t lower_trans = wctrans(\"tolower\");\n    wctrans_t upper_trans = wctrans(\"toupper\");\n    wchar_t wc = L'A';\n    if (lower_trans != 0 && upper_trans != 0) {\n        wprintf(L\"Original: %lc\\n\", wc);\n        wprintf(L\"Lowercase: %lc\\n\", towctrans(wc, lower_trans));\n        wprintf(L\"Uppercase: %lc\\n\", towctrans(L'a', upper_trans));\n    } else {\n        wprintf(L\"Transformation not supported\\n\");\n    }\n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wctrans to obtain transformation descriptors for lowercase and uppercase conversions.",
          "expectedOutput": "Original: A\nLowercase: a\nUppercase: A"
      },
      {
          "title": "Checking for Invalid Properties",
          "code": "#include <stdio.h>\n#include <wctype.h>\n#include <locale.h>\n\nvoid check_property(const char* prop) {\n    wctrans_t trans = wctrans(prop);\n    if (trans != 0) {\n        printf(\"\\\"%s\\\" is a valid property\\n\", prop);\n    } else {\n        printf(\"\\\"%s\\\" is not a valid property\\n\", prop);\n    }\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    check_property(\"tolower\");\n    check_property(\"toupper\");\n    check_property(\"invalid\");\n    return 0;\n}\n",
          "explanation": "This example shows how to check if a given property string is valid for use with wctrans.",
          "expectedOutput": "\"tolower\" is a valid property\n\"toupper\" is a valid property\n\"invalid\" is not a valid property"
      },
      {
          "title": "Using wctrans in a Loop",
          "code": "#include <stdio.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *str = L\"Hello, World!\";\n    wctrans_t lower_trans = wctrans(\"tolower\");\n    if (lower_trans != 0) {\n        wprintf(L\"Original: %ls\\n\", str);\n        wprintf(L\"Lowercase: \");\n        for (int i = 0; str[i] != L'\\0'; i++) {\n            wprintf(L\"%lc\", towctrans(str[i], lower_trans));\n        }\n        wprintf(L\"\\n\");\n    } else {\n        wprintf(L\"Lowercase transformation not supported\\n\");\n    }\n    return 0;\n}\n",
          "explanation": "This example demonstrates using wctrans in a loop to convert an entire wide character string to lowercase.",
          "expectedOutput": "Original: Hello, World!\nLowercase: hello, world!"
      }
  ],
  "related_functions": ["towctrans", "iswctype", "wctype"],
  "performance_considerations": "wctrans is generally efficient, but it's typically called once to obtain a transformation descriptor, which is then used multiple times with towctrans. This approach is more efficient than calling a specific transformation function (like towlower) repeatedly for large amounts of text."
},
{
  "function_name": "wctype",
  "include_file": "wctype.h",
  "return_type": "wctype_t",
  "parameter_types": ["const char*"],
  "main_category": "Character Type and Conversion",
  "sub_category": "Wide Character Classification",
  "data_type_manipulated": "wide characters",
  "description": "Returns a value representing a class of wide characters according to a property name like 'alnum', 'alpha', etc.",
  "extended_description": "wctype constructs a value of type wctype_t that describes a class of wide characters identified by the string argument property. This value can be used as the second argument to the iswctype function. The wctype function determines character classes based on the LC_CTYPE category of the current locale.",
  "return_value": "Returns a value of type wctype_t that represents the character class described by property. If the given property is not valid for the current locale, it returns zero.",
  "parameter_values": "property: A string that identifies the character class. Common values include \"alnum\", \"alpha\", \"cntrl\", \"digit\", \"graph\", \"lower\", \"print\", \"punct\", \"space\", \"upper\", and \"xdigit\".",
  "function_prototype": "wctype_t wctype(const char *property);",
  "examples": [
      {
          "title": "Basic Usage of wctype",
          "code": "#include <stdio.h>\n#include <wctype.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wctype_t alpha_class = wctype(\"alpha\");\n    wctype_t digit_class = wctype(\"digit\");\n    wchar_t test_chars[] = {L'A', L'1', L'@', L'ñ'};\n    for (int i = 0; i < 4; i++) {\n        wprintf(L\"'%lc' is %salpha and %sdigit\\n\",\n                test_chars[i],\n                iswctype(test_chars[i], alpha_class) ? L\"\" : L\"not \",\n                iswctype(test_chars[i], digit_class) ? L\"\" : L\"not \");\n    }\n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wctype to create character class descriptors and test characters against these classes.",
          "expectedOutput": "'A' is alpha and not digit\n'1' is not alpha and digit\n'@' is not alpha and not digit\n'ñ' is alpha and not digit"
      },
      {
          "title": "Checking for Valid Properties",
          "code": "#include <stdio.h>\n#include <wctype.h>\n#include <locale.h>\n\nvoid check_property(const char* prop) {\n    wctype_t class_desc = wctype(prop);\n    if (class_desc != 0) {\n        printf(\"\\\"%s\\\" is a valid character class\\n\", prop);\n    } else {\n        printf(\"\\\"%s\\\" is not a valid character class\\n\", prop);\n    }\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    check_property(\"alpha\");\n    check_property(\"digit\");\n    check_property(\"invalid\");\n    return 0;\n}\n",
          "explanation": "This example shows how to check if a given property string is valid for use with wctype in the current locale.",
          "expectedOutput": "\"alpha\" is a valid character class\n\"digit\" is a valid character class\n\"invalid\" is not a valid character class"
      },
      {
          "title": "Custom Character Classification",
          "code": "#include <stdio.h>\n#include <wctype.h>\n#include <locale.h>\n\nint is_vowel(wint_t wc) {\n    static const wchar_t vowels[] = L\"aeiouAEIOU\";\n    for (int i = 0; vowels[i] != L'\\0'; i++) {\n        if (wc == vowels[i]) return 1;\n    }\n    return 0;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wctype_t alpha_class = wctype(\"alpha\");\n    const wchar_t *str = L\"Hello, World!\";\n    wprintf(L\"Vowels in \\\"%ls\\\":  \", str);\n    for (int i = 0; str[i] != L'\\0'; i++) {\n        if (iswctype(str[i], alpha_class) && is_vowel(str[i])) {\n            wprintf(L\"%lc \", str[i]);\n        }\n    }\n    wprintf(L\"\\n\");\n    return 0;\n}\n",
          "explanation": "This example combines wctype with a custom character classification function to identify vowels in a string.",
          "expectedOutput": "Vowels in \"Hello, World!\":  e o o"
      }
  ],
  "related_functions": ["iswctype", "iswalnum", "iswalpha", "iswcntrl", "iswdigit", "iswgraph", "iswlower", "iswprint", "iswpunct", "iswspace", "iswupper", "iswxdigit"],
  "performance_considerations": "wctype is typically called once to obtain a character class descriptor, which is then used multiple times with iswctype. This approach is more efficient than calling specific classification functions repeatedly for large amounts of text."
},
{
  "function_name": "wcwidth",
  "include_file": "wchar.h",
  "return_type": "int",
  "parameter_types": ["wchar_t"],
  "main_category": "Character Type and Conversion",
  "sub_category": "Wide Character Manipulation",
  "data_type_manipulated": "wide characters",
  "description": "Determines the number of column positions required for a wide character.",
  "extended_description": "wcwidth determines the number of column positions on a display device required for the wide character wc. The behavior of this function is affected by the LC_CTYPE category of the current locale.",
  "return_value": "Returns the number of column positions occupied by wc, or -1 if wc is not printable. If wc is a null wide character, it returns 0.",
  "parameter_values": "wc: The wide character to be evaluated.",
  "function_prototype": "int wcwidth(wchar_t wc);",
  "examples": [
      {
          "title": "Basic Usage of wcwidth",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t chars[] = {L'A', L'あ', L'😊', L'\\t', L'\\0'};\n    for (int i = 0; chars[i] != L'\\0'; i++) {\n        int width = wcwidth(chars[i]);\n        wprintf(L\"Character '%lc' has width: %d\\n\", chars[i], width);\n    }\n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wcwidth to determine the display width of various characters, including ASCII, non-ASCII, and control characters.",
          "expectedOutput": "Character 'A' has width: 1\nCharacter 'あ' has width: 2\nCharacter '😊' has width: 2\nCharacter '\t' has width: -1"
      },
      {
          "title": "Calculating String Display Width",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint string_width(const wchar_t *str) {\n    int total_width = 0;\n    for (int i = 0; str[i] != L'\\0'; i++) {\n        int char_width = wcwidth(str[i]);\n        if (char_width == -1) {\n            char_width = 0;  // Treat non-printable as width 0\n        }\n        total_width += char_width;\n    }\n    return total_width;\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *str1 = L\"Hello, World!\";\n    const wchar_t *str2 = L\"こんにちは世界！\";\n    wprintf(L\"Width of \\\"%ls\\\": %d\\n\", str1, string_width(str1));\n    wprintf(L\"Width of \\\"%ls\\\": %d\\n\", str2, string_width(str2));\n    return 0;\n}\n",
          "explanation": "This example uses wcwidth to calculate the total display width of wide character strings, including multi-width characters.",
          "expectedOutput": "Width of \"Hello, World!\": 13\nWidth of \"こんにちは世界！\": 14"
      },
      {
          "title": "Formatting Output with wcwidth",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nvoid print_aligned(const wchar_t *str, int field_width) {\n    int str_width = 0;\n    for (int i = 0; str[i] != L'\\0'; i++) {\n        int char_width = wcwidth(str[i]);\n        if (char_width > 0) {\n            str_width += char_width;\n        }\n    }\n    int padding = field_width - str_width;\n    if (padding > 0) {\n        wprintf(L\"%*ls\", padding, L\"\");\n    }\n    wprintf(L\"%ls\", str);\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t *strs[] = {L\"Hello\", L\"こんにちは\", L\"World\", L\"世界\"};\n    for (int i = 0; i < 4; i++) {\n        print_aligned(strs[i], 12);\n        wprintf(L\"|\\n\");\n    }\n    return 0;\n}\n",
          "explanation": "This example uses wcwidth to create a function that right-aligns text in a field of a specified width, correctly handling multi-width characters.",
          "expectedOutput": "       Hello|\n   こんにちは|\n       World|\n         世界|"
      }
  ],
  "related_functions": ["wcswidth", "setlocale"],
  "performance_considerations": "wcwidth is generally efficient for determining the display width of individual characters. For processing entire strings, consider using wcswidth for better performance. The behavior of wcwidth can vary depending on the current locale settings, which may affect performance in locale-sensitive applications."
},
{
  "function_name": "wmemchr",
  "include_file": "wchar.h",
  "return_type": "wchar_t*",
  "parameter_types": ["const wchar_t*", "wchar_t", "size_t"],
  "main_category": "Memory Management",
  "sub_category": "Search",
  "data_type_manipulated": "wide characters",
  "description": "Searches for a wide character in the first 'n' wide characters of a wide character array.",
  "extended_description": "wmemchr searches for the first occurrence of the wide character 'c' in the first 'n' wide characters of the object pointed to by 's'. This function operates on raw memory and doesn't stop at null terminators.",
  "return_value": "Returns a pointer to the located wide character, or NULL if the wide character does not occur in the object.",
  "parameter_values": "s: Pointer to the wide character array to be searched. c: Wide character to be located. n: Number of wide characters to be analyzed.",
  "function_prototype": "wchar_t *wmemchr(const wchar_t *s, wchar_t c, size_t n);",
  "examples": [
      {
          "title": "Basic Usage of wmemchr",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t str[] = L\"Hello, World!\";\n    wchar_t search = L'o';\n    size_t len = wcslen(str);\n    wchar_t *result = wmemchr(str, search, len);\n    if (result != NULL) {\n        wprintf(L\"'%lc' found at position: %td\\n\", search, result - str);\n    } else {\n        wprintf(L\"'%lc' not found\\n\", search);\n    }\n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wmemchr to find a character in a wide character string.",
          "expectedOutput": "'o' found at position: 4"
      },
      {
          "title": "Searching in a Non-null-terminated Array",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t arr[] = {L'A', L'B', L'C', L'D', L'E', L'F', L'G', L'H'};\n    wchar_t search = L'E';\n    size_t size = sizeof(arr) / sizeof(wchar_t);\n    wchar_t *result = wmemchr(arr, search, size);\n    if (result != NULL) {\n        wprintf(L\"'%lc' found at index: %td\\n\", search, result - arr);\n    } else {\n        wprintf(L\"'%lc' not found\\n\", search);\n    }\n    return 0;\n}\n",
          "explanation": "This example shows how wmemchr can be used with a non-null-terminated wide character array.",
          "expectedOutput": "'E' found at index: 4"
      },
      {
          "title": "Using wmemchr with Unicode Characters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t str[] = L\"Hello, 世界! こんにちは\";\n    wchar_t search = L'世';\n    size_t len = wcslen(str);\n    wchar_t *result = wmemchr(str, search, len);\n    if (result != NULL) {\n        wprintf(L\"'%lc' found at position: %td\\n\", search, result - str);\n        wprintf(L\"Remaining string: %ls\\n\", result);\n    } else {\n        wprintf(L\"'%lc' not found\\n\", search);\n    }\n    return 0;\n}\n",
          "explanation": "This example demonstrates using wmemchr with Unicode characters in a wide character string.",
          "expectedOutput": "'世' found at position: 7\nRemaining string: 世界! こんにちは"
      }
  ],
  "related_functions": ["memchr", "wcschr", "wmemcmp"],
  "performance_considerations": "wmemchr is generally efficient for searching in wide character arrays. It's particularly useful when working with fixed-size buffers or when the search should not stop at null terminators. For very large arrays, consider using more advanced searching algorithms if the same search needs to be performed multiple times."
},
{
  "function_name": "wmemcmp",
  "include_file": "wchar.h",
  "return_type": "int",
  "parameter_types": ["const wchar_t*", "const wchar_t*", "size_t"],
  "main_category": "Memory Management",
  "sub_category": "Comparison",
  "data_type_manipulated": "wide characters",
  "description": "Compares the first 'n' wide characters of two wide character arrays.",
  "extended_description": "wmemcmp compares the first n wide characters of the object pointed to by s1 to the first n wide characters of the object pointed to by s2. This function operates on raw memory and doesn't stop at null terminators.",
  "return_value": "Returns an integer less than, equal to, or greater than zero if the first n wide characters of s1 are found, respectively, to be less than, to match, or be greater than the first n wide characters of s2.",
  "parameter_values": "s1: Pointer to the first wide character array to be compared. s2: Pointer to the second wide character array to be compared. n: Number of wide characters to be compared.",
  "function_prototype": "int wmemcmp(const wchar_t *s1, const wchar_t *s2, size_t n);",
  "examples": [
      {
          "title": "Basic Usage of wmemcmp",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t str1[] = L\"Hello\";\n    const wchar_t str2[] = L\"Hello, World!\";\n    size_t len = wcslen(str1);\n    int result = wmemcmp(str1, str2, len);\n    if (result == 0) {\n        wprintf(L\"The first %zu characters are equal\\n\", len);\n    } else if (result < 0) {\n        wprintf(L\"str1 is less than str2\\n\");\n    } else {\n        wprintf(L\"str1 is greater than str2\\n\");\n    }\n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wmemcmp to compare two wide character strings up to a specified length.",
          "expectedOutput": "The first 5 characters are equal"
      },
      {
          "title": "Comparing Non-null-terminated Arrays",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t arr1[] = {L'A', L'B', L'C', L'D', L'E'};\n    wchar_t arr2[] = {L'A', L'B', L'C', L'X', L'Y'};\n    size_t size = 5;\n    int result = wmemcmp(arr1, arr2, size);\n    wprintf(L\"Comparing: \");\n    for (size_t i = 0; i < size; i++) wprintf(L\"%lc\", arr1[i]);\n    wprintf(L\" and \");\n    for (size_t i = 0; i < size; i++) wprintf(L\"%lc\", arr2[i]);\n    wprintf(L\"\\nResult: %d\\n\", result);\n    return 0;\n}\n",
          "explanation": "This example shows how wmemcmp can be used with non-null-terminated wide character arrays.",
          "expectedOutput": "Comparing: ABCDE and ABCXY\nResult: 1"
      },
      {
          "title": "Using wmemcmp with Unicode Characters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t str1[] = L\"こんにちは\";\n    const wchar_t str2[] = L\"こんばんは\";\n    size_t len = 3;  // Compare only first 3 characters\n    int result = wmemcmp(str1, str2, len);\n    wprintf(L\"Comparing first %zu characters of '%ls' and '%ls'\\n\", len, str1, str2);\n    if (result == 0) {\n        wprintf(L\"The first %zu characters are equal\\n\", len);\n    } else if (result < 0) {\n        wprintf(L\"str1 is less than str2\\n\");\n    } else {\n        wprintf(L\"str1 is greater than str2\\n\");\n    }\n    return 0;\n}\n",
          "explanation": "This example demonstrates using wmemcmp with Unicode characters in wide character strings.",
          "expectedOutput": "Comparing first 3 characters of 'こんにちは' and 'こんばんは'\nThe first 3 characters are equal"
      }
  ],
  "related_functions": ["memcmp", "wcscmp", "wcsncmp"],
  "performance_considerations": "wmemcmp is generally efficient for comparing wide character arrays. It's particularly useful when working with fixed-size buffers or when the comparison should not stop at null terminators. For very large arrays or frequent comparisons, consider using more optimized comparison techniques if appropriate for your use case."
},
{
  "function_name": "wmemcpy",
  "include_file": "wchar.h",
  "return_type": "wchar_t*",
  "parameter_types": ["wchar_t*", "const wchar_t*", "size_t"],
  "main_category": "Memory Management",
  "sub_category": "Copying",
  "data_type_manipulated": "wide characters",
  "description": "Copies 'n' wide characters from one wide character array to another.",
  "extended_description": "wmemcpy copies n wide characters from the object pointed to by src to the object pointed to by dest. If the objects overlap, the behavior is undefined. This function operates on raw memory and doesn't stop at null terminators.",
  "return_value": "Returns the value of dest.",
  "parameter_values": "dest: Pointer to the destination array where the content is to be copied. src: Pointer to the source of data to be copied. n: Number of wide characters to copy.",
  "function_prototype": "wchar_t *wmemcpy(wchar_t *dest, const wchar_t *src, size_t n);",
  "examples": [
      {
          "title": "Basic Usage of wmemcpy",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t src[] = L\"Hello, World!\";\n    wchar_t dest[20];\n    size_t len = wcslen(src);\n    wmemcpy(dest, src, len);\n    dest[len] = L'\\0';  // Null-terminate the destination\n    wprintf(L\"Source: %ls\\n\", src);\n    wprintf(L\"Destination: %ls\\n\", dest);\n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wmemcpy to copy a wide character string.",
          "expectedOutput": "Source: Hello, World!\nDestination: Hello, World!"
      },
      {
          "title": "Copying Part of an Array",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t src[] = {L'A', L'B', L'C', L'D', L'E', L'F', L'G', L'H'};\n    wchar_t dest[5];\n    wmemcpy(dest, src + 2, 4);\n    dest[4] = L'\\0';  // Null-terminate for printing\n    wprintf(L\"Source: \");\n    for (int i = 0; i < 8; i++) wprintf(L\"%lc \", src[i]);\n    wprintf(L\"\\nDestination: %ls\\n\", dest);\n    return 0;\n}\n",
          "explanation": "This example shows how to use wmemcpy to copy a portion of a wide character array.",
          "expectedOutput": "Source: A B C D E F G H \nDestination: CDEF"
      },
      {
          "title": "Using wmemcpy with Unicode Characters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    const wchar_t src[] = L\"こんにちは世界\";\n    wchar_t dest[6];\n    wmemcpy(dest, src, 5);\n    dest[5] = L'\\0';  // Null-terminate for printing\n    wprintf(L\"Source: %ls\\n\", src);\n    wprintf(L\"Destination (first 5 characters): %ls\\n\", dest);\n    return 0;\n}\n",
          "explanation": "This example demonstrates using wmemcpy with Unicode characters in wide character strings.",
          "expectedOutput": "Source: こんにちは世界\nDestination (first 5 characters): こんにちは"
      }
  ],
  "related_functions": ["memcpy", "wcsncpy", "wmemmove"],
  "performance_considerations": "wmemcpy is generally efficient for copying wide character arrays. It's particularly useful when working with fixed-size buffers or when copying should not stop at null terminators. However, it does not handle overlapping memory regions; use wmemmove for that case."
},
{
  "function_name": "wmemmove",
  "include_file": "wchar.h",
  "return_type": "wchar_t*",
  "parameter_types": ["wchar_t*", "const wchar_t*", "size_t"],
  "main_category": "Memory Management",
  "sub_category": "Copying",
  "data_type_manipulated": "wide characters",
  "description": "Moves 'n' wide characters from one wide character array to another, handling overlapping memory correctly.",
  "extended_description": "wmemmove copies n wide characters from the object pointed to by src to the object pointed to by dest. The copying takes place as if the n wide characters from src are first copied into a temporary array that does not overlap src or dest, and then the n wide characters from the temporary array are copied to dest. This ensures correct behavior even when the source and destination regions overlap.",
  "return_value": "Returns the value of dest.",
  "parameter_values": "dest: Pointer to the destination array where the content is to be copied. src: Pointer to the source of data to be copied. n: Number of wide characters to copy.",
  "function_prototype": "wchar_t *wmemmove(wchar_t *dest, const wchar_t *src, size_t n);",
  "examples": [
      {
          "title": "Basic Usage of wmemmove",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t str[] = L\"Hello, World!\";\n    wprintf(L\"Before: %ls\\n\", str);\n    wmemmove(str + 7, str, 5);\n    wprintf(L\"After:  %ls\\n\", str);\n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wmemmove to move a portion of a string within itself.",
          "expectedOutput": "Before: Hello, World!\nAfter:  Hello, Hello!"
      },
      {
          "title": "Handling Overlapping Memory",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nvoid print_array(const wchar_t *arr, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        wprintf(L\"%lc \", arr[i]);\n    }\n    wprintf(L\"\\n\");\n}\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t arr[] = {L'A', L'B', L'C', L'D', L'E', L'F', L'G', L'H'};\n    size_t size = sizeof(arr) / sizeof(wchar_t);\n    wprintf(L\"Before: \");\n    print_array(arr, size);\n    wmemmove(arr + 2, arr, 6 * sizeof(wchar_t));\n    wprintf(L\"After:  \");\n    print_array(arr, size);\n    return 0;\n}\n",
          "explanation": "This example shows how wmemmove correctly handles overlapping memory regions when moving data within an array.",
          "expectedOutput": "Before: A B C D E F G H \nAfter:  A B A B C D E F "
      },
      {
          "title": "Using wmemmove with Unicode Characters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t str[] = L\"こんにちは世界\";\n    wprintf(L\"Before: %ls\\n\", str);\n    wmemmove(str + 5, str, 4 * sizeof(wchar_t));\n    wprintf(L\"After:  %ls\\n\", str);\n    return 0;\n}\n",
          "explanation": "This example demonstrates using wmemmove with Unicode characters in wide character strings.",
          "expectedOutput": "Before: こんにちは世界\nAfter:  こんにちこんに世界"
      }
  ],
  "related_functions": ["memmove", "wmemcpy", "wcsncpy"],
  "performance_considerations": "wmemmove is generally efficient for moving wide character arrays and is safe to use when the source and destination regions may overlap. It may be slightly slower than wmemcpy for non-overlapping regions, but the difference is usually negligible. For very large arrays, consider using more optimized memory movement techniques if appropriate for your use case."
},
{
  "function_name": "wmemset",
  "include_file": "wchar.h",
  "return_type": "wchar_t*",
  "parameter_types": ["wchar_t*", "wchar_t", "size_t"],
  "main_category": "Memory Management",
  "sub_category": "Initialization",
  "data_type_manipulated": "wide characters",
  "description": "Fills 'n' wide characters of a wide character array with a specified wide character.",
  "extended_description": "wmemset copies the value of c (converted to a wchar_t) into each of the first n wide characters of the object pointed to by s. This function operates on raw memory and doesn't stop at null terminators.",
  "return_value": "Returns the value of s.",
  "parameter_values": "s: Pointer to the wide character array to be filled. c: Value to be set. The value is passed as an int, but the function fills the block of memory using the unsigned char conversion of this value. n: Number of wide characters to be set to the value.",
  "function_prototype": "wchar_t *wmemset(wchar_t *s, wchar_t c, size_t n);",
  "examples": [
      {
          "title": "Basic Usage of wmemset",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t str[10];\n    wmemset(str, L'A', 9);\n    str[9] = L'\\0';  // Null-terminate for printing\n    wprintf(L\"Filled string: %ls\\n\", str);\n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wmemset to fill a wide character array with a specific character.",
          "expectedOutput": "Filled string: AAAAAAAAA"
      },
      {
          "title": "Partial Array Filling",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t str[] = L\"Hello, World!\";\n    wprintf(L\"Before: %ls\\n\", str);\n    wmemset(str + 7, L'*', 5);\n    wprintf(L\"After:  %ls\\n\", str);\n    return 0;\n}\n",
          "explanation": "This example shows how to use wmemset to fill only a portion of a wide character array.",
          "expectedOutput": "Before: Hello, World!\nAfter:  Hello, *****!"
      },
      {
          "title": "Using wmemset with Unicode Characters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t str[11];\n    wmemset(str, L'星', 10);\n    str[10] = L'\\0';  // Null-terminate for printing\n    wprintf(L\"Filled string: %ls\\n\", str);\n    wprintf(L\"String length: %zu\\n\", wcslen(str));\n    return 0;\n}\n",
          "explanation": "This example demonstrates using wmemset with a Unicode character to fill a wide character array.",
          "expectedOutput": "Filled string: 星星星星星星星星星星\nString length: 10"
      }
  ],
  "related_functions": ["memset", "wmemcpy", "wmemmove"],
  "performance_considerations": "wmemset is generally efficient for initializing wide character arrays. It's particularly useful when working with fixed-size buffers or when initialization should not stop at null terminators. For very large arrays, consider using optimized memory setting techniques if appropriate for your use case."
},
{
  "function_name": "wprintf",
  "include_file": "wchar.h",
  "return_type": "int",
  "parameter_types": ["const wchar_t*", "..."],
  "main_category": "File and I/O Operations",
  "sub_category": "Wide Character Support",
  "data_type_manipulated": "standard output",
  "description": "Prints formatted wide character output to the standard output.",
  "extended_description": "wprintf writes the wide string pointed to by format to the standard output (stdout). If format includes format specifiers (beginning with %), the additional arguments following format are formatted and inserted in the resulting wide string replacing their respective specifiers.",
  "return_value": "Returns the number of wide characters written, or a negative value if an error occurred.",
  "parameter_values": "format: Wide string that contains the text to be written to stdout. It can optionally contain embedded format specifiers that are replaced by the values specified in subsequent additional arguments. ...: Depending on the format string, the function may expect a sequence of additional arguments, each containing a value to be used to replace a format specifier in the format string.",
  "function_prototype": "int wprintf(const wchar_t *format, ...);",
  "examples": [
      {
          "title": "Basic Usage of wprintf",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t name[] = L\"Alice\";\n    int age = 30;\n    wprintf(L\"Name: %ls, Age: %d\\n\", name, age);\n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wprintf to print a wide character string and an integer.",
          "expectedOutput": "Name: Alice, Age: 30"
      },
      {
          "title": "Formatting Options with wprintf",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    double pi = 3.14159265359;\n    wprintf(L\"Integer: %5d\\n\", 42);\n    wprintf(L\"Float (rounded): %.2f\\n\", pi);\n    wprintf(L\"Float (scientific): %e\\n\", pi);\n    wprintf(L\"String (left-aligned): %-10ls\\n\", L\"Hello\");\n    return 0;\n}\n",
          "explanation": "This example shows various formatting options available with wprintf, including field width, precision, and alignment.",
          "expectedOutput": "Integer:    42\nFloat (rounded): 3.14\nFloat (scientific): 3.141593e+00\nString (left-aligned): Hello     "
      },
      {
          "title": "Using wprintf with Unicode Characters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t chinese[] = L\"你好\";\n    wchar_t japanese[] = L\"こんにちは\";\n    wchar_t emoji[] = L\"😊\";\n    wprintf(L\"Chinese: %ls\\n\", chinese);\n    wprintf(L\"Japanese: %ls\\n\", japanese);\n    wprintf(L\"Emoji: %ls\\n\", emoji);\n    return 0;\n}\n",
          "explanation": "This example demonstrates using wprintf to print Unicode characters, including non-Latin scripts and emojis.",
          "expectedOutput": "Chinese: 你好\nJapanese: こんにちは\nEmoji: 😊"
      }
  ],
  "related_functions": ["fwprintf", "swprintf", "vwprintf"],
  "performance_considerations": "wprintf is generally efficient for standard output operations with wide characters. However, for very frequent output operations or when formatting large amounts of data, consider using buffered I/O or custom output handling for better performance. Be aware that the behavior and performance of wprintf can vary depending on the current locale settings and the complexity of the format string."
},
{
  "function_name": "wscanf",
  "include_file": "wchar.h",
  "return_type": "int",
  "parameter_types": ["const wchar_t*", "..."],
  "main_category": "File and I/O Operations",
  "sub_category": "Wide Character Support",
  "data_type_manipulated": "standard input",
  "description": "Reads formatted wide character input from the standard input.",
  "extended_description": "wscanf reads data from the standard input (stdin) and stores them according to the parameter format into the locations given by the additional arguments. The format string specifies the admissible input sequences and how they are to be converted for assignment.",
  "return_value": "Returns the number of input items successfully matched and assigned. This can be fewer than provided for, or even zero, in the event of an early matching failure. EOF is returned if the end of input is reached before either the first successful conversion or a matching failure occurs.",
  "parameter_values": "format: Wide string that contains the format specifiers for parsing the input. ...: Additional arguments, each a pointer to a variable where the parsed data will be stored.",
  "function_prototype": "int wscanf(const wchar_t *format, ...);",
  "examples": [
      {
          "title": "Basic Usage of wscanf",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    int num;\n    wchar_t str[50];\n    wprintf(L\"Enter a number and a word: \");\n    if (wscanf(L\"%d %ls\", &num, str) == 2) {\n        wprintf(L\"You entered: %d and %ls\\n\", num, str);\n    } else {\n        wprintf(L\"Input error\\n\");\n    }\n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of wscanf to read an integer and a wide character string from standard input.",
          "expectedOutput": "Enter a number and a word: 42 Hello\nYou entered: 42 and Hello"
      },
      {
          "title": "Reading Multiple Values",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    int day, year;\n    wchar_t month[20];\n    wprintf(L\"Enter a date (DD Month YYYY): \");\n    if (wscanf(L\"%d %19ls %d\", &day, month, &year) == 3) {\n        wprintf(L\"Date entered: %d %ls %d\\n\", day, month, year);\n    } else {\n        wprintf(L\"Invalid input format\\n\");\n    }\n    return 0;\n}\n",
          "explanation": "This example shows how to use wscanf to read multiple values of different types, including a width-limited string.",
          "expectedOutput": "Enter a date (DD Month YYYY): 15 August 2023\nDate entered: 15 August 2023"
      },
      {
          "title": "Reading Unicode Characters",
          "code": "#include <stdio.h>\n#include <wchar.h>\n#include <locale.h>\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wchar_t name[50];\n    wchar_t emoji[5];\n    wprintf(L\"Enter your name and a Unicode emoji: \");\n    if (wscanf(L\"%49ls %4ls\", name, emoji) == 2) {\n        wprintf(L\"Hello, %ls! Your emoji: %ls\\n\", name, emoji);\n    } else {\n        wprintf(L\"Input error\\n\");\n    }\n    return 0;\n}\n",
          "explanation": "This example demonstrates using wscanf to read a wide character string that may include Unicode characters, including emojis.",
          "expectedOutput": "Enter your name and a Unicode emoji: Alice 😊\nHello, Alice! Your emoji: 😊"
      }
  ],
  "related_functions": ["scanf", "fwscanf", "swscanf"],
  "performance_considerations": "wscanf is generally efficient for basic input parsing. However, for complex input formats or when parsing large amounts of data, consider using more specialized parsing techniques. Be aware that the behavior and performance of wscanf can vary depending on the current locale settings and the complexity of the format string."
},
{
    "function_name": "y0",
    "include_file": "math.h",
    "return_type": "double",
    "parameter_types": ["double"],
    "main_category": "Mathematical Operations",
    "sub_category": "Advanced Computation",
    "data_type_manipulated": "floating-point numbers",
    "description": "Calculates the Bessel function of the second kind of order 0 for the given value.",
    "extended_description": "y0 computes the Bessel function of the second kind of order 0 for the input x. These special functions are solutions to Bessel's differential equation and are important in various areas of physics and engineering, particularly in problems involving cylindrical or spherical symmetry.",
    "return_value": "Returns the Bessel function of the second kind of order 0 for x. If x is negative, a domain error occurs and -HUGE_VAL is returned. If x is 0, a range error occurs and -HUGE_VAL is returned.",
    "parameter_values": "x: The value for which to compute the Bessel function of the second kind of order 0.",
    "function_prototype": "double y0(double x);",
    "examples": [
        {
            "title": "Basic Usage of y0",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = 1.0;\n    double result = y0(x);\n    printf(\"y0(%.2f) = %.6f\\n\", x, result);\n    return 0;\n}\n",
            "explanation": "This example demonstrates the basic usage of y0 to compute the Bessel function of the second kind of order 0 for x = 1.0.",
            "expectedOutput": "y0(1.00) = 0.088257"
        },
        {
            "title": "Computing y0 for Multiple Values",
            "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double values[] = {0.1, 0.5, 1.0, 2.0, 5.0};\n    int n = sizeof(values) / sizeof(values[0]);\n    \n    for (int i = 0; i < n; i++) {\n        double result = y0(values[i]);\n        printf(\"y0(%.2f) = %.6f\\n\", values[i], result);\n    }\n    return 0;\n}\n",
            "explanation": "This example calculates y0 for multiple input values, showing how the function behaves across different inputs.",
            "expectedOutput": "y0(0.10) = -1.534238\ny0(0.50) = -0.444519\ny0(1.00) = 0.088257\ny0(2.00) = 0.510376\ny0(5.00) = -0.308062"
        },
        {
          "title": "Handling Special Cases",
          "code": "#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n\nvoid compute_y0(double x) {\n    errno = 0;\n    double result = y0(x);\n    if (errno == EDOM) {\n        printf(\"y0(%.2f): Domain error\\n\", x);\n    } else if (errno == ERANGE) {\n        printf(\"y0(%.2f): Range error\\n\", x);\n    } else {\n        printf(\"y0(%.2f) = %.6f\\n\", x, result);\n    }\n}\n\nint main() {\n    compute_y0(1.0);\n    compute_y0(0.0);\n    compute_y0(-1.0);\n    return 0;\n}\n",
          "explanation": "This example shows how to handle special cases and errors when using y0, including domain and range errors.",
          "expectedOutput": "y0(1.00) = 0.088257\ny0(0.00): Range error\ny0(-1.00): Domain error"
      }
    ],
    "related_functions": ["j0", "y1", "yn"],
    "performance_considerations": "y0 is a computationally intensive function. For applications requiring high performance or many evaluations of Bessel functions, consider using look-up tables or approximation methods. Be aware that the accuracy of y0 can degrade for very large arguments."
},
{
  "function_name": "y1",
  "include_file": "math.h",
  "return_type": "double",
  "parameter_types": ["double"],
  "main_category": "Mathematical Operations",
  "sub_category": "Advanced Computation",
  "data_type_manipulated": "floating-point numbers",
  "description": "Calculates the Bessel function of the second kind of order 1 for the given value.",
  "extended_description": "y1 computes the Bessel function of the second kind of order 1 for the input x. These special functions are solutions to Bessel's differential equation and are important in various areas of physics and engineering, particularly in problems involving cylindrical or spherical symmetry.",
  "return_value": "Returns the Bessel function of the second kind of order 1 for x. If x is negative, a domain error occurs and -HUGE_VAL is returned. If x is 0, a range error occurs and -HUGE_VAL is returned.",
  "parameter_values": "x: The value for which to compute the Bessel function of the second kind of order 1.",
  "function_prototype": "double y1(double x);",
  "examples": [
      {
          "title": "Basic Usage of y1",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = 1.0;\n    double result = y1(x);\n    printf(\"y1(%.2f) = %.6f\\n\", x, result);\n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of y1 to compute the Bessel function of the second kind of order 1 for x = 1.0.",
          "expectedOutput": "y1(1.00) = -0.781213"
      },
      {
          "title": "Computing y1 for Multiple Values",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double values[] = {0.1, 0.5, 1.0, 2.0, 5.0};\n    int n = sizeof(values) / sizeof(values[0]);\n    \n    for (int i = 0; i < n; i++) {\n        double result = y1(values[i]);\n        printf(\"y1(%.2f) = %.6f\\n\", values[i], result);\n    }\n    return 0;\n}\n",
          "explanation": "This example calculates y1 for multiple input values, showing how the function behaves across different inputs.",
          "expectedOutput": "y1(0.10) = -6.458951\ny1(0.50) = -1.471472\ny1(1.00) = -0.781213\ny1(2.00) = -0.107032\ny1(5.00) = 0.147666"
      },
      {
          "title": "Handling Special Cases",
          "code": "#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n\nvoid compute_y1(double x) {\n    errno = 0;\n    double result = y1(x);\n    if (errno == EDOM) {\n        printf(\"y1(%.2f): Domain error\\n\", x);\n    } else if (errno == ERANGE) {\n        printf(\"y1(%.2f): Range error\\n\", x);\n    } else {\n        printf(\"y1(%.2f) = %.6f\\n\", x, result);\n    }\n}\n\nint main() {\n    compute_y1(1.0);\n    compute_y1(0.0);\n    compute_y1(-1.0);\n    return 0;\n}\n",
          "explanation": "This example shows how to handle special cases and errors when using y1, including domain and range errors.",
          "expectedOutput": "y1(1.00) = -0.781213\ny1(0.00): Range error\ny1(-1.00): Domain error"
      }
  ],
  "related_functions": ["j1", "y0", "yn"],
  "performance_considerations": "y1 is a computationally intensive function. For applications requiring high performance or many evaluations of Bessel functions, consider using look-up tables or approximation methods. Be aware that the accuracy of y1 can degrade for very large arguments."
},
{
  "function_name": "yn",
  "include_file": "math.h",
  "return_type": "double",
  "parameter_types": ["int", "double"],
  "main_category": "Mathematical Operations",
  "sub_category": "Advanced Computation",
  "data_type_manipulated": "floating-point numbers",
  "description": "Calculates the Bessel function of the second kind of order n for the given value.",
  "extended_description": "yn computes the Bessel function of the second kind of order n for the input x. These special functions are solutions to Bessel's differential equation and are important in various areas of physics and engineering, particularly in problems involving cylindrical or spherical symmetry.",
  "return_value": "Returns the Bessel function of the second kind of order n for x. If x is negative, a domain error occurs and -HUGE_VAL is returned. If x is 0, a range error occurs and -HUGE_VAL is returned.",
  "parameter_values": "n: The order of the Bessel function. x: The value for which to compute the Bessel function of the second kind of order n.",
  "function_prototype": "double yn(int n, double x);",
  "examples": [
      {
          "title": "Basic Usage of yn",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n = 2;\n    double x = 1.0;\n    double result = yn(n, x);\n    printf(\"y%d(%.2f) = %.6f\\n\", n, x, result);\n    return 0;\n}\n",
          "explanation": "This example demonstrates the basic usage of yn to compute the Bessel function of the second kind of order 2 for x = 1.0.",
          "expectedOutput": "y2(1.00) = -1.650683"
      },
      {
          "title": "Computing yn for Different Orders",
          "code": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    double x = 2.0;\n    for (int n = 0; n <= 5; n++) {\n        double result = yn(n, x);\n        printf(\"y%d(%.2f) = %.6f\\n\", n, x, result);\n    }\n    return 0;\n}\n",
          "explanation": "This example calculates yn for a fixed x value but varying orders, showing how the function behaves for different orders.",
          "expectedOutput": "y0(2.00) = 0.510376\ny1(2.00) = -0.107032\ny2(2.00) = -0.617408\ny3(2.00) = -1.125727\ny4(2.00) = -2.087904\ny5(2.00) = -4.102344"
      },
      {
          "title": "Handling Special Cases and Errors",
          "code": "#include <stdio.h>\n#include <math.h>\n#include <errno.h>\n\nvoid compute_yn(int n, double x) {\n    errno = 0;\n    double result = yn(n, x);\n    if (errno == EDOM) {\n        printf(\"y%d(%.2f): Domain error\\n\", n, x);\n    } else if (errno == ERANGE) {\n        printf(\"y%d(%.2f): Range error\\n\", n, x);\n    } else {\n        printf(\"y%d(%.2f) = %.6f\\n\", n, x, result);\n    }\n}\n\nint main() {\n    compute_yn(2, 1.0);\n    compute_yn(0, 0.0);\n    compute_yn(1, -1.0);\n    return 0;\n}\n",
          "explanation": "This example shows how to handle special cases and errors when using yn, including domain and range errors for different orders.",
          "expectedOutput": "y2(1.00) = -1.650683\ny0(0.00): Range error\ny1(-1.00): Domain error"
      }
  ],
  "related_functions": ["jn", "y0", "y1"],
  "performance_considerations": "yn is a computationally intensive function, especially for large orders or arguments. For applications requiring high performance or many evaluations of Bessel functions, consider using look-up tables, recurrence relations, or approximation methods. Be aware that the accuracy of yn can degrade for very large arguments or orders."
}
          
   
  
]